{
  "version": 3,
  "sources": ["../../.pnpm/class-variance-authority@0.7.1/node_modules/class-variance-authority/dist/index.mjs", "../../.pnpm/@tanstack+query-core@5.74.3/node_modules/@tanstack/query-core/build/modern/subscribable.js", "../../.pnpm/@tanstack+query-core@5.74.3/node_modules/@tanstack/query-core/build/modern/utils.js", "../../.pnpm/@tanstack+query-core@5.74.3/node_modules/@tanstack/query-core/build/modern/focusManager.js", "../../.pnpm/@tanstack+query-core@5.74.3/node_modules/@tanstack/query-core/build/modern/onlineManager.js", "../../.pnpm/@tanstack+query-core@5.74.3/node_modules/@tanstack/query-core/build/modern/thenable.js", "../../.pnpm/@tanstack+query-core@5.74.3/node_modules/@tanstack/query-core/build/modern/retryer.js", "../../.pnpm/@tanstack+query-core@5.74.3/node_modules/@tanstack/query-core/build/modern/notifyManager.js", "../../.pnpm/@tanstack+query-core@5.74.3/node_modules/@tanstack/query-core/build/modern/removable.js", "../../.pnpm/@tanstack+query-core@5.74.3/node_modules/@tanstack/query-core/build/modern/query.js", "../../.pnpm/@tanstack+query-core@5.74.3/node_modules/@tanstack/query-core/build/modern/queryObserver.js", "../../.pnpm/@tanstack+react-query@5.74.3_react@19.1.0/node_modules/@tanstack/react-query/build/modern/QueryClientProvider.js", "../../.pnpm/@tanstack+react-query@5.74.3_react@19.1.0/node_modules/@tanstack/react-query/build/modern/isRestoring.js", "../../.pnpm/@tanstack+react-query@5.74.3_react@19.1.0/node_modules/@tanstack/react-query/build/modern/QueryErrorResetBoundary.js", "../../.pnpm/@tanstack+react-query@5.74.3_react@19.1.0/node_modules/@tanstack/react-query/build/modern/utils.js", "../../.pnpm/@tanstack+react-query@5.74.3_react@19.1.0/node_modules/@tanstack/react-query/build/modern/errorBoundaryUtils.js", "../../.pnpm/@tanstack+react-query@5.74.3_react@19.1.0/node_modules/@tanstack/react-query/build/modern/suspense.js", "../../.pnpm/@tanstack+react-query@5.74.3_react@19.1.0/node_modules/@tanstack/react-query/build/modern/useBaseQuery.js", "../../.pnpm/@tanstack+react-query@5.74.3_react@19.1.0/node_modules/@tanstack/react-query/build/modern/useQuery.js", "../../.pnpm/@tanstack+react-query@5.74.3_react@19.1.0/node_modules/@tanstack/react-query/build/modern/useSuspenseQuery.js", "../../zudoku/src/lib/util/joinUrl.ts", "../../zudoku/src/lib/components/cache.ts", "../../zudoku/src/lib/components/navigation/utils.ts", "../../zudoku/src/lib/components/context/ZudokuContext.ts", "../../.pnpm/zustand@5.0.5_@types+react@19.1.8_react@19.1.0_use-sync-external-store@1.5.0_react@19.1.0_/node_modules/zustand/esm/vanilla.mjs", "../../.pnpm/zustand@5.0.5_@types+react@19.1.8_react@19.1.0_use-sync-external-store@1.5.0_react@19.1.0_/node_modules/zustand/esm/react.mjs", "../../.pnpm/zustand@5.0.5_@types+react@19.1.8_react@19.1.0_use-sync-external-store@1.5.0_react@19.1.0_/node_modules/zustand/esm/middleware.mjs", "../../zudoku/src/lib/authentication/state.ts", "../../zudoku/src/lib/authentication/hook.ts"],
  "sourcesContent": ["/**\n * Copyright 2022 Joe Bell. All rights reserved.\n *\n * This file is licensed to you under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with the\n * License. You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR REPRESENTATIONS OF ANY KIND, either express or implied. See the\n * License for the specific language governing permissions and limitations under\n * the License.\n */ import { clsx } from \"clsx\";\nconst falsyToString = (value)=>typeof value === \"boolean\" ? `${value}` : value === 0 ? \"0\" : value;\nexport const cx = clsx;\nexport const cva = (base, config)=>(props)=>{\n        var _config_compoundVariants;\n        if ((config === null || config === void 0 ? void 0 : config.variants) == null) return cx(base, props === null || props === void 0 ? void 0 : props.class, props === null || props === void 0 ? void 0 : props.className);\n        const { variants, defaultVariants } = config;\n        const getVariantClassNames = Object.keys(variants).map((variant)=>{\n            const variantProp = props === null || props === void 0 ? void 0 : props[variant];\n            const defaultVariantProp = defaultVariants === null || defaultVariants === void 0 ? void 0 : defaultVariants[variant];\n            if (variantProp === null) return null;\n            const variantKey = falsyToString(variantProp) || falsyToString(defaultVariantProp);\n            return variants[variant][variantKey];\n        });\n        const propsWithoutUndefined = props && Object.entries(props).reduce((acc, param)=>{\n            let [key, value] = param;\n            if (value === undefined) {\n                return acc;\n            }\n            acc[key] = value;\n            return acc;\n        }, {});\n        const getCompoundVariantClassNames = config === null || config === void 0 ? void 0 : (_config_compoundVariants = config.compoundVariants) === null || _config_compoundVariants === void 0 ? void 0 : _config_compoundVariants.reduce((acc, param)=>{\n            let { class: cvClass, className: cvClassName, ...compoundVariantOptions } = param;\n            return Object.entries(compoundVariantOptions).every((param)=>{\n                let [key, value] = param;\n                return Array.isArray(value) ? value.includes({\n                    ...defaultVariants,\n                    ...propsWithoutUndefined\n                }[key]) : ({\n                    ...defaultVariants,\n                    ...propsWithoutUndefined\n                })[key] === value;\n            }) ? [\n                ...acc,\n                cvClass,\n                cvClassName\n            ] : acc;\n        }, []);\n        return cx(base, getVariantClassNames, getCompoundVariantClassNames, props === null || props === void 0 ? void 0 : props.class, props === null || props === void 0 ? void 0 : props.className);\n    };\n\n", "// src/subscribable.ts\nvar Subscribable = class {\n  constructor() {\n    this.listeners = /* @__PURE__ */ new Set();\n    this.subscribe = this.subscribe.bind(this);\n  }\n  subscribe(listener) {\n    this.listeners.add(listener);\n    this.onSubscribe();\n    return () => {\n      this.listeners.delete(listener);\n      this.onUnsubscribe();\n    };\n  }\n  hasListeners() {\n    return this.listeners.size > 0;\n  }\n  onSubscribe() {\n  }\n  onUnsubscribe() {\n  }\n};\nexport {\n  Subscribable\n};\n//# sourceMappingURL=subscribable.js.map", "// src/utils.ts\nvar isServer = typeof window === \"undefined\" || \"Deno\" in globalThis;\nfunction noop() {\n}\nfunction functionalUpdate(updater, input) {\n  return typeof updater === \"function\" ? updater(input) : updater;\n}\nfunction isValidTimeout(value) {\n  return typeof value === \"number\" && value >= 0 && value !== Infinity;\n}\nfunction timeUntilStale(updatedAt, staleTime) {\n  return Math.max(updatedAt + (staleTime || 0) - Date.now(), 0);\n}\nfunction resolveStaleTime(staleTime, query) {\n  return typeof staleTime === \"function\" ? staleTime(query) : staleTime;\n}\nfunction resolveEnabled(enabled, query) {\n  return typeof enabled === \"function\" ? enabled(query) : enabled;\n}\nfunction matchQuery(filters, query) {\n  const {\n    type = \"all\",\n    exact,\n    fetchStatus,\n    predicate,\n    queryKey,\n    stale\n  } = filters;\n  if (queryKey) {\n    if (exact) {\n      if (query.queryHash !== hashQueryKeyByOptions(queryKey, query.options)) {\n        return false;\n      }\n    } else if (!partialMatchKey(query.queryKey, queryKey)) {\n      return false;\n    }\n  }\n  if (type !== \"all\") {\n    const isActive = query.isActive();\n    if (type === \"active\" && !isActive) {\n      return false;\n    }\n    if (type === \"inactive\" && isActive) {\n      return false;\n    }\n  }\n  if (typeof stale === \"boolean\" && query.isStale() !== stale) {\n    return false;\n  }\n  if (fetchStatus && fetchStatus !== query.state.fetchStatus) {\n    return false;\n  }\n  if (predicate && !predicate(query)) {\n    return false;\n  }\n  return true;\n}\nfunction matchMutation(filters, mutation) {\n  const { exact, status, predicate, mutationKey } = filters;\n  if (mutationKey) {\n    if (!mutation.options.mutationKey) {\n      return false;\n    }\n    if (exact) {\n      if (hashKey(mutation.options.mutationKey) !== hashKey(mutationKey)) {\n        return false;\n      }\n    } else if (!partialMatchKey(mutation.options.mutationKey, mutationKey)) {\n      return false;\n    }\n  }\n  if (status && mutation.state.status !== status) {\n    return false;\n  }\n  if (predicate && !predicate(mutation)) {\n    return false;\n  }\n  return true;\n}\nfunction hashQueryKeyByOptions(queryKey, options) {\n  const hashFn = options?.queryKeyHashFn || hashKey;\n  return hashFn(queryKey);\n}\nfunction hashKey(queryKey) {\n  return JSON.stringify(\n    queryKey,\n    (_, val) => isPlainObject(val) ? Object.keys(val).sort().reduce((result, key) => {\n      result[key] = val[key];\n      return result;\n    }, {}) : val\n  );\n}\nfunction partialMatchKey(a, b) {\n  if (a === b) {\n    return true;\n  }\n  if (typeof a !== typeof b) {\n    return false;\n  }\n  if (a && b && typeof a === \"object\" && typeof b === \"object\") {\n    return Object.keys(b).every((key) => partialMatchKey(a[key], b[key]));\n  }\n  return false;\n}\nfunction replaceEqualDeep(a, b) {\n  if (a === b) {\n    return a;\n  }\n  const array = isPlainArray(a) && isPlainArray(b);\n  if (array || isPlainObject(a) && isPlainObject(b)) {\n    const aItems = array ? a : Object.keys(a);\n    const aSize = aItems.length;\n    const bItems = array ? b : Object.keys(b);\n    const bSize = bItems.length;\n    const copy = array ? [] : {};\n    let equalItems = 0;\n    for (let i = 0; i < bSize; i++) {\n      const key = array ? i : bItems[i];\n      if ((!array && aItems.includes(key) || array) && a[key] === void 0 && b[key] === void 0) {\n        copy[key] = void 0;\n        equalItems++;\n      } else {\n        copy[key] = replaceEqualDeep(a[key], b[key]);\n        if (copy[key] === a[key] && a[key] !== void 0) {\n          equalItems++;\n        }\n      }\n    }\n    return aSize === bSize && equalItems === aSize ? a : copy;\n  }\n  return b;\n}\nfunction shallowEqualObjects(a, b) {\n  if (!b || Object.keys(a).length !== Object.keys(b).length) {\n    return false;\n  }\n  for (const key in a) {\n    if (a[key] !== b[key]) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction isPlainArray(value) {\n  return Array.isArray(value) && value.length === Object.keys(value).length;\n}\nfunction isPlainObject(o) {\n  if (!hasObjectPrototype(o)) {\n    return false;\n  }\n  const ctor = o.constructor;\n  if (ctor === void 0) {\n    return true;\n  }\n  const prot = ctor.prototype;\n  if (!hasObjectPrototype(prot)) {\n    return false;\n  }\n  if (!prot.hasOwnProperty(\"isPrototypeOf\")) {\n    return false;\n  }\n  if (Object.getPrototypeOf(o) !== Object.prototype) {\n    return false;\n  }\n  return true;\n}\nfunction hasObjectPrototype(o) {\n  return Object.prototype.toString.call(o) === \"[object Object]\";\n}\nfunction sleep(timeout) {\n  return new Promise((resolve) => {\n    setTimeout(resolve, timeout);\n  });\n}\nfunction replaceData(prevData, data, options) {\n  if (typeof options.structuralSharing === \"function\") {\n    return options.structuralSharing(prevData, data);\n  } else if (options.structuralSharing !== false) {\n    if (process.env.NODE_ENV !== \"production\") {\n      try {\n        return replaceEqualDeep(prevData, data);\n      } catch (error) {\n        console.error(\n          `Structural sharing requires data to be JSON serializable. To fix this, turn off structuralSharing or return JSON-serializable data from your queryFn. [${options.queryHash}]: ${error}`\n        );\n        throw error;\n      }\n    }\n    return replaceEqualDeep(prevData, data);\n  }\n  return data;\n}\nfunction keepPreviousData(previousData) {\n  return previousData;\n}\nfunction addToEnd(items, item, max = 0) {\n  const newItems = [...items, item];\n  return max && newItems.length > max ? newItems.slice(1) : newItems;\n}\nfunction addToStart(items, item, max = 0) {\n  const newItems = [item, ...items];\n  return max && newItems.length > max ? newItems.slice(0, -1) : newItems;\n}\nvar skipToken = Symbol();\nfunction ensureQueryFn(options, fetchOptions) {\n  if (process.env.NODE_ENV !== \"production\") {\n    if (options.queryFn === skipToken) {\n      console.error(\n        `Attempted to invoke queryFn when set to skipToken. This is likely a configuration error. Query hash: '${options.queryHash}'`\n      );\n    }\n  }\n  if (!options.queryFn && fetchOptions?.initialPromise) {\n    return () => fetchOptions.initialPromise;\n  }\n  if (!options.queryFn || options.queryFn === skipToken) {\n    return () => Promise.reject(new Error(`Missing queryFn: '${options.queryHash}'`));\n  }\n  return options.queryFn;\n}\nexport {\n  addToEnd,\n  addToStart,\n  ensureQueryFn,\n  functionalUpdate,\n  hashKey,\n  hashQueryKeyByOptions,\n  isPlainArray,\n  isPlainObject,\n  isServer,\n  isValidTimeout,\n  keepPreviousData,\n  matchMutation,\n  matchQuery,\n  noop,\n  partialMatchKey,\n  replaceData,\n  replaceEqualDeep,\n  resolveEnabled,\n  resolveStaleTime,\n  shallowEqualObjects,\n  skipToken,\n  sleep,\n  timeUntilStale\n};\n//# sourceMappingURL=utils.js.map", "// src/focusManager.ts\nimport { Subscribable } from \"./subscribable.js\";\nimport { isServer } from \"./utils.js\";\nvar FocusManager = class extends Subscribable {\n  #focused;\n  #cleanup;\n  #setup;\n  constructor() {\n    super();\n    this.#setup = (onFocus) => {\n      if (!isServer && window.addEventListener) {\n        const listener = () => onFocus();\n        window.addEventListener(\"visibilitychange\", listener, false);\n        return () => {\n          window.removeEventListener(\"visibilitychange\", listener);\n        };\n      }\n      return;\n    };\n  }\n  onSubscribe() {\n    if (!this.#cleanup) {\n      this.setEventListener(this.#setup);\n    }\n  }\n  onUnsubscribe() {\n    if (!this.hasListeners()) {\n      this.#cleanup?.();\n      this.#cleanup = void 0;\n    }\n  }\n  setEventListener(setup) {\n    this.#setup = setup;\n    this.#cleanup?.();\n    this.#cleanup = setup((focused) => {\n      if (typeof focused === \"boolean\") {\n        this.setFocused(focused);\n      } else {\n        this.onFocus();\n      }\n    });\n  }\n  setFocused(focused) {\n    const changed = this.#focused !== focused;\n    if (changed) {\n      this.#focused = focused;\n      this.onFocus();\n    }\n  }\n  onFocus() {\n    const isFocused = this.isFocused();\n    this.listeners.forEach((listener) => {\n      listener(isFocused);\n    });\n  }\n  isFocused() {\n    if (typeof this.#focused === \"boolean\") {\n      return this.#focused;\n    }\n    return globalThis.document?.visibilityState !== \"hidden\";\n  }\n};\nvar focusManager = new FocusManager();\nexport {\n  FocusManager,\n  focusManager\n};\n//# sourceMappingURL=focusManager.js.map", "// src/onlineManager.ts\nimport { Subscribable } from \"./subscribable.js\";\nimport { isServer } from \"./utils.js\";\nvar OnlineManager = class extends Subscribable {\n  #online = true;\n  #cleanup;\n  #setup;\n  constructor() {\n    super();\n    this.#setup = (onOnline) => {\n      if (!isServer && window.addEventListener) {\n        const onlineListener = () => onOnline(true);\n        const offlineListener = () => onOnline(false);\n        window.addEventListener(\"online\", onlineListener, false);\n        window.addEventListener(\"offline\", offlineListener, false);\n        return () => {\n          window.removeEventListener(\"online\", onlineListener);\n          window.removeEventListener(\"offline\", offlineListener);\n        };\n      }\n      return;\n    };\n  }\n  onSubscribe() {\n    if (!this.#cleanup) {\n      this.setEventListener(this.#setup);\n    }\n  }\n  onUnsubscribe() {\n    if (!this.hasListeners()) {\n      this.#cleanup?.();\n      this.#cleanup = void 0;\n    }\n  }\n  setEventListener(setup) {\n    this.#setup = setup;\n    this.#cleanup?.();\n    this.#cleanup = setup(this.setOnline.bind(this));\n  }\n  setOnline(online) {\n    const changed = this.#online !== online;\n    if (changed) {\n      this.#online = online;\n      this.listeners.forEach((listener) => {\n        listener(online);\n      });\n    }\n  }\n  isOnline() {\n    return this.#online;\n  }\n};\nvar onlineManager = new OnlineManager();\nexport {\n  OnlineManager,\n  onlineManager\n};\n//# sourceMappingURL=onlineManager.js.map", "// src/thenable.ts\nfunction pendingThenable() {\n  let resolve;\n  let reject;\n  const thenable = new Promise((_resolve, _reject) => {\n    resolve = _resolve;\n    reject = _reject;\n  });\n  thenable.status = \"pending\";\n  thenable.catch(() => {\n  });\n  function finalize(data) {\n    Object.assign(thenable, data);\n    delete thenable.resolve;\n    delete thenable.reject;\n  }\n  thenable.resolve = (value) => {\n    finalize({\n      status: \"fulfilled\",\n      value\n    });\n    resolve(value);\n  };\n  thenable.reject = (reason) => {\n    finalize({\n      status: \"rejected\",\n      reason\n    });\n    reject(reason);\n  };\n  return thenable;\n}\nexport {\n  pendingThenable\n};\n//# sourceMappingURL=thenable.js.map", "// src/retryer.ts\nimport { focusManager } from \"./focusManager.js\";\nimport { onlineManager } from \"./onlineManager.js\";\nimport { pendingThenable } from \"./thenable.js\";\nimport { isServer, sleep } from \"./utils.js\";\nfunction defaultRetryDelay(failureCount) {\n  return Math.min(1e3 * 2 ** failureCount, 3e4);\n}\nfunction canFetch(networkMode) {\n  return (networkMode ?? \"online\") === \"online\" ? onlineManager.isOnline() : true;\n}\nvar CancelledError = class extends Error {\n  constructor(options) {\n    super(\"CancelledError\");\n    this.revert = options?.revert;\n    this.silent = options?.silent;\n  }\n};\nfunction isCancelledError(value) {\n  return value instanceof CancelledError;\n}\nfunction createRetryer(config) {\n  let isRetryCancelled = false;\n  let failureCount = 0;\n  let isResolved = false;\n  let continueFn;\n  const thenable = pendingThenable();\n  const cancel = (cancelOptions) => {\n    if (!isResolved) {\n      reject(new CancelledError(cancelOptions));\n      config.abort?.();\n    }\n  };\n  const cancelRetry = () => {\n    isRetryCancelled = true;\n  };\n  const continueRetry = () => {\n    isRetryCancelled = false;\n  };\n  const canContinue = () => focusManager.isFocused() && (config.networkMode === \"always\" || onlineManager.isOnline()) && config.canRun();\n  const canStart = () => canFetch(config.networkMode) && config.canRun();\n  const resolve = (value) => {\n    if (!isResolved) {\n      isResolved = true;\n      config.onSuccess?.(value);\n      continueFn?.();\n      thenable.resolve(value);\n    }\n  };\n  const reject = (value) => {\n    if (!isResolved) {\n      isResolved = true;\n      config.onError?.(value);\n      continueFn?.();\n      thenable.reject(value);\n    }\n  };\n  const pause = () => {\n    return new Promise((continueResolve) => {\n      continueFn = (value) => {\n        if (isResolved || canContinue()) {\n          continueResolve(value);\n        }\n      };\n      config.onPause?.();\n    }).then(() => {\n      continueFn = void 0;\n      if (!isResolved) {\n        config.onContinue?.();\n      }\n    });\n  };\n  const run = () => {\n    if (isResolved) {\n      return;\n    }\n    let promiseOrValue;\n    const initialPromise = failureCount === 0 ? config.initialPromise : void 0;\n    try {\n      promiseOrValue = initialPromise ?? config.fn();\n    } catch (error) {\n      promiseOrValue = Promise.reject(error);\n    }\n    Promise.resolve(promiseOrValue).then(resolve).catch((error) => {\n      if (isResolved) {\n        return;\n      }\n      const retry = config.retry ?? (isServer ? 0 : 3);\n      const retryDelay = config.retryDelay ?? defaultRetryDelay;\n      const delay = typeof retryDelay === \"function\" ? retryDelay(failureCount, error) : retryDelay;\n      const shouldRetry = retry === true || typeof retry === \"number\" && failureCount < retry || typeof retry === \"function\" && retry(failureCount, error);\n      if (isRetryCancelled || !shouldRetry) {\n        reject(error);\n        return;\n      }\n      failureCount++;\n      config.onFail?.(failureCount, error);\n      sleep(delay).then(() => {\n        return canContinue() ? void 0 : pause();\n      }).then(() => {\n        if (isRetryCancelled) {\n          reject(error);\n        } else {\n          run();\n        }\n      });\n    });\n  };\n  return {\n    promise: thenable,\n    cancel,\n    continue: () => {\n      continueFn?.();\n      return thenable;\n    },\n    cancelRetry,\n    continueRetry,\n    canStart,\n    start: () => {\n      if (canStart()) {\n        run();\n      } else {\n        pause().then(run);\n      }\n      return thenable;\n    }\n  };\n}\nexport {\n  CancelledError,\n  canFetch,\n  createRetryer,\n  isCancelledError\n};\n//# sourceMappingURL=retryer.js.map", "// src/notifyManager.ts\nvar defaultScheduler = (cb) => setTimeout(cb, 0);\nfunction createNotifyManager() {\n  let queue = [];\n  let transactions = 0;\n  let notifyFn = (callback) => {\n    callback();\n  };\n  let batchNotifyFn = (callback) => {\n    callback();\n  };\n  let scheduleFn = defaultScheduler;\n  const schedule = (callback) => {\n    if (transactions) {\n      queue.push(callback);\n    } else {\n      scheduleFn(() => {\n        notifyFn(callback);\n      });\n    }\n  };\n  const flush = () => {\n    const originalQueue = queue;\n    queue = [];\n    if (originalQueue.length) {\n      scheduleFn(() => {\n        batchNotifyFn(() => {\n          originalQueue.forEach((callback) => {\n            notifyFn(callback);\n          });\n        });\n      });\n    }\n  };\n  return {\n    batch: (callback) => {\n      let result;\n      transactions++;\n      try {\n        result = callback();\n      } finally {\n        transactions--;\n        if (!transactions) {\n          flush();\n        }\n      }\n      return result;\n    },\n    /**\n     * All calls to the wrapped function will be batched.\n     */\n    batchCalls: (callback) => {\n      return (...args) => {\n        schedule(() => {\n          callback(...args);\n        });\n      };\n    },\n    schedule,\n    /**\n     * Use this method to set a custom notify function.\n     * This can be used to for example wrap notifications with `React.act` while running tests.\n     */\n    setNotifyFunction: (fn) => {\n      notifyFn = fn;\n    },\n    /**\n     * Use this method to set a custom function to batch notifications together into a single tick.\n     * By default React Query will use the batch function provided by ReactDOM or React Native.\n     */\n    setBatchNotifyFunction: (fn) => {\n      batchNotifyFn = fn;\n    },\n    setScheduler: (fn) => {\n      scheduleFn = fn;\n    }\n  };\n}\nvar notifyManager = createNotifyManager();\nexport {\n  createNotifyManager,\n  defaultScheduler,\n  notifyManager\n};\n//# sourceMappingURL=notifyManager.js.map", "// src/removable.ts\nimport { isServer, isValidTimeout } from \"./utils.js\";\nvar Removable = class {\n  #gcTimeout;\n  destroy() {\n    this.clearGcTimeout();\n  }\n  scheduleGc() {\n    this.clearGcTimeout();\n    if (isValidTimeout(this.gcTime)) {\n      this.#gcTimeout = setTimeout(() => {\n        this.optionalRemove();\n      }, this.gcTime);\n    }\n  }\n  updateGcTime(newGcTime) {\n    this.gcTime = Math.max(\n      this.gcTime || 0,\n      newGcTime ?? (isServer ? Infinity : 5 * 60 * 1e3)\n    );\n  }\n  clearGcTimeout() {\n    if (this.#gcTimeout) {\n      clearTimeout(this.#gcTimeout);\n      this.#gcTimeout = void 0;\n    }\n  }\n};\nexport {\n  Removable\n};\n//# sourceMappingURL=removable.js.map", "// src/query.ts\nimport {\n  ensureQueryFn,\n  noop,\n  replaceData,\n  resolveEnabled,\n  skipToken,\n  timeUntilStale\n} from \"./utils.js\";\nimport { notifyManager } from \"./notifyManager.js\";\nimport { canFetch, createRetryer, isCancelledError } from \"./retryer.js\";\nimport { Removable } from \"./removable.js\";\nvar Query = class extends Removable {\n  #initialState;\n  #revertState;\n  #cache;\n  #client;\n  #retryer;\n  #defaultOptions;\n  #abortSignalConsumed;\n  constructor(config) {\n    super();\n    this.#abortSignalConsumed = false;\n    this.#defaultOptions = config.defaultOptions;\n    this.setOptions(config.options);\n    this.observers = [];\n    this.#client = config.client;\n    this.#cache = this.#client.getQueryCache();\n    this.queryKey = config.queryKey;\n    this.queryHash = config.queryHash;\n    this.#initialState = getDefaultState(this.options);\n    this.state = config.state ?? this.#initialState;\n    this.scheduleGc();\n  }\n  get meta() {\n    return this.options.meta;\n  }\n  get promise() {\n    return this.#retryer?.promise;\n  }\n  setOptions(options) {\n    this.options = { ...this.#defaultOptions, ...options };\n    this.updateGcTime(this.options.gcTime);\n  }\n  optionalRemove() {\n    if (!this.observers.length && this.state.fetchStatus === \"idle\") {\n      this.#cache.remove(this);\n    }\n  }\n  setData(newData, options) {\n    const data = replaceData(this.state.data, newData, this.options);\n    this.#dispatch({\n      data,\n      type: \"success\",\n      dataUpdatedAt: options?.updatedAt,\n      manual: options?.manual\n    });\n    return data;\n  }\n  setState(state, setStateOptions) {\n    this.#dispatch({ type: \"setState\", state, setStateOptions });\n  }\n  cancel(options) {\n    const promise = this.#retryer?.promise;\n    this.#retryer?.cancel(options);\n    return promise ? promise.then(noop).catch(noop) : Promise.resolve();\n  }\n  destroy() {\n    super.destroy();\n    this.cancel({ silent: true });\n  }\n  reset() {\n    this.destroy();\n    this.setState(this.#initialState);\n  }\n  isActive() {\n    return this.observers.some(\n      (observer) => resolveEnabled(observer.options.enabled, this) !== false\n    );\n  }\n  isDisabled() {\n    if (this.getObserversCount() > 0) {\n      return !this.isActive();\n    }\n    return this.options.queryFn === skipToken || this.state.dataUpdateCount + this.state.errorUpdateCount === 0;\n  }\n  isStale() {\n    if (this.state.isInvalidated) {\n      return true;\n    }\n    if (this.getObserversCount() > 0) {\n      return this.observers.some(\n        (observer) => observer.getCurrentResult().isStale\n      );\n    }\n    return this.state.data === void 0;\n  }\n  isStaleByTime(staleTime = 0) {\n    return this.state.isInvalidated || this.state.data === void 0 || !timeUntilStale(this.state.dataUpdatedAt, staleTime);\n  }\n  onFocus() {\n    const observer = this.observers.find((x) => x.shouldFetchOnWindowFocus());\n    observer?.refetch({ cancelRefetch: false });\n    this.#retryer?.continue();\n  }\n  onOnline() {\n    const observer = this.observers.find((x) => x.shouldFetchOnReconnect());\n    observer?.refetch({ cancelRefetch: false });\n    this.#retryer?.continue();\n  }\n  addObserver(observer) {\n    if (!this.observers.includes(observer)) {\n      this.observers.push(observer);\n      this.clearGcTimeout();\n      this.#cache.notify({ type: \"observerAdded\", query: this, observer });\n    }\n  }\n  removeObserver(observer) {\n    if (this.observers.includes(observer)) {\n      this.observers = this.observers.filter((x) => x !== observer);\n      if (!this.observers.length) {\n        if (this.#retryer) {\n          if (this.#abortSignalConsumed) {\n            this.#retryer.cancel({ revert: true });\n          } else {\n            this.#retryer.cancelRetry();\n          }\n        }\n        this.scheduleGc();\n      }\n      this.#cache.notify({ type: \"observerRemoved\", query: this, observer });\n    }\n  }\n  getObserversCount() {\n    return this.observers.length;\n  }\n  invalidate() {\n    if (!this.state.isInvalidated) {\n      this.#dispatch({ type: \"invalidate\" });\n    }\n  }\n  fetch(options, fetchOptions) {\n    if (this.state.fetchStatus !== \"idle\") {\n      if (this.state.data !== void 0 && fetchOptions?.cancelRefetch) {\n        this.cancel({ silent: true });\n      } else if (this.#retryer) {\n        this.#retryer.continueRetry();\n        return this.#retryer.promise;\n      }\n    }\n    if (options) {\n      this.setOptions(options);\n    }\n    if (!this.options.queryFn) {\n      const observer = this.observers.find((x) => x.options.queryFn);\n      if (observer) {\n        this.setOptions(observer.options);\n      }\n    }\n    if (process.env.NODE_ENV !== \"production\") {\n      if (!Array.isArray(this.options.queryKey)) {\n        console.error(\n          `As of v4, queryKey needs to be an Array. If you are using a string like 'repoData', please change it to an Array, e.g. ['repoData']`\n        );\n      }\n    }\n    const abortController = new AbortController();\n    const addSignalProperty = (object) => {\n      Object.defineProperty(object, \"signal\", {\n        enumerable: true,\n        get: () => {\n          this.#abortSignalConsumed = true;\n          return abortController.signal;\n        }\n      });\n    };\n    const fetchFn = () => {\n      const queryFn = ensureQueryFn(this.options, fetchOptions);\n      const queryFnContext = {\n        client: this.#client,\n        queryKey: this.queryKey,\n        meta: this.meta\n      };\n      addSignalProperty(queryFnContext);\n      this.#abortSignalConsumed = false;\n      if (this.options.persister) {\n        return this.options.persister(\n          queryFn,\n          queryFnContext,\n          this\n        );\n      }\n      return queryFn(queryFnContext);\n    };\n    const context = {\n      fetchOptions,\n      options: this.options,\n      queryKey: this.queryKey,\n      client: this.#client,\n      state: this.state,\n      fetchFn\n    };\n    addSignalProperty(context);\n    this.options.behavior?.onFetch(\n      context,\n      this\n    );\n    this.#revertState = this.state;\n    if (this.state.fetchStatus === \"idle\" || this.state.fetchMeta !== context.fetchOptions?.meta) {\n      this.#dispatch({ type: \"fetch\", meta: context.fetchOptions?.meta });\n    }\n    const onError = (error) => {\n      if (!(isCancelledError(error) && error.silent)) {\n        this.#dispatch({\n          type: \"error\",\n          error\n        });\n      }\n      if (!isCancelledError(error)) {\n        this.#cache.config.onError?.(\n          error,\n          this\n        );\n        this.#cache.config.onSettled?.(\n          this.state.data,\n          error,\n          this\n        );\n      }\n      this.scheduleGc();\n    };\n    this.#retryer = createRetryer({\n      initialPromise: fetchOptions?.initialPromise,\n      fn: context.fetchFn,\n      abort: abortController.abort.bind(abortController),\n      onSuccess: (data) => {\n        if (data === void 0) {\n          if (process.env.NODE_ENV !== \"production\") {\n            console.error(\n              `Query data cannot be undefined. Please make sure to return a value other than undefined from your query function. Affected query key: ${this.queryHash}`\n            );\n          }\n          onError(new Error(`${this.queryHash} data is undefined`));\n          return;\n        }\n        try {\n          this.setData(data);\n        } catch (error) {\n          onError(error);\n          return;\n        }\n        this.#cache.config.onSuccess?.(data, this);\n        this.#cache.config.onSettled?.(\n          data,\n          this.state.error,\n          this\n        );\n        this.scheduleGc();\n      },\n      onError,\n      onFail: (failureCount, error) => {\n        this.#dispatch({ type: \"failed\", failureCount, error });\n      },\n      onPause: () => {\n        this.#dispatch({ type: \"pause\" });\n      },\n      onContinue: () => {\n        this.#dispatch({ type: \"continue\" });\n      },\n      retry: context.options.retry,\n      retryDelay: context.options.retryDelay,\n      networkMode: context.options.networkMode,\n      canRun: () => true\n    });\n    return this.#retryer.start();\n  }\n  #dispatch(action) {\n    const reducer = (state) => {\n      switch (action.type) {\n        case \"failed\":\n          return {\n            ...state,\n            fetchFailureCount: action.failureCount,\n            fetchFailureReason: action.error\n          };\n        case \"pause\":\n          return {\n            ...state,\n            fetchStatus: \"paused\"\n          };\n        case \"continue\":\n          return {\n            ...state,\n            fetchStatus: \"fetching\"\n          };\n        case \"fetch\":\n          return {\n            ...state,\n            ...fetchState(state.data, this.options),\n            fetchMeta: action.meta ?? null\n          };\n        case \"success\":\n          return {\n            ...state,\n            data: action.data,\n            dataUpdateCount: state.dataUpdateCount + 1,\n            dataUpdatedAt: action.dataUpdatedAt ?? Date.now(),\n            error: null,\n            isInvalidated: false,\n            status: \"success\",\n            ...!action.manual && {\n              fetchStatus: \"idle\",\n              fetchFailureCount: 0,\n              fetchFailureReason: null\n            }\n          };\n        case \"error\":\n          const error = action.error;\n          if (isCancelledError(error) && error.revert && this.#revertState) {\n            return { ...this.#revertState, fetchStatus: \"idle\" };\n          }\n          return {\n            ...state,\n            error,\n            errorUpdateCount: state.errorUpdateCount + 1,\n            errorUpdatedAt: Date.now(),\n            fetchFailureCount: state.fetchFailureCount + 1,\n            fetchFailureReason: error,\n            fetchStatus: \"idle\",\n            status: \"error\"\n          };\n        case \"invalidate\":\n          return {\n            ...state,\n            isInvalidated: true\n          };\n        case \"setState\":\n          return {\n            ...state,\n            ...action.state\n          };\n      }\n    };\n    this.state = reducer(this.state);\n    notifyManager.batch(() => {\n      this.observers.forEach((observer) => {\n        observer.onQueryUpdate();\n      });\n      this.#cache.notify({ query: this, type: \"updated\", action });\n    });\n  }\n};\nfunction fetchState(data, options) {\n  return {\n    fetchFailureCount: 0,\n    fetchFailureReason: null,\n    fetchStatus: canFetch(options.networkMode) ? \"fetching\" : \"paused\",\n    ...data === void 0 && {\n      error: null,\n      status: \"pending\"\n    }\n  };\n}\nfunction getDefaultState(options) {\n  const data = typeof options.initialData === \"function\" ? options.initialData() : options.initialData;\n  const hasData = data !== void 0;\n  const initialDataUpdatedAt = hasData ? typeof options.initialDataUpdatedAt === \"function\" ? options.initialDataUpdatedAt() : options.initialDataUpdatedAt : 0;\n  return {\n    data,\n    dataUpdateCount: 0,\n    dataUpdatedAt: hasData ? initialDataUpdatedAt ?? Date.now() : 0,\n    error: null,\n    errorUpdateCount: 0,\n    errorUpdatedAt: 0,\n    fetchFailureCount: 0,\n    fetchFailureReason: null,\n    fetchMeta: null,\n    isInvalidated: false,\n    status: hasData ? \"success\" : \"pending\",\n    fetchStatus: \"idle\"\n  };\n}\nexport {\n  Query,\n  fetchState\n};\n//# sourceMappingURL=query.js.map", "// src/queryObserver.ts\nimport { focusManager } from \"./focusManager.js\";\nimport { notifyManager } from \"./notifyManager.js\";\nimport { fetchState } from \"./query.js\";\nimport { Subscribable } from \"./subscribable.js\";\nimport { pendingThenable } from \"./thenable.js\";\nimport {\n  isServer,\n  isValidTimeout,\n  noop,\n  replaceData,\n  resolveEnabled,\n  resolveStaleTime,\n  shallowEqualObjects,\n  timeUntilStale\n} from \"./utils.js\";\nvar QueryObserver = class extends Subscribable {\n  constructor(client, options) {\n    super();\n    this.options = options;\n    this.#client = client;\n    this.#selectError = null;\n    this.#currentThenable = pendingThenable();\n    if (!this.options.experimental_prefetchInRender) {\n      this.#currentThenable.reject(\n        new Error(\"experimental_prefetchInRender feature flag is not enabled\")\n      );\n    }\n    this.bindMethods();\n    this.setOptions(options);\n  }\n  #client;\n  #currentQuery = void 0;\n  #currentQueryInitialState = void 0;\n  #currentResult = void 0;\n  #currentResultState;\n  #currentResultOptions;\n  #currentThenable;\n  #selectError;\n  #selectFn;\n  #selectResult;\n  // This property keeps track of the last query with defined data.\n  // It will be used to pass the previous data and query to the placeholder function between renders.\n  #lastQueryWithDefinedData;\n  #staleTimeoutId;\n  #refetchIntervalId;\n  #currentRefetchInterval;\n  #trackedProps = /* @__PURE__ */ new Set();\n  bindMethods() {\n    this.refetch = this.refetch.bind(this);\n  }\n  onSubscribe() {\n    if (this.listeners.size === 1) {\n      this.#currentQuery.addObserver(this);\n      if (shouldFetchOnMount(this.#currentQuery, this.options)) {\n        this.#executeFetch();\n      } else {\n        this.updateResult();\n      }\n      this.#updateTimers();\n    }\n  }\n  onUnsubscribe() {\n    if (!this.hasListeners()) {\n      this.destroy();\n    }\n  }\n  shouldFetchOnReconnect() {\n    return shouldFetchOn(\n      this.#currentQuery,\n      this.options,\n      this.options.refetchOnReconnect\n    );\n  }\n  shouldFetchOnWindowFocus() {\n    return shouldFetchOn(\n      this.#currentQuery,\n      this.options,\n      this.options.refetchOnWindowFocus\n    );\n  }\n  destroy() {\n    this.listeners = /* @__PURE__ */ new Set();\n    this.#clearStaleTimeout();\n    this.#clearRefetchInterval();\n    this.#currentQuery.removeObserver(this);\n  }\n  setOptions(options) {\n    const prevOptions = this.options;\n    const prevQuery = this.#currentQuery;\n    this.options = this.#client.defaultQueryOptions(options);\n    if (this.options.enabled !== void 0 && typeof this.options.enabled !== \"boolean\" && typeof this.options.enabled !== \"function\" && typeof resolveEnabled(this.options.enabled, this.#currentQuery) !== \"boolean\") {\n      throw new Error(\n        \"Expected enabled to be a boolean or a callback that returns a boolean\"\n      );\n    }\n    this.#updateQuery();\n    this.#currentQuery.setOptions(this.options);\n    if (prevOptions._defaulted && !shallowEqualObjects(this.options, prevOptions)) {\n      this.#client.getQueryCache().notify({\n        type: \"observerOptionsUpdated\",\n        query: this.#currentQuery,\n        observer: this\n      });\n    }\n    const mounted = this.hasListeners();\n    if (mounted && shouldFetchOptionally(\n      this.#currentQuery,\n      prevQuery,\n      this.options,\n      prevOptions\n    )) {\n      this.#executeFetch();\n    }\n    this.updateResult();\n    if (mounted && (this.#currentQuery !== prevQuery || resolveEnabled(this.options.enabled, this.#currentQuery) !== resolveEnabled(prevOptions.enabled, this.#currentQuery) || resolveStaleTime(this.options.staleTime, this.#currentQuery) !== resolveStaleTime(prevOptions.staleTime, this.#currentQuery))) {\n      this.#updateStaleTimeout();\n    }\n    const nextRefetchInterval = this.#computeRefetchInterval();\n    if (mounted && (this.#currentQuery !== prevQuery || resolveEnabled(this.options.enabled, this.#currentQuery) !== resolveEnabled(prevOptions.enabled, this.#currentQuery) || nextRefetchInterval !== this.#currentRefetchInterval)) {\n      this.#updateRefetchInterval(nextRefetchInterval);\n    }\n  }\n  getOptimisticResult(options) {\n    const query = this.#client.getQueryCache().build(this.#client, options);\n    const result = this.createResult(query, options);\n    if (shouldAssignObserverCurrentProperties(this, result)) {\n      this.#currentResult = result;\n      this.#currentResultOptions = this.options;\n      this.#currentResultState = this.#currentQuery.state;\n    }\n    return result;\n  }\n  getCurrentResult() {\n    return this.#currentResult;\n  }\n  trackResult(result, onPropTracked) {\n    const trackedResult = {};\n    Object.keys(result).forEach((key) => {\n      Object.defineProperty(trackedResult, key, {\n        configurable: false,\n        enumerable: true,\n        get: () => {\n          this.trackProp(key);\n          onPropTracked?.(key);\n          return result[key];\n        }\n      });\n    });\n    return trackedResult;\n  }\n  trackProp(key) {\n    this.#trackedProps.add(key);\n  }\n  getCurrentQuery() {\n    return this.#currentQuery;\n  }\n  refetch({ ...options } = {}) {\n    return this.fetch({\n      ...options\n    });\n  }\n  fetchOptimistic(options) {\n    const defaultedOptions = this.#client.defaultQueryOptions(options);\n    const query = this.#client.getQueryCache().build(this.#client, defaultedOptions);\n    return query.fetch().then(() => this.createResult(query, defaultedOptions));\n  }\n  fetch(fetchOptions) {\n    return this.#executeFetch({\n      ...fetchOptions,\n      cancelRefetch: fetchOptions.cancelRefetch ?? true\n    }).then(() => {\n      this.updateResult();\n      return this.#currentResult;\n    });\n  }\n  #executeFetch(fetchOptions) {\n    this.#updateQuery();\n    let promise = this.#currentQuery.fetch(\n      this.options,\n      fetchOptions\n    );\n    if (!fetchOptions?.throwOnError) {\n      promise = promise.catch(noop);\n    }\n    return promise;\n  }\n  #updateStaleTimeout() {\n    this.#clearStaleTimeout();\n    const staleTime = resolveStaleTime(\n      this.options.staleTime,\n      this.#currentQuery\n    );\n    if (isServer || this.#currentResult.isStale || !isValidTimeout(staleTime)) {\n      return;\n    }\n    const time = timeUntilStale(this.#currentResult.dataUpdatedAt, staleTime);\n    const timeout = time + 1;\n    this.#staleTimeoutId = setTimeout(() => {\n      if (!this.#currentResult.isStale) {\n        this.updateResult();\n      }\n    }, timeout);\n  }\n  #computeRefetchInterval() {\n    return (typeof this.options.refetchInterval === \"function\" ? this.options.refetchInterval(this.#currentQuery) : this.options.refetchInterval) ?? false;\n  }\n  #updateRefetchInterval(nextInterval) {\n    this.#clearRefetchInterval();\n    this.#currentRefetchInterval = nextInterval;\n    if (isServer || resolveEnabled(this.options.enabled, this.#currentQuery) === false || !isValidTimeout(this.#currentRefetchInterval) || this.#currentRefetchInterval === 0) {\n      return;\n    }\n    this.#refetchIntervalId = setInterval(() => {\n      if (this.options.refetchIntervalInBackground || focusManager.isFocused()) {\n        this.#executeFetch();\n      }\n    }, this.#currentRefetchInterval);\n  }\n  #updateTimers() {\n    this.#updateStaleTimeout();\n    this.#updateRefetchInterval(this.#computeRefetchInterval());\n  }\n  #clearStaleTimeout() {\n    if (this.#staleTimeoutId) {\n      clearTimeout(this.#staleTimeoutId);\n      this.#staleTimeoutId = void 0;\n    }\n  }\n  #clearRefetchInterval() {\n    if (this.#refetchIntervalId) {\n      clearInterval(this.#refetchIntervalId);\n      this.#refetchIntervalId = void 0;\n    }\n  }\n  createResult(query, options) {\n    const prevQuery = this.#currentQuery;\n    const prevOptions = this.options;\n    const prevResult = this.#currentResult;\n    const prevResultState = this.#currentResultState;\n    const prevResultOptions = this.#currentResultOptions;\n    const queryChange = query !== prevQuery;\n    const queryInitialState = queryChange ? query.state : this.#currentQueryInitialState;\n    const { state } = query;\n    let newState = { ...state };\n    let isPlaceholderData = false;\n    let data;\n    if (options._optimisticResults) {\n      const mounted = this.hasListeners();\n      const fetchOnMount = !mounted && shouldFetchOnMount(query, options);\n      const fetchOptionally = mounted && shouldFetchOptionally(query, prevQuery, options, prevOptions);\n      if (fetchOnMount || fetchOptionally) {\n        newState = {\n          ...newState,\n          ...fetchState(state.data, query.options)\n        };\n      }\n      if (options._optimisticResults === \"isRestoring\") {\n        newState.fetchStatus = \"idle\";\n      }\n    }\n    let { error, errorUpdatedAt, status } = newState;\n    data = newState.data;\n    let skipSelect = false;\n    if (options.placeholderData !== void 0 && data === void 0 && status === \"pending\") {\n      let placeholderData;\n      if (prevResult?.isPlaceholderData && options.placeholderData === prevResultOptions?.placeholderData) {\n        placeholderData = prevResult.data;\n        skipSelect = true;\n      } else {\n        placeholderData = typeof options.placeholderData === \"function\" ? options.placeholderData(\n          this.#lastQueryWithDefinedData?.state.data,\n          this.#lastQueryWithDefinedData\n        ) : options.placeholderData;\n      }\n      if (placeholderData !== void 0) {\n        status = \"success\";\n        data = replaceData(\n          prevResult?.data,\n          placeholderData,\n          options\n        );\n        isPlaceholderData = true;\n      }\n    }\n    if (options.select && data !== void 0 && !skipSelect) {\n      if (prevResult && data === prevResultState?.data && options.select === this.#selectFn) {\n        data = this.#selectResult;\n      } else {\n        try {\n          this.#selectFn = options.select;\n          data = options.select(data);\n          data = replaceData(prevResult?.data, data, options);\n          this.#selectResult = data;\n          this.#selectError = null;\n        } catch (selectError) {\n          this.#selectError = selectError;\n        }\n      }\n    }\n    if (this.#selectError) {\n      error = this.#selectError;\n      data = this.#selectResult;\n      errorUpdatedAt = Date.now();\n      status = \"error\";\n    }\n    const isFetching = newState.fetchStatus === \"fetching\";\n    const isPending = status === \"pending\";\n    const isError = status === \"error\";\n    const isLoading = isPending && isFetching;\n    const hasData = data !== void 0;\n    const result = {\n      status,\n      fetchStatus: newState.fetchStatus,\n      isPending,\n      isSuccess: status === \"success\",\n      isError,\n      isInitialLoading: isLoading,\n      isLoading,\n      data,\n      dataUpdatedAt: newState.dataUpdatedAt,\n      error,\n      errorUpdatedAt,\n      failureCount: newState.fetchFailureCount,\n      failureReason: newState.fetchFailureReason,\n      errorUpdateCount: newState.errorUpdateCount,\n      isFetched: newState.dataUpdateCount > 0 || newState.errorUpdateCount > 0,\n      isFetchedAfterMount: newState.dataUpdateCount > queryInitialState.dataUpdateCount || newState.errorUpdateCount > queryInitialState.errorUpdateCount,\n      isFetching,\n      isRefetching: isFetching && !isPending,\n      isLoadingError: isError && !hasData,\n      isPaused: newState.fetchStatus === \"paused\",\n      isPlaceholderData,\n      isRefetchError: isError && hasData,\n      isStale: isStale(query, options),\n      refetch: this.refetch,\n      promise: this.#currentThenable\n    };\n    const nextResult = result;\n    if (this.options.experimental_prefetchInRender) {\n      const finalizeThenableIfPossible = (thenable) => {\n        if (nextResult.status === \"error\") {\n          thenable.reject(nextResult.error);\n        } else if (nextResult.data !== void 0) {\n          thenable.resolve(nextResult.data);\n        }\n      };\n      const recreateThenable = () => {\n        const pending = this.#currentThenable = nextResult.promise = pendingThenable();\n        finalizeThenableIfPossible(pending);\n      };\n      const prevThenable = this.#currentThenable;\n      switch (prevThenable.status) {\n        case \"pending\":\n          if (query.queryHash === prevQuery.queryHash) {\n            finalizeThenableIfPossible(prevThenable);\n          }\n          break;\n        case \"fulfilled\":\n          if (nextResult.status === \"error\" || nextResult.data !== prevThenable.value) {\n            recreateThenable();\n          }\n          break;\n        case \"rejected\":\n          if (nextResult.status !== \"error\" || nextResult.error !== prevThenable.reason) {\n            recreateThenable();\n          }\n          break;\n      }\n    }\n    return nextResult;\n  }\n  updateResult() {\n    const prevResult = this.#currentResult;\n    const nextResult = this.createResult(this.#currentQuery, this.options);\n    this.#currentResultState = this.#currentQuery.state;\n    this.#currentResultOptions = this.options;\n    if (this.#currentResultState.data !== void 0) {\n      this.#lastQueryWithDefinedData = this.#currentQuery;\n    }\n    if (shallowEqualObjects(nextResult, prevResult)) {\n      return;\n    }\n    this.#currentResult = nextResult;\n    const shouldNotifyListeners = () => {\n      if (!prevResult) {\n        return true;\n      }\n      const { notifyOnChangeProps } = this.options;\n      const notifyOnChangePropsValue = typeof notifyOnChangeProps === \"function\" ? notifyOnChangeProps() : notifyOnChangeProps;\n      if (notifyOnChangePropsValue === \"all\" || !notifyOnChangePropsValue && !this.#trackedProps.size) {\n        return true;\n      }\n      const includedProps = new Set(\n        notifyOnChangePropsValue ?? this.#trackedProps\n      );\n      if (this.options.throwOnError) {\n        includedProps.add(\"error\");\n      }\n      return Object.keys(this.#currentResult).some((key) => {\n        const typedKey = key;\n        const changed = this.#currentResult[typedKey] !== prevResult[typedKey];\n        return changed && includedProps.has(typedKey);\n      });\n    };\n    this.#notify({ listeners: shouldNotifyListeners() });\n  }\n  #updateQuery() {\n    const query = this.#client.getQueryCache().build(this.#client, this.options);\n    if (query === this.#currentQuery) {\n      return;\n    }\n    const prevQuery = this.#currentQuery;\n    this.#currentQuery = query;\n    this.#currentQueryInitialState = query.state;\n    if (this.hasListeners()) {\n      prevQuery?.removeObserver(this);\n      query.addObserver(this);\n    }\n  }\n  onQueryUpdate() {\n    this.updateResult();\n    if (this.hasListeners()) {\n      this.#updateTimers();\n    }\n  }\n  #notify(notifyOptions) {\n    notifyManager.batch(() => {\n      if (notifyOptions.listeners) {\n        this.listeners.forEach((listener) => {\n          listener(this.#currentResult);\n        });\n      }\n      this.#client.getQueryCache().notify({\n        query: this.#currentQuery,\n        type: \"observerResultsUpdated\"\n      });\n    });\n  }\n};\nfunction shouldLoadOnMount(query, options) {\n  return resolveEnabled(options.enabled, query) !== false && query.state.data === void 0 && !(query.state.status === \"error\" && options.retryOnMount === false);\n}\nfunction shouldFetchOnMount(query, options) {\n  return shouldLoadOnMount(query, options) || query.state.data !== void 0 && shouldFetchOn(query, options, options.refetchOnMount);\n}\nfunction shouldFetchOn(query, options, field) {\n  if (resolveEnabled(options.enabled, query) !== false) {\n    const value = typeof field === \"function\" ? field(query) : field;\n    return value === \"always\" || value !== false && isStale(query, options);\n  }\n  return false;\n}\nfunction shouldFetchOptionally(query, prevQuery, options, prevOptions) {\n  return (query !== prevQuery || resolveEnabled(prevOptions.enabled, query) === false) && (!options.suspense || query.state.status !== \"error\") && isStale(query, options);\n}\nfunction isStale(query, options) {\n  return resolveEnabled(options.enabled, query) !== false && query.isStaleByTime(resolveStaleTime(options.staleTime, query));\n}\nfunction shouldAssignObserverCurrentProperties(observer, optimisticResult) {\n  if (!shallowEqualObjects(observer.getCurrentResult(), optimisticResult)) {\n    return true;\n  }\n  return false;\n}\nexport {\n  QueryObserver\n};\n//# sourceMappingURL=queryObserver.js.map", "\"use client\";\n\n// src/QueryClientProvider.tsx\nimport * as React from \"react\";\nimport { jsx } from \"react/jsx-runtime\";\nvar QueryClientContext = React.createContext(\n  void 0\n);\nvar useQueryClient = (queryClient) => {\n  const client = React.useContext(QueryClientContext);\n  if (queryClient) {\n    return queryClient;\n  }\n  if (!client) {\n    throw new Error(\"No QueryClient set, use QueryClientProvider to set one\");\n  }\n  return client;\n};\nvar QueryClientProvider = ({\n  client,\n  children\n}) => {\n  React.useEffect(() => {\n    client.mount();\n    return () => {\n      client.unmount();\n    };\n  }, [client]);\n  return /* @__PURE__ */ jsx(QueryClientContext.Provider, { value: client, children });\n};\nexport {\n  QueryClientContext,\n  QueryClientProvider,\n  useQueryClient\n};\n//# sourceMappingURL=QueryClientProvider.js.map", "\"use client\";\n\n// src/isRestoring.ts\nimport * as React from \"react\";\nvar IsRestoringContext = React.createContext(false);\nvar useIsRestoring = () => React.useContext(IsRestoringContext);\nvar IsRestoringProvider = IsRestoringContext.Provider;\nexport {\n  IsRestoringProvider,\n  useIsRestoring\n};\n//# sourceMappingURL=isRestoring.js.map", "\"use client\";\n\n// src/QueryErrorResetBoundary.tsx\nimport * as React from \"react\";\nimport { jsx } from \"react/jsx-runtime\";\nfunction createValue() {\n  let isReset = false;\n  return {\n    clearReset: () => {\n      isReset = false;\n    },\n    reset: () => {\n      isReset = true;\n    },\n    isReset: () => {\n      return isReset;\n    }\n  };\n}\nvar QueryErrorResetBoundaryContext = React.createContext(createValue());\nvar useQueryErrorResetBoundary = () => React.useContext(QueryErrorResetBoundaryContext);\nvar QueryErrorResetBoundary = ({\n  children\n}) => {\n  const [value] = React.useState(() => createValue());\n  return /* @__PURE__ */ jsx(QueryErrorResetBoundaryContext.Provider, { value, children: typeof children === \"function\" ? children(value) : children });\n};\nexport {\n  QueryErrorResetBoundary,\n  useQueryErrorResetBoundary\n};\n//# sourceMappingURL=QueryErrorResetBoundary.js.map", "// src/utils.ts\nfunction shouldThrowError(throwError, params) {\n  if (typeof throwError === \"function\") {\n    return throwError(...params);\n  }\n  return !!throwError;\n}\nfunction noop() {\n}\nexport {\n  noop,\n  shouldThrowError\n};\n//# sourceMappingURL=utils.js.map", "\"use client\";\n\n// src/errorBoundaryUtils.ts\nimport * as React from \"react\";\nimport { shouldThrowError } from \"./utils.js\";\nvar ensurePreventErrorBoundaryRetry = (options, errorResetBoundary) => {\n  if (options.suspense || options.throwOnError || options.experimental_prefetchInRender) {\n    if (!errorResetBoundary.isReset()) {\n      options.retryOnMount = false;\n    }\n  }\n};\nvar useClearResetErrorBoundary = (errorResetBoundary) => {\n  React.useEffect(() => {\n    errorResetBoundary.clearReset();\n  }, [errorResetBoundary]);\n};\nvar getHasError = ({\n  result,\n  errorResetBoundary,\n  throwOnError,\n  query,\n  suspense\n}) => {\n  return result.isError && !errorResetBoundary.isReset() && !result.isFetching && query && (suspense && result.data === void 0 || shouldThrowError(throwOnError, [result.error, query]));\n};\nexport {\n  ensurePreventErrorBoundaryRetry,\n  getHasError,\n  useClearResetErrorBoundary\n};\n//# sourceMappingURL=errorBoundaryUtils.js.map", "// src/suspense.ts\nvar defaultThrowOnError = (_error, query) => query.state.data === void 0;\nvar ensureSuspenseTimers = (defaultedOptions) => {\n  const originalStaleTime = defaultedOptions.staleTime;\n  if (defaultedOptions.suspense) {\n    defaultedOptions.staleTime = typeof originalStaleTime === \"function\" ? (...args) => Math.max(originalStaleTime(...args), 1e3) : Math.max(originalStaleTime ?? 1e3, 1e3);\n    if (typeof defaultedOptions.gcTime === \"number\") {\n      defaultedOptions.gcTime = Math.max(defaultedOptions.gcTime, 1e3);\n    }\n  }\n};\nvar willFetch = (result, isRestoring) => result.isLoading && result.isFetching && !isRestoring;\nvar shouldSuspend = (defaultedOptions, result) => defaultedOptions?.suspense && result.isPending;\nvar fetchOptimistic = (defaultedOptions, observer, errorResetBoundary) => observer.fetchOptimistic(defaultedOptions).catch(() => {\n  errorResetBoundary.clearReset();\n});\nexport {\n  defaultThrowOnError,\n  ensureSuspenseTimers,\n  fetchOptimistic,\n  shouldSuspend,\n  willFetch\n};\n//# sourceMappingURL=suspense.js.map", "\"use client\";\n\n// src/useBaseQuery.ts\nimport * as React from \"react\";\nimport { isServer, notifyManager } from \"@tanstack/query-core\";\nimport { useQueryClient } from \"./QueryClientProvider.js\";\nimport { useQueryErrorResetBoundary } from \"./QueryErrorResetBoundary.js\";\nimport {\n  ensurePreventErrorBoundaryRetry,\n  getHasError,\n  useClearResetErrorBoundary\n} from \"./errorBoundaryUtils.js\";\nimport { useIsRestoring } from \"./isRestoring.js\";\nimport {\n  ensureSuspenseTimers,\n  fetchOptimistic,\n  shouldSuspend,\n  willFetch\n} from \"./suspense.js\";\nimport { noop } from \"./utils.js\";\nfunction useBaseQuery(options, Observer, queryClient) {\n  if (process.env.NODE_ENV !== \"production\") {\n    if (typeof options !== \"object\" || Array.isArray(options)) {\n      throw new Error(\n        'Bad argument type. Starting with v5, only the \"Object\" form is allowed when calling query related functions. Please use the error stack to find the culprit call. More info here: https://tanstack.com/query/latest/docs/react/guides/migrating-to-v5#supports-a-single-signature-one-object'\n      );\n    }\n  }\n  const client = useQueryClient(queryClient);\n  const isRestoring = useIsRestoring();\n  const errorResetBoundary = useQueryErrorResetBoundary();\n  const defaultedOptions = client.defaultQueryOptions(options);\n  client.getDefaultOptions().queries?._experimental_beforeQuery?.(\n    defaultedOptions\n  );\n  if (process.env.NODE_ENV !== \"production\") {\n    if (!defaultedOptions.queryFn) {\n      console.error(\n        `[${defaultedOptions.queryHash}]: No queryFn was passed as an option, and no default queryFn was found. The queryFn parameter is only optional when using a default queryFn. More info here: https://tanstack.com/query/latest/docs/framework/react/guides/default-query-function`\n      );\n    }\n  }\n  defaultedOptions._optimisticResults = isRestoring ? \"isRestoring\" : \"optimistic\";\n  ensureSuspenseTimers(defaultedOptions);\n  ensurePreventErrorBoundaryRetry(defaultedOptions, errorResetBoundary);\n  useClearResetErrorBoundary(errorResetBoundary);\n  const isNewCacheEntry = !client.getQueryCache().get(defaultedOptions.queryHash);\n  const [observer] = React.useState(\n    () => new Observer(\n      client,\n      defaultedOptions\n    )\n  );\n  const result = observer.getOptimisticResult(defaultedOptions);\n  const shouldSubscribe = !isRestoring && options.subscribed !== false;\n  React.useSyncExternalStore(\n    React.useCallback(\n      (onStoreChange) => {\n        const unsubscribe = shouldSubscribe ? observer.subscribe(notifyManager.batchCalls(onStoreChange)) : noop;\n        observer.updateResult();\n        return unsubscribe;\n      },\n      [observer, shouldSubscribe]\n    ),\n    () => observer.getCurrentResult(),\n    () => observer.getCurrentResult()\n  );\n  React.useEffect(() => {\n    observer.setOptions(defaultedOptions);\n  }, [defaultedOptions, observer]);\n  if (shouldSuspend(defaultedOptions, result)) {\n    throw fetchOptimistic(defaultedOptions, observer, errorResetBoundary);\n  }\n  if (getHasError({\n    result,\n    errorResetBoundary,\n    throwOnError: defaultedOptions.throwOnError,\n    query: client.getQueryCache().get(defaultedOptions.queryHash),\n    suspense: defaultedOptions.suspense\n  })) {\n    throw result.error;\n  }\n  ;\n  client.getDefaultOptions().queries?._experimental_afterQuery?.(\n    defaultedOptions,\n    result\n  );\n  if (defaultedOptions.experimental_prefetchInRender && !isServer && willFetch(result, isRestoring)) {\n    const promise = isNewCacheEntry ? (\n      // Fetch immediately on render in order to ensure `.promise` is resolved even if the component is unmounted\n      fetchOptimistic(defaultedOptions, observer, errorResetBoundary)\n    ) : (\n      // subscribe to the \"cache promise\" so that we can finalize the currentThenable once data comes in\n      client.getQueryCache().get(defaultedOptions.queryHash)?.promise\n    );\n    promise?.catch(noop).finally(() => {\n      observer.updateResult();\n    });\n  }\n  return !defaultedOptions.notifyOnChangeProps ? observer.trackResult(result) : result;\n}\nexport {\n  useBaseQuery\n};\n//# sourceMappingURL=useBaseQuery.js.map", "\"use client\";\n\n// src/useQuery.ts\nimport { QueryObserver } from \"@tanstack/query-core\";\nimport { useBaseQuery } from \"./useBaseQuery.js\";\nfunction useQuery(options, queryClient) {\n  return useBaseQuery(options, QueryObserver, queryClient);\n}\nexport {\n  useQuery\n};\n//# sourceMappingURL=useQuery.js.map", "\"use client\";\n\n// src/useSuspenseQuery.ts\nimport { QueryObserver, skipToken } from \"@tanstack/query-core\";\nimport { useBaseQuery } from \"./useBaseQuery.js\";\nimport { defaultThrowOnError } from \"./suspense.js\";\nfunction useSuspenseQuery(options, queryClient) {\n  if (process.env.NODE_ENV !== \"production\") {\n    if (options.queryFn === skipToken) {\n      console.error(\"skipToken is not allowed for useSuspenseQuery\");\n    }\n  }\n  return useBaseQuery(\n    {\n      ...options,\n      enabled: true,\n      suspense: true,\n      throwOnError: defaultThrowOnError,\n      placeholderData: void 0\n    },\n    QueryObserver,\n    queryClient\n  );\n}\nexport {\n  useSuspenseQuery\n};\n//# sourceMappingURL=useSuspenseQuery.js.map", "// Mostly adapted from https://github.com/moxystudio/js-proper-url-join\nconst defaultUrlRegExp = /^(\\w+:\\/\\/[^/?]+)?([^?]*)(\\?.*)?$/;\n\nconst normalizeParts = (\n  parts: (string | number | null | undefined | false)[],\n): string[] =>\n  parts\n    .filter(\n      (part): part is string | number =>\n        part !== null &&\n        part !== undefined &&\n        part !== false &&\n        (typeof part === \"string\" || typeof part === \"number\"),\n    )\n    .map((part) => `${part}`)\n    .filter((part) => part);\n\ninterface ParsedParts {\n  prefix: string;\n  pathname: string[];\n}\n\nconst parseParts = (parts: string[]): ParsedParts => {\n  const partsStr = parts.join(\"/\");\n  const [, prefix = \"\", pathname = \"\"] = partsStr.match(defaultUrlRegExp) ?? [];\n\n  return {\n    prefix,\n    pathname: pathname.split(\"/\").filter((part) => part !== \"\"),\n  };\n};\n\nconst buildUrl = (parsedParts: ParsedParts): string => {\n  const { prefix, pathname } = parsedParts;\n  let url = prefix;\n\n  if (pathname.length > 0) {\n    if (url) {\n      url += \"/\";\n    } else {\n      url = \"/\";\n    }\n    url += pathname.join(\"/\");\n  } else if (!url) {\n    url = \"/\";\n  }\n\n  return url;\n};\n\nexport const joinUrl = (\n  ...parts: Array<string | number | null | undefined | false>\n): string => {\n  const normalizedParts = normalizeParts(parts);\n  const parsedParts = parseParts(normalizedParts);\n  return buildUrl(parsedParts);\n};\n", "import { useQueryClient } from \"@tanstack/react-query\";\n\nexport const CACHE_KEYS = Object.freeze({\n  API_IDENTITIES: [\"api-identities\"],\n});\n\nexport const useCache = () => {\n  const queryClient = useQueryClient();\n\n  return {\n    invalidateCache: async (key: keyof typeof CACHE_KEYS) => {\n      await queryClient.invalidateQueries({ queryKey: CACHE_KEYS[key] });\n    },\n  };\n};\n\n/**\n * If a query has this key in its queryKey, it will not put its result in the dehydrated state in the SSR.\n *\n * This is useful if the query should only be suspended and not included in the initial HTML response.\n * (e.g. too large in size, or not needed for the initial page load)\n */\nexport const NO_DEHYDRATE = \"no-dehydrate\";\n", "import { cva } from \"class-variance-authority\";\nimport { useLocation } from \"react-router\";\nimport type {\n  NavigationCategory,\n  NavigationItem,\n} from \"../../../config/validators/NavigationSchema.js\";\nimport { joinUrl } from \"../../util/joinUrl.js\";\nimport { useCurrentNavigation } from \"../context/ZudokuContext.js\";\n\nexport type TraverseCallback<T> = (\n  item: NavigationItem,\n  parentCategories: NavigationItem[],\n) => T | void;\n\nexport const traverseNavigation = <T>(\n  navigation: NavigationItem[],\n  callback: TraverseCallback<T>,\n): T | undefined => {\n  for (const item of navigation) {\n    const result = traverseNavigationItem(item, callback);\n    if (result !== undefined) return result;\n  }\n};\n\nexport const traverseNavigationItem = <T>(\n  item: NavigationItem,\n  callback: TraverseCallback<T>,\n  parentCategories: NavigationItem[] = [],\n): T | undefined => {\n  const result = callback(item, parentCategories);\n  if (result !== undefined) return result;\n\n  if (item.type === \"category\") {\n    for (const child of item.items) {\n      const childResult = traverseNavigationItem(child, callback, [\n        ...parentCategories,\n        item,\n      ]);\n      if (childResult !== undefined) return childResult;\n    }\n  }\n};\n\nexport const useCurrentItem = () => {\n  const location = useLocation();\n  const { navigation } = useCurrentNavigation();\n\n  return traverseNavigation(navigation, (item) => {\n    if (item.type === \"doc\" && joinUrl(item.path) === location.pathname) {\n      return item;\n    }\n  });\n};\n\nexport const useIsCategoryOpen = (category: NavigationCategory) => {\n  const location = useLocation();\n\n  return traverseNavigationItem(category, (item) => {\n    if (item.type === \"category\" && item.link) {\n      const categoryLinkPath = joinUrl(item.link.path);\n      if (categoryLinkPath === location.pathname) {\n        return true;\n      }\n    }\n\n    if (item.type === \"doc\") {\n      const docPath = joinUrl(item.path);\n      if (docPath === location.pathname) {\n        return true;\n      }\n    }\n  });\n};\n\nexport const usePrevNext = (): {\n  prev?: { label: string; id: string };\n  next?: { label: string; id: string };\n} => {\n  const currentId = useLocation().pathname;\n  const { navigation } = useCurrentNavigation();\n\n  let prev;\n  let next;\n\n  let foundCurrent = false;\n\n  traverseNavigation(navigation, (item) => {\n    const itemId =\n      item.type === \"doc\"\n        ? joinUrl(item.path)\n        : item.type === \"category\" && item.link\n          ? joinUrl(item.link.path)\n          : undefined;\n\n    if (!itemId) return;\n\n    if (foundCurrent) {\n      next = { label: item.label, id: itemId };\n      return true;\n    }\n\n    if (currentId === itemId) {\n      foundCurrent = true;\n    } else {\n      prev = { label: item.label, id: itemId };\n    }\n  });\n\n  return { prev, next };\n};\n\nexport const navigationListItem = cva(\n  \"relative flex items-center gap-2 px-(--padding-nav-item) my-0.5 py-1.5 rounded-lg hover:bg-accent tabular-nums\",\n  {\n    variants: {\n      isActive: {\n        true: \"bg-accent font-medium\",\n        false: \"text-foreground/80\",\n      },\n      isMuted: {\n        true: \"text-foreground/30\",\n        false: \"\",\n      },\n      isPending: {\n        true: \"bg-accent animate-pulse\",\n        false: \"\",\n      },\n    },\n    defaultVariants: {\n      isActive: false,\n    },\n  },\n);\n\nexport const isHiddenItem =\n  (isAuthenticated?: boolean) =>\n  (item: NavigationItem): boolean => {\n    if (item.display === \"hide\") return false;\n    if (!item.label) return false;\n\n    return (\n      (item.display === \"auth\" && isAuthenticated) ||\n      (item.display === \"anon\" && !isAuthenticated) ||\n      !item.display ||\n      item.display === \"always\"\n    );\n  };\n", "import { useQuery, useSuspenseQuery } from \"@tanstack/react-query\";\nimport { createContext, useContext } from \"react\";\nimport { matchPath, useLocation } from \"react-router\";\nimport { type NavigationItem } from \"../../../config/validators/NavigationSchema.js\";\nimport { useAuth } from \"../../authentication/hook.js\";\nimport type { ZudokuContext } from \"../../core/ZudokuContext.js\";\nimport { joinUrl } from \"../../util/joinUrl.js\";\nimport { CACHE_KEYS } from \"../cache.js\";\nimport { traverseNavigation } from \"../navigation/utils.js\";\n\nexport const ZudokuReactContext = createContext<ZudokuContext | undefined>(\n  undefined,\n);\n\nexport const useZudoku = () => {\n  const context = useContext(ZudokuReactContext);\n\n  if (!context) {\n    throw new Error(\"useZudoku must be used within a ZudokuProvider.\");\n  }\n\n  return context;\n};\n\nexport const useApiIdentities = () => {\n  const { getApiIdentities } = useZudoku();\n\n  return useQuery({\n    queryFn: getApiIdentities,\n    queryKey: CACHE_KEYS.API_IDENTITIES,\n  });\n};\n\nconst getItemPath = (item: NavigationItem) => {\n  switch (item.type) {\n    case \"doc\":\n      return joinUrl(item.path);\n    case \"category\":\n      return item.link ? joinUrl(item.link.path) : undefined;\n    case \"link\":\n      return item.to;\n    case \"custom-page\":\n      return item.path;\n    default:\n      return undefined;\n  }\n};\nexport const useCurrentNavigation = () => {\n  const { getPluginNavigation, navigation, options } = useZudoku();\n  const location = useLocation();\n  const auth = useAuth();\n\n  const isProtectedRoute = options.protectedRoutes?.some((route) =>\n    matchPath(route, location.pathname),\n  );\n\n  const navItem = traverseNavigation(navigation, (item, parentCategories) => {\n    if (getItemPath(item) === location.pathname) {\n      return parentCategories.at(0) ?? item;\n    }\n  });\n\n  const { data } = useSuspenseQuery({\n    queryFn: () => getPluginNavigation(location.pathname),\n    queryKey: [\"plugin-navigation\", location.pathname],\n  });\n\n  let topNavItem = navItem;\n  if (!navItem && data.length > 0) {\n    // Extract base paths from plugin navigation items\n    const pluginBasePaths = data.flatMap((item) => {\n      return getItemPath(item)?.split(\"?\").at(0)?.split(\"#\").at(0) ?? [];\n    });\n\n    // Find top-level nav item that matches any plugin base path\n    topNavItem = navigation\n      .flatMap((item) => {\n        const itemPath = getItemPath(item);\n        return itemPath ? [{ item, path: itemPath }] : [];\n      })\n      .sort((a, b) => b.path.length - a.path.length)\n      .find(({ path }) => {\n        return pluginBasePaths.some(\n          (basePath) =>\n            matchPath({ path, end: false }, basePath) ??\n            matchPath({ path: basePath, end: false }, path),\n        );\n      })?.item;\n  }\n\n  const hasNavigation =\n    auth.isAuthEnabled && !auth.isAuthenticated && isProtectedRoute;\n\n  return {\n    navigation: hasNavigation\n      ? []\n      : [...(navItem?.type === \"category\" ? navItem.items : []), ...data],\n    topNavItem,\n  };\n};\n", "const createStoreImpl = (createState) => {\n  let state;\n  const listeners = /* @__PURE__ */ new Set();\n  const setState = (partial, replace) => {\n    const nextState = typeof partial === \"function\" ? partial(state) : partial;\n    if (!Object.is(nextState, state)) {\n      const previousState = state;\n      state = (replace != null ? replace : typeof nextState !== \"object\" || nextState === null) ? nextState : Object.assign({}, state, nextState);\n      listeners.forEach((listener) => listener(state, previousState));\n    }\n  };\n  const getState = () => state;\n  const getInitialState = () => initialState;\n  const subscribe = (listener) => {\n    listeners.add(listener);\n    return () => listeners.delete(listener);\n  };\n  const api = { setState, getState, getInitialState, subscribe };\n  const initialState = state = createState(setState, getState, api);\n  return api;\n};\nconst createStore = (createState) => createState ? createStoreImpl(createState) : createStoreImpl;\n\nexport { createStore };\n", "import React from 'react';\nimport { createStore } from 'zustand/vanilla';\n\nconst identity = (arg) => arg;\nfunction useStore(api, selector = identity) {\n  const slice = React.useSyncExternalStore(\n    api.subscribe,\n    () => selector(api.getState()),\n    () => selector(api.getInitialState())\n  );\n  React.useDebugValue(slice);\n  return slice;\n}\nconst createImpl = (createState) => {\n  const api = createStore(createState);\n  const useBoundStore = (selector) => useStore(api, selector);\n  Object.assign(useBoundStore, api);\n  return useBoundStore;\n};\nconst create = (createState) => createState ? createImpl(createState) : createImpl;\n\nexport { create, useStore };\n", "const reduxImpl = (reducer, initial) => (set, _get, api) => {\n  api.dispatch = (action) => {\n    set((state) => reducer(state, action), false, action);\n    return action;\n  };\n  api.dispatchFromDevtools = true;\n  return { dispatch: (...args) => api.dispatch(...args), ...initial };\n};\nconst redux = reduxImpl;\n\nconst trackedConnections = /* @__PURE__ */ new Map();\nconst getTrackedConnectionState = (name) => {\n  const api = trackedConnections.get(name);\n  if (!api) return {};\n  return Object.fromEntries(\n    Object.entries(api.stores).map(([key, api2]) => [key, api2.getState()])\n  );\n};\nconst extractConnectionInformation = (store, extensionConnector, options) => {\n  if (store === void 0) {\n    return {\n      type: \"untracked\",\n      connection: extensionConnector.connect(options)\n    };\n  }\n  const existingConnection = trackedConnections.get(options.name);\n  if (existingConnection) {\n    return { type: \"tracked\", store, ...existingConnection };\n  }\n  const newConnection = {\n    connection: extensionConnector.connect(options),\n    stores: {}\n  };\n  trackedConnections.set(options.name, newConnection);\n  return { type: \"tracked\", store, ...newConnection };\n};\nconst removeStoreFromTrackedConnections = (name, store) => {\n  if (store === void 0) return;\n  const connectionInfo = trackedConnections.get(name);\n  if (!connectionInfo) return;\n  delete connectionInfo.stores[store];\n  if (Object.keys(connectionInfo.stores).length === 0) {\n    trackedConnections.delete(name);\n  }\n};\nconst findCallerName = (stack) => {\n  var _a, _b;\n  if (!stack) return void 0;\n  const traceLines = stack.split(\"\\n\");\n  const apiSetStateLineIndex = traceLines.findIndex(\n    (traceLine) => traceLine.includes(\"api.setState\")\n  );\n  if (apiSetStateLineIndex < 0) return void 0;\n  const callerLine = ((_a = traceLines[apiSetStateLineIndex + 1]) == null ? void 0 : _a.trim()) || \"\";\n  return (_b = /.+ (.+) .+/.exec(callerLine)) == null ? void 0 : _b[1];\n};\nconst devtoolsImpl = (fn, devtoolsOptions = {}) => (set, get, api) => {\n  const { enabled, anonymousActionType, store, ...options } = devtoolsOptions;\n  let extensionConnector;\n  try {\n    extensionConnector = (enabled != null ? enabled : (import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") && window.__REDUX_DEVTOOLS_EXTENSION__;\n  } catch (e) {\n  }\n  if (!extensionConnector) {\n    return fn(set, get, api);\n  }\n  const { connection, ...connectionInformation } = extractConnectionInformation(store, extensionConnector, options);\n  let isRecording = true;\n  api.setState = (state, replace, nameOrAction) => {\n    const r = set(state, replace);\n    if (!isRecording) return r;\n    const inferredActionType = findCallerName(new Error().stack);\n    const action = nameOrAction === void 0 ? { type: anonymousActionType || inferredActionType || \"anonymous\" } : typeof nameOrAction === \"string\" ? { type: nameOrAction } : nameOrAction;\n    if (store === void 0) {\n      connection == null ? void 0 : connection.send(action, get());\n      return r;\n    }\n    connection == null ? void 0 : connection.send(\n      {\n        ...action,\n        type: `${store}/${action.type}`\n      },\n      {\n        ...getTrackedConnectionState(options.name),\n        [store]: api.getState()\n      }\n    );\n    return r;\n  };\n  api.devtools = {\n    cleanup: () => {\n      if (connection && typeof connection.unsubscribe === \"function\") {\n        connection.unsubscribe();\n      }\n      removeStoreFromTrackedConnections(options.name, store);\n    }\n  };\n  const setStateFromDevtools = (...a) => {\n    const originalIsRecording = isRecording;\n    isRecording = false;\n    set(...a);\n    isRecording = originalIsRecording;\n  };\n  const initialState = fn(api.setState, get, api);\n  if (connectionInformation.type === \"untracked\") {\n    connection == null ? void 0 : connection.init(initialState);\n  } else {\n    connectionInformation.stores[connectionInformation.store] = api;\n    connection == null ? void 0 : connection.init(\n      Object.fromEntries(\n        Object.entries(connectionInformation.stores).map(([key, store2]) => [\n          key,\n          key === connectionInformation.store ? initialState : store2.getState()\n        ])\n      )\n    );\n  }\n  if (api.dispatchFromDevtools && typeof api.dispatch === \"function\") {\n    let didWarnAboutReservedActionType = false;\n    const originalDispatch = api.dispatch;\n    api.dispatch = (...args) => {\n      if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\" && args[0].type === \"__setState\" && !didWarnAboutReservedActionType) {\n        console.warn(\n          '[zustand devtools middleware] \"__setState\" action type is reserved to set state from the devtools. Avoid using it.'\n        );\n        didWarnAboutReservedActionType = true;\n      }\n      originalDispatch(...args);\n    };\n  }\n  connection.subscribe((message) => {\n    var _a;\n    switch (message.type) {\n      case \"ACTION\":\n        if (typeof message.payload !== \"string\") {\n          console.error(\n            \"[zustand devtools middleware] Unsupported action format\"\n          );\n          return;\n        }\n        return parseJsonThen(\n          message.payload,\n          (action) => {\n            if (action.type === \"__setState\") {\n              if (store === void 0) {\n                setStateFromDevtools(action.state);\n                return;\n              }\n              if (Object.keys(action.state).length !== 1) {\n                console.error(\n                  `\n                    [zustand devtools middleware] Unsupported __setState action format.\n                    When using 'store' option in devtools(), the 'state' should have only one key, which is a value of 'store' that was passed in devtools(),\n                    and value of this only key should be a state object. Example: { \"type\": \"__setState\", \"state\": { \"abc123Store\": { \"foo\": \"bar\" } } }\n                    `\n                );\n              }\n              const stateFromDevtools = action.state[store];\n              if (stateFromDevtools === void 0 || stateFromDevtools === null) {\n                return;\n              }\n              if (JSON.stringify(api.getState()) !== JSON.stringify(stateFromDevtools)) {\n                setStateFromDevtools(stateFromDevtools);\n              }\n              return;\n            }\n            if (!api.dispatchFromDevtools) return;\n            if (typeof api.dispatch !== \"function\") return;\n            api.dispatch(action);\n          }\n        );\n      case \"DISPATCH\":\n        switch (message.payload.type) {\n          case \"RESET\":\n            setStateFromDevtools(initialState);\n            if (store === void 0) {\n              return connection == null ? void 0 : connection.init(api.getState());\n            }\n            return connection == null ? void 0 : connection.init(getTrackedConnectionState(options.name));\n          case \"COMMIT\":\n            if (store === void 0) {\n              connection == null ? void 0 : connection.init(api.getState());\n              return;\n            }\n            return connection == null ? void 0 : connection.init(getTrackedConnectionState(options.name));\n          case \"ROLLBACK\":\n            return parseJsonThen(message.state, (state) => {\n              if (store === void 0) {\n                setStateFromDevtools(state);\n                connection == null ? void 0 : connection.init(api.getState());\n                return;\n              }\n              setStateFromDevtools(state[store]);\n              connection == null ? void 0 : connection.init(getTrackedConnectionState(options.name));\n            });\n          case \"JUMP_TO_STATE\":\n          case \"JUMP_TO_ACTION\":\n            return parseJsonThen(message.state, (state) => {\n              if (store === void 0) {\n                setStateFromDevtools(state);\n                return;\n              }\n              if (JSON.stringify(api.getState()) !== JSON.stringify(state[store])) {\n                setStateFromDevtools(state[store]);\n              }\n            });\n          case \"IMPORT_STATE\": {\n            const { nextLiftedState } = message.payload;\n            const lastComputedState = (_a = nextLiftedState.computedStates.slice(-1)[0]) == null ? void 0 : _a.state;\n            if (!lastComputedState) return;\n            if (store === void 0) {\n              setStateFromDevtools(lastComputedState);\n            } else {\n              setStateFromDevtools(lastComputedState[store]);\n            }\n            connection == null ? void 0 : connection.send(\n              null,\n              // FIXME no-any\n              nextLiftedState\n            );\n            return;\n          }\n          case \"PAUSE_RECORDING\":\n            return isRecording = !isRecording;\n        }\n        return;\n    }\n  });\n  return initialState;\n};\nconst devtools = devtoolsImpl;\nconst parseJsonThen = (stringified, fn) => {\n  let parsed;\n  try {\n    parsed = JSON.parse(stringified);\n  } catch (e) {\n    console.error(\n      \"[zustand devtools middleware] Could not parse the received json\",\n      e\n    );\n  }\n  if (parsed !== void 0) fn(parsed);\n};\n\nconst subscribeWithSelectorImpl = (fn) => (set, get, api) => {\n  const origSubscribe = api.subscribe;\n  api.subscribe = (selector, optListener, options) => {\n    let listener = selector;\n    if (optListener) {\n      const equalityFn = (options == null ? void 0 : options.equalityFn) || Object.is;\n      let currentSlice = selector(api.getState());\n      listener = (state) => {\n        const nextSlice = selector(state);\n        if (!equalityFn(currentSlice, nextSlice)) {\n          const previousSlice = currentSlice;\n          optListener(currentSlice = nextSlice, previousSlice);\n        }\n      };\n      if (options == null ? void 0 : options.fireImmediately) {\n        optListener(currentSlice, currentSlice);\n      }\n    }\n    return origSubscribe(listener);\n  };\n  const initialState = fn(set, get, api);\n  return initialState;\n};\nconst subscribeWithSelector = subscribeWithSelectorImpl;\n\nfunction combine(initialState, create) {\n  return (...args) => Object.assign({}, initialState, create(...args));\n}\n\nfunction createJSONStorage(getStorage, options) {\n  let storage;\n  try {\n    storage = getStorage();\n  } catch (e) {\n    return;\n  }\n  const persistStorage = {\n    getItem: (name) => {\n      var _a;\n      const parse = (str2) => {\n        if (str2 === null) {\n          return null;\n        }\n        return JSON.parse(str2, options == null ? void 0 : options.reviver);\n      };\n      const str = (_a = storage.getItem(name)) != null ? _a : null;\n      if (str instanceof Promise) {\n        return str.then(parse);\n      }\n      return parse(str);\n    },\n    setItem: (name, newValue) => storage.setItem(name, JSON.stringify(newValue, options == null ? void 0 : options.replacer)),\n    removeItem: (name) => storage.removeItem(name)\n  };\n  return persistStorage;\n}\nconst toThenable = (fn) => (input) => {\n  try {\n    const result = fn(input);\n    if (result instanceof Promise) {\n      return result;\n    }\n    return {\n      then(onFulfilled) {\n        return toThenable(onFulfilled)(result);\n      },\n      catch(_onRejected) {\n        return this;\n      }\n    };\n  } catch (e) {\n    return {\n      then(_onFulfilled) {\n        return this;\n      },\n      catch(onRejected) {\n        return toThenable(onRejected)(e);\n      }\n    };\n  }\n};\nconst persistImpl = (config, baseOptions) => (set, get, api) => {\n  let options = {\n    storage: createJSONStorage(() => localStorage),\n    partialize: (state) => state,\n    version: 0,\n    merge: (persistedState, currentState) => ({\n      ...currentState,\n      ...persistedState\n    }),\n    ...baseOptions\n  };\n  let hasHydrated = false;\n  const hydrationListeners = /* @__PURE__ */ new Set();\n  const finishHydrationListeners = /* @__PURE__ */ new Set();\n  let storage = options.storage;\n  if (!storage) {\n    return config(\n      (...args) => {\n        console.warn(\n          `[zustand persist middleware] Unable to update item '${options.name}', the given storage is currently unavailable.`\n        );\n        set(...args);\n      },\n      get,\n      api\n    );\n  }\n  const setItem = () => {\n    const state = options.partialize({ ...get() });\n    return storage.setItem(options.name, {\n      state,\n      version: options.version\n    });\n  };\n  const savedSetState = api.setState;\n  api.setState = (state, replace) => {\n    savedSetState(state, replace);\n    void setItem();\n  };\n  const configResult = config(\n    (...args) => {\n      set(...args);\n      void setItem();\n    },\n    get,\n    api\n  );\n  api.getInitialState = () => configResult;\n  let stateFromStorage;\n  const hydrate = () => {\n    var _a, _b;\n    if (!storage) return;\n    hasHydrated = false;\n    hydrationListeners.forEach((cb) => {\n      var _a2;\n      return cb((_a2 = get()) != null ? _a2 : configResult);\n    });\n    const postRehydrationCallback = ((_b = options.onRehydrateStorage) == null ? void 0 : _b.call(options, (_a = get()) != null ? _a : configResult)) || void 0;\n    return toThenable(storage.getItem.bind(storage))(options.name).then((deserializedStorageValue) => {\n      if (deserializedStorageValue) {\n        if (typeof deserializedStorageValue.version === \"number\" && deserializedStorageValue.version !== options.version) {\n          if (options.migrate) {\n            const migration = options.migrate(\n              deserializedStorageValue.state,\n              deserializedStorageValue.version\n            );\n            if (migration instanceof Promise) {\n              return migration.then((result) => [true, result]);\n            }\n            return [true, migration];\n          }\n          console.error(\n            `State loaded from storage couldn't be migrated since no migrate function was provided`\n          );\n        } else {\n          return [false, deserializedStorageValue.state];\n        }\n      }\n      return [false, void 0];\n    }).then((migrationResult) => {\n      var _a2;\n      const [migrated, migratedState] = migrationResult;\n      stateFromStorage = options.merge(\n        migratedState,\n        (_a2 = get()) != null ? _a2 : configResult\n      );\n      set(stateFromStorage, true);\n      if (migrated) {\n        return setItem();\n      }\n    }).then(() => {\n      postRehydrationCallback == null ? void 0 : postRehydrationCallback(stateFromStorage, void 0);\n      stateFromStorage = get();\n      hasHydrated = true;\n      finishHydrationListeners.forEach((cb) => cb(stateFromStorage));\n    }).catch((e) => {\n      postRehydrationCallback == null ? void 0 : postRehydrationCallback(void 0, e);\n    });\n  };\n  api.persist = {\n    setOptions: (newOptions) => {\n      options = {\n        ...options,\n        ...newOptions\n      };\n      if (newOptions.storage) {\n        storage = newOptions.storage;\n      }\n    },\n    clearStorage: () => {\n      storage == null ? void 0 : storage.removeItem(options.name);\n    },\n    getOptions: () => options,\n    rehydrate: () => hydrate(),\n    hasHydrated: () => hasHydrated,\n    onHydrate: (cb) => {\n      hydrationListeners.add(cb);\n      return () => {\n        hydrationListeners.delete(cb);\n      };\n    },\n    onFinishHydration: (cb) => {\n      finishHydrationListeners.add(cb);\n      return () => {\n        finishHydrationListeners.delete(cb);\n      };\n    }\n  };\n  if (!options.skipHydration) {\n    hydrate();\n  }\n  return stateFromStorage || configResult;\n};\nconst persist = persistImpl;\n\nexport { combine, createJSONStorage, devtools, persist, redux, subscribeWithSelector };\n", "import { create, type Mutate, type StoreApi } from \"zustand\";\nimport { createJSONStorage, persist } from \"zustand/middleware\";\n\nexport interface AuthState<ProviderData = unknown> {\n  isAuthenticated: boolean;\n  isPending: boolean;\n  profile: UserProfile | null;\n  providerData: ProviderData | null;\n  setAuthenticationPending: () => void;\n  setLoggedOut: () => void;\n  setLoggedIn: ({\n    profile,\n    providerData,\n  }: {\n    profile: UserProfile;\n    providerData: unknown;\n  }) => void;\n}\n\nexport type StoreWithPersist<T> = Mutate<\n  StoreApi<T>,\n  [[\"zustand/persist\", unknown]]\n>;\n\nconst withStorageDOMEvents = <T>(store: StoreWithPersist<T>) => {\n  const storageEventCallback = (e: StorageEvent) => {\n    if (e.key === store.persist.getOptions().name && e.newValue) {\n      void store.persist.rehydrate();\n    }\n  };\n\n  window.addEventListener(\"storage\", storageEventCallback);\n\n  return () => {\n    window.removeEventListener(\"storage\", storageEventCallback);\n  };\n};\n\nexport const useAuthState = create<AuthState>()(\n  persist(\n    (set) => ({\n      isAuthenticated: false,\n      isPending: true,\n      profile: null,\n      providerData: null,\n      setAuthenticationPending: () =>\n        set(() => ({\n          isAuthenticated: false,\n          isPending: false,\n          profile: null,\n          providerData: null,\n        })),\n      setLoggedOut: () =>\n        set(() => ({\n          isAuthenticated: false,\n          isPending: false,\n          profile: null,\n          providerData: null,\n        })),\n      setLoggedIn: ({\n        profile,\n        providerData,\n      }: {\n        profile: UserProfile;\n        providerData: unknown;\n      }) =>\n        set(() => ({\n          isAuthenticated: true,\n          isPending: false,\n          profile,\n          providerData,\n        })),\n    }),\n    {\n      merge: (persistedState, currentState) => {\n        return {\n          ...currentState,\n          isPending: false,\n          ...(typeof persistedState === \"object\" ? persistedState : {}),\n        };\n      },\n      name: \"auth-state\",\n      storage: createJSONStorage(() => localStorage),\n    },\n  ),\n);\n\nif (typeof window !== \"undefined\") {\n  withStorageDOMEvents(useAuthState);\n}\n\nexport interface UserProfile {\n  sub: string;\n  email: string | undefined;\n  emailVerified: boolean;\n  name: string | undefined;\n  pictureUrl: string | undefined;\n  [key: string]: string | boolean | undefined;\n}\n", "import { useZudoku } from \"../components/context/ZudokuContext.js\";\nimport { useAuthState } from \"./state.js\";\n\nexport const useAuth = () => {\n  const { authentication } = useZudoku();\n  const authState = useAuthState();\n  const isAuthEnabled = typeof authentication !== \"undefined\";\n\n  return {\n    isAuthEnabled,\n    ...authState,\n\n    login: async () => {\n      if (!isAuthEnabled) {\n        throw new Error(\"Authentication is not enabled.\");\n      }\n      // TODO: Should handle errors/state\n      await authentication.signIn({\n        redirectTo: window.location.href,\n      });\n    },\n\n    logout: async () => {\n      if (!isAuthEnabled) {\n        throw new Error(\"Authentication is not enabled.\");\n      }\n      // TODO: Should handle errors/state\n      await authentication.signOut();\n\n      // Redirect to home\n      window.location.href = \"/\";\n    },\n\n    signup: async () => {\n      if (!isAuthEnabled) {\n        throw new Error(\"Authentication is not enabled.\");\n      }\n      await authentication.signUp({\n        redirectTo: window.location.href,\n      });\n    },\n  };\n};\n"],
  "mappings": "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",
  "names": ["falsyToString", "value", "cx", "clsx", "cva", "base", "config", "props", "_config_compoundVariants", "variants", "defaultVariants", "getVariantClassNames", "variant", "variantProp", "defaultVariantProp", "variantKey", "propsWithoutUndefined", "acc", "param", "key", "getCompoundVariantClassNames", "cvClass", "cvClassName", "compoundVariantOptions", "Subscribable", "listener", "isServer", "noop", "functionalUpdate", "updater", "input", "isValidTimeout", "value", "timeUntilStale", "updatedAt", "staleTime", "resolveStaleTime", "query", "resolveEnabled", "enabled", "matchQuery", "filters", "type", "exact", "fetchStatus", "predicate", "queryKey", "stale", "hashQueryKeyByOptions", "partialMatchKey", "isActive", "matchMutation", "mutation", "status", "mutationKey", "hashKey", "options", "_", "val", "isPlainObject", "result", "key", "a", "b", "replaceEqualDeep", "array", "isPlainArray", "aItems", "aSize", "bItems", "bSize", "copy", "equalItems", "i", "shallowEqualObjects", "o", "hasObjectPrototype", "ctor", "prot", "sleep", "timeout", "resolve", "replaceData", "prevData", "data", "error", "addToEnd", "items", "item", "max", "newItems", "addToStart", "skipToken", "ensureQueryFn", "options", "fetchOptions", "FocusManager", "Subscribable", "#focused", "#cleanup", "#setup", "onFocus", "isServer", "listener", "setup", "focused", "isFocused", "focusManager", "OnlineManager", "#online", "onOnline", "onlineListener", "offlineListener", "online", "onlineManager", "pendingThenable", "resolve", "reject", "thenable", "_resolve", "_reject", "finalize", "data", "value", "reason", "defaultRetryDelay", "failureCount", "canFetch", "networkMode", "CancelledError", "isCancelledError", "createRetryer", "config", "isRetryCancelled", "isResolved", "continueFn", "cancel", "cancelOptions", "cancelRetry", "continueRetry", "canContinue", "canStart", "pause", "continueResolve", "run", "promiseOrValue", "initialPromise", "error", "retry", "retryDelay", "delay", "shouldRetry", "sleep", "defaultScheduler", "cb", "createNotifyManager", "queue", "transactions", "notifyFn", "callback", "batchNotifyFn", "scheduleFn", "schedule", "flush", "originalQueue", "result", "args", "fn", "notifyManager", "Removable", "#gcTimeout", "isValidTimeout", "newGcTime", "Query", "#initialState", "#revertState", "#cache", "#client", "#retryer", "#defaultOptions", "#abortSignalConsumed", "getDefaultState", "newData", "replaceData", "#dispatch", "state", "setStateOptions", "promise", "noop", "observer", "resolveEnabled", "staleTime", "timeUntilStale", "x", "abortController", "addSignalProperty", "object", "fetchFn", "queryFn", "queryFnContext", "context", "onError", "action", "reducer", "fetchState", "hasData", "initialDataUpdatedAt", "QueryObserver", "client", "#selectError", "#currentThenable", "#currentQuery", "#currentQueryInitialState", "#currentResult", "#currentResultState", "#currentResultOptions", "#selectFn", "#selectResult", "#lastQueryWithDefinedData", "#staleTimeoutId", "#refetchIntervalId", "#currentRefetchInterval", "#trackedProps", "shouldFetchOnMount", "#executeFetch", "#updateTimers", "shouldFetchOn", "#clearStaleTimeout", "#clearRefetchInterval", "prevOptions", "prevQuery", "#updateQuery", "shallowEqualObjects", "mounted", "shouldFetchOptionally", "resolveStaleTime", "#updateStaleTimeout", "nextRefetchInterval", "#computeRefetchInterval", "#updateRefetchInterval", "query", "shouldAssignObserverCurrentProperties", "onPropTracked", "trackedResult", "key", "defaultedOptions", "timeout", "nextInterval", "prevResult", "prevResultState", "prevResultOptions", "queryInitialState", "newState", "isPlaceholderData", "fetchOnMount", "fetchOptionally", "errorUpdatedAt", "status", "skipSelect", "placeholderData", "selectError", "isFetching", "isPending", "isError", "isLoading", "nextResult", "isStale", "finalizeThenableIfPossible", "recreateThenable", "pending", "prevThenable", "shouldNotifyListeners", "notifyOnChangeProps", "notifyOnChangePropsValue", "includedProps", "typedKey", "#notify", "notifyOptions", "shouldLoadOnMount", "field", "optimisticResult", "QueryClientContext", "useQueryClient", "queryClient", "QueryClientProvider", "children", "jsx", "IsRestoringContext", "useIsRestoring", "createValue", "isReset", "QueryErrorResetBoundaryContext", "useQueryErrorResetBoundary", "shouldThrowError", "throwError", "params", "ensurePreventErrorBoundaryRetry", "errorResetBoundary", "useClearResetErrorBoundary", "React", "getHasError", "throwOnError", "suspense", "defaultThrowOnError", "_error", "ensureSuspenseTimers", "originalStaleTime", "willFetch", "isRestoring", "shouldSuspend", "fetchOptimistic", "useBaseQuery", "Observer", "isNewCacheEntry", "shouldSubscribe", "onStoreChange", "unsubscribe", "useQuery", "useSuspenseQuery", "defaultUrlRegExp", "normalizeParts", "parts", "part", "parseParts", "partsStr", "prefix", "pathname", "buildUrl", "parsedParts", "url", "joinUrl", "normalizedParts", "CACHE_KEYS", "useCache", "NO_DEHYDRATE", "traverseNavigation", "navigation", "traverseNavigationItem", "parentCategories", "child", "childResult", "useCurrentItem", "location", "useLocation", "useCurrentNavigation", "useIsCategoryOpen", "category", "usePrevNext", "currentId", "prev", "next", "foundCurrent", "itemId", "navigationListItem", "cva", "isHiddenItem", "isAuthenticated", "ZudokuReactContext", "createContext", "useZudoku", "useContext", "useApiIdentities", "getApiIdentities", "getItemPath", "getPluginNavigation", "auth", "useAuth", "isProtectedRoute", "route", "matchPath", "navItem", "topNavItem", "pluginBasePaths", "itemPath", "a", "b", "path", "basePath", "createStoreImpl", "createState", "listeners", "setState", "partial", "replace", "nextState", "previousState", "getState", "api", "initialState", "createStore", "identity", "arg", "useStore", "selector", "slice", "createImpl", "useBoundStore", "create", "createJSONStorage", "getStorage", "storage", "name", "_a", "parse", "str2", "str", "newValue", "toThenable", "input", "onFulfilled", "_onRejected", "e", "_onFulfilled", "onRejected", "persistImpl", "baseOptions", "set", "get", "persistedState", "currentState", "hasHydrated", "hydrationListeners", "finishHydrationListeners", "setItem", "savedSetState", "configResult", "stateFromStorage", "hydrate", "_b", "_a2", "postRehydrationCallback", "deserializedStorageValue", "migration", "migrationResult", "migrated", "migratedState", "newOptions", "persist", "withStorageDOMEvents", "store", "storageEventCallback", "useAuthState", "profile", "providerData", "authentication", "authState", "isAuthEnabled"]
}
