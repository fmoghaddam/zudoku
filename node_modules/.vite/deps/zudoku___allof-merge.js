import "./chunk-G3PMV62Z.js";

// node_modules/allof-merge/dist/index.mjs
function e(e2, t2) {
  var r2 = {};
  for (var n2 in e2) Object.prototype.hasOwnProperty.call(e2, n2) && t2.indexOf(n2) < 0 && (r2[n2] = e2[n2]);
  if (null != e2 && "function" == typeof Object.getOwnPropertySymbols) {
    var s2 = 0;
    for (n2 = Object.getOwnPropertySymbols(e2); s2 < n2.length; s2++) t2.indexOf(n2[s2]) < 0 && Object.prototype.propertyIsEnumerable.call(e2, n2[s2]) && (r2[n2[s2]] = e2[n2[s2]]);
  }
  return r2;
}
function t(e2, t2) {
  var r2 = {};
  for (var n2 in e2) Object.prototype.hasOwnProperty.call(e2, n2) && t2.indexOf(n2) < 0 && (r2[n2] = e2[n2]);
  if (null != e2 && "function" == typeof Object.getOwnPropertySymbols) {
    var s2 = 0;
    for (n2 = Object.getOwnPropertySymbols(e2); s2 < n2.length; s2++) t2.indexOf(n2[s2]) < 0 && Object.prototype.propertyIsEnumerable.call(e2, n2[s2]) && (r2[n2[s2]] = e2[n2[s2]]);
  }
  return r2;
}
var r = (e2 = {}, t2, r2, n2) => {
  const s2 = `/${t2}`, o2 = "function" == typeof e2["/**"] ? e2["/**"]({ key: t2, path: r2, value: n2 }) : e2["/**"], i2 = "function" == typeof e2["/*"] ? e2["/*"]({ key: t2, path: r2, value: n2 }) : e2["/*"];
  let a2 = {};
  if (s2 in e2) a2 = e2[s2];
  else if (!o2 && !i2) return;
  return a2 = "function" == typeof a2 ? a2({ key: t2, path: r2, value: n2 }) : a2, i2 && (a2 = Object.assign(Object.assign({}, i2), a2)), o2 ? Object.assign(Object.assign({ "/**": e2["/**"] }, o2), a2) : a2;
};
var n = (e2) => {
  const t2 = {}, r2 = e2.reduce(((e3, t3) => (Object.keys(t3).forEach(((t4) => e3.add(t4))), e3)), /* @__PURE__ */ new Set());
  for (const s2 of r2.keys()) {
    const r3 = e2.filter(((e3) => s2 in e3));
    if (1 !== r3.length) {
      if ("/" !== s2.charAt(0)) throw new Error(`Cannot merge rules. Duplicate key: ${s2}. Rules should not have same Rule key`);
      t2[s2] = (e3, t3) => {
        const o2 = r3.map(((r4) => "function" == typeof r4[s2] ? r4[s2](e3, t3) : r4[s2]));
        return n(o2);
      };
    } else t2[s2] = r3[0][s2];
  }
  return t2;
};
var s = (e2) => "object" == typeof e2 && null !== e2;
var o = (e2) => Array.isArray(e2);
var i = (e2, i2, a2 = {}) => {
  var l2, f2;
  i2 = o(i2) ? i2 : [i2];
  const c2 = o(a2.rules) ? n(a2.rules) : a2.rules, u2 = [{ data: e2, state: a2.state, path: [], keys: [], keyIndex: -1, rules: c2 }];
  for (; u2.length > 0; ) {
    const e3 = u2[u2.length - 1];
    if (e3.keyIndex >= e3.keys.length) {
      for (; null === (l2 = e3.hooks) || void 0 === l2 ? void 0 : l2.length; ) e3.hooks.pop()();
      u2.pop();
      continue;
    }
    const n2 = e3.keys[e3.keyIndex++], [a3, p2, d2] = u2.length > 1 ? [e3.data[n2], [...e3.path, n2], r(e3.rules, n2, [...e3.path, n2], e3.data[n2])] : [e3.data, e3.path, c2];
    let y2 = { value: a3, path: p2, key: n2, state: e3.state, rules: d2 };
    const h2 = [];
    for (const e4 of i2) {
      if (!e4 || "function" != typeof e4) continue;
      const r2 = null !== (f2 = e4(y2)) && void 0 !== f2 ? f2 : {}, { terminate: n3, done: s2, exitHook: o2 } = r2, i3 = t(r2, ["terminate", "done", "exitHook"]);
      if (n3) return;
      if (o2 && h2.push(o2), y2 = Object.assign(Object.assign({}, y2), i3), s2) {
        y2 = null;
        break;
      }
    }
    if (y2 && s(y2.value)) {
      const e4 = o(y2.value) ? [...y2.value.keys()] : Object.keys(y2.value);
      u2.push({ hooks: h2, state: y2.state, data: y2.value, path: p2, keys: e4, keyIndex: 0, rules: y2.rules });
    } else for (; h2.length; ) h2.pop()();
  }
};
var a = () => {
  const e2 = /* @__PURE__ */ new WeakMap();
  let t2;
  return [({ value: e3 }) => {
    t2 = e3;
  }, ({ value: r2, path: n2, key: o2, state: i2 }) => {
    if (o2 = n2.length ? o2 : "#", s(t2) && s(r2)) {
      if (e2.has(t2)) return i2.node[o2] = e2.get(t2), { done: true };
      const n3 = Array.isArray(r2) ? [] : {};
      i2.node[o2] = n3, e2.set(t2, n3);
    } else i2.node[o2] = r2;
    return { value: r2, state: Object.assign(Object.assign({}, i2), { node: i2.node[o2] }) };
  }];
};
var l = class extends Map {
  add(e2, t2) {
    const r2 = this.get(e2);
    return r2 ? r2.push(t2) : this.set(e2, [t2]), this;
  }
};
var f = (e2, t2) => {
  const r2 = {};
  for (const n2 of t2) n2 in e2 && (r2[n2] = e2[n2], delete e2[n2]);
  return r2;
};
var c = (e2, t2) => {
  if (Array.isArray(e2) && Array.isArray(t2)) return [...e2, ...t2];
  if (s(e2) && s(t2)) {
    const r2 = Object.assign({}, e2);
    for (const e3 of Object.keys(t2)) r2[e3] = c(r2[e3], t2[e3]);
    return r2;
  }
  return t2;
};
var u = (e2) => e2 && e2.$ref && "string" == typeof e2.$ref;
var p = (e2) => e2 && e2.anyOf && Array.isArray(e2.anyOf);
var d = (e2) => e2 && e2.oneOf && Array.isArray(e2.oneOf);
var y = (e2, t2 = "") => {
  const [r2 = t2, n2] = e2.split("#"), s2 = n2 && "/" !== n2 ? n2 : "";
  return { filePath: r2, pointer: s2, normalized: h(r2, s2), jsonPath: m(s2) };
};
var h = (e2, t2) => e2 ? `${e2}${t2 ? "#" + t2 : ""}` : t2 ? `#${t2}` : "#";
var g = (e2, t2, r2 = [t2]) => {
  if (!s(e2)) return;
  let n2 = e2;
  const o2 = m(t2);
  for (const t3 of o2) if (Array.isArray(n2) && n2.length > +t3) n2 = n2[+t3];
  else if (s(n2) && t3 in n2) n2 = n2[t3];
  else {
    if (!u(n2)) return;
    {
      const t4 = y(n2.$ref);
      n2 = t4.filePath || r2.includes(t4.pointer) ? void 0 : g(e2, t4.pointer, [...r2, t4.pointer]);
    }
  }
  return n2;
};
var O = { slash: /\//g, tilde: /~/g, escapedSlash: /~1/g, escapedTilde: /~0/g };
var m = (e2) => e2.split("/").map(((e3) => decodeURIComponent(e3.replace(O.escapedSlash, "/").replace(O.escapedTilde, "~")))).slice(1);
var $ = (e2) => e2.length ? "/" + e2.map(((e3) => encodeURIComponent(String(e3).replace(O.tilde, "~0").replace(O.slash, "~1")))).join("/") : "";
var b = (e2, t2) => JSON.stringify(e2) == JSON.stringify(t2);
var v = (e2) => {
  let t2 = 1;
  for (; e2 * t2 % 1 != 0; ) t2 *= 10;
  return t2;
};
function j(e2) {
  const t2 = e2.reduce(((e3, t3) => Math.max(e3, v(t3))), 0);
  return e2.reduce(((e3, r2) => Math.round(e3 * t2 * r2 * t2 / k(e3 * t2, r2 * t2)) / t2));
}
function k(e2, t2) {
  return 0 === t2 ? e2 : k(t2, e2 % t2);
}
var A = (e2) => {
  if (0 === e2.length) return [[]];
  const t2 = e2[0], r2 = e2.slice(1), n2 = A(r2), s2 = [];
  for (const e3 of t2) for (const t3 of n2) s2.push([e3, ...t3]);
  return s2;
};
var x = (e2) => {
  const t2 = [];
  for (const r2 of e2) {
    if (!("properties" in r2)) continue;
    const n2 = new Set(Object.keys(r2.properties)), s2 = new l();
    for (const t3 of n2.values()) for (const o3 of e2) if (!(o3 == r2 || o3.properties && t3 in o3.properties)) if ("patternProperties" in o3 && o3.patternProperties) for (const e3 of Object.keys(o3.patternProperties)) new RegExp(e3).test(t3) || n2.delete(t3);
    else "additionalProperties" in o3 && (false === o3.additionalProperties ? n2.delete(t3) : "object" == typeof o3.additionalProperties && s2.add(t3, o3.additionalProperties));
    if (!n2.size) continue;
    const o2 = {};
    for (const e3 of n2.values()) s2.has(e3) ? o2[e3] = { allOf: [r2.properties[e3], ...s2.get(e3)] } : o2[e3] = r2.properties[e3];
    t2.push(o2);
  }
  return t2;
};
var P = (e2) => {
  const t2 = [];
  for (const r2 of e2) {
    if (!("patternProperties" in r2)) continue;
    const n2 = new Set(Object.keys(r2.patternProperties));
    for (const t3 of e2) if (t3 != r2 && "additionalProperties" in t3 && !t3.additionalProperties) for (const e3 of n2.values()) t3.patternProperties && e3 in t3.patternProperties || n2.delete(e3);
    if (!n2.size) continue;
    const s2 = {};
    for (const e3 of n2.values()) s2[e3] = r2.patternProperties[e3];
    t2.push(s2);
  }
  return t2;
};
var I = (e2) => {
  const t2 = {}, r2 = E(e2);
  for (const [e3, n2] of Object.entries(r2)) n2.includes(false) ? t2[e3] = false : t2[e3] = n2.length > 1 ? { allOf: n2 } : n2[0];
  return t2;
};
var w = (e2, t2) => !!e2.reduce(((e3, t3) => e3 && true === t3), true) || R(e2, t2);
var S = () => "Could not merge values, they are probably incompatible";
var M = (e2) => `Merge rule not found for key: ${e2}`;
var E = (e2) => {
  const t2 = {};
  for (const r2 of e2) for (const e3 of Object.keys(r2)) Array.isArray(t2[e3]) ? t2[e3].push(r2[e3]) : t2[e3] = [r2[e3]];
  return t2;
};
var R = (e2, t2) => {
  if (e2.includes(false)) return false;
  const r2 = {}, n2 = E(e2);
  "properties" in n2 && (n2.properties = x(e2)), "patternProperties" in n2 && (n2.patternProperties = P(e2));
  for (let [s2, o2] of Object.entries(n2)) {
    if (!o2.length) continue;
    const n3 = t2.mergeRules;
    let i2 = `/${s2}` in n3 ? n3[`/${s2}`] : n3["/?"];
    i2 = i2 && !("$" in i2) && "/" in i2 ? i2["/"] : i2, i2 = "function" == typeof i2 ? i2() : i2;
    const a2 = i2 && "$" in i2 ? i2.$ : void 0;
    if (!a2) throw new Error(M(s2));
    const l2 = o2.length > 1 ? a2(o2, Object.assign(Object.assign({}, t2), { allOfItems: e2 })) : o2[0];
    void 0 === l2 ? t2.mergeError(o2) : r2[s2] = l2;
  }
  return Object.keys(r2).length ? r2 : void 0;
};
var H = ([e2]) => e2;
var C = (e2) => e2[e2.length - 1];
var q = (e2) => e2.reduce(((e3, t2) => e3 || t2), false);
var N = (e2) => Math.min(...e2);
var J = (e2) => Math.max(...e2);
var z = (e2) => e2.length > 1 ? e2.reduce(((e3, t2) => `${e3}(?=${t2})`), "") : e2[0];
var B = ([e2, ...t2]) => t2.reduce(((e3, t3) => e3.filter(((e4) => t3.includes(e4)))), e2);
var L = ([e2, ...t2]) => t2.find(((t3) => !b(t3, e2))) ? void 0 : e2;
var U = ([e2, ...t2]) => t2.reduce(((e3, t3) => c(e3, t3)), e2);
var D = (e2) => A(e2).map(((e3) => ({ allOf: e3 })));
var T = (e2) => ({ anyOf: e2 });
var W = (e2) => j(e2);
var F = (e2, t2) => {
  const r2 = e2.map(((e3) => e3.map(((e4) => JSON.stringify(e4))))), n2 = B(r2).map(((e3) => JSON.parse(e3))).sort();
  return n2.length || t2.mergeError(e2), n2;
};
var G = (e2, t2) => {
  const r2 = e2.map(((e3) => Array.isArray(e3) ? e3 : [e3])), n2 = B(r2);
  return 1 === n2.length ? n2[0] : n2.length ? n2 : void 0;
};
var K = (e2) => {
  const t2 = /* @__PURE__ */ new Set();
  for (const r2 of e2) for (const e3 of r2) t2.add(e3);
  return Array.from(t2).sort();
};
var Q = (e2, t2) => {
  const r2 = {}, n2 = E(e2);
  for (const [e3, t3] of Object.entries(n2)) {
    if (t3.reduce(((e4, t4) => e4 && Array.isArray(t4)), true)) r2[e3] = K(t3);
    else {
      const n3 = t3.map(((e4) => Array.isArray(e4) ? { required: e4 } : e4));
      r2[e3] = n3.length > 1 ? { allOf: n3 } : n3[0];
    }
  }
  return r2;
};
var V = (e2, t2) => {
  if (!e2.reduce(((e3, t3) => Array.isArray(t3) || e3), false)) return R(e2, t2);
  const r2 = [];
  let n2 = 1 / 0, s2 = 0;
  const o2 = new l();
  for (const e3 of t2.allOfItems) "additionalItems" in e3 && e3.additionalItems && "items" in e3 && Array.isArray(e3.items) && o2.add(e3.items.length, e3.additionalItems), "items" in e3 && (r2.push(e3.items), Array.isArray(e3.items) && (s2 = Math.max(s2, e3.items.length), "additionalItems" in e3 && false === e3.additionalItems && (n2 = Math.min(n2, e3.items.length))));
  const i2 = Math.min(s2, n2), a2 = [...Array(i2)].map((() => ({ allOf: [] })));
  for (const e3 of r2) if (Array.isArray(e3)) for (let t3 = 0; t3 < i2; t3++) {
    const r3 = [];
    for (let e4 = 0; e4 <= t3; e4++) o2.has(e4) && r3.push(...o2.get(e4));
    t3 < e3.length ? a2[t3].allOf.push(r3.length ? Object.assign(Object.assign({}, e3[t3]), { allOf: r3 }) : e3[t3]) : a2[t3].allOf.push(!r3.length || { allOf: r3 });
  }
  else a2.forEach((({ allOf: t3 }) => t3.push(e3)));
  return a2;
};
var X = (e2, t2) => {
  const r2 = [], n2 = [];
  for (const e3 of t2.allOfItems) "items" in e3 && !Array.isArray(e3.items) && n2.push(e3.items), "additionalItems" in e3 && "items" in e3 && Array.isArray(e3.items) && r2.push(e3.additionalItems);
  return n2.length && r2.forEach(((e3) => e3.allOf = n2)), R(r2, t2);
};
var Y = ["draft-04", "draft-06"];
var Z = (e2 = "draft-06", t2 = {}) => Object.assign(Object.assign(Object.assign(Object.assign({ "/maximum": { $: N }, "/exclusiveMaximum": { $: q }, "/minimum": { $: J }, "/exclusiveMinimum": { $: q }, "/maxLength": { $: N }, "/minLength": { $: J }, "/maxItems": { $: N }, "/minItems": { $: J }, "/uniqueItems": { $: q }, "/maxProperties": { $: N }, "/minProperties": { $: J }, "/required": { $: K }, "/multipleOf": { $: W }, "/enum": { $: F }, "/type": { $: G }, "/allOf": { "/*": () => Z(e2, t2), $: D }, "/not": { $: T }, "/oneOf": { "/*": () => Z(e2, t2), $: D, sibling: ["definitions", "$defs", "$id", "$schema"] }, "/anyOf": { "/*": () => Z(e2, t2), $: D, sibling: ["definitions", "$defs", "$id", "$schema"] }, "/properties": { "/*": () => Z(e2, t2), $: I }, "/items": () => Object.assign(Object.assign({}, Z(e2, t2)), { $: V, "/*": ({ key: r2 }) => "number" == typeof r2 ? Z(e2, t2) : {} }), "/additionalProperties": () => Object.assign(Object.assign({}, Z(e2, t2)), { $: w }), "/additionalItems": () => Object.assign(Object.assign({}, Z(e2, t2)), { $: X }), "/patternProperties": { "/*": () => Z(e2, t2), $: I }, "/pattern": { $: z }, "/readOnly": { $: q }, "/writeOnly": { $: q }, "/example": { $: U }, "/examples": { $: U }, "/deprecated": { $: q } }, "draft-04" !== e2 ? { "/propertyNames": () => Z(e2, t2), "/contains": () => Z(e2, t2), "/dependencies": { "/*": () => Z(e2, t2), $: Q }, "/const": { $: L }, "/exclusiveMaximum": { $: N }, "/exclusiveMinimum": { $: J }, "/$defs": { "/*": () => Z(e2, t2), $: U } } : {}), { "/definitions": { "/*": () => Z(e2, t2), $: U }, "/xml": { $: U }, "/externalDocs": { $: C }, "/description": { $: C }, "/title": { $: C }, "/format": { $: C }, "/default": { $: C }, "/?": { $: C } }), t2), { $: R });
var _ = ["3.0.x", "3.1.x"];
var ee = (e2) => Z(e2, { "/discriminator": { $: U }, "/oneOf": { "/*": () => ee(e2), $: D, sibling: ["discriminator"] }, "/anyOf": { "/*": () => ee(e2), $: D, sibling: ["discriminator"] } });
var te = (e2) => "3.0.x" === e2 ? Object.assign(Object.assign({}, ee("draft-04")), { "/items": ({ key: e3 }) => Object.assign(Object.assign({}, ee("draft-04")), { $: V }) }) : ee("draft-06");
var re = (e2) => ({ "/*": { "/schema": te(e2) } });
var ne = (e2) => ({ "/content": { "/*": { "/schema": te(e2), "/encoding": { "/headers": re(e2) } } } });
var se = (e2) => ({ "/*": { "/headers": re(e2), "/content": { "/*": { "/schema": te(e2), "/encoding": { "/headers": re(e2) } } } } });
var oe = (e2 = "3.0.x") => ({ "/paths": { "/*": { "/*": { "/parameters": re(e2), "/requestBody": ne(e2), "/responses": se(e2) }, "/parameters": re(e2) } }, "/components": { "/schemas": { "/*": te(e2) }, "/responses": se(e2), "/parameters": re(e2), "/requestBodies": { "/*": ne(e2) }, "/headers": re(e2) } });
var ie = Z("draft-06", { "/args": () => ie, "/nullable": { $: q }, "/specifiedByURL": { $: C }, "/values": { $: U, "/*": { $: U, "/description": { $: C }, "/deprecated": { $: C, "/reason": { $: C } } } }, "/interfaces": { $: U, "/*": { $: U } }, "/directives": { $: U, "/*": () => Object.assign(Object.assign({}, ie), { "/meta": { $: U } }) } });
var ae = { "/queries": { "/*": () => ie }, "/mutations": { "/*": () => ie }, "/subscriptions": { "/*": () => ie }, "/components": { "/*": { "/*": ie }, "/directives": { "/*": { "/args": () => ie } } } };
var le = (t2, r2, n2) => {
  const s2 = n2.sibling || [], o2 = t2, i2 = r2, a2 = o2[i2], l2 = e(o2, ["symbol" == typeof i2 ? i2 : i2 + ""]), c2 = f(l2, s2);
  return Object.keys(l2).length ? Object.assign({ [r2]: a2.map(((e2) => ({ allOf: [l2, e2] }))) }, c2) : t2;
};
var fe = (t2, r2, n2, s2) => {
  const o2 = [], i2 = $(r2), a2 = [], l2 = { pointer: i2, data: "", refs: [] };
  for (const r3 of t2) if (u(r3) && !a2.includes(r3.$ref)) {
    "" === l2.data && (l2.data = JSON.stringify(t2));
    const { $ref: i3 } = r3, f3 = e(r3, ["$ref"]), { filePath: c2, normalized: u2, pointer: p2 } = y(i3), d2 = s2.find(((e2) => e2.refs.includes(r3.$ref) && e2.data === l2.data && p2 !== e2.pointer));
    if (d2) return { allOfItems: [{ $ref: "#" + d2.pointer }], brokenRefs: a2 };
    l2.refs.push(u2);
    const h2 = c2 ? void 0 : g(n2, p2);
    void 0 === h2 ? (a2.push(u2), o2.push(r3)) : o2.push(h2), Object.keys(f3).length && o2.push(f3);
  } else o2.push(r3);
  l2.refs.length && s2.push(l2);
  const f2 = ce(o2);
  return f2.find(((e2) => u(e2) && !a2.includes(e2.$ref))) ? fe(f2, r2, n2, s2) : { allOfItems: f2, brokenRefs: a2 };
};
var ce = (t2) => {
  const r2 = [];
  for (const n2 of t2) if (s(n2)) if (n2.allOf && Array.isArray(n2.allOf)) {
    const { allOf: t3 } = n2, s2 = e(n2, ["allOf"]), o2 = Object.keys(s2).length ? [...t3, s2] : t3;
    r2.push(...ce(o2));
  } else r2.push(n2);
  return r2;
};
var ue = (e2) => {
  if ("object" != typeof e2 || !e2) return Z();
  if ("openapi" in e2 && "string" == typeof e2.openapi && /3.+/.test(e2.openapi)) {
    const t2 = e2.openapi.startsWith("3.1") ? "3.1.x" : "3.0.x";
    return oe(t2);
  }
  return "graphapi" in e2 && "string" == typeof e2.graphapi ? ae : Z();
};
var pe = (e2, t2) => {
  var r2;
  const n2 = null !== (r2 = null == t2 ? void 0 : t2.rules) && void 0 !== r2 ? r2 : ue(e2);
  return ((e3, t3 = [], r3 = {}) => {
    var n3;
    t3 = Array.isArray(t3) ? t3 : [t3];
    const s2 = { "#": void 0 }, o2 = Object.assign({ state: Object.assign(Object.assign({}, null !== (n3 = r3.state) && void 0 !== n3 ? n3 : {}), { root: s2, node: s2 }) }, r3.rules ? { rules: r3.rules } : {}), [l2, f2] = a();
    return i(e3, [l2, ...t3, f2], o2), s2["#"];
  })(e2, de(t2), { rules: n2 });
};
var de = (t2) => {
  const r2 = /* @__PURE__ */ new Map();
  let n2 = null == t2 ? void 0 : t2.source;
  const o2 = [];
  return ({ value: i2, key: a2, path: l2, rules: f2, state: c2 }) => {
    l2.length || (null == t2 ? void 0 : t2.source) || (n2 = i2);
    const u2 = (e2) => {
      var n3;
      const s2 = ye(l2);
      s2 ? r2.set(...s2) : null === (n3 = null == t2 ? void 0 : t2.onMergeError) || void 0 === n3 || n3.call(t2, S(), l2, e2);
    }, y2 = () => {
      const { node: e2 } = c2, t3 = $(l2);
      if (r2.has(t3)) {
        const n3 = r2.get(t3), s2 = e2[a2];
        Array.isArray(s2) && (s2.length < 2 && u2((null == i2 ? void 0 : i2.allOf) || []), s2.splice(n3, 1));
      }
    };
    if (!s(i2) || Array.isArray(i2)) return { exitHook: y2 };
    if (!((e2) => !!e2 && e2["/allOf"] && "$" in e2["/allOf"])(f2)) return { exitHook: y2 };
    const { allOf: h2 } = i2, g2 = e(i2, ["allOf"]), O2 = [];
    if (Array.isArray(h2) && O2.push(...h2), O2.length) Object.keys(g2).length && O2.push(g2);
    else {
      const { $ref: r3 } = g2, n3 = e(g2, ["$ref"]);
      if ((null == t2 ? void 0 : t2.mergeRefSibling) && r3 && Object.keys(n3).length > 0) O2.push({ $ref: r3 }, n3);
      else if (null == t2 ? void 0 : t2.mergeCombinarySibling) {
        if (p(g2) && f2["/anyOf"]) return { value: le(g2, "anyOf", f2["/anyOf"]), exitHook: y2 };
        if (d(g2) && f2["/oneOf"]) return { value: le(g2, "oneOf", f2["/oneOf"]), exitHook: y2 };
      }
    }
    if (!O2.length) return { value: g2, exitHook: y2 };
    const { allOfItems: m2, brokenRefs: b2 } = fe(O2, l2, n2, o2);
    if (b2.length) return b2.forEach(((e2) => {
      var r3;
      return null === (r3 = null == t2 ? void 0 : t2.onRefResolveError) || void 0 === r3 ? void 0 : r3.call(t2, "Cannot resolve $ref", l2, e2);
    })), { value: { allOf: m2 }, exitHook: y2 };
    if (m2.length < 2) return { value: m2.length ? m2[0] : {}, exitHook: y2 };
    const v2 = R(m2, { allOfItems: m2, mergeRules: f2, mergeError: u2 });
    return (null == t2 ? void 0 : t2.mergeCombinarySibling) && p(v2) ? { value: le(v2, "anyOf", f2["/anyOf"]), exitHook: y2 } : (null == t2 ? void 0 : t2.mergeCombinarySibling) && d(v2) ? { value: le(v2, "oneOf", f2["/oneOf"]), exitHook: y2 } : { value: v2, exitHook: y2 };
  };
};
var ye = (e2) => {
  for (let t2 = e2.length - 2; t2 >= 0; t2--) if ("anyOf" === e2[t2] || "oneOf" === e2[t2]) {
    const r2 = e2.slice(0, t2 + 1);
    return [$(r2), e2[t2 + 1]];
  }
};
export {
  l as MapArray,
  X as additionalItemsMergeResolver,
  w as additionalPropertiesMergeResolver,
  de as allOfResolverHook,
  q as alternative,
  $ as buildPointer,
  k as calculateGCD,
  j as calculateLCM,
  h as createRef,
  Q as dependenciesMergeResolver,
  L as equal,
  A as findCombinations,
  v as findMultiplierForInteger,
  H as first,
  E as getAllOfItemsMap,
  P as getPatternPropertiesForMerge,
  x as getPropertiesForMerge,
  ae as graphapiMergeRules,
  B as intersectItems,
  p as isAnyOfNode,
  b as isEqual,
  d as isOneOfNode,
  u as isRefNode,
  V as itemsMergeResolver,
  R as jsonSchemaMergeResolver,
  Z as jsonSchemaMergeRules,
  Y as jsonSchemaVersion,
  C as last,
  J as maxValue,
  pe as merge,
  D as mergeArray,
  F as mergeEnum,
  W as mergeMultipleOf,
  T as mergeNot,
  U as mergeObjects,
  z as mergePattern,
  K as mergeStringItems,
  G as mergeTypes,
  c as mergeValues,
  N as minValue,
  te as openApiJsonSchemaMergeRules,
  oe as openApiMergeRules,
  _ as openApiVersion,
  m as parsePointer,
  y as parseRef,
  O as pathMask,
  f as popValues,
  I as propertiesMergeResolver,
  g as resolvePointer,
  ue as selectMergeRules
};
/*! Bundled license information:

allof-merge/dist/index.mjs:
  (*!
   * allof-merge v0.6.6
   * Copyright (C) 2012-2024 Damir Yusipov
   * Date: Sat, 17 Feb 2024 19:27:36 GMT
   *)
*/
//# sourceMappingURL=zudoku___allof-merge.js.map
