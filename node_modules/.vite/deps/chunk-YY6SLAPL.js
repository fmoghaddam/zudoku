import {
  require_react
} from "./chunk-S73QDKPN.js";
import {
  __toESM
} from "./chunk-G3PMV62Z.js";

// node_modules/zudoku/lib/chunk-DQRVZFIR-DHK7_Ilc.js
var i = __toESM(require_react(), 1);
var F = {};
var ue;
function Ae() {
  if (ue) return F;
  ue = 1, Object.defineProperty(F, "__esModule", { value: true }), F.parse = s, F.serialize = u;
  const e = /^[\u0021-\u003A\u003C\u003E-\u007E]+$/, t = /^[\u0021-\u003A\u003C-\u007E]*$/, r = /^([.]?[a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)([.][a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)*$/i, o = /^[\u0020-\u003A\u003D-\u007E]*$/, n = Object.prototype.toString, a = (() => {
    const f = function() {
    };
    return f.prototype = /* @__PURE__ */ Object.create(null), f;
  })();
  function s(f, g) {
    const d = new a(), v = f.length;
    if (v < 2)
      return d;
    const E = g?.decode || m;
    let h = 0;
    do {
      const w = f.indexOf("=", h);
      if (w === -1)
        break;
      const y = f.indexOf(";", h), b = y === -1 ? v : y;
      if (w > b) {
        h = f.lastIndexOf(";", w - 1) + 1;
        continue;
      }
      const R = c(f, h, w), C = l(f, w, R), $ = f.slice(R, C);
      if (d[$] === void 0) {
        let S = c(f, w + 1, b), P = l(f, b, S);
        const O = E(f.slice(S, P));
        d[$] = O;
      }
      h = b + 1;
    } while (h < v);
    return d;
  }
  function c(f, g, d) {
    do {
      const v = f.charCodeAt(g);
      if (v !== 32 && v !== 9)
        return g;
    } while (++g < d);
    return d;
  }
  function l(f, g, d) {
    for (; g > d; ) {
      const v = f.charCodeAt(--g);
      if (v !== 32 && v !== 9)
        return g + 1;
    }
    return d;
  }
  function u(f, g, d) {
    const v = d?.encode || encodeURIComponent;
    if (!e.test(f))
      throw new TypeError(`argument name is invalid: ${f}`);
    const E = v(g);
    if (!t.test(E))
      throw new TypeError(`argument val is invalid: ${g}`);
    let h = f + "=" + E;
    if (!d)
      return h;
    if (d.maxAge !== void 0) {
      if (!Number.isInteger(d.maxAge))
        throw new TypeError(`option maxAge is invalid: ${d.maxAge}`);
      h += "; Max-Age=" + d.maxAge;
    }
    if (d.domain) {
      if (!r.test(d.domain))
        throw new TypeError(`option domain is invalid: ${d.domain}`);
      h += "; Domain=" + d.domain;
    }
    if (d.path) {
      if (!o.test(d.path))
        throw new TypeError(`option path is invalid: ${d.path}`);
      h += "; Path=" + d.path;
    }
    if (d.expires) {
      if (!p(d.expires) || !Number.isFinite(d.expires.valueOf()))
        throw new TypeError(`option expires is invalid: ${d.expires}`);
      h += "; Expires=" + d.expires.toUTCString();
    }
    if (d.httpOnly && (h += "; HttpOnly"), d.secure && (h += "; Secure"), d.partitioned && (h += "; Partitioned"), d.priority)
      switch (typeof d.priority == "string" ? d.priority.toLowerCase() : void 0) {
        case "low":
          h += "; Priority=Low";
          break;
        case "medium":
          h += "; Priority=Medium";
          break;
        case "high":
          h += "; Priority=High";
          break;
        default:
          throw new TypeError(`option priority is invalid: ${d.priority}`);
      }
    if (d.sameSite)
      switch (typeof d.sameSite == "string" ? d.sameSite.toLowerCase() : d.sameSite) {
        case true:
        case "strict":
          h += "; SameSite=Strict";
          break;
        case "lax":
          h += "; SameSite=Lax";
          break;
        case "none":
          h += "; SameSite=None";
          break;
        default:
          throw new TypeError(`option sameSite is invalid: ${d.sameSite}`);
      }
    return h;
  }
  function m(f) {
    if (f.indexOf("%") === -1)
      return f;
    try {
      return decodeURIComponent(f);
    } catch {
      return f;
    }
  }
  function p(f) {
    return n.call(f) === "[object Date]";
  }
  return F;
}
Ae();
function x(e, t) {
  if (e === false || e === null || typeof e > "u")
    throw new Error(t);
}
function L(e, t) {
  if (!e) {
    typeof console < "u" && console.warn(t);
    try {
      throw new Error(t);
    } catch {
    }
  }
}
function W({
  pathname: e = "/",
  search: t = "",
  hash: r = ""
}) {
  return t && t !== "?" && (e += t.charAt(0) === "?" ? t : "?" + t), r && r !== "#" && (e += r.charAt(0) === "#" ? r : "#" + r), e;
}
function Y(e) {
  let t = {};
  if (e) {
    let r = e.indexOf("#");
    r >= 0 && (t.hash = e.substring(r), e = e.substring(0, r));
    let o = e.indexOf("?");
    o >= 0 && (t.search = e.substring(o), e = e.substring(0, o)), e && (t.pathname = e);
  }
  return t;
}
function pe(e, t, r = "/") {
  return Oe(e, t, r, false);
}
function Oe(e, t, r, o) {
  let n = typeof t == "string" ? Y(t) : t, a = A(n.pathname || "/", r);
  if (a == null)
    return null;
  let s = ge(e);
  De(s);
  let c = null;
  for (let l = 0; c == null && l < s.length; ++l) {
    let u = ye(a);
    c = ze(
      s[l],
      u,
      o
    );
  }
  return c;
}
function ge(e, t = [], r = [], o = "") {
  let n = (a, s, c) => {
    let l = {
      relativePath: c === void 0 ? a.path || "" : c,
      caseSensitive: a.caseSensitive === true,
      childrenIndex: s,
      route: a
    };
    l.relativePath.startsWith("/") && (x(
      l.relativePath.startsWith(o),
      `Absolute route path "${l.relativePath}" nested under path "${o}" is not valid. An absolute child route path must start with the combined path of all its parent routes.`
    ), l.relativePath = l.relativePath.slice(o.length));
    let u = M([o, l.relativePath]), m = r.concat(l);
    a.children && a.children.length > 0 && (x(
      // Our types know better, but runtime JS may not!
      // @ts-expect-error
      a.index !== true,
      `Index routes must not have child routes. Please remove all child routes from route path "${u}".`
    ), ge(a.children, t, m, u)), !(a.path == null && !a.index) && t.push({
      path: u,
      score: He(u, a.index),
      routesMeta: m
    });
  };
  return e.forEach((a, s) => {
    if (a.path === "" || !a.path?.includes("?"))
      n(a, s);
    else
      for (let c of ve(a.path))
        n(a, s, c);
  }), t;
}
function ve(e) {
  let t = e.split("/");
  if (t.length === 0) return [];
  let [r, ...o] = t, n = r.endsWith("?"), a = r.replace(/\?$/, "");
  if (o.length === 0)
    return n ? [a, ""] : [a];
  let s = ve(o.join("/")), c = [];
  return c.push(
    ...s.map(
      (l) => l === "" ? a : [a, l].join("/")
    )
  ), n && c.push(...s), c.map(
    (l) => e.startsWith("/") && l === "" ? "/" : l
  );
}
function De(e) {
  e.sort(
    (t, r) => t.score !== r.score ? r.score - t.score : je(
      t.routesMeta.map((o) => o.childrenIndex),
      r.routesMeta.map((o) => o.childrenIndex)
    )
  );
}
var Ie = /^:[\w-]+$/;
var _e = 3;
var Fe = 2;
var Ue = 1;
var We = 10;
var Be = -2;
var ce = (e) => e === "*";
function He(e, t) {
  let r = e.split("/"), o = r.length;
  return r.some(ce) && (o += Be), t && (o += Fe), r.filter((n) => !ce(n)).reduce(
    (n, a) => n + (Ie.test(a) ? _e : a === "" ? Ue : We),
    o
  );
}
function je(e, t) {
  return e.length === t.length && e.slice(0, -1).every((o, n) => o === t[n]) ? (
    // If two routes are siblings, we should try to match the earlier sibling
    // first. This allows people to have fine-grained control over the matching
    // behavior by simply putting routes with identical paths in the order they
    // want them tried.
    e[e.length - 1] - t[t.length - 1]
  ) : (
    // Otherwise, it doesn't really make sense to rank non-siblings by index,
    // so they sort equally.
    0
  );
}
function ze(e, t, r = false) {
  let { routesMeta: o } = e, n = {}, a = "/", s = [];
  for (let c = 0; c < o.length; ++c) {
    let l = o[c], u = c === o.length - 1, m = a === "/" ? t : t.slice(a.length) || "/", p = B(
      { path: l.relativePath, caseSensitive: l.caseSensitive, end: u },
      m
    ), f = l.route;
    if (!p && u && r && !o[o.length - 1].route.index && (p = B(
      {
        path: l.relativePath,
        caseSensitive: l.caseSensitive,
        end: false
      },
      m
    )), !p)
      return null;
    Object.assign(n, p.params), s.push({
      // TODO: Can this as be avoided?
      params: n,
      pathname: M([a, p.pathname]),
      pathnameBase: qe(
        M([a, p.pathnameBase])
      ),
      route: f
    }), p.pathnameBase !== "/" && (a = M([a, p.pathnameBase]));
  }
  return s;
}
function or(e, t = {}) {
  let r = e;
  r.endsWith("*") && r !== "*" && !r.endsWith("/*") && (L(
    false,
    `Route path "${r}" will be treated as if it were "${r.replace(/\*$/, "/*")}" because the \`*\` character must always follow a \`/\` in the pattern. To get rid of this warning, please change the route path to "${r.replace(/\*$/, "/*")}".`
  ), r = r.replace(/\*$/, "/*"));
  const o = r.startsWith("/") ? "/" : "", n = (s) => s == null ? "" : typeof s == "string" ? s : String(s), a = r.split(/\/+/).map((s, c, l) => {
    if (c === l.length - 1 && s === "*")
      return n(t["*"]);
    const m = s.match(/^:([\w-]+)(\??)$/);
    if (m) {
      const [, p, f] = m;
      let g = t[p];
      return x(f === "?" || g != null, `Missing ":${p}" param`), n(g);
    }
    return s.replace(/\?$/g, "");
  }).filter((s) => !!s);
  return o + a.join("/");
}
function B(e, t) {
  typeof e == "string" && (e = { path: e, caseSensitive: false, end: true });
  let [r, o] = Ve(
    e.path,
    e.caseSensitive,
    e.end
  ), n = t.match(r);
  if (!n) return null;
  let a = n[0], s = a.replace(/(.)\/+$/, "$1"), c = n.slice(1);
  return {
    params: o.reduce(
      (u, { paramName: m, isOptional: p }, f) => {
        if (m === "*") {
          let d = c[f] || "";
          s = a.slice(0, a.length - d.length).replace(/(.)\/+$/, "$1");
        }
        const g = c[f];
        return p && !g ? u[m] = void 0 : u[m] = (g || "").replace(/%2F/g, "/"), u;
      },
      {}
    ),
    pathname: a,
    pathnameBase: s,
    pattern: e
  };
}
function Ve(e, t = false, r = true) {
  L(
    e === "*" || !e.endsWith("*") || e.endsWith("/*"),
    `Route path "${e}" will be treated as if it were "${e.replace(/\*$/, "/*")}" because the \`*\` character must always follow a \`/\` in the pattern. To get rid of this warning, please change the route path to "${e.replace(/\*$/, "/*")}".`
  );
  let o = [], n = "^" + e.replace(/\/*\*?$/, "").replace(/^\/*/, "/").replace(/[\\.*+^${}|()[\]]/g, "\\$&").replace(
    /\/:([\w-]+)(\?)?/g,
    (s, c, l) => (o.push({ paramName: c, isOptional: l != null }), l ? "/?([^\\/]+)?" : "/([^\\/]+)")
  );
  return e.endsWith("*") ? (o.push({ paramName: "*" }), n += e === "*" || e === "/*" ? "(.*)$" : "(?:\\/(.+)|\\/*)$") : r ? n += "\\/*$" : e !== "" && e !== "/" && (n += "(?:(?=\\/|$))"), [new RegExp(n, t ? void 0 : "i"), o];
}
function ye(e) {
  try {
    return e.split("/").map((t) => decodeURIComponent(t).replace(/\//g, "%2F")).join("/");
  } catch (t) {
    return L(
      false,
      `The URL path "${e}" could not be decoded because it is a malformed URL segment. This is probably due to a bad percent encoding (${t}).`
    ), e;
  }
}
function A(e, t) {
  if (t === "/") return e;
  if (!e.toLowerCase().startsWith(t.toLowerCase()))
    return null;
  let r = t.endsWith("/") ? t.length - 1 : t.length, o = e.charAt(r);
  return o && o !== "/" ? null : e.slice(r) || "/";
}
function Ye(e, t = "/") {
  let {
    pathname: r,
    search: o = "",
    hash: n = ""
  } = typeof e == "string" ? Y(e) : e;
  return {
    pathname: r ? r.startsWith("/") ? r : Je(r, t) : t,
    search: Ge(o),
    hash: Xe(n)
  };
}
function Je(e, t) {
  let r = t.replace(/\/+$/, "").split("/");
  return e.split("/").forEach((n) => {
    n === ".." ? r.length > 1 && r.pop() : n !== "." && r.push(n);
  }), r.length > 1 ? r.join("/") : "/";
}
function G(e, t, r, o) {
  return `Cannot include a '${e}' character in a manually specified \`to.${t}\` field [${JSON.stringify(
    o
  )}].  Please separate it out to the \`to.${r}\` field. Alternatively you may provide the full path as a string in <Link to="..."> and the router will parse it for you.`;
}
function Ke(e) {
  return e.filter(
    (t, r) => r === 0 || t.route.path && t.route.path.length > 0
  );
}
function Z(e) {
  let t = Ke(e);
  return t.map(
    (r, o) => o === t.length - 1 ? r.pathname : r.pathnameBase
  );
}
function ee(e, t, r, o = false) {
  let n;
  typeof e == "string" ? n = Y(e) : (n = { ...e }, x(
    !n.pathname || !n.pathname.includes("?"),
    G("?", "pathname", "search", n)
  ), x(
    !n.pathname || !n.pathname.includes("#"),
    G("#", "pathname", "hash", n)
  ), x(
    !n.search || !n.search.includes("#"),
    G("#", "search", "hash", n)
  ));
  let a = e === "" || n.pathname === "", s = a ? "/" : n.pathname, c;
  if (s == null)
    c = r;
  else {
    let p = t.length - 1;
    if (!o && s.startsWith("..")) {
      let f = s.split("/");
      for (; f[0] === ".."; )
        f.shift(), p -= 1;
      n.pathname = f.join("/");
    }
    c = p >= 0 ? t[p] : "/";
  }
  let l = Ye(n, c), u = s && s !== "/" && s.endsWith("/"), m = (a || s === ".") && r.endsWith("/");
  return !l.pathname.endsWith("/") && (u || m) && (l.pathname += "/"), l;
}
var M = (e) => e.join("/").replace(/\/\/+/g, "/");
var qe = (e) => e.replace(/\/+$/, "").replace(/^\/*/, "/");
var Ge = (e) => !e || e === "?" ? "" : e.startsWith("?") ? e : "?" + e;
var Xe = (e) => !e || e === "#" ? "" : e.startsWith("#") ? e : "#" + e;
var ir = (e, t = 302) => {
  let r = t;
  typeof r == "number" ? r = { status: r } : typeof r.status > "u" && (r.status = 302);
  let o = new Headers(r.headers);
  return o.set("Location", e), new Response(null, { ...r, headers: o });
};
function we(e) {
  return e != null && typeof e.status == "number" && typeof e.statusText == "string" && typeof e.internal == "boolean" && "data" in e;
}
var Ee = [
  "POST",
  "PUT",
  "PATCH",
  "DELETE"
];
new Set(
  Ee
);
var Qe = [
  "GET",
  ...Ee
];
new Set(Qe);
var D = i.createContext(null);
D.displayName = "DataRouter";
var _ = i.createContext(null);
_.displayName = "DataRouterState";
var J = i.createContext({
  isTransitioning: false
});
J.displayName = "ViewTransition";
var te = i.createContext(
  /* @__PURE__ */ new Map()
);
te.displayName = "Fetchers";
var Ze = i.createContext(null);
Ze.displayName = "Await";
var T = i.createContext(
  null
);
T.displayName = "Navigation";
var K = i.createContext(
  null
);
K.displayName = "Location";
var k = i.createContext({
  outlet: null,
  matches: [],
  isDataRoute: false
});
k.displayName = "Route";
var re = i.createContext(null);
re.displayName = "RouteError";
function et(e, { relative: t } = {}) {
  x(
    I(),
    // TODO: This error is probably because they somehow have 2 versions of the
    // router loaded. We can help them understand how to avoid that.
    "useHref() may be used only in the context of a <Router> component."
  );
  let { basename: r, navigator: o } = i.useContext(T), { hash: n, pathname: a, search: s } = H(e, { relative: t }), c = a;
  return r !== "/" && (c = a === "/" ? r : M([r, a])), o.createHref({ pathname: c, search: s, hash: n });
}
function I() {
  return i.useContext(K) != null;
}
function N() {
  return x(
    I(),
    // TODO: This error is probably because they somehow have 2 versions of the
    // router loaded. We can help them understand how to avoid that.
    "useLocation() may be used only in the context of a <Router> component."
  ), i.useContext(K).location;
}
function lr(e) {
  x(
    I(),
    // TODO: This error is probably because they somehow have 2 versions of the
    // router loaded. We can help them understand how to avoid that.
    "useMatch() may be used only in the context of a <Router> component."
  );
  let { pathname: t } = N();
  return i.useMemo(
    () => B(e, ye(t)),
    [t, e]
  );
}
var xe = "You should call navigate() in a React.useEffect(), not when your component is first rendered.";
function Re(e) {
  i.useContext(T).static || i.useLayoutEffect(e);
}
function ne() {
  let { isDataRoute: e } = i.useContext(k);
  return e ? ht() : tt();
}
function tt() {
  x(
    I(),
    // TODO: This error is probably because they somehow have 2 versions of the
    // router loaded. We can help them understand how to avoid that.
    "useNavigate() may be used only in the context of a <Router> component."
  );
  let e = i.useContext(D), { basename: t, navigator: r } = i.useContext(T), { matches: o } = i.useContext(k), { pathname: n } = N(), a = JSON.stringify(Z(o)), s = i.useRef(false);
  return Re(() => {
    s.current = true;
  }), i.useCallback(
    (l, u = {}) => {
      if (L(s.current, xe), !s.current) return;
      if (typeof l == "number") {
        r.go(l);
        return;
      }
      let m = ee(
        l,
        JSON.parse(a),
        n,
        u.relative === "path"
      );
      e == null && t !== "/" && (m.pathname = m.pathname === "/" ? t : M([t, m.pathname])), (u.replace ? r.replace : r.push)(
        m,
        u.state,
        u
      );
    },
    [
      t,
      r,
      a,
      n,
      e
    ]
  );
}
var rt = i.createContext(null);
function nt(e) {
  let t = i.useContext(k).outlet;
  return t && i.createElement(rt.Provider, { value: e }, t);
}
function sr() {
  let { matches: e } = i.useContext(k), t = e[e.length - 1];
  return t ? t.params : {};
}
function H(e, { relative: t } = {}) {
  let { matches: r } = i.useContext(k), { pathname: o } = N(), n = JSON.stringify(Z(r));
  return i.useMemo(
    () => ee(
      e,
      JSON.parse(n),
      o,
      t === "path"
    ),
    [e, n, o, t]
  );
}
function be(e, t, r, o) {
  x(
    I(),
    // TODO: This error is probably because they somehow have 2 versions of the
    // router loaded. We can help them understand how to avoid that.
    "useRoutes() may be used only in the context of a <Router> component."
  );
  let { navigator: n } = i.useContext(T), { matches: a } = i.useContext(k), s = a[a.length - 1], c = s ? s.params : {}, l = s ? s.pathname : "/", u = s ? s.pathnameBase : "/", m = s && s.route;
  {
    let h = m && m.path || "";
    Se(
      l,
      !m || h.endsWith("*") || h.endsWith("*?"),
      `You rendered descendant <Routes> (or called \`useRoutes()\`) at "${l}" (under <Route path="${h}">) but the parent route path has no trailing "*". This means if you navigate deeper, the parent won't match anymore and therefore the child routes will never render.

Please change the parent <Route path="${h}"> to <Route path="${h === "/" ? "*" : `${h}/*`}">.`
    );
  }
  let p = N(), f;
  f = p;
  let g = f.pathname || "/", d = g;
  if (u !== "/") {
    let h = u.replace(/^\//, "").split("/");
    d = "/" + g.replace(/^\//, "").split("/").slice(h.length).join("/");
  }
  let v = pe(e, { pathname: d });
  return L(
    m || v != null,
    `No routes matched location "${f.pathname}${f.search}${f.hash}" `
  ), L(
    v == null || v[v.length - 1].route.element !== void 0 || v[v.length - 1].route.Component !== void 0 || v[v.length - 1].route.lazy !== void 0,
    `Matched leaf route at location "${f.pathname}${f.search}${f.hash}" does not have an element or Component. This means it will render an <Outlet /> with a null value by default resulting in an "empty" page.`
  ), st(
    v && v.map(
      (h) => Object.assign({}, h, {
        params: Object.assign({}, c, h.params),
        pathname: M([
          u,
          // Re-encode pathnames that were decoded inside matchRoutes
          n.encodeLocation ? n.encodeLocation(h.pathname).pathname : h.pathname
        ]),
        pathnameBase: h.pathnameBase === "/" ? u : M([
          u,
          // Re-encode pathnames that were decoded inside matchRoutes
          n.encodeLocation ? n.encodeLocation(h.pathnameBase).pathname : h.pathnameBase
        ])
      })
    ),
    a,
    r,
    o
  );
}
function at() {
  let e = dt(), t = we(e) ? `${e.status} ${e.statusText}` : e instanceof Error ? e.message : JSON.stringify(e), r = e instanceof Error ? e.stack : null, o = "rgba(200,200,200, 0.5)", n = { padding: "0.5rem", backgroundColor: o }, a = { padding: "2px 4px", backgroundColor: o }, s = null;
  return console.error(
    "Error handled by React Router default ErrorBoundary:",
    e
  ), s = i.createElement(i.Fragment, null, i.createElement("p", null, "ðŸ’¿ Hey developer ðŸ‘‹"), i.createElement("p", null, "You can provide a way better UX than this when your app throws errors by providing your own ", i.createElement("code", { style: a }, "ErrorBoundary"), " or", " ", i.createElement("code", { style: a }, "errorElement"), " prop on your route.")), i.createElement(i.Fragment, null, i.createElement("h2", null, "Unexpected Application Error!"), i.createElement("h3", { style: { fontStyle: "italic" } }, t), r ? i.createElement("pre", { style: n }, r) : null, s);
}
var ot = i.createElement(at, null);
var it = class extends i.Component {
  constructor(e) {
    super(e), this.state = {
      location: e.location,
      revalidation: e.revalidation,
      error: e.error
    };
  }
  static getDerivedStateFromError(e) {
    return { error: e };
  }
  static getDerivedStateFromProps(e, t) {
    return t.location !== e.location || t.revalidation !== "idle" && e.revalidation === "idle" ? {
      error: e.error,
      location: e.location,
      revalidation: e.revalidation
    } : {
      error: e.error !== void 0 ? e.error : t.error,
      location: t.location,
      revalidation: e.revalidation || t.revalidation
    };
  }
  componentDidCatch(e, t) {
    console.error(
      "React Router caught the following error during render",
      e,
      t
    );
  }
  render() {
    return this.state.error !== void 0 ? i.createElement(k.Provider, { value: this.props.routeContext }, i.createElement(
      re.Provider,
      {
        value: this.state.error,
        children: this.props.component
      }
    )) : this.props.children;
  }
};
function lt({ routeContext: e, match: t, children: r }) {
  let o = i.useContext(D);
  return o && o.static && o.staticContext && (t.route.errorElement || t.route.ErrorBoundary) && (o.staticContext._deepestRenderedBoundaryId = t.route.id), i.createElement(k.Provider, { value: e }, r);
}
function st(e, t = [], r = null, o = null) {
  if (e == null) {
    if (!r)
      return null;
    if (r.errors)
      e = r.matches;
    else if (t.length === 0 && !r.initialized && r.matches.length > 0)
      e = r.matches;
    else
      return null;
  }
  let n = e, a = r?.errors;
  if (a != null) {
    let l = n.findIndex(
      (u) => u.route.id && a?.[u.route.id] !== void 0
    );
    x(
      l >= 0,
      `Could not find a matching route for errors on route IDs: ${Object.keys(
        a
      ).join(",")}`
    ), n = n.slice(
      0,
      Math.min(n.length, l + 1)
    );
  }
  let s = false, c = -1;
  if (r)
    for (let l = 0; l < n.length; l++) {
      let u = n[l];
      if ((u.route.HydrateFallback || u.route.hydrateFallbackElement) && (c = l), u.route.id) {
        let { loaderData: m, errors: p } = r, f = u.route.loader && !m.hasOwnProperty(u.route.id) && (!p || p[u.route.id] === void 0);
        if (u.route.lazy || f) {
          s = true, c >= 0 ? n = n.slice(0, c + 1) : n = [n[0]];
          break;
        }
      }
    }
  return n.reduceRight((l, u, m) => {
    let p, f = false, g = null, d = null;
    r && (p = a && u.route.id ? a[u.route.id] : void 0, g = u.route.errorElement || ot, s && (c < 0 && m === 0 ? (Se(
      "route-fallback",
      false,
      "No `HydrateFallback` element provided to render during initial hydration"
    ), f = true, d = null) : c === m && (f = true, d = u.route.hydrateFallbackElement || null)));
    let v = t.concat(n.slice(0, m + 1)), E = () => {
      let h;
      return p ? h = g : f ? h = d : u.route.Component ? h = i.createElement(u.route.Component, null) : u.route.element ? h = u.route.element : h = l, i.createElement(
        lt,
        {
          match: u,
          routeContext: {
            outlet: l,
            matches: v,
            isDataRoute: r != null
          },
          children: h
        }
      );
    };
    return r && (u.route.ErrorBoundary || u.route.errorElement || m === 0) ? i.createElement(
      it,
      {
        location: r.location,
        revalidation: r.revalidation,
        component: g,
        error: p,
        children: E(),
        routeContext: { outlet: null, matches: v, isDataRoute: true }
      }
    ) : E();
  }, null);
}
function ae(e) {
  return `${e} must be used within a data router.  See https://reactrouter.com/en/main/routers/picking-a-router.`;
}
function ut(e) {
  let t = i.useContext(D);
  return x(t, ae(e)), t;
}
function Ce(e) {
  let t = i.useContext(_);
  return x(t, ae(e)), t;
}
function ct(e) {
  let t = i.useContext(k);
  return x(t, ae(e)), t;
}
function oe(e) {
  let t = ct(e), r = t.matches[t.matches.length - 1];
  return x(
    r.route.id,
    `${e} can only be used on routes that contain a unique "id"`
  ), r.route.id;
}
function ft() {
  return oe(
    "useRouteId"
    /* UseRouteId */
  );
}
function ur() {
  return Ce(
    "useNavigation"
    /* UseNavigation */
  ).navigation;
}
function dt() {
  let e = i.useContext(re), t = Ce(
    "useRouteError"
    /* UseRouteError */
  ), r = oe(
    "useRouteError"
    /* UseRouteError */
  );
  return e !== void 0 ? e : t.errors?.[r];
}
function ht() {
  let { router: e } = ut(
    "useNavigate"
    /* UseNavigateStable */
  ), t = oe(
    "useNavigate"
    /* UseNavigateStable */
  ), r = i.useRef(false);
  return Re(() => {
    r.current = true;
  }), i.useCallback(
    async (n, a = {}) => {
      L(r.current, xe), r.current && (typeof n == "number" ? e.navigate(n) : await e.navigate(n, { fromRouteId: t, ...a }));
    },
    [e, t]
  );
}
var fe = {};
function Se(e, t, r) {
  !t && !fe[e] && (fe[e] = true, L(false, r));
}
var de = {};
function he(e, t) {
  !e && !de[t] && (de[t] = true, console.warn(t));
}
var mt = class {
  constructor() {
    this.status = "pending", this.promise = new Promise((e, t) => {
      this.resolve = (r) => {
        this.status === "pending" && (this.status = "resolved", e(r));
      }, this.reject = (r) => {
        this.status === "pending" && (this.status = "rejected", t(r));
      };
    });
  }
};
function cr({
  router: e,
  flushSync: t
}) {
  let [r, o] = i.useState(e.state), [n, a] = i.useState(), [s, c] = i.useState({
    isTransitioning: false
  }), [l, u] = i.useState(), [m, p] = i.useState(), [f, g] = i.useState(), d = i.useRef(/* @__PURE__ */ new Map()), v = i.useCallback(
    (y, { deletedFetchers: b, flushSync: R, viewTransitionOpts: C }) => {
      y.fetchers.forEach((S, P) => {
        S.data !== void 0 && d.current.set(P, S.data);
      }), b.forEach((S) => d.current.delete(S)), he(
        R === false || t != null,
        'You provided the `flushSync` option to a router update, but you are not using the `<RouterProvider>` from `react-router/dom` so `ReactDOM.flushSync()` is unavailable.  Please update your app to `import { RouterProvider } from "react-router/dom"` and ensure you have `react-dom` installed as a dependency to use the `flushSync` option.'
      );
      let $ = e.window != null && e.window.document != null && typeof e.window.document.startViewTransition == "function";
      if (he(
        C == null || $,
        "You provided the `viewTransition` option to a router update, but you do not appear to be running in a DOM environment as `window.startViewTransition` is not available."
      ), !C || !$) {
        t && R ? t(() => o(y)) : i.startTransition(() => o(y));
        return;
      }
      if (t && R) {
        t(() => {
          m && (l && l.resolve(), m.skipTransition()), c({
            isTransitioning: true,
            flushSync: true,
            currentLocation: C.currentLocation,
            nextLocation: C.nextLocation
          });
        });
        let S = e.window.document.startViewTransition(() => {
          t(() => o(y));
        });
        S.finished.finally(() => {
          t(() => {
            u(void 0), p(void 0), a(void 0), c({ isTransitioning: false });
          });
        }), t(() => p(S));
        return;
      }
      m ? (l && l.resolve(), m.skipTransition(), g({
        state: y,
        currentLocation: C.currentLocation,
        nextLocation: C.nextLocation
      })) : (a(y), c({
        isTransitioning: true,
        flushSync: false,
        currentLocation: C.currentLocation,
        nextLocation: C.nextLocation
      }));
    },
    [e.window, t, m, l]
  );
  i.useLayoutEffect(() => e.subscribe(v), [e, v]), i.useEffect(() => {
    s.isTransitioning && !s.flushSync && u(new mt());
  }, [s]), i.useEffect(() => {
    if (l && n && e.window) {
      let y = n, b = l.promise, R = e.window.document.startViewTransition(async () => {
        i.startTransition(() => o(y)), await b;
      });
      R.finished.finally(() => {
        u(void 0), p(void 0), a(void 0), c({ isTransitioning: false });
      }), p(R);
    }
  }, [n, l, e.window]), i.useEffect(() => {
    l && n && r.location.key === n.location.key && l.resolve();
  }, [l, m, r.location, n]), i.useEffect(() => {
    !s.isTransitioning && f && (a(f.state), c({
      isTransitioning: true,
      flushSync: false,
      currentLocation: f.currentLocation,
      nextLocation: f.nextLocation
    }), g(void 0));
  }, [s.isTransitioning, f]);
  let E = i.useMemo(() => ({
    createHref: e.createHref,
    encodeLocation: e.encodeLocation,
    go: (y) => e.navigate(y),
    push: (y, b, R) => e.navigate(y, {
      state: b,
      preventScrollReset: R?.preventScrollReset
    }),
    replace: (y, b, R) => e.navigate(y, {
      replace: true,
      state: b,
      preventScrollReset: R?.preventScrollReset
    })
  }), [e]), h = e.basename || "/", w = i.useMemo(
    () => ({
      router: e,
      navigator: E,
      static: false,
      basename: h
    }),
    [e, E, h]
  );
  return i.createElement(i.Fragment, null, i.createElement(D.Provider, { value: w }, i.createElement(_.Provider, { value: r }, i.createElement(te.Provider, { value: d.current }, i.createElement(J.Provider, { value: s }, i.createElement(
    Pe,
    {
      basename: h,
      location: r.location,
      navigationType: r.historyAction,
      navigator: E
    },
    i.createElement(
      pt,
      {
        routes: e.routes,
        future: e.future,
        state: r
      }
    )
  ))))), null);
}
var pt = i.memo(gt);
function gt({
  routes: e,
  future: t,
  state: r
}) {
  return be(e, void 0, r, t);
}
function fr({
  to: e,
  replace: t,
  state: r,
  relative: o
}) {
  x(
    I(),
    // TODO: This error is probably because they somehow have 2 versions of
    // the router loaded. We can help them understand how to avoid that.
    "<Navigate> may be used only in the context of a <Router> component."
  );
  let { static: n } = i.useContext(T);
  L(
    !n,
    "<Navigate> must not be used on the initial render in a <StaticRouter>. This is a no-op, but you should modify your code so the <Navigate> is only ever rendered in response to some user interaction or state change."
  );
  let { matches: a } = i.useContext(k), { pathname: s } = N(), c = ne(), l = ee(
    e,
    Z(a),
    s,
    o === "path"
  ), u = JSON.stringify(l);
  return i.useEffect(() => {
    c(JSON.parse(u), { replace: t, state: r, relative: o });
  }, [c, u, o, t, r]), null;
}
function dr(e) {
  return nt(e.context);
}
function Pe({
  basename: e = "/",
  children: t = null,
  location: r,
  navigationType: o = "POP",
  navigator: n,
  static: a = false
}) {
  x(
    !I(),
    "You cannot render a <Router> inside another <Router>. You should never have more than one in your app."
  );
  let s = e.replace(/^\/*/, "/"), c = i.useMemo(
    () => ({
      basename: s,
      navigator: n,
      static: a,
      future: {}
    }),
    [s, n, a]
  );
  typeof r == "string" && (r = Y(r));
  let {
    pathname: l = "/",
    search: u = "",
    hash: m = "",
    state: p = null,
    key: f = "default"
  } = r, g = i.useMemo(() => {
    let d = A(l, s);
    return d == null ? null : {
      location: {
        pathname: d,
        search: u,
        hash: m,
        state: p,
        key: f
      },
      navigationType: o
    };
  }, [s, l, u, m, p, f, o]);
  return L(
    g != null,
    `<Router basename="${s}"> is not able to match the URL "${l}${u}${m}" because it does not start with the basename, so the <Router> won't render anything.`
  ), g == null ? null : i.createElement(T.Provider, { value: c }, i.createElement(K.Provider, { children: t, value: g }));
}
var z = "get";
var V = "application/x-www-form-urlencoded";
function q(e) {
  return e != null && typeof e.tagName == "string";
}
function vt(e) {
  return q(e) && e.tagName.toLowerCase() === "button";
}
function yt(e) {
  return q(e) && e.tagName.toLowerCase() === "form";
}
function wt(e) {
  return q(e) && e.tagName.toLowerCase() === "input";
}
function Et(e) {
  return !!(e.metaKey || e.altKey || e.ctrlKey || e.shiftKey);
}
function xt(e, t) {
  return e.button === 0 && // Ignore everything but left clicks
  (!t || t === "_self") && // Let browser handle "target=_blank" etc.
  !Et(e);
}
function Q(e = "") {
  return new URLSearchParams(
    typeof e == "string" || Array.isArray(e) || e instanceof URLSearchParams ? e : Object.keys(e).reduce((t, r) => {
      let o = e[r];
      return t.concat(
        Array.isArray(o) ? o.map((n) => [r, n]) : [[r, o]]
      );
    }, [])
  );
}
function Rt(e, t) {
  let r = Q(e);
  return t && t.forEach((o, n) => {
    r.has(n) || t.getAll(n).forEach((a) => {
      r.append(n, a);
    });
  }), r;
}
var j = null;
function bt() {
  if (j === null)
    try {
      new FormData(
        document.createElement("form"),
        // @ts-expect-error if FormData supports the submitter parameter, this will throw
        0
      ), j = false;
    } catch {
      j = true;
    }
  return j;
}
var Ct = /* @__PURE__ */ new Set([
  "application/x-www-form-urlencoded",
  "multipart/form-data",
  "text/plain"
]);
function X(e) {
  return e != null && !Ct.has(e) ? (L(
    false,
    `"${e}" is not a valid \`encType\` for \`<Form>\`/\`<fetcher.Form>\` and will default to "${V}"`
  ), null) : e;
}
function St(e, t) {
  let r, o, n, a, s;
  if (yt(e)) {
    let c = e.getAttribute("action");
    o = c ? A(c, t) : null, r = e.getAttribute("method") || z, n = X(e.getAttribute("enctype")) || V, a = new FormData(e);
  } else if (vt(e) || wt(e) && (e.type === "submit" || e.type === "image")) {
    let c = e.form;
    if (c == null)
      throw new Error(
        'Cannot submit a <button> or <input type="submit"> without a <form>'
      );
    let l = e.getAttribute("formaction") || c.getAttribute("action");
    if (o = l ? A(l, t) : null, r = e.getAttribute("formmethod") || c.getAttribute("method") || z, n = X(e.getAttribute("formenctype")) || X(c.getAttribute("enctype")) || V, a = new FormData(c, e), !bt()) {
      let { name: u, type: m, value: p } = e;
      if (m === "image") {
        let f = u ? `${u}.` : "";
        a.append(`${f}x`, "0"), a.append(`${f}y`, "0");
      } else u && a.append(u, p);
    }
  } else {
    if (q(e))
      throw new Error(
        'Cannot submit element that is not <form>, <button>, or <input type="submit|image">'
      );
    r = z, o = null, n = V, s = e;
  }
  return a && n === "text/plain" && (s = a, a = void 0), { action: o, method: r.toLowerCase(), encType: n, formData: a, body: s };
}
function ie(e, t) {
  if (e === false || e === null || typeof e > "u")
    throw new Error(t);
}
async function Pt(e, t) {
  if (e.id in t)
    return t[e.id];
  try {
    let r = await import(
      /* @vite-ignore */
      /* webpackIgnore: true */
      e.module
    );
    return t[e.id] = r, r;
  } catch (r) {
    return console.error(
      `Error loading route module \`${e.module}\`, reloading page...`
    ), console.error(r), window.__reactRouterContext && window.__reactRouterContext.isSpaMode, window.location.reload(), new Promise(() => {
    });
  }
}
function Lt(e) {
  return e == null ? false : e.href == null ? e.rel === "preload" && typeof e.imageSrcSet == "string" && typeof e.imageSizes == "string" : typeof e.rel == "string" && typeof e.href == "string";
}
async function kt(e, t, r) {
  let o = await Promise.all(
    e.map(async (n) => {
      let a = t.routes[n.route.id];
      if (a) {
        let s = await Pt(a, r);
        return s.links ? s.links() : [];
      }
      return [];
    })
  );
  return Mt(
    o.flat(1).filter(Lt).filter((n) => n.rel === "stylesheet" || n.rel === "preload").map(
      (n) => n.rel === "stylesheet" ? { ...n, rel: "prefetch", as: "style" } : { ...n, rel: "prefetch" }
    )
  );
}
function me(e, t, r, o, n, a) {
  let s = (l, u) => r[u] ? l.route.id !== r[u].route.id : true, c = (l, u) => (
    // param change, /users/123 -> /users/456
    r[u].pathname !== l.pathname || // splat param changed, which is not present in match.path
    // e.g. /files/images/avatar.jpg -> files/finances.xls
    r[u].route.path?.endsWith("*") && r[u].params["*"] !== l.params["*"]
  );
  return a === "assets" ? t.filter(
    (l, u) => s(l, u) || c(l, u)
  ) : a === "data" ? t.filter((l, u) => {
    let m = o.routes[l.route.id];
    if (!m || !m.hasLoader)
      return false;
    if (s(l, u) || c(l, u))
      return true;
    if (l.route.shouldRevalidate) {
      let p = l.route.shouldRevalidate({
        currentUrl: new URL(
          n.pathname + n.search + n.hash,
          window.origin
        ),
        currentParams: r[0]?.params || {},
        nextUrl: new URL(e, window.origin),
        nextParams: l.params,
        defaultShouldRevalidate: true
      });
      if (typeof p == "boolean")
        return p;
    }
    return true;
  }) : [];
}
function $t(e, t, { includeHydrateFallback: r } = {}) {
  return Tt(
    e.map((o) => {
      let n = t.routes[o.route.id];
      if (!n) return [];
      let a = [n.module];
      return n.clientActionModule && (a = a.concat(n.clientActionModule)), n.clientLoaderModule && (a = a.concat(n.clientLoaderModule)), r && n.hydrateFallbackModule && (a = a.concat(n.hydrateFallbackModule)), n.imports && (a = a.concat(n.imports)), a;
    }).flat(1)
  );
}
function Tt(e) {
  return [...new Set(e)];
}
function Nt(e) {
  let t = {}, r = Object.keys(e).sort();
  for (let o of r)
    t[o] = e[o];
  return t;
}
function Mt(e, t) {
  let r = /* @__PURE__ */ new Set();
  return new Set(t), e.reduce((o, n) => {
    let a = JSON.stringify(Nt(n));
    return r.has(a) || (r.add(a), o.push({ key: a, link: n })), o;
  }, []);
}
Object.getOwnPropertyNames(Object.prototype).sort().join("\0");
var At = /* @__PURE__ */ new Set([100, 101, 204, 205]);
function Ot(e, t) {
  let r = typeof e == "string" ? new URL(
    e,
    // This can be called during the SSR flow via PrefetchPageLinksImpl so
    // don't assume window is available
    typeof window > "u" ? "server://singlefetch/" : window.location.origin
  ) : e;
  return r.pathname === "/" ? r.pathname = "_root.data" : t && A(r.pathname, t) === "/" ? r.pathname = `${t.replace(/\/$/, "")}/_root.data` : r.pathname = `${r.pathname.replace(/\/$/, "")}.data`, r;
}
function Le() {
  let e = i.useContext(D);
  return ie(
    e,
    "You must render this element inside a <DataRouterContext.Provider> element"
  ), e;
}
function Dt() {
  let e = i.useContext(_);
  return ie(
    e,
    "You must render this element inside a <DataRouterStateContext.Provider> element"
  ), e;
}
var le = i.createContext(void 0);
le.displayName = "FrameworkContext";
function ke() {
  let e = i.useContext(le);
  return ie(
    e,
    "You must render this element inside a <HydratedRouter> element"
  ), e;
}
function It(e, t) {
  let r = i.useContext(le), [o, n] = i.useState(false), [a, s] = i.useState(false), { onFocus: c, onBlur: l, onMouseEnter: u, onMouseLeave: m, onTouchStart: p } = t, f = i.useRef(null);
  i.useEffect(() => {
    if (e === "render" && s(true), e === "viewport") {
      let v = (h) => {
        h.forEach((w) => {
          s(w.isIntersecting);
        });
      }, E = new IntersectionObserver(v, { threshold: 0.5 });
      return f.current && E.observe(f.current), () => {
        E.disconnect();
      };
    }
  }, [e]), i.useEffect(() => {
    if (o) {
      let v = setTimeout(() => {
        s(true);
      }, 100);
      return () => {
        clearTimeout(v);
      };
    }
  }, [o]);
  let g = () => {
    n(true);
  }, d = () => {
    n(false), s(false);
  };
  return r ? e !== "intent" ? [a, f, {}] : [
    a,
    f,
    {
      onFocus: U(c, g),
      onBlur: U(l, d),
      onMouseEnter: U(u, g),
      onMouseLeave: U(m, d),
      onTouchStart: U(p, g)
    }
  ] : [false, f, {}];
}
function U(e, t) {
  return (r) => {
    e && e(r), r.defaultPrevented || t(r);
  };
}
function _t({
  page: e,
  ...t
}) {
  let { router: r } = Le(), o = i.useMemo(
    () => pe(r.routes, e, r.basename),
    [r.routes, e, r.basename]
  );
  return o ? i.createElement(Ut, { page: e, matches: o, ...t }) : null;
}
function Ft(e) {
  let { manifest: t, routeModules: r } = ke(), [o, n] = i.useState([]);
  return i.useEffect(() => {
    let a = false;
    return kt(e, t, r).then(
      (s) => {
        a || n(s);
      }
    ), () => {
      a = true;
    };
  }, [e, t, r]), o;
}
function Ut({
  page: e,
  matches: t,
  ...r
}) {
  let o = N(), { manifest: n, routeModules: a } = ke(), { basename: s } = Le(), { loaderData: c, matches: l } = Dt(), u = i.useMemo(
    () => me(
      e,
      t,
      l,
      n,
      o,
      "data"
    ),
    [e, t, l, n, o]
  ), m = i.useMemo(
    () => me(
      e,
      t,
      l,
      n,
      o,
      "assets"
    ),
    [e, t, l, n, o]
  ), p = i.useMemo(() => {
    if (e === o.pathname + o.search + o.hash)
      return [];
    let d = /* @__PURE__ */ new Set(), v = false;
    if (t.forEach((h) => {
      let w = n.routes[h.route.id];
      !w || !w.hasLoader || (!u.some((y) => y.route.id === h.route.id) && h.route.id in c && a[h.route.id]?.shouldRevalidate || w.hasClientLoader ? v = true : d.add(h.route.id));
    }), d.size === 0)
      return [];
    let E = Ot(e, s);
    return v && d.size > 0 && E.searchParams.set(
      "_routes",
      t.filter((h) => d.has(h.route.id)).map((h) => h.route.id).join(",")
    ), [E.pathname + E.search];
  }, [
    s,
    c,
    o,
    n,
    u,
    t,
    e,
    a
  ]), f = i.useMemo(
    () => $t(m, n),
    [m, n]
  ), g = Ft(m);
  return i.createElement(i.Fragment, null, p.map((d) => i.createElement("link", { key: d, rel: "prefetch", as: "fetch", href: d, ...r })), f.map((d) => i.createElement("link", { key: d, rel: "modulepreload", href: d, ...r })), g.map(({ key: d, link: v }) => (
    // these don't spread `linkProps` because they are full link descriptors
    // already with their own props
    i.createElement("link", { key: d, ...v })
  )));
}
function Wt(...e) {
  return (t) => {
    e.forEach((r) => {
      typeof r == "function" ? r(t) : r != null && (r.current = t);
    });
  };
}
var $e = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u";
try {
  $e && (window.__reactRouterVersion = "7.6.1");
} catch {
}
var Te = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i;
var Ne = i.forwardRef(
  function({
    onClick: t,
    discover: r = "render",
    prefetch: o = "none",
    relative: n,
    reloadDocument: a,
    replace: s,
    state: c,
    target: l,
    to: u,
    preventScrollReset: m,
    viewTransition: p,
    ...f
  }, g) {
    let { basename: d } = i.useContext(T), v = typeof u == "string" && Te.test(u), E, h = false;
    if (typeof u == "string" && v && (E = u, $e))
      try {
        let P = new URL(window.location.href), O = u.startsWith("//") ? new URL(P.protocol + u) : new URL(u), se = A(O.pathname, d);
        O.origin === P.origin && se != null ? u = se + O.search + O.hash : h = true;
      } catch {
        L(
          false,
          `<Link to="${u}"> contains an invalid URL which will probably break when clicked - please update to a valid URL path.`
        );
      }
    let w = et(u, { relative: n }), [y, b, R] = It(
      o,
      f
    ), C = zt(u, {
      replace: s,
      state: c,
      target: l,
      preventScrollReset: m,
      relative: n,
      viewTransition: p
    });
    function $(P) {
      t && t(P), P.defaultPrevented || C(P);
    }
    let S = (
      // eslint-disable-next-line jsx-a11y/anchor-has-content
      i.createElement(
        "a",
        {
          ...f,
          ...R,
          href: E || w,
          onClick: h || a ? t : $,
          ref: Wt(g, b),
          target: l,
          "data-discover": !v && r === "render" ? "true" : void 0
        }
      )
    );
    return y && !v ? i.createElement(i.Fragment, null, S, i.createElement(_t, { page: w })) : S;
  }
);
Ne.displayName = "Link";
var Bt = i.forwardRef(
  function({
    "aria-current": t = "page",
    caseSensitive: r = false,
    className: o = "",
    end: n = false,
    style: a,
    to: s,
    viewTransition: c,
    children: l,
    ...u
  }, m) {
    let p = H(s, { relative: u.relative }), f = N(), g = i.useContext(_), { navigator: d, basename: v } = i.useContext(T), E = g != null && // Conditional usage is OK here because the usage of a data router is static
    // eslint-disable-next-line react-hooks/rules-of-hooks
    qt(p) && c === true, h = d.encodeLocation ? d.encodeLocation(p).pathname : p.pathname, w = f.pathname, y = g && g.navigation && g.navigation.location ? g.navigation.location.pathname : null;
    r || (w = w.toLowerCase(), y = y ? y.toLowerCase() : null, h = h.toLowerCase()), y && v && (y = A(y, v) || y);
    const b = h !== "/" && h.endsWith("/") ? h.length - 1 : h.length;
    let R = w === h || !n && w.startsWith(h) && w.charAt(b) === "/", C = y != null && (y === h || !n && y.startsWith(h) && y.charAt(h.length) === "/"), $ = {
      isActive: R,
      isPending: C,
      isTransitioning: E
    }, S = R ? t : void 0, P;
    typeof o == "function" ? P = o($) : P = [
      o,
      R ? "active" : null,
      C ? "pending" : null,
      E ? "transitioning" : null
    ].filter(Boolean).join(" ");
    let O = typeof a == "function" ? a($) : a;
    return i.createElement(
      Ne,
      {
        ...u,
        "aria-current": S,
        className: P,
        ref: m,
        style: O,
        to: s,
        viewTransition: c
      },
      typeof l == "function" ? l($) : l
    );
  }
);
Bt.displayName = "NavLink";
var Ht = i.forwardRef(
  ({
    discover: e = "render",
    fetcherKey: t,
    navigate: r,
    reloadDocument: o,
    replace: n,
    state: a,
    method: s = z,
    action: c,
    onSubmit: l,
    relative: u,
    preventScrollReset: m,
    viewTransition: p,
    ...f
  }, g) => {
    let d = Jt(), v = Kt(c, { relative: u }), E = s.toLowerCase() === "get" ? "get" : "post", h = typeof c == "string" && Te.test(c), w = (y) => {
      if (l && l(y), y.defaultPrevented) return;
      y.preventDefault();
      let b = y.nativeEvent.submitter, R = b?.getAttribute("formmethod") || s;
      d(b || y.currentTarget, {
        fetcherKey: t,
        method: R,
        navigate: r,
        replace: n,
        state: a,
        relative: u,
        preventScrollReset: m,
        viewTransition: p
      });
    };
    return i.createElement(
      "form",
      {
        ref: g,
        method: E,
        action: v,
        onSubmit: o ? l : w,
        ...f,
        "data-discover": !h && e === "render" ? "true" : void 0
      }
    );
  }
);
Ht.displayName = "Form";
function jt(e) {
  return `${e} must be used within a data router.  See https://reactrouter.com/en/main/routers/picking-a-router.`;
}
function Me(e) {
  let t = i.useContext(D);
  return x(t, jt(e)), t;
}
function zt(e, {
  target: t,
  replace: r,
  state: o,
  preventScrollReset: n,
  relative: a,
  viewTransition: s
} = {}) {
  let c = ne(), l = N(), u = H(e, { relative: a });
  return i.useCallback(
    (m) => {
      if (xt(m, t)) {
        m.preventDefault();
        let p = r !== void 0 ? r : W(l) === W(u);
        c(e, {
          replace: p,
          state: o,
          preventScrollReset: n,
          relative: a,
          viewTransition: s
        });
      }
    },
    [
      l,
      c,
      u,
      r,
      o,
      t,
      e,
      n,
      a,
      s
    ]
  );
}
function hr(e) {
  L(
    typeof URLSearchParams < "u",
    "You cannot use the `useSearchParams` hook in a browser that does not support the URLSearchParams API. If you need to support Internet Explorer 11, we recommend you load a polyfill such as https://github.com/ungap/url-search-params."
  );
  let t = i.useRef(Q(e)), r = i.useRef(false), o = N(), n = i.useMemo(
    () => (
      // Only merge in the defaults if we haven't yet called setSearchParams.
      // Once we call that we want those to take precedence, otherwise you can't
      // remove a param with setSearchParams({}) if it has an initial value
      Rt(
        o.search,
        r.current ? null : t.current
      )
    ),
    [o.search]
  ), a = ne(), s = i.useCallback(
    (c, l) => {
      const u = Q(
        typeof c == "function" ? c(n) : c
      );
      r.current = true, a("?" + u, l);
    },
    [a, n]
  );
  return [n, s];
}
var Vt = 0;
var Yt = () => `__${String(++Vt)}__`;
function Jt() {
  let { router: e } = Me(
    "useSubmit"
    /* UseSubmit */
  ), { basename: t } = i.useContext(T), r = ft();
  return i.useCallback(
    async (o, n = {}) => {
      let { action: a, method: s, encType: c, formData: l, body: u } = St(
        o,
        t
      );
      if (n.navigate === false) {
        let m = n.fetcherKey || Yt();
        await e.fetch(m, r, n.action || a, {
          preventScrollReset: n.preventScrollReset,
          formData: l,
          body: u,
          formMethod: n.method || s,
          formEncType: n.encType || c,
          flushSync: n.flushSync
        });
      } else
        await e.navigate(n.action || a, {
          preventScrollReset: n.preventScrollReset,
          formData: l,
          body: u,
          formMethod: n.method || s,
          formEncType: n.encType || c,
          replace: n.replace,
          state: n.state,
          fromRouteId: r,
          flushSync: n.flushSync,
          viewTransition: n.viewTransition
        });
    },
    [e, t, r]
  );
}
function Kt(e, { relative: t } = {}) {
  let { basename: r } = i.useContext(T), o = i.useContext(k);
  x(o, "useFormAction must be used inside a RouteContext");
  let [n] = o.matches.slice(-1), a = { ...H(e || ".", { relative: t }) }, s = N();
  if (e == null) {
    a.search = s.search;
    let c = new URLSearchParams(a.search), l = c.getAll("index");
    if (l.some((m) => m === "")) {
      c.delete("index"), l.filter((p) => p).forEach((p) => c.append("index", p));
      let m = c.toString();
      a.search = m ? `?${m}` : "";
    }
  }
  return (!e || e === ".") && n.route.index && (a.search = a.search ? a.search.replace(/^\?/, "?index&") : "?index"), r !== "/" && (a.pathname = a.pathname === "/" ? r : M([r, a.pathname])), W(a);
}
function qt(e, t = {}) {
  let r = i.useContext(J);
  x(
    r != null,
    "`useViewTransitionState` must be used within `react-router-dom`'s `RouterProvider`.  Did you accidentally import `RouterProvider` from `react-router`?"
  );
  let { basename: o } = Me(
    "useViewTransitionState"
    /* useViewTransitionState */
  ), n = H(e, { relative: t.relative });
  if (!r.isTransitioning)
    return false;
  let a = A(r.currentLocation.pathname, o) || r.currentLocation.pathname, s = A(r.nextLocation.pathname, o) || r.nextLocation.pathname;
  return B(n.pathname, s) != null || B(n.pathname, a) != null;
}
function mr({
  context: e,
  router: t,
  hydrate: r = true,
  nonce: o
}) {
  x(
    t && e,
    "You must provide `router` and `context` to <StaticRouterProvider>"
  );
  let n = {
    router: t,
    navigator: Qt(),
    static: true,
    staticContext: e,
    basename: e.basename || "/"
  }, a = /* @__PURE__ */ new Map(), s = "";
  if (r !== false) {
    let l = {
      loaderData: e.loaderData,
      actionData: e.actionData,
      errors: Xt(e.errors)
    };
    s = `window.__staticRouterHydrationData = JSON.parse(${ar(JSON.stringify(JSON.stringify(l)))});`;
  }
  let { state: c } = n.router;
  return i.createElement(i.Fragment, null, i.createElement(D.Provider, { value: n }, i.createElement(_.Provider, { value: c }, i.createElement(te.Provider, { value: a }, i.createElement(J.Provider, { value: { isTransitioning: false } }, i.createElement(
    Pe,
    {
      basename: n.basename,
      location: c.location,
      navigationType: c.historyAction,
      navigator: n.navigator,
      static: n.static
    },
    i.createElement(
      Gt,
      {
        routes: t.routes,
        future: t.future,
        state: c
      }
    )
  ))))), s ? i.createElement(
    "script",
    {
      suppressHydrationWarning: true,
      nonce: o,
      dangerouslySetInnerHTML: { __html: s }
    }
  ) : null);
}
function Gt({
  routes: e,
  future: t,
  state: r
}) {
  return be(e, void 0, r, t);
}
function Xt(e) {
  if (!e) return null;
  let t = Object.entries(e), r = {};
  for (let [o, n] of t)
    we(n) ? r[o] = { ...n, __type: "RouteErrorResponse" } : n instanceof Error ? r[o] = {
      message: n.message,
      __type: "Error",
      // If this is a subclass (i.e., ReferenceError), send up the type so we
      // can re-create the same type during hydration.
      ...n.name !== "Error" ? {
        __subType: n.name
      } : {}
    } : r[o] = n;
  return r;
}
function Qt() {
  return {
    createHref: Zt,
    encodeLocation: er,
    push(e) {
      throw new Error(
        `You cannot use navigator.push() on the server because it is a stateless environment. This error was probably triggered when you did a \`navigate(${JSON.stringify(e)})\` somewhere in your app.`
      );
    },
    replace(e) {
      throw new Error(
        `You cannot use navigator.replace() on the server because it is a stateless environment. This error was probably triggered when you did a \`navigate(${JSON.stringify(e)}, { replace: true })\` somewhere in your app.`
      );
    },
    go(e) {
      throw new Error(
        `You cannot use navigator.go() on the server because it is a stateless environment. This error was probably triggered when you did a \`navigate(${e})\` somewhere in your app.`
      );
    },
    back() {
      throw new Error(
        "You cannot use navigator.back() on the server because it is a stateless environment."
      );
    },
    forward() {
      throw new Error(
        "You cannot use navigator.forward() on the server because it is a stateless environment."
      );
    }
  };
}
function Zt(e) {
  return typeof e == "string" ? e : W(e);
}
function er(e) {
  let t = typeof e == "string" ? e : W(e);
  t = t.replace(/ $/, "%20");
  let r = tr.test(t) ? new URL(t) : new URL(t, "http://localhost");
  return {
    pathname: r.pathname,
    search: r.search,
    hash: r.hash
  };
}
var tr = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i;
var rr = {
  "&": "\\u0026",
  ">": "\\u003e",
  "<": "\\u003c",
  "\u2028": "\\u2028",
  "\u2029": "\\u2029"
};
var nr = /[&><\u2028\u2029]/g;
function ar(e) {
  return e.replace(nr, (t) => rr[t]);
}
[
  ...At
];

export {
  or,
  B,
  ir,
  we,
  et,
  N,
  lr,
  ne,
  sr,
  ur,
  dt,
  cr,
  fr,
  dr,
  Ne,
  Bt,
  hr,
  mr
};
/*! Bundled license information:

zudoku/lib/chunk-DQRVZFIR-DHK7_Ilc.js:
  (**
   * react-router v7.6.1
   *
   * Copyright (c) Remix Software Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   *)
*/
//# sourceMappingURL=chunk-YY6SLAPL.js.map
