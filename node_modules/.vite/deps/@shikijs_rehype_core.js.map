{
  "version": 3,
  "sources": ["../../hast-util-to-string/lib/index.js", "../../@shikijs/rehype/dist/core.mjs"],
  "sourcesContent": ["/**\n * @import {Nodes, Parents} from 'hast'\n */\n\n/**\n * Get the plain-text value of a hast node.\n *\n * @param {Nodes} node\n *   Node to serialize.\n * @returns {string}\n *   Serialized node.\n */\nexport function toString(node) {\n  // “The concatenation of data of all the Text node descendants of the context\n  // object, in tree order.”\n  if ('children' in node) {\n    return all(node)\n  }\n\n  // “Context object’s data.”\n  return 'value' in node ? node.value : ''\n}\n\n/**\n * @param {Nodes} node\n *   Node.\n * @returns {string}\n *   Serialized node.\n */\nfunction one(node) {\n  if (node.type === 'text') {\n    return node.value\n  }\n\n  return 'children' in node ? all(node) : ''\n}\n\n/**\n * @param {Parents} node\n *   Node.\n * @returns {string}\n *   Serialized node.\n */\nfunction all(node) {\n  let index = -1\n  /** @type {Array<string>} */\n  const result = []\n\n  while (++index < node.children.length) {\n    result[index] = one(node.children[index])\n  }\n\n  return result.join('')\n}\n", "import { isSpecialLang } from 'shiki/core';\nimport { visit } from 'unist-util-visit';\nimport { toString } from 'hast-util-to-string';\n\nconst InlineCodeHandlers = {\n  \"tailing-curly-colon\": (_tree, node) => {\n    const raw = toString(node);\n    const match = raw.match(/(.+)\\{:([\\w-]+)\\}$/);\n    if (!match)\n      return;\n    return {\n      type: \"inline\",\n      code: match[1] ?? raw,\n      lang: match.at(2)\n    };\n  }\n};\nconst languagePrefix$1 = \"language-\";\nconst PreHandler = (_tree, node) => {\n  const head = node.children[0];\n  if (!head || head.type !== \"element\" || head.tagName !== \"code\" || !head.properties) {\n    return;\n  }\n  const classes = head.properties.className;\n  const languageClass = Array.isArray(classes) ? classes.find(\n    (d) => typeof d === \"string\" && d.startsWith(languagePrefix$1)\n  ) : void 0;\n  return {\n    type: \"pre\",\n    lang: typeof languageClass === \"string\" ? languageClass.slice(languagePrefix$1.length) : void 0,\n    code: toString(head),\n    meta: head.data?.meta ?? head.properties.metastring?.toString() ?? \"\"\n  };\n};\n\nconst languagePrefix = \"language-\";\nfunction rehypeShikiFromHighlighter(highlighter, options) {\n  const {\n    addLanguageClass = false,\n    parseMetaString,\n    cache,\n    defaultLanguage,\n    fallbackLanguage,\n    onError,\n    stripEndNewline = true,\n    inline = false,\n    lazy = false,\n    ...rest\n  } = options;\n  function highlight(lang, code, metaString = \"\", meta = {}) {\n    const cacheKey = `${lang}:${metaString}:${code}`;\n    const cachedValue = cache?.get(cacheKey);\n    if (cachedValue) {\n      return cachedValue;\n    }\n    const codeOptions = {\n      ...rest,\n      lang,\n      meta: {\n        ...rest.meta,\n        ...meta,\n        __raw: metaString\n      }\n    };\n    if (addLanguageClass) {\n      codeOptions.transformers = [\n        ...codeOptions.transformers ?? [],\n        {\n          name: \"rehype-shiki:code-language-class\",\n          code(node) {\n            this.addClassToHast(node, `${languagePrefix}${lang}`);\n            return node;\n          }\n        }\n      ];\n    }\n    if (stripEndNewline && code.endsWith(\"\\n\"))\n      code = code.slice(0, -1);\n    try {\n      const fragment = highlighter.codeToHast(code, codeOptions);\n      cache?.set(cacheKey, fragment);\n      return fragment;\n    } catch (error) {\n      if (onError)\n        onError(error);\n      else\n        throw error;\n    }\n  }\n  return (tree) => {\n    const queue = [];\n    visit(tree, \"element\", (node, index, parent) => {\n      let handler;\n      if (!parent || index == null)\n        return;\n      if (node.tagName === \"pre\") {\n        handler = PreHandler;\n      } else if (node.tagName === \"code\" && inline) {\n        handler = InlineCodeHandlers[inline];\n      } else {\n        return;\n      }\n      const parsed = handler(tree, node);\n      if (!parsed)\n        return;\n      let lang;\n      let lazyLoad = false;\n      if (!parsed.lang) {\n        lang = defaultLanguage;\n      } else if (highlighter.getLoadedLanguages().includes(parsed.lang) || isSpecialLang(parsed.lang)) {\n        lang = parsed.lang;\n      } else if (lazy) {\n        lazyLoad = true;\n        lang = parsed.lang;\n      } else if (fallbackLanguage) {\n        lang = fallbackLanguage;\n      }\n      if (!lang)\n        return;\n      const meta = parsed.meta ? parseMetaString?.(parsed.meta, node, tree) : void 0;\n      const processNode = (targetLang) => {\n        const fragment = highlight(targetLang, parsed.code, parsed.meta, meta ?? {});\n        if (!fragment)\n          return;\n        if (parsed.type === \"inline\") {\n          const head = fragment.children[0];\n          if (head.type === \"element\" && head.tagName === \"pre\") {\n            head.tagName = \"span\";\n          }\n        }\n        parent.children[index] = fragment;\n      };\n      if (lazyLoad) {\n        try {\n          queue.push(highlighter.loadLanguage(lang).then(() => processNode(lang)));\n        } catch (error) {\n          if (fallbackLanguage)\n            return processNode(fallbackLanguage);\n          else if (onError)\n            onError(error);\n          else throw error;\n        }\n      } else {\n        processNode(lang);\n      }\n      return \"skip\";\n    });\n    if (queue.length > 0) {\n      async function run() {\n        await Promise.all(queue);\n      }\n      return run();\n    }\n  };\n}\n\nexport { rehypeShikiFromHighlighter as default };\n"],
  "mappings": "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",
  "names": []
}
