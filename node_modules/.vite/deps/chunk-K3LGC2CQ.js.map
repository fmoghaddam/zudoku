{
  "version": 3,
  "sources": ["../../@whatwg-node/promise-helpers/esm/index.js", "../../@envelop/instrumentation/esm/instrumentation.js", "../../@envelop/core/esm/document-string-map.js", "../../@envelop/core/esm/utils.js", "../../@envelop/core/esm/orchestrator.js", "../../@envelop/core/esm/create.js", "../../@envelop/core/esm/plugins/use-envelop.js", "../../@envelop/core/esm/plugins/use-logger.js", "../../@envelop/core/esm/plugins/use-schema.js", "../../@envelop/core/esm/plugins/use-masked-errors.js", "../../@envelop/core/esm/plugins/use-error-handler.js", "../../@envelop/core/esm/plugins/use-extend-context.js", "../../@envelop/core/esm/plugins/use-payload-formatter.js", "../../@envelop/core/esm/plugins/use-engine.js", "../../@envelop/core/esm/plugins/use-validation-rule.js"],
  "sourcesContent": ["const kFakePromise = Symbol.for('@whatwg-node/promise-helpers/FakePromise');\nexport function isPromise(value) {\n    return value?.then != null;\n}\nexport function isActualPromise(value) {\n    const maybePromise = value;\n    return maybePromise && maybePromise.then && maybePromise.catch && maybePromise.finally;\n}\nexport function handleMaybePromise(inputFactory, outputSuccessFactory, outputErrorFactory, finallyFactory) {\n    let result$ = fakePromise().then(inputFactory).then(outputSuccessFactory, outputErrorFactory);\n    if (finallyFactory) {\n        result$ = result$.finally(finallyFactory);\n    }\n    return unfakePromise(result$);\n}\nexport function fakePromise(value) {\n    if (value && isActualPromise(value)) {\n        return value;\n    }\n    if (isPromise(value)) {\n        return {\n            then: (resolve, reject) => fakePromise(value.then(resolve, reject)),\n            catch: reject => fakePromise(value.then(res => res, reject)),\n            finally: cb => fakePromise(cb ? promiseLikeFinally(value, cb) : value),\n            [Symbol.toStringTag]: 'Promise',\n        };\n    }\n    // Write a fake promise to avoid the promise constructor\n    // being called with `new Promise` in the browser.\n    return {\n        then(resolve) {\n            if (resolve) {\n                try {\n                    return fakePromise(resolve(value));\n                }\n                catch (err) {\n                    return fakeRejectPromise(err);\n                }\n            }\n            return this;\n        },\n        catch() {\n            return this;\n        },\n        finally(cb) {\n            if (cb) {\n                try {\n                    return fakePromise(cb()).then(() => value, () => value);\n                }\n                catch (err) {\n                    return fakeRejectPromise(err);\n                }\n            }\n            return this;\n        },\n        [Symbol.toStringTag]: 'Promise',\n        __fakePromiseValue: value,\n        [kFakePromise]: 'resolved',\n    };\n}\nexport function createDeferredPromise() {\n    if (Promise.withResolvers) {\n        return Promise.withResolvers();\n    }\n    let resolveFn;\n    let rejectFn;\n    const promise = new Promise(function deferredPromiseExecutor(resolve, reject) {\n        resolveFn = resolve;\n        rejectFn = reject;\n    });\n    return {\n        promise,\n        get resolve() {\n            return resolveFn;\n        },\n        get reject() {\n            return rejectFn;\n        },\n    };\n}\nexport { iterateAsync as iterateAsyncVoid };\nexport function iterateAsync(iterable, callback, results) {\n    if (iterable?.length === 0) {\n        return;\n    }\n    const iterator = iterable[Symbol.iterator]();\n    let index = 0;\n    function iterate() {\n        const { done: endOfIterator, value } = iterator.next();\n        if (endOfIterator) {\n            return;\n        }\n        let endedEarly = false;\n        function endEarly() {\n            endedEarly = true;\n        }\n        return handleMaybePromise(function handleCallback() {\n            return callback(value, endEarly, index++);\n        }, function handleCallbackResult(result) {\n            if (result) {\n                results?.push(result);\n            }\n            if (endedEarly) {\n                return;\n            }\n            return iterate();\n        });\n    }\n    return iterate();\n}\nexport function fakeRejectPromise(error) {\n    return {\n        then(_resolve, reject) {\n            if (reject) {\n                try {\n                    return fakePromise(reject(error));\n                }\n                catch (err) {\n                    return fakeRejectPromise(err);\n                }\n            }\n            return this;\n        },\n        catch(reject) {\n            if (reject) {\n                try {\n                    return fakePromise(reject(error));\n                }\n                catch (err) {\n                    return fakeRejectPromise(err);\n                }\n            }\n            return this;\n        },\n        finally(cb) {\n            if (cb) {\n                try {\n                    cb();\n                }\n                catch (err) {\n                    return fakeRejectPromise(err);\n                }\n            }\n            return this;\n        },\n        __fakeRejectError: error,\n        [Symbol.toStringTag]: 'Promise',\n        [kFakePromise]: 'rejected',\n    };\n}\nexport function mapMaybePromise(input, onSuccess, onError) {\n    return handleMaybePromise(() => input, onSuccess, onError);\n}\n/**\n * Given an AsyncIterable and a callback function, return an AsyncIterator\n * which produces values mapped via calling the callback function.\n */\nexport function mapAsyncIterator(iterator, onNext, onError, onEnd) {\n    if (Symbol.asyncIterator in iterator) {\n        iterator = iterator[Symbol.asyncIterator]();\n    }\n    let $return;\n    let abruptClose;\n    let onEndWithValue;\n    if (onEnd) {\n        let onEndWithValueResult /** R in onEndWithValue */;\n        onEndWithValue = value => {\n            onEndWithValueResult ||= handleMaybePromise(onEnd, () => value, () => value);\n            return onEndWithValueResult;\n        };\n    }\n    if (typeof iterator.return === 'function') {\n        $return = iterator.return;\n        abruptClose = (error) => {\n            const rethrow = () => {\n                throw error;\n            };\n            return $return.call(iterator).then(rethrow, rethrow);\n        };\n    }\n    function mapResult(result) {\n        if (result.done) {\n            return onEndWithValue ? onEndWithValue(result) : result;\n        }\n        return handleMaybePromise(() => result.value, value => handleMaybePromise(() => onNext(value), iteratorResult, abruptClose));\n    }\n    let mapReject;\n    if (onError) {\n        let onErrorResult;\n        // Capture rejectCallback to ensure it cannot be null.\n        const reject = onError;\n        mapReject = (error) => {\n            onErrorResult ||= handleMaybePromise(() => error, error => handleMaybePromise(() => reject(error), iteratorResult, abruptClose));\n            return onErrorResult;\n        };\n    }\n    return {\n        next() {\n            return iterator.next().then(mapResult, mapReject);\n        },\n        return() {\n            const res$ = $return\n                ? $return.call(iterator).then(mapResult, mapReject)\n                : fakePromise({ value: undefined, done: true });\n            return onEndWithValue ? res$.then(onEndWithValue) : res$;\n        },\n        throw(error) {\n            if (typeof iterator.throw === 'function') {\n                return iterator.throw(error).then(mapResult, mapReject);\n            }\n            if (abruptClose) {\n                return abruptClose(error);\n            }\n            return fakeRejectPromise(error);\n        },\n        [Symbol.asyncIterator]() {\n            return this;\n        },\n    };\n}\nfunction iteratorResult(value) {\n    return { value, done: false };\n}\nfunction isFakePromise(value) {\n    return value?.[kFakePromise] === 'resolved';\n}\nfunction isFakeRejectPromise(value) {\n    return value?.[kFakePromise] === 'rejected';\n}\nexport function promiseLikeFinally(value, onFinally) {\n    if ('finally' in value) {\n        return value.finally(onFinally);\n    }\n    return value.then(res => {\n        const finallyRes = onFinally();\n        return isPromise(finallyRes) ? finallyRes.then(() => res) : res;\n    }, err => {\n        const finallyRes = onFinally();\n        if (isPromise(finallyRes)) {\n            return finallyRes.then(() => {\n                throw err;\n            });\n        }\n        else {\n            throw err;\n        }\n    });\n}\nexport function unfakePromise(promise) {\n    if (isFakePromise(promise)) {\n        return promise.__fakePromiseValue;\n    }\n    if (isFakeRejectPromise(promise)) {\n        throw promise.__fakeRejectError;\n    }\n    return promise;\n}\n", "import { handleMaybePromise, isPromise } from '@whatwg-node/promise-helpers';\n/**\n * Composes 2 instrumentations together into one instrumentation.\n * The first one will be the outer call, the second one the inner call.\n */\nexport function chain(first, next) {\n    const merged = { ...next, ...first };\n    for (const key of Object.keys(merged)) {\n        if (key in first && key in next) {\n            merged[key] = (payload, wrapped) => first[key](payload, () => next[key](payload, wrapped));\n        }\n    }\n    return merged;\n}\n/**\n * Composes a list of instrumentation together into one instrumentation object.\n * The order of execution will respect the order of the array,\n * the first one being the outter most call, the last one the inner most call.\n */\nexport function composeInstrumentation(instrumentation) {\n    return instrumentation.length > 0 ? instrumentation.reduce(chain) : undefined;\n}\n/**\n * Extract instrumentation from a list of plugins.\n * It returns instrumentation found, and the list of plugins without their instrumentation.\n *\n * You can use this to easily customize the composition of the instrumentation if the default one\n * doesn't suits your needs.\n */\nexport function getInstrumentationAndPlugin(plugins) {\n    const pluginInstrumentation = [];\n    const newPlugins = [];\n    for (const { instrumentation, ...plugin } of plugins) {\n        if (instrumentation) {\n            pluginInstrumentation.push(instrumentation);\n        }\n        newPlugins.push(plugin);\n    }\n    return { pluginInstrumentation, plugins: newPlugins };\n}\n/**\n * A helper to instrument a function.\n *\n * @param payload: The first argument that will be passed to the instrumentation on each function call\n * @returns Function and Async Functions factories allowing to wrap a function with a given instrument.\n */\nexport const getInstrumented = (payload) => ({\n    /**\n     * Wraps the `wrapped` function with the given `instrument` wrapper.\n     * @returns The wrapped function, or `undefined` if the instrument is `undefined`.\n     */\n    fn(instrument, wrapped) {\n        if (!instrument) {\n            return wrapped;\n        }\n        return (...args) => {\n            let result;\n            instrument(payload, () => {\n                result = wrapped(...args);\n            });\n            return result;\n        };\n    },\n    /**\n     * Wraps the `wrapped` function with the given `instrument` wrapper.\n     * @returns The wrapped function, or `undefined` if the instrument is `undefined`.\n     */\n    asyncFn(instrument, wrapped) {\n        if (!instrument) {\n            return wrapped;\n        }\n        return (...args) => {\n            let result;\n            return handleMaybePromise(() => instrument(payload, () => {\n                result = wrapped(...args);\n                return isPromise(result) ? result.then(() => undefined) : undefined;\n            }), () => {\n                return result;\n            });\n        };\n    },\n});\n", "export const documentStringMap = new WeakMap();\nfunction getDocumentString(document, print) {\n    let documentSource = documentStringMap.get(document);\n    if (!documentSource && print) {\n        documentSource = print(document);\n        documentStringMap.set(document, documentSource);\n    }\n    return documentSource;\n}\nexport { getDocumentString };\n", "import { fakePromise } from '@whatwg-node/promise-helpers';\nexport const envelopIsIntrospectionSymbol = Symbol('ENVELOP_IS_INTROSPECTION');\nexport function isIntrospectionOperationString(operation) {\n    return (typeof operation === 'string' ? operation : operation.body).indexOf('__schema') !== -1;\n}\nfunction getSubscribeArgs(args) {\n    return args.length === 1\n        ? args[0]\n        : {\n            schema: args[0],\n            document: args[1],\n            rootValue: args[2],\n            contextValue: args[3],\n            variableValues: args[4],\n            operationName: args[5],\n            fieldResolver: args[6],\n            subscribeFieldResolver: args[7],\n        };\n}\n/**\n * Utility function for making a subscribe function that handles polymorphic arguments.\n */\nexport const makeSubscribe = (subscribeFn) => ((...polyArgs) => subscribeFn(getSubscribeArgs(polyArgs)));\nexport { mapAsyncIterator } from '@whatwg-node/promise-helpers';\nfunction getExecuteArgs(args) {\n    return args.length === 1\n        ? args[0]\n        : {\n            schema: args[0],\n            document: args[1],\n            rootValue: args[2],\n            contextValue: args[3],\n            variableValues: args[4],\n            operationName: args[5],\n            fieldResolver: args[6],\n            typeResolver: args[7],\n        };\n}\n/**\n * Utility function for making a execute function that handles polymorphic arguments.\n */\nexport const makeExecute = (executeFn) => ((...polyArgs) => executeFn(getExecuteArgs(polyArgs)));\n/**\n * Returns true if the provided object implements the AsyncIterator protocol via\n * implementing a `Symbol.asyncIterator` method.\n *\n * Source: https://github.com/graphql/graphql-js/blob/main/src/jsutils/isAsyncIterable.ts\n */\nexport function isAsyncIterable(maybeAsyncIterable) {\n    return (typeof maybeAsyncIterable === 'object' &&\n        maybeAsyncIterable != null &&\n        typeof maybeAsyncIterable[Symbol.asyncIterator] === 'function');\n}\n/**\n * A utility function for handling `onExecuteDone` hook result, for simplifying the handling of AsyncIterable returned from `execute`.\n *\n * @param payload The payload send to `onExecuteDone` hook function\n * @param fn The handler to be executed on each result\n * @returns a subscription for streamed results, or undefined in case of an non-async\n */\nexport function handleStreamOrSingleExecutionResult(payload, fn) {\n    if (isAsyncIterable(payload.result)) {\n        return { onNext: fn };\n    }\n    fn({\n        args: payload.args,\n        result: payload.result,\n        setResult: payload.setResult,\n    });\n    return undefined;\n}\nexport function finalAsyncIterator(source, onFinal) {\n    const iterator = source[Symbol.asyncIterator]();\n    let isDone = false;\n    const stream = {\n        [Symbol.asyncIterator]() {\n            return stream;\n        },\n        next() {\n            return iterator.next().then(result => {\n                if (result.done && isDone === false) {\n                    isDone = true;\n                    onFinal();\n                }\n                return result;\n            });\n        },\n        return() {\n            const promise = iterator.return?.();\n            if (isDone === false) {\n                isDone = true;\n                onFinal();\n            }\n            return promise || fakePromise({ done: true, value: undefined });\n        },\n        throw(error) {\n            const promise = iterator.throw?.();\n            if (promise) {\n                return promise;\n            }\n            // if the source has no throw method we just re-throw error\n            // usually throw is not called anyways\n            throw error;\n        },\n    };\n    return stream;\n}\nexport function errorAsyncIterator(source, onError) {\n    const iterator = source[Symbol.asyncIterator]();\n    const stream = {\n        [Symbol.asyncIterator]() {\n            return stream;\n        },\n        next() {\n            return iterator.next().catch(error => {\n                onError(error);\n                return { done: true, value: undefined };\n            });\n        },\n        return() {\n            const promise = iterator.return?.();\n            return promise || fakePromise({ done: true, value: undefined });\n        },\n        throw(error) {\n            const promise = iterator.throw?.();\n            if (promise) {\n                return promise;\n            }\n            // if the source has no throw method we just re-throw error\n            // usually throw is not called anyways\n            throw error;\n        },\n    };\n    return stream;\n}\nexport { mapMaybePromise, isPromise } from '@whatwg-node/promise-helpers';\n", "import { chain } from '@envelop/instrumentation';\nimport { handleMaybePromise, iterateAsync, iterateAsyncVoid } from '@whatwg-node/promise-helpers';\nimport { documentStringMap } from './document-string-map.js';\nimport { errorAsyncIterator, finalAsyncIterator, isAsyncIterable, makeExecute, makeSubscribe, mapAsyncIterator, } from './utils.js';\nfunction throwEngineFunctionError(name) {\n    throw Error(`No \\`${name}\\` function found! Register it using \"useEngine\" plugin.`);\n}\nexport function createEnvelopOrchestrator({ plugins, }) {\n    let schema = null;\n    let initDone = false;\n    const parse = () => throwEngineFunctionError('parse');\n    const validate = () => throwEngineFunctionError('validate');\n    const execute = () => throwEngineFunctionError('execute');\n    const subscribe = () => throwEngineFunctionError('subscribe');\n    let instrumentation;\n    // Define the initial method for replacing the GraphQL schema, this is needed in order\n    // to allow setting the schema from the onPluginInit callback. We also need to make sure\n    // here not to call the same plugin that initiated the schema switch.\n    const replaceSchema = (newSchema, ignorePluginIndex = -1) => {\n        if (schema === newSchema) {\n            return;\n        }\n        schema = newSchema;\n        if (initDone) {\n            for (const [i, plugin] of plugins.entries()) {\n                if (i !== ignorePluginIndex) {\n                    plugin.onSchemaChange &&\n                        plugin.onSchemaChange({\n                            schema,\n                            replaceSchema: schemaToSet => {\n                                replaceSchema(schemaToSet, i);\n                            },\n                        });\n                }\n            }\n        }\n    };\n    const contextErrorHandlers = [];\n    // Iterate all plugins and trigger onPluginInit\n    for (let i = 0; i < plugins.length; i++) {\n        const plugin = plugins[i];\n        const pluginsToAdd = [];\n        plugin.onPluginInit?.({\n            plugins,\n            addPlugin: newPlugin => {\n                pluginsToAdd.push(newPlugin);\n            },\n            setSchema: modifiedSchema => replaceSchema(modifiedSchema, i),\n            registerContextErrorHandler: handler => contextErrorHandlers.push(handler),\n        });\n        pluginsToAdd.length && plugins.splice(i + 1, 0, ...pluginsToAdd);\n    }\n    // A set of before callbacks defined here in order to allow it to be used later\n    const beforeCallbacks = {\n        init: [],\n        parse: [],\n        validate: [],\n        subscribe: [],\n        execute: [],\n        context: [],\n    };\n    for (const { onContextBuilding, onExecute, onParse, onSubscribe, onValidate, onEnveloped, instrumentation: pluginInstrumentation, } of plugins) {\n        onEnveloped && beforeCallbacks.init.push(onEnveloped);\n        onContextBuilding && beforeCallbacks.context.push(onContextBuilding);\n        onExecute && beforeCallbacks.execute.push(onExecute);\n        onParse && beforeCallbacks.parse.push(onParse);\n        onSubscribe && beforeCallbacks.subscribe.push(onSubscribe);\n        onValidate && beforeCallbacks.validate.push(onValidate);\n        if (pluginInstrumentation) {\n            instrumentation = instrumentation\n                ? chain(instrumentation, pluginInstrumentation)\n                : pluginInstrumentation;\n        }\n    }\n    const init = initialContext => {\n        for (const [i, onEnveloped] of beforeCallbacks.init.entries()) {\n            onEnveloped({\n                context: initialContext,\n                extendContext: extension => {\n                    if (!initialContext) {\n                        return;\n                    }\n                    Object.assign(initialContext, extension);\n                },\n                setSchema: modifiedSchema => replaceSchema(modifiedSchema, i),\n            });\n        }\n    };\n    const customParse = beforeCallbacks.parse.length\n        ? initialContext => (source, parseOptions) => {\n            let result = null;\n            let parseFn = parse;\n            const context = initialContext;\n            const afterCalls = [];\n            for (const onParse of beforeCallbacks.parse) {\n                const afterFn = onParse({\n                    context,\n                    extendContext: extension => {\n                        Object.assign(context, extension);\n                    },\n                    params: { source, options: parseOptions },\n                    parseFn,\n                    setParseFn: newFn => {\n                        parseFn = newFn;\n                    },\n                    setParsedDocument: newDoc => {\n                        result = newDoc;\n                    },\n                });\n                if (afterFn) {\n                    afterCalls.push(afterFn);\n                }\n            }\n            if (result === null) {\n                try {\n                    result = parseFn(source, parseOptions);\n                }\n                catch (e) {\n                    result = e;\n                }\n            }\n            for (const afterCb of afterCalls) {\n                afterCb({\n                    context,\n                    extendContext: extension => {\n                        Object.assign(context, extension);\n                    },\n                    replaceParseResult: newResult => {\n                        result = newResult;\n                    },\n                    result,\n                });\n            }\n            if (result === null) {\n                throw new Error(`Failed to parse document.`);\n            }\n            if (result instanceof Error) {\n                throw result;\n            }\n            documentStringMap.set(result, source.toString());\n            return result;\n        }\n        : () => parse;\n    const customValidate = beforeCallbacks.validate\n        .length\n        ? initialContext => (schema, documentAST, rules, typeInfo, validationOptions) => {\n            let actualRules = rules ? [...rules] : undefined;\n            let validateFn = validate;\n            let result = null;\n            const context = initialContext;\n            const afterCalls = [];\n            for (const onValidate of beforeCallbacks.validate) {\n                const afterFn = onValidate({\n                    context,\n                    extendContext: extension => {\n                        Object.assign(context, extension);\n                    },\n                    params: {\n                        schema,\n                        documentAST,\n                        rules: actualRules,\n                        typeInfo,\n                        options: validationOptions,\n                    },\n                    validateFn,\n                    addValidationRule: rule => {\n                        if (!actualRules) {\n                            actualRules = [];\n                        }\n                        actualRules.push(rule);\n                    },\n                    setValidationFn: newFn => {\n                        validateFn = newFn;\n                    },\n                    setResult: newResults => {\n                        result = newResults;\n                    },\n                });\n                afterFn && afterCalls.push(afterFn);\n            }\n            if (!result) {\n                result = validateFn(schema, documentAST, actualRules, typeInfo, validationOptions);\n            }\n            if (!result) {\n                return;\n            }\n            const valid = result.length === 0;\n            for (const afterCb of afterCalls) {\n                afterCb({\n                    valid,\n                    result,\n                    context,\n                    extendContext: extension => {\n                        Object.assign(context, extension);\n                    },\n                    setResult: newResult => {\n                        result = newResult;\n                    },\n                });\n            }\n            return result;\n        }\n        : () => validate;\n    const customContextFactory = beforeCallbacks.context.length\n        ? initialContext => orchestratorCtx => {\n            const afterCalls = [];\n            // In order to have access to the \"last working\" context object we keep this outside of the try block:\n            const context = initialContext;\n            if (orchestratorCtx) {\n                Object.assign(context, orchestratorCtx);\n            }\n            let isBreakingContextBuilding = false;\n            return handleMaybePromise(() => iterateAsync(beforeCallbacks.context, (onContext, stopEarly) => onContext({\n                context,\n                extendContext: extension => {\n                    Object.assign(context, extension);\n                },\n                breakContextBuilding: () => {\n                    isBreakingContextBuilding = true;\n                    stopEarly();\n                },\n            }), afterCalls), () => {\n                if (!isBreakingContextBuilding) {\n                    return handleMaybePromise(() => iterateAsync(afterCalls, afterCb => afterCb({\n                        context,\n                        extendContext(extension) {\n                            Object.assign(context, extension);\n                        },\n                    })), () => context);\n                }\n                return context;\n            }, err => {\n                let error = err;\n                for (const errorCb of contextErrorHandlers) {\n                    errorCb({\n                        context,\n                        error,\n                        setError: err => {\n                            error = err;\n                        },\n                    });\n                }\n                throw error;\n            });\n        }\n        : initialContext => orchestratorCtx => {\n            if (orchestratorCtx) {\n                Object.assign(initialContext, orchestratorCtx);\n            }\n            return initialContext;\n        };\n    const useCustomSubscribe = beforeCallbacks.subscribe.length;\n    const customSubscribe = useCustomSubscribe\n        ? makeSubscribe(args => {\n            let subscribeFn = subscribe;\n            const afterCallbacks = [];\n            const context = args.contextValue || {};\n            let result;\n            return handleMaybePromise(() => iterateAsync(beforeCallbacks.subscribe, (onSubscribe, endEarly) => onSubscribe({\n                subscribeFn,\n                setSubscribeFn: newSubscribeFn => {\n                    subscribeFn = newSubscribeFn;\n                },\n                context,\n                extendContext: extension => {\n                    Object.assign(context, extension);\n                },\n                args: args,\n                setResultAndStopExecution: stopResult => {\n                    result = stopResult;\n                    endEarly();\n                },\n            }), afterCallbacks), () => {\n                const afterCalls = [];\n                const subscribeErrorHandlers = [];\n                for (const { onSubscribeResult, onSubscribeError } of afterCallbacks) {\n                    if (onSubscribeResult) {\n                        afterCalls.push(onSubscribeResult);\n                    }\n                    if (onSubscribeError) {\n                        subscribeErrorHandlers.push(onSubscribeError);\n                    }\n                }\n                return handleMaybePromise(() => result || subscribeFn(args), result => {\n                    const onNextHandler = [];\n                    const onEndHandler = [];\n                    for (const afterCb of afterCalls) {\n                        const hookResult = afterCb({\n                            args: args,\n                            result,\n                            setResult: newResult => {\n                                result = newResult;\n                            },\n                        });\n                        if (hookResult) {\n                            if (hookResult.onNext) {\n                                onNextHandler.push(hookResult.onNext);\n                            }\n                            if (hookResult.onEnd) {\n                                onEndHandler.push(hookResult.onEnd);\n                            }\n                        }\n                    }\n                    if (onNextHandler.length && isAsyncIterable(result)) {\n                        result = mapAsyncIterator(result, (result) => handleMaybePromise(() => iterateAsync(onNextHandler, onNext => onNext({\n                            args: args,\n                            result,\n                            setResult: newResult => (result = newResult),\n                        })), () => result));\n                    }\n                    if (onEndHandler.length && isAsyncIterable(result)) {\n                        result = finalAsyncIterator(result, () => {\n                            for (const onEnd of onEndHandler) {\n                                onEnd();\n                            }\n                        });\n                    }\n                    if (subscribeErrorHandlers.length && isAsyncIterable(result)) {\n                        result = errorAsyncIterator(result, err => {\n                            let error = err;\n                            for (const handler of subscribeErrorHandlers) {\n                                handler({\n                                    error,\n                                    setError: err => {\n                                        error = err;\n                                    },\n                                });\n                            }\n                            throw error;\n                        });\n                    }\n                    return result;\n                });\n            });\n        })\n        : makeSubscribe(subscribe);\n    const useCustomExecute = beforeCallbacks.execute.length;\n    const customExecute = useCustomExecute\n        ? makeExecute(args => {\n            let executeFn = execute;\n            let result;\n            const afterCalls = [];\n            const afterDoneCalls = [];\n            const context = args.contextValue || {};\n            return handleMaybePromise(() => iterateAsync(beforeCallbacks.execute, (onExecute, endEarly) => onExecute({\n                executeFn,\n                setExecuteFn: newExecuteFn => {\n                    executeFn = newExecuteFn;\n                },\n                setResultAndStopExecution: stopResult => {\n                    result = stopResult;\n                    endEarly();\n                },\n                context,\n                extendContext: extension => {\n                    if (typeof extension === 'object') {\n                        Object.assign(context, extension);\n                    }\n                    else {\n                        throw new Error(`Invalid context extension provided! Expected \"object\", got: \"${JSON.stringify(extension)}\" (${typeof extension})`);\n                    }\n                },\n                args: args,\n            }), afterCalls), () => handleMaybePromise(() => result ||\n                executeFn({\n                    ...args,\n                    contextValue: context,\n                }), result => handleMaybePromise(() => iterateAsync(afterCalls, afterCb => afterCb.onExecuteDone?.({\n                args: args,\n                result,\n                setResult: newResult => {\n                    result = newResult;\n                },\n            }), afterDoneCalls), () => {\n                const onNextHandler = [];\n                const onEndHandler = [];\n                for (const { onNext, onEnd } of afterDoneCalls) {\n                    if (onNext) {\n                        onNextHandler.push(onNext);\n                    }\n                    if (onEnd) {\n                        onEndHandler.push(onEnd);\n                    }\n                }\n                if (onNextHandler.length && isAsyncIterable(result)) {\n                    result = mapAsyncIterator(result, result => handleMaybePromise(() => iterateAsyncVoid(onNextHandler, onNext => onNext({\n                        args: args,\n                        result: result,\n                        setResult: newResult => {\n                            result = newResult;\n                        },\n                    })), () => result));\n                }\n                if (onEndHandler.length && isAsyncIterable(result)) {\n                    result = finalAsyncIterator(result, () => {\n                        for (const onEnd of onEndHandler) {\n                            onEnd();\n                        }\n                    });\n                }\n                return result;\n            })));\n        })\n        : makeExecute(execute);\n    initDone = true;\n    // This is done in order to trigger the first schema available, to allow plugins that needs the schema\n    // eagerly to have it.\n    if (schema) {\n        for (const [i, plugin] of plugins.entries()) {\n            plugin.onSchemaChange?.({\n                schema,\n                replaceSchema: modifiedSchema => replaceSchema(modifiedSchema, i),\n            });\n        }\n    }\n    return {\n        getCurrentSchema() {\n            return schema;\n        },\n        init,\n        parse: customParse,\n        validate: customValidate,\n        execute: customExecute,\n        subscribe: customSubscribe,\n        contextFactory: customContextFactory,\n        instrumentation,\n    };\n}\n", "import { getInstrumented } from '@envelop/instrumentation';\nimport { createEnvelopOrchestrator } from './orchestrator.js';\nfunction notEmpty(value) {\n    return value != null;\n}\nexport function envelop(options) {\n    const plugins = options.plugins.filter(notEmpty);\n    const orchestrator = createEnvelopOrchestrator({\n        plugins,\n    });\n    const instrumentation = orchestrator.instrumentation;\n    const getEnveloped = (context = {}) => {\n        const instrumented = getInstrumented({ context });\n        const typedOrchestrator = orchestrator;\n        instrumented.fn(instrumentation?.init, orchestrator.init)(context);\n        return {\n            parse: instrumented.fn(instrumentation?.parse, typedOrchestrator.parse(context)),\n            validate: instrumented.fn(instrumentation?.validate, typedOrchestrator.validate(context)),\n            contextFactory: instrumented.fn(instrumentation?.context, typedOrchestrator.contextFactory(context)),\n            execute: instrumented.asyncFn(instrumentation?.execute, typedOrchestrator.execute),\n            subscribe: instrumented.asyncFn(instrumentation?.subscribe, typedOrchestrator.subscribe),\n            schema: typedOrchestrator.getCurrentSchema(),\n        };\n    };\n    getEnveloped._plugins = plugins;\n    return getEnveloped;\n}\n", "export const useEnvelop = (envelop) => {\n    let initialized = false;\n    return {\n        onPluginInit({ addPlugin }) {\n            if (initialized) {\n                return;\n            }\n            for (const plugin of envelop._plugins) {\n                addPlugin(plugin);\n            }\n            // Avoid double execution if envelop is extended multiple times\n            initialized = true;\n        },\n    };\n};\n", "import { envelopIsIntrospectionSymbol, isIntrospectionOperationString } from '../utils.js';\nconst DEFAULT_OPTIONS = {\n    logFn: console.log,\n};\nexport const useLogger = (rawOptions = DEFAULT_OPTIONS) => {\n    const options = {\n        DEFAULT_OPTIONS,\n        ...rawOptions,\n    };\n    return {\n        onParse({ extendContext, params }) {\n            if (options.skipIntrospection && isIntrospectionOperationString(params.source)) {\n                extendContext({\n                    [envelopIsIntrospectionSymbol]: true,\n                });\n            }\n        },\n        onExecute({ args }) {\n            if (args.contextValue[envelopIsIntrospectionSymbol]) {\n                return;\n            }\n            options.logFn('execute-start', { args });\n            return {\n                onExecuteDone: ({ result }) => {\n                    options.logFn('execute-end', { args, result });\n                },\n            };\n        },\n        onSubscribe({ args }) {\n            if (args.contextValue[envelopIsIntrospectionSymbol]) {\n                return;\n            }\n            options.logFn('subscribe-start', { args });\n            return {\n                onSubscribeResult: ({ result }) => {\n                    options.logFn('subscribe-end', { args, result });\n                },\n            };\n        },\n    };\n};\n", "export const useSchema = (schema) => {\n    return {\n        onPluginInit({ setSchema }) {\n            setSchema(schema);\n        },\n    };\n};\nexport const useSchemaByContext = (schemaLoader) => {\n    return {\n        onEnveloped({ setSchema, context }) {\n            setSchema(schemaLoader(context));\n        },\n    };\n};\n", "import { handleStreamOrSingleExecutionResult } from '../utils.js';\nexport const DEFAULT_ERROR_MESSAGE = 'Unexpected error.';\nexport function isGraphQLError(error) {\n    return error instanceof Error && error.name === 'GraphQLError';\n}\nexport function isOriginalGraphQLError(error) {\n    if (isGraphQLError(error)) {\n        if (error.originalError != null) {\n            return isOriginalGraphQLError(error.originalError);\n        }\n        return true;\n    }\n    return false;\n}\nfunction createSerializableGraphQLError(message, originalError, isDev) {\n    const error = new Error(message);\n    error.name = 'GraphQLError';\n    if (isDev) {\n        const extensions = originalError instanceof Error\n            ? { message: originalError.message, stack: originalError.stack }\n            : { message: String(originalError) };\n        Object.defineProperty(error, 'extensions', {\n            get() {\n                return extensions;\n            },\n        });\n    }\n    Object.defineProperty(error, 'toJSON', {\n        value() {\n            return {\n                message: error.message,\n                extensions: error.extensions,\n            };\n        },\n    });\n    return error;\n}\nexport const createDefaultMaskError = (isDev) => (error, message) => {\n    if (isOriginalGraphQLError(error)) {\n        return error;\n    }\n    return createSerializableGraphQLError(message, error, isDev);\n};\nconst isDev = globalThis.process?.env?.NODE_ENV === 'development';\nexport const defaultMaskError = createDefaultMaskError(isDev);\nconst makeHandleResult = (maskError, message) => ({ result, setResult, }) => {\n    if (result.errors != null) {\n        setResult({ ...result, errors: result.errors.map(error => maskError(error, message)) });\n    }\n};\nexport function useMaskedErrors(opts) {\n    const maskError = opts?.maskError ?? defaultMaskError;\n    const message = opts?.errorMessage || DEFAULT_ERROR_MESSAGE;\n    const handleResult = makeHandleResult(maskError, message);\n    return {\n        onPluginInit(context) {\n            context.registerContextErrorHandler(({ error, setError }) => {\n                setError(maskError(error, message));\n            });\n        },\n        onExecute() {\n            return {\n                onExecuteDone(payload) {\n                    return handleStreamOrSingleExecutionResult(payload, handleResult);\n                },\n            };\n        },\n        onSubscribe() {\n            return {\n                onSubscribeResult(payload) {\n                    return handleStreamOrSingleExecutionResult(payload, handleResult);\n                },\n                onSubscribeError({ error, setError }) {\n                    setError(maskError(error, message));\n                },\n            };\n        },\n    };\n}\n", "import { handleStreamOrSingleExecutionResult } from '../utils.js';\nimport { isGraphQLError } from './use-masked-errors.js';\nconst makeHandleResult = (errorHandler) => ({ result, args }) => {\n    if (result.errors?.length) {\n        errorHandler({ errors: result.errors, context: args, phase: 'execution' });\n    }\n};\nexport const useErrorHandler = (errorHandler) => {\n    const handleResult = makeHandleResult(errorHandler);\n    return {\n        onParse() {\n            return function onParseEnd({ result, context }) {\n                if (result instanceof Error) {\n                    errorHandler({ errors: [result], context, phase: 'parse' });\n                }\n            };\n        },\n        onValidate() {\n            return function onValidateEnd({ valid, result, context }) {\n                if (valid === false && result.length > 0) {\n                    errorHandler({ errors: result, context, phase: 'validate' });\n                }\n            };\n        },\n        onPluginInit(context) {\n            context.registerContextErrorHandler(({ error }) => {\n                if (isGraphQLError(error)) {\n                    errorHandler({ errors: [error], context, phase: 'context' });\n                }\n                else {\n                    // @ts-expect-error its not an error at this point so we just create a new one - can we handle this better?\n                    errorHandler({ errors: [new Error(error)], context, phase: 'context' });\n                }\n            });\n        },\n        onExecute() {\n            return {\n                onExecuteDone(payload) {\n                    return handleStreamOrSingleExecutionResult(payload, handleResult);\n                },\n            };\n        },\n        onSubscribe() {\n            return {\n                onSubscribeResult(payload) {\n                    return handleStreamOrSingleExecutionResult(payload, handleResult);\n                },\n            };\n        },\n    };\n};\n", "import { handleMaybePromise } from '@whatwg-node/promise-helpers';\nexport const useExtendContext = (contextFactory) => ({\n    onContextBuilding({ context, extendContext }) {\n        return handleMaybePromise(() => contextFactory(context), result => extendContext(result));\n    },\n});\n", "import { handleStreamOrSingleExecutionResult } from '../utils.js';\nconst makeHandleResult = (formatter) => ({ args, result, setResult, }) => {\n    const modified = formatter(result, args);\n    if (modified !== false) {\n        setResult(modified);\n    }\n};\nexport const usePayloadFormatter = (formatter) => ({\n    onExecute() {\n        const handleResult = makeHandleResult(formatter);\n        return {\n            onExecuteDone(payload) {\n                return handleStreamOrSingleExecutionResult(payload, handleResult);\n            },\n        };\n    },\n});\n", "export const useEngine = (engine) => {\n    return {\n        onExecute: ({ setExecuteFn }) => {\n            if (engine.execute) {\n                setExecuteFn(engine.execute);\n            }\n        },\n        onParse: ({ setParseFn }) => {\n            if (engine.parse) {\n                setParseFn(engine.parse);\n            }\n        },\n        onValidate: ({ setValidationFn, addValidationRule }) => {\n            if (engine.validate) {\n                setValidationFn(engine.validate);\n            }\n            engine.specifiedRules?.map(addValidationRule);\n        },\n        onSubscribe: ({ setSubscribeFn }) => {\n            if (engine.subscribe) {\n                setSubscribeFn(engine.subscribe);\n            }\n        },\n    };\n};\n", "export const useValidationRule = (rule) => {\n    return {\n        onValidate({ addValidationRule }) {\n            addValidationRule(rule);\n        },\n    };\n};\n"],
  "mappings": "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",
  "names": ["error", "schema", "err", "result", "envelop", "isDev", "makeHandleResult", "makeHandleResult"]
}
