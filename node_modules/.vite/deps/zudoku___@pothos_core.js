import {
  GraphQLBoolean,
  GraphQLEnumType,
  GraphQLError,
  GraphQLFloat,
  GraphQLID,
  GraphQLInputObjectType,
  GraphQLInt,
  GraphQLInterfaceType,
  GraphQLList,
  GraphQLNonNull,
  GraphQLObjectType,
  GraphQLScalarType,
  GraphQLSchema,
  GraphQLString,
  GraphQLUnionType,
  defaultFieldResolver,
  defaultTypeResolver,
  getArgumentValues,
  lexicographicSortSchema
} from "./chunk-JJFCR6GE.js";
import "./chunk-G3PMV62Z.js";

// node_modules/@pothos/core/esm/errors.js
var PothosError = class extends GraphQLError {
  constructor(message, options) {
    super(message, options);
    this.name = "PothosError";
  }
};
var PothosSchemaError = class extends PothosError {
  constructor(message, options) {
    super(message, options);
    this.name = "PothosSchemaError";
  }
};
var PothosValidationError = class extends PothosError {
  constructor(message, options) {
    super(message, options);
    this.name = "PothosValidationError";
  }
};

// node_modules/@pothos/core/esm/utils/context-cache.js
var contextCacheSymbol = Symbol.for("Pothos.contextCache");
function initContextCache() {
  return {
    [contextCacheSymbol]: {}
  };
}
function createContextCache(create) {
  const cache = /* @__PURE__ */ new WeakMap();
  const getOrCreate = (context, ...args) => {
    const cacheKey = context[contextCacheSymbol] || context;
    if (cache.has(cacheKey)) {
      return cache.get(cacheKey);
    }
    const entry = create(context, ...args);
    cache.set(cacheKey, entry);
    return entry;
  };
  getOrCreate.delete = (context) => {
    const cacheKey = context[contextCacheSymbol] || context;
    cache.delete(cacheKey);
  };
  return getOrCreate;
}

// node_modules/@pothos/core/esm/plugins/plugin.js
function _define_property(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
var runCache = /* @__PURE__ */ new WeakMap();
var BasePlugin = class {
  /**
  * Called for each type defined with the SchemaBuilder
  * @param  {PothosTypeConfig} typeConfig - Config object describing the added type
  * @return {PothosTypeConfig} Original or updated `typeConfig`
  */
  onTypeConfig(typeConfig) {
    return typeConfig;
  }
  /**
  * Called for each field on an Object or Interface type
  * @param  {PothosOutputFieldConfig} fieldConfig - Config object describing the added field
  * @return {PothosOutputFieldConfig} Original or updated `fieldConfig`
  */
  onOutputFieldConfig(fieldConfig) {
    return fieldConfig;
  }
  /**
  * Called for each argument or field on an Input object defined in your schema
  * @param  {PothosInputFieldConfig} fieldConfig - Config object describing the added field
  * @return {PothosInputFieldConfig} Original or updated `fieldConfig`
  */
  onInputFieldConfig(fieldConfig) {
    return fieldConfig;
  }
  /**
  * Called for each Enum value defined in your schema
  * @param  {PothosEnumValueConfig} valueConfig - Config object describing the enum value
  * @return {PothosEnumValueConfig} Original or updated `valueConfig`
  */
  onEnumValueConfig(valueConfig) {
    return valueConfig;
  }
  /**
  * Called before builder.toSchema() schema is called
  */
  beforeBuild() {
  }
  /**
  * Called after all fields and types have been built during `builder.toSchema()`
  * @param  {GraphQLSchema} schema - the generated schema
  * @return {PothosEnumValueConfig} Original or updated `schema`
  */
  afterBuild(schema) {
    return schema;
  }
  /**
  * Called with the resolver for each field in the schema
  * @param  {GraphQLFieldResolver} resolve - the resolve function
  * @param  {PothosOutputFieldConfig} fieldConfig - the config object for the field associated with this resolve function
  * @return {GraphQLFieldResolver} - Either the original, or a new resolver function to use for this field
  */
  wrapResolve(resolver, _fieldConfig) {
    return resolver;
  }
  /**
  * Called with the subscribe for each field on the Subscription type
  * @param  {GraphQLFieldResolver} subscribe - the subscribe function
  * @param  {PothosOutputFieldConfig} fieldConfig - the config object for the field associated with this subscribe function
  * @return {GraphQLFieldResolver} - Either the original, or a new subscribe function to use for this field
  */
  wrapSubscribe(subscribe, _fieldConfig) {
    return subscribe;
  }
  /**
  * Called with the resolveType for each Interface or Union type
  * @param  {GraphQLTypeResolver} resolveType - the resolveType function
  * @param  {PothosInterfaceTypeConfig | PothosUnionTypeConfig} typeConfig - the config object for the Interface or Union type
  * @return {GraphQLTypeResolver} - Either the original, or a new resolveType function to use for this field
  */
  wrapResolveType(resolveType, _typeConfig) {
    return resolveType;
  }
  /**
  * Called with the isTypeOf for each Object type
  * @param  {GraphQLTypeResolver} resolveType - the resolveType function
  * @param  {PothosObjectTypeConfig} typeConfig - the config object for the Interface or Union type
  * @return {GraphQLTypeResolver} - Either the original, or a new resolveType function to use for this field
  */
  wrapIsTypeOf(isTypeOf, _typeConfig) {
    return isTypeOf;
  }
  runUnique(key, cb) {
    if (!runCache.has(this.builder)) {
      runCache.set(this.builder, /* @__PURE__ */ new Map());
    }
    if (!runCache.get(this.builder).has(key)) {
      const result = cb();
      runCache.get(this.builder).set(key, result);
      return result;
    }
    return runCache.get(this.builder).get(key);
  }
  /**
  * Creates a data object unique to the current request for use by this plugin
  * @param  {Types['Context']} context - the context object for the current request
  * @return {object} - The data object for the current request
  */
  createRequestData(_context) {
    throw new PothosError("createRequestData not implemented");
  }
  /**
  * Returns a data object for the current request.  requires `createRequestData` to be implemented
  * @param  {Types['Context']} context - the context object for the current request
  * @return {object} - The data object for the current request
  */
  requestData(context) {
    return this.requestDataMap(context);
  }
  constructor(buildCache, name) {
    _define_property(this, "name", void 0);
    _define_property(this, "builder", void 0);
    _define_property(this, "buildCache", void 0);
    _define_property(this, "options", void 0);
    _define_property(this, "requestDataMap", createContextCache((ctx) => this.createRequestData(ctx)));
    this.name = name;
    this.builder = buildCache.builder;
    this.buildCache = buildCache;
    this.options = buildCache.options;
  }
};

// node_modules/@pothos/core/esm/plugins/merge-plugins.js
function _define_property2(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
var MergedPlugins = class extends BasePlugin {
  onTypeConfig(typeConfig) {
    return this.plugins.reduceRight((config, plugin) => config === null ? config : plugin.onTypeConfig(config), typeConfig);
  }
  onInputFieldConfig(fieldConfig) {
    return this.plugins.reduceRight((config, plugin) => config === null ? config : plugin.onInputFieldConfig(config), fieldConfig);
  }
  onOutputFieldConfig(fieldConfig) {
    return this.plugins.reduceRight((config, plugin) => config === null ? config : plugin.onOutputFieldConfig(config), fieldConfig);
  }
  onEnumValueConfig(valueConfig) {
    return this.plugins.reduceRight((config, plugin) => config === null ? config : plugin.onEnumValueConfig(config), valueConfig);
  }
  beforeBuild() {
    for (const plugin of this.plugins) {
      plugin.beforeBuild();
    }
  }
  afterBuild(schema) {
    return this.plugins.reduceRight((nextSchema, plugin) => plugin.afterBuild(nextSchema), schema);
  }
  wrapResolve(resolve, fieldConfig) {
    const wrapped = this.plugins.reduceRight((nextResolve, plugin) => plugin.wrapResolve(nextResolve, fieldConfig), resolve);
    if (fieldConfig.argMappers.length) {
      const argMappers = fieldConfig.argMappers;
      return (parent, args, context, info) => {
        const mappedArgs = argMappers.reduce((acc, argMapper) => {
          return argMapper(acc, context, info);
        }, args);
        return wrapped(parent, mappedArgs, context, info);
      };
    }
    return wrapped;
  }
  wrapSubscribe(subscribe, fieldConfig) {
    const wrapped = this.plugins.reduceRight((nextSubscribe, plugin) => plugin.wrapSubscribe(nextSubscribe, fieldConfig), subscribe);
    if (!wrapped || !fieldConfig.argMappers.length) {
      return wrapped;
    }
    const argMappers = fieldConfig.argMappers;
    return (parent, args, context, info) => {
      const mappedArgs = argMappers.reduce((acc, argMapper) => {
        return argMapper(acc, context, info);
      }, args);
      return wrapped(parent, mappedArgs, context, info);
    };
  }
  wrapResolveType(resolveType, typeConfig) {
    return this.plugins.reduceRight((nextResolveType, plugin) => plugin.wrapResolveType(nextResolveType, typeConfig), resolveType);
  }
  wrapIsTypeOf(isTypeOf, typeConfig) {
    return this.plugins.reduceRight((nextResolveType, plugin) => plugin.wrapIsTypeOf(nextResolveType, typeConfig), isTypeOf);
  }
  constructor(buildCache, plugins) {
    super(buildCache, "PothosMergedPlugin"), _define_property2(this, "plugins", void 0);
    this.plugins = plugins;
  }
};

// node_modules/@pothos/core/esm/types/type-params.js
var outputShapeKey = Symbol.for("Pothos.outputShapeKey");
var parentShapeKey = Symbol.for("Pothos.parentShapeKey");
var abstractReturnShapeKey = Symbol.for("Pothos.abstractReturnShapeKey");
var inputShapeKey = Symbol.for("Pothos.inputShapeKey");
var inputFieldShapeKey = Symbol.for("Pothos.inputFieldShapeKey");
var outputFieldShapeKey = Symbol.for("Pothos.outputFieldShapeKey");
var typeBrandKey = Symbol.for("Pothos.typeBrandKey");

// node_modules/@pothos/core/esm/refs/base.js
function _define_property3(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
var BaseTypeRef = class {
  toString() {
    return `${this.kind}Ref<${this.name}>`;
  }
  associate(ref) {
    if (this.association && typeof this.associate !== "string") {
      throw new PothosSchemaError(`${this} is already associated with ${this.association}`);
    }
    this.association = ref;
  }
  onConfig(cb) {
    this.configCallbacks.add(cb);
    if (this.currentConfig) {
      cb(this.currentConfig);
    }
  }
  updateConfig(config) {
    if (typeof config === "function") {
      this.onceOnConfig((oldConfig) => {
        this.updateConfig(config(oldConfig));
      });
      return;
    }
    this.currentConfig = config;
    for (const cb of this.configCallbacks) {
      if (this.currentConfig !== config) {
        break;
      }
      cb(config);
    }
  }
  prepareForBuild() {
    this.preparedForBuild = true;
  }
  onceOnConfig(cb) {
    const callback = (config) => {
      this.configCallbacks.delete(callback);
      cb(config);
    };
    this.onConfig(callback);
  }
  constructor(kind, name, config) {
    _define_property3(this, "kind", void 0);
    _define_property3(this, "name", void 0);
    _define_property3(this, "association", null);
    _define_property3(this, "configCallbacks", /* @__PURE__ */ new Set());
    _define_property3(this, "preparedForBuild", false);
    _define_property3(this, "currentConfig", void 0);
    this.kind = kind;
    this.name = name;
    this.currentConfig = config !== null && config !== void 0 ? config : null;
  }
};

// node_modules/@pothos/core/esm/refs/scalar.js
function _define_property4(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
var _outputShapeKey = outputShapeKey;
var _parentShapeKey = parentShapeKey;
var _inputShapeKey = inputShapeKey;
var ScalarRef = class extends BaseTypeRef {
  constructor(name, config) {
    super("Scalar", name, config), _define_property4(this, "kind", "Scalar"), _define_property4(this, "$inferType", void 0), _define_property4(this, "$inferInput", void 0), _define_property4(this, _outputShapeKey, void 0), _define_property4(this, _parentShapeKey, void 0), _define_property4(this, _inputShapeKey, void 0);
  }
};

// node_modules/@pothos/core/esm/refs/builtin-scalar.js
function _define_property5(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
var BuiltinScalarRef = class extends ScalarRef {
  constructor(type) {
    super(type.name), _define_property5(this, "type", void 0);
    this.type = type;
  }
};

// node_modules/@pothos/core/esm/refs/input-list.js
function _define_property6(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
var _inputShapeKey2 = inputShapeKey;
var InputListRef = class extends BaseTypeRef {
  constructor(listType, required) {
    super("InputList", `InputList<${String(listType)}>`), _define_property6(this, "kind", "InputList"), _define_property6(this, _inputShapeKey2, void 0), _define_property6(this, "$inferInput", void 0), _define_property6(this, "listType", void 0), _define_property6(this, "required", void 0);
    this.listType = listType;
    this.required = required;
  }
};

// node_modules/@pothos/core/esm/refs/list.js
function _define_property7(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
var _outputShapeKey2 = outputShapeKey;
var _parentShapeKey2 = parentShapeKey;
var ListRef = class extends BaseTypeRef {
  constructor(listType, nullable) {
    super("List", `List<${String(listType)}>`), _define_property7(this, "kind", "List"), _define_property7(this, "$inferType", void 0), _define_property7(this, _outputShapeKey2, void 0), _define_property7(this, _parentShapeKey2, void 0), _define_property7(this, "listType", void 0), _define_property7(this, "nullable", void 0);
    this.listType = listType;
    this.nullable = nullable;
  }
};

// node_modules/@pothos/core/esm/utils/base64.js
var getGlobalThis = () => {
  if (typeof globalThis !== "undefined") {
    return globalThis;
  }
  if (typeof self !== "undefined") {
    return self;
  }
  if (typeof window !== "undefined") {
    return window;
  }
  if (typeof global !== "undefined") {
    return global;
  }
  if (false) {
    return void 0;
  }
  throw new Error("Unable to locate global `this`");
};
function encodeBase64(value) {
  const localGlobalThis = getGlobalThis();
  if (typeof localGlobalThis.Buffer === "function") {
    return localGlobalThis.Buffer.from(value).toString("base64");
  }
  if (typeof localGlobalThis.btoa === "function") {
    return localGlobalThis.btoa(value);
  }
  throw new Error("Unable to locate global `Buffer` or `btoa`");
}
var base64Regex = /^(?:[\d+/A-Za-z]{4})*(?:[\d+/A-Za-z]{2}==|[\d+/A-Za-z]{3}=)?$/;
function decodeBase64(value) {
  if (!base64Regex.test(value)) {
    throw new PothosValidationError("Invalid base64 string");
  }
  const localGlobalThis = getGlobalThis();
  if (typeof localGlobalThis.Buffer === "function") {
    return localGlobalThis.Buffer.from(value, "base64").toString();
  }
  if (typeof localGlobalThis.atob === "function") {
    return localGlobalThis.atob(value);
  }
  throw new Error("Unable to locate global `Buffer` or `atob`");
}

// node_modules/@pothos/core/esm/utils/enums.js
function normalizeEnumValues(values) {
  const result = {};
  if (Array.isArray(values)) {
    for (const key of values) {
      result[String(key)] = {
        pothosOptions: {}
      };
    }
  } else {
    for (const [key, value] of Object.entries(values)) {
      if (value && typeof value === "object") {
        result[key] = {
          ...value,
          pothosOptions: value
        };
      } else if (typeof value === "string") {
        result[value] = {
          pothosOptions: {}
        };
      }
    }
  }
  return result;
}
function valuesFromEnum(Enum, values) {
  const result = {};
  for (const key of Object.keys(Enum).filter((key2) => typeof Enum[Enum[key2]] !== "number")) {
    result[key] = {
      value: Enum[key],
      pothosOptions: {},
      ...values === null || values === void 0 ? void 0 : values[key]
    };
  }
  return result;
}

// node_modules/@pothos/core/esm/utils/params.js
function unwrapOutputFieldType(type) {
  if (type.kind === "List") {
    return unwrapOutputFieldType(type.type);
  }
  return type.ref;
}
function typeFromParam(param, configStore, nullableOption) {
  const itemNullable = typeof nullableOption === "object" ? nullableOption.items : false;
  const nullable = typeof nullableOption === "object" ? nullableOption.list : !!nullableOption;
  if (Array.isArray(param)) {
    return {
      kind: "List",
      type: typeFromParam(param[0], configStore, itemNullable),
      nullable
    };
  }
  if (param instanceof ListRef) {
    return {
      kind: "List",
      type: typeFromParam(param.listType, configStore, param.nullable),
      nullable
    };
  }
  const ref = configStore.getOutputTypeRef(param);
  const kind = ref instanceof BaseTypeRef ? ref.kind : configStore.getTypeConfig(ref).graphqlKind;
  const name = ref instanceof BaseTypeRef ? ref.name : configStore.getTypeConfig(ref).name;
  if (kind !== "InputObject" && kind !== "List" && kind !== "InputList") {
    return {
      kind,
      ref,
      nullable
    };
  }
  throw new PothosSchemaError(`Expected input param ${name} to be an output type but got ${kind}`);
}
function unwrapInputFieldType(type) {
  if (type.kind === "List") {
    return unwrapInputFieldType(type.type);
  }
  return type.ref;
}
function inputTypeFromParam(param, configStore, requiredOption) {
  const itemRequired = typeof requiredOption === "object" ? requiredOption.items : true;
  const required = typeof requiredOption === "object" ? requiredOption.list : !!requiredOption;
  if (Array.isArray(param)) {
    return {
      kind: "List",
      type: inputTypeFromParam(param[0], configStore, itemRequired),
      required
    };
  }
  if (param instanceof InputListRef) {
    return {
      kind: "List",
      type: inputTypeFromParam(param.listType, configStore, param.required),
      required
    };
  }
  const ref = configStore.getInputTypeRef(param);
  const kind = ref instanceof BaseTypeRef ? ref.kind : configStore.getTypeConfig(ref).graphqlKind;
  const name = ref instanceof BaseTypeRef ? ref.name : configStore.getTypeConfig(ref).name;
  if (kind === "InputObject" || kind === "Enum" || kind === "Scalar") {
    return {
      kind,
      ref,
      required
    };
  }
  throw new PothosSchemaError(`Expected input param ${name} to be an InputObject, Enum, or Scalar but got ${kind}`);
}

// node_modules/@pothos/core/esm/utils/input.js
function resolveInputTypeConfig(type, buildCache) {
  if (type.kind === "List") {
    return resolveInputTypeConfig(type.type, buildCache);
  }
  const config = buildCache.getTypeConfig(type.ref);
  if (config.kind === "Enum" || config.kind === "Scalar" || config.kind === "InputObject") {
    return config;
  }
  throw new PothosSchemaError(`Unexpected config type ${config.kind} for input ref ${String(type.ref)}`);
}
function mapInputFields(inputs, buildCache, mapper, cache = /* @__PURE__ */ new Map()) {
  const filterMappings = /* @__PURE__ */ new Map();
  const hasMappings = /* @__PURE__ */ new Map();
  return filterMapped(internalMapInputFields(inputs, buildCache, mapper, cache));
  function filterMapped(map) {
    if (filterMappings.has(map)) {
      return filterMappings.get(map);
    }
    const filtered = /* @__PURE__ */ new Map();
    filterMappings.set(map, filtered);
    map.forEach((mapping, fieldName) => {
      if (mapping.kind === "Enum" || mapping.kind === "Scalar") {
        filtered.set(fieldName, mapping);
        return;
      }
      const hasNestedMappings = checkForMappings(mapping.fields.map, hasMappings);
      if (mapping.value !== null || hasNestedMappings) {
        const filteredTypeFields = filterMapped(mapping.fields.map);
        const mappingForType = {
          ...mapping,
          fields: {
            configs: mapping.fields.configs,
            map: filteredTypeFields
          }
        };
        filtered.set(fieldName, mappingForType);
      }
    });
    return filtered.size > 0 ? filtered : null;
  }
  function checkForMappings(map, hasMappings2) {
    if (hasMappings2.has(map)) {
      return hasMappings2.get(map);
    }
    hasMappings2.set(map, false);
    let result = false;
    for (const mapping of map.values()) {
      if (mapping.value !== null) {
        result = true;
      } else if (mapping.kind === "InputObject" && mapping.fields.map && checkForMappings(mapping.fields.map, hasMappings2)) {
        result = true;
      }
    }
    hasMappings2.set(map, result);
    return result;
  }
}
function internalMapInputFields(inputs, buildCache, mapper, seenTypes) {
  const map = /* @__PURE__ */ new Map();
  for (const [fieldName, inputField] of Object.entries(inputs)) {
    const typeConfig = resolveInputTypeConfig(inputField.type, buildCache);
    const fieldMapping = mapper(inputField);
    if (typeConfig.kind === "Enum" || typeConfig.kind === "Scalar") {
      if (fieldMapping !== null) {
        map.set(fieldName, {
          kind: typeConfig.kind,
          isList: inputField.type.kind === "List",
          config: inputField,
          value: fieldMapping
        });
      }
      continue;
    }
    const inputFieldConfigs = buildCache.getInputTypeFieldConfigs(unwrapInputFieldType(inputField.type));
    if (!seenTypes.has(typeConfig.name)) {
      const typeEntry = {
        configs: inputFieldConfigs,
        map: /* @__PURE__ */ new Map()
      };
      seenTypes.set(typeConfig.name, typeEntry);
      typeEntry.map = internalMapInputFields(inputFieldConfigs, buildCache, mapper, seenTypes);
    }
    const typeFields = seenTypes.get(typeConfig.name);
    map.set(fieldName, {
      kind: typeConfig.kind,
      isList: inputField.type.kind === "List",
      config: inputField,
      value: fieldMapping,
      fields: typeFields
    });
  }
  return map;
}
function createInputValueMapper(argMap, mapValue) {
  return function mapObject(obj, map = argMap, ...args) {
    const mapped = {
      ...obj
    };
    map.forEach((field, fieldName) => {
      let fieldVal = obj[fieldName];
      if (fieldVal === null || fieldVal === void 0) {
        return;
      }
      if (field.kind === "InputObject" && field.fields.map) {
        fieldVal = field.isList ? fieldVal.map((val) => val && mapObject(val, field.fields.map, ...args)) : mapObject(fieldVal, field.fields.map, ...args);
        mapped[fieldName] = fieldVal;
      }
      if (field.kind !== "InputObject" || field.value !== null) {
        mapped[fieldName] = field.isList ? fieldVal.map((val) => val == null ? val : mapValue(val, field, ...args)) : mapValue(fieldVal, field, ...args);
      }
    });
    return mapped;
  };
}

// node_modules/@pothos/core/esm/utils/sort-classes.js
function classDepth(obj) {
  const proto = Object.getPrototypeOf(obj);
  if (!proto) {
    return 0;
  }
  return 1 + classDepth(proto);
}
function sortClasses(classes) {
  return [
    ...classes
  ].sort((a, b) => {
    const depthA = classDepth(a);
    const depthB = classDepth(b);
    if (depthA > depthB) {
      return -1;
    }
    if (depthB > depthA) {
      return 1;
    }
    return 0;
  });
}

// node_modules/@pothos/core/esm/utils/index.js
function assertNever(value) {
  throw new TypeError(`Unexpected value: ${value}`);
}
function assertArray(value) {
  if (!Array.isArray(value)) {
    throw new PothosValidationError("List resolvers must return arrays");
  }
  return true;
}
function isThenable(value) {
  return !!(value && (typeof value === "object" || typeof value === "function") && typeof value.then === "function");
}
function verifyRef(ref) {
  if (ref === void 0) {
    throw new PothosSchemaError(`Received undefined as a type ref.

This is often caused by a circular import
If this ref is imported from a file that re-exports it (like index.ts)
you may be able to resolve this by importing it directly from the file that defines it.
`);
  }
}
function verifyInterfaces(interfaces) {
  if (!interfaces || typeof interfaces === "function") {
    return;
  }
  if (!Array.isArray(interfaces)) {
    throw new PothosSchemaError("interfaces must be an array or function");
  }
  for (const iface of interfaces) {
    if (iface === void 0) {
      throw new PothosSchemaError(`Received undefined in list of interfaces.

This is often caused by a circular import
If this ref is imported from a file that re-exports it (like index.ts)
you may be able to resolve this by importing it directly from the file that defines it.

Alternatively you can define interfaces with a function that will be lazily evaluated,
which may resolver issues with circular dependencies:

Example:
builder.objectType('MyObject', {
  interface: () => [Interface1, Interface2],
  ...
});
`);
    }
  }
}
function brandWithType(val, type) {
  if (typeof val !== "object" || val === null) {
    return;
  }
  Object.defineProperty(val, typeBrandKey, {
    enumerable: false,
    value: type
  });
}
function getTypeBrand(val) {
  if (typeof val === "object" && val !== null && typeBrandKey in val) {
    return val[typeBrandKey];
  }
  return null;
}
function unwrapListParam(param) {
  if (Array.isArray(param)) {
    return unwrapListParam(param[0]);
  }
  if (param instanceof ListRef || param instanceof InputListRef) {
    return unwrapListParam(param.listType);
  }
  return param;
}
function unwrapOutputListParam(param) {
  if (Array.isArray(param)) {
    return unwrapOutputListParam(param[0]);
  }
  if (param instanceof ListRef) {
    return unwrapOutputListParam(param.listType);
  }
  return param;
}
function unwrapInputListParam(param) {
  if (Array.isArray(param)) {
    return unwrapInputListParam(param[0]);
  }
  if (param instanceof InputListRef) {
    return unwrapInputListParam(param.listType);
  }
  return param;
}
function completeValue(valOrPromise, onSuccess, onError) {
  if (isThenable(valOrPromise)) {
    return Promise.resolve(valOrPromise).then(onSuccess, onError);
  }
  const result = onSuccess(valOrPromise);
  if (isThenable(result)) {
    return Promise.resolve(result);
  }
  return result;
}
function getMappedArgumentValues(def, node, context, info) {
  var _def_extensions;
  const args = getArgumentValues(def, node, info.variableValues);
  const mappers = (_def_extensions = def.extensions) === null || _def_extensions === void 0 ? void 0 : _def_extensions.pothosArgMappers;
  if (mappers && mappers.length > 0) {
    return mappers.reduce((acc, argMapper) => argMapper(acc, context, info), args);
  }
  return args;
}

// node_modules/@pothos/core/esm/build-cache.js
function _define_property8(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
var BuildCache = class {
  getTypeConfig(ref, kind) {
    const baseConfig = this.configStore.getTypeConfig(ref, kind);
    if (!this.typeConfigs.has(baseConfig.name)) {
      this.typeConfigs.set(baseConfig.name, this.plugin.onTypeConfig(baseConfig));
    }
    const typeConfig = this.typeConfigs.get(baseConfig.name);
    return typeConfig;
  }
  getInputTypeFieldConfigs(ref) {
    const typeConfig = this.getTypeConfig(ref, "InputObject");
    const builtType = this.types.get(typeConfig.name);
    if (!builtType) {
      throw new PothosSchemaError(`Input type ${typeConfig.name} has not been built yet`);
    }
    const fields = builtType.getFields();
    const fieldConfigs = {};
    for (const fieldName of Object.keys(fields)) {
      var _fields_fieldName_extensions;
      fieldConfigs[fieldName] = (_fields_fieldName_extensions = fields[fieldName].extensions) === null || _fields_fieldName_extensions === void 0 ? void 0 : _fields_fieldName_extensions.pothosConfig;
    }
    return fieldConfigs;
  }
  getImplementers(iface) {
    if (this.implementers.has(iface.name)) {
      return this.implementers.get(iface.name);
    }
    const implementers = [
      ...this.configStore.typeConfigs.values()
    ].filter((config) => config.kind === "Object" && config.interfaces.find((i) => this.configStore.getTypeConfig(i).name === iface.name));
    this.implementers.set(iface.name, implementers);
    return implementers;
  }
  buildAll() {
    this.configStore.prepareForBuild();
    for (const config of this.configStore.typeConfigs.values()) {
      if (config.kind === "Enum" || config.kind === "Scalar") {
        this.buildTypeFromConfig(config);
      }
    }
    for (const config of this.configStore.typeConfigs.values()) {
      if (config.kind === "InputObject") {
        this.buildTypeFromConfig(config);
      }
    }
    for (const type of this.types.values()) {
      if (type instanceof GraphQLInputObjectType) {
        type.getFields();
      }
    }
    for (const config of this.configStore.typeConfigs.values()) {
      if (config.kind === "Interface") {
        this.buildTypeFromConfig(config);
      }
    }
    for (const config of this.configStore.typeConfigs.values()) {
      if (config.kind === "Object") {
        this.buildTypeFromConfig(config);
      }
    }
    for (const config of this.configStore.typeConfigs.values()) {
      if (config.kind === "Union") {
        this.buildTypeFromConfig(config);
      }
    }
    for (const config of this.configStore.typeConfigs.values()) {
      if (config.kind === "Query" || config.kind === "Mutation" || config.kind === "Subscription") {
        this.buildTypeFromConfig(config);
      }
    }
    for (const type of this.types.values()) {
      if (type instanceof GraphQLObjectType || type instanceof GraphQLInterfaceType) {
        type.getFields();
      } else if (type instanceof GraphQLUnionType) {
        type.getTypes();
      }
    }
  }
  buildTypeFromConfig(baseConfig) {
    const config = this.getTypeConfig(baseConfig.name);
    const { name } = config;
    this.typeConfigs.set(name, config);
    switch (config.kind) {
      case "Enum":
        this.addType(name, this.buildEnum(config));
        break;
      case "InputObject":
        this.addType(name, this.buildInputObject(config));
        break;
      case "Interface":
        this.addType(name, this.buildInterface(config));
        break;
      case "Scalar":
        this.addType(name, this.buildScalar(config));
        break;
      case "Union":
        this.addType(name, this.buildUnion(config));
        break;
      case "Object":
      case "Query":
      case "Mutation":
      case "Subscription":
        this.addType(name, this.buildObject(config));
        break;
      default:
        assertNever(config);
    }
  }
  addType(ref, type) {
    if (this.types.has(ref)) {
      throw new PothosSchemaError(`reference or name has already been used to create another type (${type.name})`);
    }
    this.types.set(ref, type);
  }
  buildOutputTypeParam(type) {
    if (type.kind === "List") {
      if (type.nullable) {
        return new GraphQLList(this.buildOutputTypeParam(type.type));
      }
      return new GraphQLNonNull(new GraphQLList(this.buildOutputTypeParam(type.type)));
    }
    if (type.nullable) {
      return this.getOutputType(type.ref);
    }
    return new GraphQLNonNull(this.getOutputType(type.ref));
  }
  buildInputTypeParam(type) {
    if (type.kind === "List") {
      if (type.required) {
        return new GraphQLNonNull(new GraphQLList(this.buildInputTypeParam(type.type)));
      }
      return new GraphQLList(this.buildInputTypeParam(type.type));
    }
    if (type.required) {
      return new GraphQLNonNull(this.getInputType(type.ref));
    }
    return this.getInputType(type.ref);
  }
  buildFields(fields) {
    const built = {};
    for (const [fieldName, originalConfig] of fields) {
      if (!this.outputFieldConfigs.has(originalConfig)) {
        this.outputFieldConfigs.set(originalConfig, this.plugin.onOutputFieldConfig(originalConfig));
      }
      const updatedConfig = this.outputFieldConfigs.get(originalConfig);
      if (!updatedConfig) {
        continue;
      }
      const config = {
        ...updatedConfig
      };
      const argMap = /* @__PURE__ */ new Map();
      for (const argName of Object.keys(config.args)) {
        argMap.set(argName, config.args[argName]);
      }
      const args = this.buildInputFields(argMap);
      const argConfigs = {};
      for (const argName of Object.keys(config.args)) {
        argConfigs[argName] = this.inputFieldConfigs.get(config.args[argName]);
      }
      config.args = argConfigs;
      var _config_resolve;
      const resolve = this.plugin.wrapResolve((_config_resolve = config.resolve) !== null && _config_resolve !== void 0 ? _config_resolve : defaultFieldResolver, config);
      const subscribe = this.plugin.wrapSubscribe(config.subscribe, config);
      var _config_resolve1;
      built[fieldName] = {
        ...config,
        type: this.buildOutputTypeParam(config.type),
        args,
        extensions: {
          ...config.extensions,
          pothosResolveWrapped: resolve !== ((_config_resolve1 = config.resolve) !== null && _config_resolve1 !== void 0 ? _config_resolve1 : defaultFieldResolver),
          pothosSubscribeWrapped: subscribe !== config.subscribe,
          pothosOptions: config.pothosOptions,
          pothosConfig: config,
          pothosArgMappers: config.argMappers
        },
        resolve: resolve === defaultFieldResolver ? void 0 : resolve,
        subscribe
      };
    }
    return built;
  }
  buildInputFields(fields) {
    const built = {};
    for (const [fieldName, originalConfig] of fields) {
      if (!this.inputFieldConfigs.has(originalConfig)) {
        this.inputFieldConfigs.set(originalConfig, this.plugin.onInputFieldConfig(originalConfig));
      }
      const config = this.inputFieldConfigs.get(originalConfig);
      if (config) {
        built[fieldName] = {
          ...config,
          type: this.buildInputTypeParam(config.type),
          extensions: {
            ...config.extensions,
            pothosOptions: config.pothosOptions,
            pothosConfig: config
          }
        };
      }
    }
    return built;
  }
  getInterfaceFields(type) {
    const interfaceFields = type.getInterfaces().reduce((all, iface) => Object.assign(all, this.getFields(iface)), {});
    const configs = this.configStore.getFields(type.name, "Interface");
    const fields = this.buildFields(configs);
    return {
      ...interfaceFields,
      ...fields
    };
  }
  getObjectFields(type) {
    const interfaceFields = type.getInterfaces().reduce((all, iface) => Object.assign(all, this.getFields(iface)), {});
    const objectFields = this.buildFields(this.configStore.getFields(type.name, "Object"));
    return {
      ...interfaceFields,
      ...objectFields
    };
  }
  getRootFields(type) {
    return this.buildFields(this.configStore.getFields(type.name, "Object"));
  }
  getFields(type) {
    if (type instanceof GraphQLObjectType) {
      const config = this.configStore.getTypeConfig(type.name);
      if (config.kind === "Query" || config.kind === "Mutation" || config.kind === "Subscription") {
        return this.getRootFields(type);
      }
      return this.getObjectFields(type);
    }
    if (type instanceof GraphQLInterfaceType) {
      return this.getInterfaceFields(type);
    }
    throw new PothosSchemaError(`Type ${type.name} does not have fields to resolve`);
  }
  getInputFields(type) {
    return this.buildInputFields(this.configStore.getFields(type.name, "InputObject"));
  }
  getType(ref) {
    if (ref instanceof BuiltinScalarRef) {
      return ref.type;
    }
    const typeConfig = this.configStore.getTypeConfig(ref);
    const type = this.types.get(typeConfig.name);
    if (!type) {
      this.buildTypeFromConfig(typeConfig);
      return this.types.get(typeConfig.name);
    }
    return type;
  }
  getOutputType(ref) {
    const type = this.getType(ref);
    if (type instanceof GraphQLInputObjectType) {
      throw new PothosSchemaError(`Expected ${String(ref)} to be an output type but it was defined as an InputObject`);
    }
    return type;
  }
  getInputType(ref) {
    const type = this.getType(ref);
    if (!type) {
      throw new PothosSchemaError(`Missing implementation of for type ${String(ref)}`);
    }
    if (type instanceof GraphQLObjectType) {
      throw new PothosSchemaError(`Expected ${type.name} to be an input type but it was defined as a GraphQLObjectType`);
    }
    if (type instanceof GraphQLInterfaceType) {
      throw new PothosSchemaError(`Expected ${type.name} to be an input type but it was defined as a GraphQLInterfaceType`);
    }
    if (type instanceof GraphQLUnionType) {
      throw new PothosSchemaError(`Expected ${String(ref)} to be an input type but it was defined as an GraphQLUnionType`);
    }
    return type;
  }
  getTypeOfKind(ref, kind) {
    const type = this.getType(ref);
    switch (kind) {
      case "Object":
      case "Query":
      case "Mutation":
      case "Subscription":
        if (type instanceof GraphQLObjectType) {
          return type;
        }
        break;
      case "Interface":
        if (type instanceof GraphQLInterfaceType) {
          return type;
        }
        break;
      case "Union":
        if (type instanceof GraphQLUnionType) {
          return type;
        }
        break;
      case "Enum":
        if (type instanceof GraphQLEnumType) {
          return type;
        }
        break;
      case "Scalar":
        if (type instanceof GraphQLScalarType) {
          return type;
        }
        break;
      case "InputObject":
        if (type instanceof GraphQLScalarType) {
          return type;
        }
        break;
      default:
        break;
    }
    throw new PothosSchemaError(`Expected ${String(ref)} to be of type ${kind}`);
  }
  buildObject(config) {
    var _config_isTypeOf;
    const type = new GraphQLObjectType({
      ...config,
      extensions: {
        ...config.extensions,
        pothosOptions: config.pothosOptions,
        pothosConfig: config
      },
      fields: () => this.getFields(type),
      isTypeOf: config.kind === "Object" ? this.plugin.wrapIsTypeOf((_config_isTypeOf = config.isTypeOf) !== null && _config_isTypeOf !== void 0 ? _config_isTypeOf : void 0, config) : void 0,
      interfaces: config.kind === "Object" ? () => config.interfaces.map((iface) => this.getTypeOfKind(iface, "Interface")) : void 0
    });
    return type;
  }
  buildInterface(config) {
    const resolveType = (parent, context, info) => {
      const typeBrand = getTypeBrand(parent);
      if (typeBrand) {
        if (typeof typeBrand === "string") {
          return typeBrand;
        }
        return this.getTypeConfig(typeBrand).name;
      }
      var _config_resolveType;
      const resolver = (_config_resolveType = config.resolveType) !== null && _config_resolveType !== void 0 ? _config_resolveType : defaultTypeResolver;
      return resolver(parent, context, info, type);
    };
    const type = new GraphQLInterfaceType({
      ...config,
      extensions: {
        ...config.extensions,
        pothosOptions: config.pothosOptions,
        pothosConfig: config
      },
      interfaces: () => config.interfaces.map((iface) => this.getTypeOfKind(iface, "Interface")),
      fields: () => this.getFields(type),
      resolveType: this.plugin.wrapResolveType(resolveType, config)
    });
    return type;
  }
  buildUnion(config) {
    const resolveType = (parent, context, info, type) => {
      if (typeof parent === "object" && parent !== null && typeBrandKey in parent) {
        const typeBrand = parent[typeBrandKey];
        if (typeof typeBrand === "string") {
          return typeBrand;
        }
        return this.getTypeConfig(typeBrand).name;
      }
      if (!config.resolveType) {
        return defaultTypeResolver(parent, context, info, type);
      }
      const resultOrPromise = config.resolveType(parent, context, info, type);
      const getResult = (result) => {
        if (typeof result === "string" || !result) {
          return result;
        }
        if (result instanceof GraphQLObjectType) {
          return result.name;
        }
        try {
          const typeConfig = this.configStore.getTypeConfig(result);
          return typeConfig.name;
        } catch {
        }
        return result;
      };
      return isThenable(resultOrPromise) ? resultOrPromise.then(getResult) : getResult(resultOrPromise);
    };
    return new GraphQLUnionType({
      ...config,
      extensions: {
        ...config.extensions,
        pothosOptions: config.pothosOptions,
        pothosConfig: config
      },
      types: () => config.types.map((member) => this.getTypeOfKind(member, "Object")),
      resolveType: this.plugin.wrapResolveType(resolveType, config)
    });
  }
  buildInputObject(config) {
    const type = new GraphQLInputObjectType({
      ...config,
      extensions: {
        ...config.extensions,
        pothosOptions: config.pothosOptions,
        pothosConfig: config
      },
      fields: () => this.getInputFields(type)
    });
    return type;
  }
  buildScalar(config) {
    if (config.name === "ID") {
      return GraphQLID;
    }
    if (config.name === "Int") {
      return GraphQLInt;
    }
    if (config.name === "Float") {
      return GraphQLFloat;
    }
    if (config.name === "Boolean") {
      return GraphQLBoolean;
    }
    if (config.name === "String") {
      return GraphQLString;
    }
    return new GraphQLScalarType({
      ...config,
      extensions: {
        ...config.extensions,
        pothosOptions: config.pothosOptions,
        pothosConfig: config
      }
    });
  }
  buildEnum(config) {
    const values = {};
    const configValues = typeof config.values === "function" ? config.values() : config.values;
    for (const key of Object.keys(config.values)) {
      const original = configValues[key];
      if (!this.enumValueConfigs.has(original)) {
        this.enumValueConfigs.set(original, this.plugin.onEnumValueConfig(original));
      }
      const valueConfig = this.enumValueConfigs.get(original);
      if (valueConfig) {
        values[key] = this.enumValueConfigs.get(original);
      }
    }
    return new GraphQLEnumType({
      ...config,
      values,
      extensions: {
        ...config.extensions,
        pothosOptions: config.pothosOptions,
        pothosConfig: config
      }
    });
  }
  constructor(builder, options) {
    _define_property8(this, "types", /* @__PURE__ */ new Map());
    _define_property8(this, "builder", void 0);
    _define_property8(this, "plugin", void 0);
    _define_property8(this, "options", void 0);
    _define_property8(this, "configStore", void 0);
    _define_property8(this, "pluginList", void 0);
    _define_property8(this, "implementers", /* @__PURE__ */ new Map());
    _define_property8(this, "typeConfigs", /* @__PURE__ */ new Map());
    _define_property8(this, "enumValueConfigs", /* @__PURE__ */ new Map());
    _define_property8(this, "outputFieldConfigs", /* @__PURE__ */ new Map());
    _define_property8(this, "inputFieldConfigs", /* @__PURE__ */ new Map());
    this.builder = builder;
    this.configStore = builder.configStore;
    this.options = options;
    const plugins = {};
    var _builder_options_plugins;
    this.pluginList = ((_builder_options_plugins = builder.options.plugins) !== null && _builder_options_plugins !== void 0 ? _builder_options_plugins : []).map((pluginName) => {
      const Plugin = this.builder.constructor.plugins[pluginName];
      if (!Plugin) {
        throw new PothosError(`No plugin named ${pluginName} was registered`);
      }
      plugins[pluginName] = new Plugin(this, pluginName);
      return plugins[pluginName];
    });
    this.plugin = new MergedPlugins(this, this.pluginList);
  }
};

// node_modules/@pothos/core/esm/refs/input-object.js
function _define_property9(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
var _inputShapeKey3 = inputShapeKey;
var InputObjectRef = class extends BaseTypeRef {
  addFields(fields) {
    this.fields.add(fields);
    for (const cb of this.fieldCbs) {
      for (const [name, ref] of Object.entries(fields())) {
        if (ref) {
          cb(name, ref);
        }
      }
    }
  }
  onField(cb) {
    this.fieldCbs.add(cb);
    for (const fieldMap of this.fields) {
      for (const [name, ref] of Object.entries(fieldMap())) {
        if (ref) {
          cb(name, ref);
        }
      }
    }
  }
  constructor(name) {
    super("InputObject", name), _define_property9(this, "kind", "InputObject"), _define_property9(this, "$inferInput", void 0), _define_property9(this, _inputShapeKey3, void 0), _define_property9(this, "fields", /* @__PURE__ */ new Set()), _define_property9(this, "fieldCbs", /* @__PURE__ */ new Set());
  }
};
var ImplementableInputObjectRef = class extends InputObjectRef {
  implement(options) {
    this.builder.inputType(this, options);
    return this;
  }
  constructor(builder, name) {
    super(name), _define_property9(this, "builder", void 0);
    this.builder = builder;
  }
};

// node_modules/@pothos/core/esm/refs/base-with-fields.js
function _define_property10(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
var TypeRefWithFields = class extends BaseTypeRef {
  addFields(fields) {
    for (const cb of this.fieldCbs) {
      for (const [name, ref] of Object.entries(fields())) {
        if (ref) {
          cb(name, ref);
        }
      }
    }
    this.fields.add(fields);
  }
  addInterfaces(interfaces) {
    if (Array.isArray(interfaces) && interfaces.length === 0) {
      return;
    }
    if (this.preparedForBuild) {
      this.updateConfig((cfg) => ({
        ...cfg,
        interfaces: [
          ...cfg.interfaces,
          ...typeof interfaces === "function" ? interfaces() : interfaces
        ]
      }));
    } else {
      this.interfaces.push(() => Array.isArray(interfaces) ? interfaces : interfaces());
    }
  }
  onField(cb) {
    this.fieldCbs.add(cb);
    for (const fieldMap of this.fields) {
      for (const [name, ref] of Object.entries(fieldMap())) {
        if (ref) {
          cb(name, ref);
        }
      }
    }
  }
  prepareForBuild() {
    if (this.preparedForBuild) {
      return;
    }
    super.prepareForBuild();
    if (this.interfaces.length > 0) {
      this.updateConfig((cfg) => {
        var _cfg_interfaces;
        return {
          ...cfg,
          interfaces: [
            ...(_cfg_interfaces = cfg.interfaces) !== null && _cfg_interfaces !== void 0 ? _cfg_interfaces : [],
            ...this.interfaces.flatMap((interfaces) => interfaces())
          ]
        };
      });
    }
  }
  constructor(...args) {
    super(...args), _define_property10(this, "fields", /* @__PURE__ */ new Set()), _define_property10(this, "fieldCbs", /* @__PURE__ */ new Set()), _define_property10(this, "interfaces", []);
  }
};

// node_modules/@pothos/core/esm/refs/interface.js
function _define_property11(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
var _outputShapeKey3 = outputShapeKey;
var _parentShapeKey3 = parentShapeKey;
var InterfaceRef = class extends TypeRefWithFields {
  constructor(name, config) {
    super("Interface", name, config), _define_property11(this, "kind", "Interface"), _define_property11(this, "$inferType", void 0), _define_property11(this, _outputShapeKey3, void 0), _define_property11(this, _parentShapeKey3, void 0);
  }
};
var ImplementableInterfaceRef = class extends InterfaceRef {
  implement(options) {
    return this.builder.interfaceType(this, options);
  }
  constructor(builder, name) {
    super(name), _define_property11(this, "builder", void 0);
    this.builder = builder;
  }
};

// node_modules/@pothos/core/esm/refs/object.js
function _define_property12(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
var _outputShapeKey4 = outputShapeKey;
var _parentShapeKey4 = parentShapeKey;
var ObjectRef = class extends TypeRefWithFields {
  constructor(name, config) {
    super("Object", name, config), _define_property12(this, "kind", "Object"), _define_property12(this, "$inferType", void 0), _define_property12(this, _outputShapeKey4, void 0), _define_property12(this, _parentShapeKey4, void 0);
  }
};
var ImplementableObjectRef = class extends ObjectRef {
  implement(options) {
    return this.builder.objectType(this, options);
  }
  constructor(builder, name) {
    super(name), _define_property12(this, "builder", void 0);
    this.builder = builder;
  }
};

// node_modules/@pothos/core/esm/refs/mutation.js
function _define_property13(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
var MutationRef = class extends ObjectRef {
  constructor(...args) {
    super(...args), _define_property13(this, "kind", "Object");
  }
};

// node_modules/@pothos/core/esm/refs/query.js
var QueryRef = class extends ObjectRef {
};

// node_modules/@pothos/core/esm/refs/subscription.js
var SubscriptionRef = class extends ObjectRef {
};

// node_modules/@pothos/core/esm/config-store.js
function _define_property14(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
var ConfigStore = class {
  addFields(param, fields) {
    this.onTypeConfig(param, (_config, ref) => {
      if (!(ref instanceof InterfaceRef || ref instanceof ObjectRef || ref instanceof QueryRef || ref instanceof MutationRef || ref instanceof SubscriptionRef)) {
        throw new PothosSchemaError(`Can not add fields to ${ref} because it is not an object`);
      }
      ref.addFields(fields);
    });
  }
  addInputFields(param, fields) {
    this.onTypeConfig(param, (_config, ref) => {
      if (!(ref instanceof InputObjectRef)) {
        throw new PothosSchemaError(`Can not add fields to ${ref} because it is not an input object`);
      }
      ref.addFields(fields);
    });
  }
  associateParamWithRef(param, ref) {
    const resolved = this.resolveParamAssociations(ref);
    this.paramAssociations.set(param, resolved);
    var _this_pendingTypeConfigResolutions_get;
    const pendingResolutions = (_this_pendingTypeConfigResolutions_get = this.pendingTypeConfigResolutions.get(param)) !== null && _this_pendingTypeConfigResolutions_get !== void 0 ? _this_pendingTypeConfigResolutions_get : [];
    if (pendingResolutions.length > 0) {
      if (typeof resolved === "string" && this.typeConfigs.has(resolved)) {
        for (const cb of pendingResolutions) {
          const config = this.typeConfigs.get(resolved);
          cb(config, this.implementors.get(config.name));
        }
      } else {
        for (const cb of pendingResolutions) {
          this.onTypeConfig(resolved, cb);
        }
      }
    }
    this.pendingTypeConfigResolutions.delete(param);
  }
  onTypeConfig(param, onConfig) {
    const resolved = this.resolveParamAssociations(param);
    if (typeof resolved === "string" && this.typeConfigs.has(resolved)) {
      const config = this.typeConfigs.get(resolved);
      onConfig(config, this.implementors.get(config.name));
    } else {
      if (!this.pendingTypeConfigResolutions.has(resolved)) {
        this.pendingTypeConfigResolutions.set(resolved, []);
      }
      this.pendingTypeConfigResolutions.get(resolved).push(onConfig);
    }
  }
  onTypeConfigOfKind(param, kind, onConfig) {
    this.onTypeConfig(param, (config) => {
      if (config.kind !== kind) {
        throw new PothosSchemaError(`Expected ${this.describeRef(param)} to be of kind ${kind} but it is of kind ${config.kind}`);
      }
      onConfig(config);
    });
  }
  addTypeRef(ref) {
    if (this.refs.has(ref)) {
      return;
    }
    if (!this.pending) {
      ref.prepareForBuild();
    }
    this.refs.add(ref);
    ref.onConfig((config) => {
      const implementor = this.implementors.get(config.name);
      if (implementor && implementor !== ref) {
        throw new PothosSchemaError(`Duplicate typename: Another type with name ${config.name} already exists.`);
      }
      if (!implementor) {
        this.implementors.set(config.name, ref);
        this.associateParamWithRef(ref, config.name);
        if (ref instanceof ObjectRef || ref instanceof InterfaceRef || ref instanceof InputObjectRef) {
          if (!this.fields.has(config.name)) {
            this.fields.set(config.name, /* @__PURE__ */ new Map());
          }
          this.onPrepare(() => {
            ref.onField((fieldName, field) => {
              const fields = this.fields.get(config.name);
              if (fields.has(fieldName)) {
                throw new PothosSchemaError(`Duplicate field ${fieldName} on ${config.name}`);
              }
              var _this_typeConfigs_get;
              fields.set(fieldName, field.getConfig(fieldName, (_this_typeConfigs_get = this.typeConfigs.get(config.name)) !== null && _this_typeConfigs_get !== void 0 ? _this_typeConfigs_get : config));
            });
          });
        }
      }
      this.typeConfigs.set(config.name, config);
      if (this.pendingTypeConfigResolutions.has(config.name)) {
        const cbs = this.pendingTypeConfigResolutions.get(config.name);
        for (const cb of cbs) {
          cb(config, ref);
        }
      }
      this.pendingTypeConfigResolutions.delete(config.name);
    });
  }
  subscribeToFields(_ref) {
  }
  hasImplementation(typeName) {
    return this.typeConfigs.has(typeName);
  }
  hasConfig(ref) {
    const resolved = this.resolveParamAssociations(ref);
    if (typeof resolved !== "string" || !this.typeConfigs.has(resolved)) {
      return false;
    }
    return true;
  }
  getTypeConfig(ref, kind) {
    const resolved = this.resolveParamAssociations(ref);
    if (typeof resolved !== "string" || !this.typeConfigs.has(resolved)) {
      throw new PothosSchemaError(`${this.describeRef(ref)} has not been implemented`);
    }
    const config = this.typeConfigs.get(resolved);
    if (kind && config.graphqlKind !== kind) {
      throw new PothosSchemaError(`Expected ref to resolve to a ${kind} type, but got ${config.kind}`);
    }
    return config;
  }
  getInputTypeRef(param) {
    const resolved = this.resolveParamAssociations(param);
    if (param instanceof BaseTypeRef) {
      if (param.kind !== "InputObject" && param.kind !== "Enum" && param.kind !== "Scalar") {
        throw new PothosSchemaError(`Expected ${this.describeRef(param)} to be an input type but got ${param.kind}`);
      }
      return param;
    }
    if (typeof resolved === "string" && this.typeConfigs.has(resolved)) {
      const ref = this.implementors.get(resolved);
      if (ref instanceof BaseTypeRef) {
        if (ref.kind !== "InputObject" && ref.kind !== "Enum" && ref.kind !== "Scalar") {
          throw new PothosSchemaError(`Expected ${this.describeRef(ref)} to be an input type but got ${ref.kind}`);
        }
        return ref;
      }
    }
    throw new PothosSchemaError(`${this.describeRef(param)} has not been implemented`);
  }
  getOutputTypeRef(param) {
    const resolved = this.resolveParamAssociations(param);
    if (param instanceof BaseTypeRef) {
      if (param.kind === "InputObject" || param.kind === "InputList") {
        throw new PothosSchemaError(`Expected ${param.name} to be an output type but got ${param.kind}`);
      }
      return param;
    }
    if (typeof resolved === "string" && this.typeConfigs.has(resolved)) {
      const ref = this.implementors.get(resolved);
      if (ref instanceof BaseTypeRef) {
        if (ref.kind === "InputObject" || ref.kind === "InputList") {
          throw new PothosSchemaError(`Expected ${ref.name} to be an output type but got ${ref.kind}`);
        }
        return ref;
      }
    }
    throw new PothosSchemaError(`${this.describeRef(param)} has not been implemented`);
  }
  getFields(name, kind) {
    const typeConfig = this.getTypeConfig(name);
    if (!this.fields.has(name)) {
      this.fields.set(name, /* @__PURE__ */ new Map());
    }
    const fields = this.fields.get(name);
    if (kind && typeConfig.graphqlKind !== kind) {
      throw new PothosSchemaError(`Expected ${name} to be a ${kind} type, but found ${typeConfig.graphqlKind}`);
    }
    return fields;
  }
  prepareForBuild() {
    this.pending = false;
    for (const ref of this.refs) {
      ref.prepareForBuild();
    }
    const { pendingActions } = this;
    this.pendingActions = [];
    for (const fn of pendingActions) {
      fn();
    }
    if (this.pendingTypeConfigResolutions.size > 0) {
      throw new PothosSchemaError(`Missing implementations for some references (${[
        ...this.pendingTypeConfigResolutions.keys()
      ].map((ref) => this.describeRef(ref)).join(", ")}).`);
    }
  }
  onPrepare(cb) {
    if (this.pending) {
      this.pendingActions.push(cb);
    } else {
      cb();
    }
  }
  resolveParamAssociations(param) {
    let current = this.paramAssociations.get(param);
    while (current && this.paramAssociations.has(current)) {
      current = this.paramAssociations.get(current);
    }
    return current !== null && current !== void 0 ? current : param;
  }
  describeRef(ref) {
    if (typeof ref === "string") {
      return ref;
    }
    if (ref && ref.toString !== {}.toString) {
      return String(ref);
    }
    if (typeof ref === "function" && ref.name !== (() => {
    }).name) {
      return `function ${ref.name}`;
    }
    return "<unnamed ref or enum>";
  }
  constructor(builder) {
    _define_property14(this, "typeConfigs", /* @__PURE__ */ new Map());
    _define_property14(this, "fields", /* @__PURE__ */ new Map());
    _define_property14(this, "refs", /* @__PURE__ */ new Set());
    _define_property14(this, "implementors", /* @__PURE__ */ new Map());
    _define_property14(this, "pendingActions", []);
    _define_property14(this, "paramAssociations", /* @__PURE__ */ new Map());
    _define_property14(this, "pendingTypeConfigResolutions", /* @__PURE__ */ new Map());
    _define_property14(this, "pending", true);
    _define_property14(this, "builder", void 0);
    this.builder = builder;
  }
};

// node_modules/@pothos/core/esm/refs/arg.js
function _define_property15(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
var _inputFieldShapeKey = inputFieldShapeKey;
var ArgumentRef = class {
  onConfig(cb) {
    this.pendingActions.push(cb);
  }
  updateConfig(cb) {
    this.pendingActions.push(cb);
  }
  getConfig(name, field, typeConfig) {
    const config = this.pendingActions.reduce((config2, cb) => {
      var _cb;
      return (_cb = cb(config2)) !== null && _cb !== void 0 ? _cb : config2;
    }, this.initConfig(name, field, typeConfig));
    for (const cb of this.onUseCallbacks) {
      this.onUseCallbacks.delete(cb);
      cb(config);
    }
    return config;
  }
  onFirstUse(cb) {
    this.onUseCallbacks.add(cb);
  }
  constructor(initConfig) {
    _define_property15(this, "kind", "Arg");
    _define_property15(this, "fieldName", void 0);
    _define_property15(this, "$inferInput", void 0);
    _define_property15(this, _inputFieldShapeKey, void 0);
    _define_property15(this, "pendingActions", []);
    _define_property15(this, "initConfig", void 0);
    _define_property15(this, "onUseCallbacks", /* @__PURE__ */ new Set());
    this.initConfig = initConfig;
  }
};

// node_modules/@pothos/core/esm/refs/input-field.js
function _define_property16(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
var _inputFieldShapeKey2 = inputFieldShapeKey;
var InputFieldRef = class {
  updateConfig(cb) {
    this.pendingActions.push(cb);
  }
  getConfig(name, typeConfig) {
    const config = this.pendingActions.reduce((config2, cb) => {
      var _cb;
      return (_cb = cb(config2)) !== null && _cb !== void 0 ? _cb : config2;
    }, this.initConfig(name, typeConfig));
    for (const cb of this.onUseCallbacks) {
      this.onUseCallbacks.delete(cb);
      cb(config);
    }
    return config;
  }
  onFirstUse(cb) {
    this.onUseCallbacks.add(cb);
  }
  constructor(initConfig) {
    _define_property16(this, "kind", "InputObject");
    _define_property16(this, "fieldName", void 0);
    _define_property16(this, "$inferInput", void 0);
    _define_property16(this, _inputFieldShapeKey2, void 0);
    _define_property16(this, "pendingActions", []);
    _define_property16(this, "initConfig", void 0);
    _define_property16(this, "onUseCallbacks", /* @__PURE__ */ new Set());
    this.initConfig = initConfig;
  }
};

// node_modules/@pothos/core/esm/fieldUtils/input.js
function _define_property17(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
var InputFieldBuilder = class {
  argBuilder() {
    const builder = this.field.bind(this);
    const protoKeys = Object.keys(Object.getPrototypeOf(this)).filter((key) => typeof this[key] === "function" && Function.prototype[key] === void 0);
    for (const key of [
      ...Object.keys(this),
      ...protoKeys
    ]) {
      builder[key] = typeof this[key] === "function" ? this[key].bind(this) : this[key];
    }
    return builder;
  }
  /**
  * Create in input field or argument for the current type
  * @param {PothosSchemaTypes.InputFieldOptions} [options={}] - Options for this field
  */
  field(options) {
    const ref = this.kind === "Arg" ? new ArgumentRef((name, field, typeConfig) => {
      const opts = options;
      var _opts_required, _opts_extensions;
      return {
        name,
        parentField: field,
        kind: this.kind,
        graphqlKind: this.kind,
        parentType: typeConfig.name,
        type: inputTypeFromParam(opts.type, this.builder.configStore, (_opts_required = opts.required) !== null && _opts_required !== void 0 ? _opts_required : this.builder.defaultInputFieldRequiredness),
        pothosOptions: opts,
        description: opts.description,
        deprecationReason: opts.deprecationReason,
        defaultValue: opts.defaultValue,
        extensions: (_opts_extensions = opts.extensions) !== null && _opts_extensions !== void 0 ? _opts_extensions : {}
      };
    }) : new InputFieldRef((name, typeConfig) => {
      const opts = options;
      var _opts_required, _opts_extensions;
      return {
        name,
        parentField: void 0,
        kind: this.kind,
        graphqlKind: this.kind,
        parentType: typeConfig.name,
        type: inputTypeFromParam(opts.type, this.builder.configStore, (_opts_required = opts.required) !== null && _opts_required !== void 0 ? _opts_required : this.builder.defaultInputFieldRequiredness),
        pothosOptions: opts,
        description: opts.description,
        deprecationReason: opts.deprecationReason,
        defaultValue: opts.defaultValue,
        extensions: (_opts_extensions = opts.extensions) !== null && _opts_extensions !== void 0 ? _opts_extensions : {}
      };
    });
    return ref;
  }
  helper(type) {
    return (...args) => {
      const [options = {}] = args;
      return this.field({
        ...options,
        type
      });
    };
  }
  constructor(builder, kind) {
    _define_property17(this, "kind", void 0);
    _define_property17(this, "builder", void 0);
    _define_property17(this, "boolean", this.helper("Boolean"));
    _define_property17(this, "float", this.helper("Float"));
    _define_property17(this, "id", this.helper("ID"));
    _define_property17(this, "int", this.helper("Int"));
    _define_property17(this, "string", this.helper("String"));
    _define_property17(this, "booleanList", this.helper([
      "Boolean"
    ]));
    _define_property17(this, "floatList", this.helper([
      "Float"
    ]));
    _define_property17(this, "idList", this.helper([
      "ID"
    ]));
    _define_property17(this, "intList", this.helper([
      "Int"
    ]));
    _define_property17(this, "stringList", this.helper([
      "String"
    ]));
    _define_property17(this, "listRef", (type, options) => {
      var _options_required;
      return new InputListRef(type, (_options_required = options === null || options === void 0 ? void 0 : options.required) !== null && _options_required !== void 0 ? _options_required : true);
    });
    this.builder = builder;
    this.kind = kind;
  }
};

// node_modules/@pothos/core/esm/refs/field.js
function _define_property18(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
var _outputFieldShapeKey = outputFieldShapeKey;
var FieldRef = class {
  updateConfig(cb) {
    this.pendingActions.push(cb);
  }
  getConfig(name, typeConfig) {
    const config = this.pendingActions.reduce((cfg, cb) => {
      var _cb;
      return (_cb = cb(cfg)) !== null && _cb !== void 0 ? _cb : cfg;
    }, this.initConfig(name, typeConfig));
    for (const cb of this.onUseCallbacks) {
      this.onUseCallbacks.delete(cb);
      cb(config);
    }
    return config;
  }
  onFirstUse(cb) {
    this.onUseCallbacks.add(cb);
  }
  constructor(kind, initConfig) {
    _define_property18(this, "kind", void 0);
    _define_property18(this, "fieldName", void 0);
    _define_property18(this, "$inferType", void 0);
    _define_property18(this, _outputFieldShapeKey, void 0);
    _define_property18(this, "pendingActions", []);
    _define_property18(this, "initConfig", void 0);
    _define_property18(this, "onUseCallbacks", /* @__PURE__ */ new Set());
    this.kind = kind;
    this.initConfig = initConfig;
  }
};

// node_modules/@pothos/core/esm/fieldUtils/base.js
function _define_property19(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
var BaseFieldUtil = class {
  createField(options) {
    const ref = new FieldRef(this.kind, (name, typeConfig) => {
      var _options_extensions;
      const args = {};
      if (options.args) {
        for (const [argName, arg] of Object.entries(options.args)) {
          args[argName] = arg.getConfig(argName, name, typeConfig);
        }
      }
      let { resolve } = options;
      if (((_options_extensions = options.extensions) === null || _options_extensions === void 0 ? void 0 : _options_extensions.pothosExposedField) === name) {
        resolve = defaultFieldResolver;
      }
      const { subscribe } = options;
      var _options_nullable;
      return {
        kind: this.kind,
        graphqlKind: typeConfig.graphqlKind,
        parentType: typeConfig.name,
        name,
        args,
        argMappers: [],
        type: typeFromParam(options.type, this.builder.configStore, (_options_nullable = options.nullable) !== null && _options_nullable !== void 0 ? _options_nullable : this.builder.defaultFieldNullability),
        pothosOptions: options,
        extensions: {
          pothosOriginalResolve: resolve,
          pothosOriginalSubscribe: subscribe,
          ...options.extensions
        },
        description: options.description,
        deprecationReason: options.deprecationReason,
        resolve,
        subscribe
      };
    });
    return ref;
  }
  exposeField(name, { extensions, ...options }) {
    return this.createField({
      ...options,
      extensions: {
        pothosExposedField: name,
        ...extensions
      },
      resolve: (parent) => parent[name]
    });
  }
  constructor(builder, kind, graphqlKind) {
    _define_property19(this, "kind", void 0);
    _define_property19(this, "graphqlKind", void 0);
    _define_property19(this, "builder", void 0);
    this.builder = builder;
    this.kind = kind;
    this.graphqlKind = graphqlKind;
  }
};

// node_modules/@pothos/core/esm/fieldUtils/root.js
function _define_property20(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
var RootFieldBuilder = class extends BaseFieldUtil {
  /**
  * Create a Boolean field
  * @param {PothosSchemaTypes.FieldOptions} options - Options for this field
  */
  boolean(...args) {
    const [options = {}] = args;
    return this.createField({
      resolve: void 0,
      ...options,
      type: "Boolean"
    });
  }
  /**
  * Create a Float field
  * @param {PothosSchemaTypes.FieldOptions} options - Options for this field
  */
  float(...args) {
    const [options = {}] = args;
    return this.createField({
      resolve: void 0,
      ...options,
      type: "Float"
    });
  }
  /**
  * Create a ID field
  * @param {PothosSchemaTypes.FieldOptions} options - Options for this field
  */
  id(...args) {
    const [options = {}] = args;
    return this.createField({
      resolve: void 0,
      ...options,
      type: "ID"
    });
  }
  /**
  * Create a Int field
  * @param {PothosSchemaTypes.FieldOptions} options - Options for this field
  */
  int(...args) {
    const [options = {}] = args;
    return this.createField({
      resolve: void 0,
      ...options,
      type: "Int"
    });
  }
  /**
  * Create a String field
  * @param {PothosSchemaTypes.FieldOptions} options - Options for this field
  */
  string(...args) {
    const [options = {}] = args;
    return this.createField({
      resolve: void 0,
      ...options,
      type: "String"
    });
  }
  /**
  * Create a Boolean list field
  * @param {PothosSchemaTypes.FieldOptions} options - Options for this field
  */
  booleanList(...args) {
    const [options = {}] = args;
    return this.createField({
      resolve: void 0,
      ...options,
      type: [
        "Boolean"
      ]
    });
  }
  /**
  * Create a Float list field
  * @param {PothosSchemaTypes.FieldOptions} options - Options for this field
  */
  floatList(...args) {
    const [options = {}] = args;
    return this.createField({
      resolve: void 0,
      ...options,
      type: [
        "Float"
      ]
    });
  }
  /**
  * Create a ID list field
  * @param {PothosSchemaTypes.FieldOptions} options - Options for this field
  */
  idList(...args) {
    const [options = {}] = args;
    return this.createField({
      resolve: void 0,
      ...options,
      type: [
        "ID"
      ]
    });
  }
  /**
  * Create a Int list field
  * @param {PothosSchemaTypes.FieldOptions} options - Options for this field
  */
  intList(...args) {
    const [options = {}] = args;
    return this.createField({
      resolve: void 0,
      ...options,
      type: [
        "Int"
      ]
    });
  }
  /**
  * Create a String list field
  * @param {PothosSchemaTypes.FieldOptions} options - Options for this field
  */
  stringList(...args) {
    const [options = {}] = args;
    return this.createField({
      resolve: void 0,
      ...options,
      type: [
        "String"
      ]
    });
  }
  /**
  * create a new field for the current type
  * @param {PothosSchemaTypes.FieldOptions} options - options for this field
  */
  field(options) {
    return this.createField(options);
  }
  listRef(type, options) {
    var _options_nullable;
    return new ListRef(type, (_options_nullable = options === null || options === void 0 ? void 0 : options.nullable) !== null && _options_nullable !== void 0 ? _options_nullable : false);
  }
  constructor(...args) {
    super(...args), _define_property20(this, "arg", new InputFieldBuilder(this.builder, "Arg").argBuilder());
  }
};

// node_modules/@pothos/core/esm/fieldUtils/builder.js
var FieldBuilder = class extends RootFieldBuilder {
  /**
  * Create a Boolean field from a boolean property on the parent object
  * @param {string} name - the name of the property on the source object (does not need to match the field name).
  * @param {object} [options={}] - Options for this field
  */
  exposeBoolean(name, ...args) {
    const [options = {}] = args;
    return this.exposeField(name, {
      ...options,
      type: "Boolean"
    });
  }
  /**
  * Create a Float field from a numeric property on the parent object
  * @param {string} name - the name of the property on the source object (does not need to match the field name).
  * @param {object} [options={}] - Options for this field
  */
  exposeFloat(name, ...args) {
    const [options = {}] = args;
    return this.exposeField(name, {
      ...options,
      type: "Float"
    });
  }
  /**
  * Create an ID field from a property on the parent object
  * @param {string} name - the name of the property on the source object (does not need to match the field name).
  * @param {object} [options={}] - Options for this field
  */
  exposeID(name, ...args) {
    const [options = {}] = args;
    return this.exposeField(name, {
      ...options,
      type: "ID"
    });
  }
  /**
  * Create an Int field from a numeric property on the parent object
  * @param {string} name - the name of the property on the source object (does not need to match the field name).
  * @param {object} [options={}] - Options for this field
  */
  exposeInt(name, ...args) {
    const [options = {}] = args;
    return this.exposeField(name, {
      ...options,
      type: "Int"
    });
  }
  /**
  * Create a String field from a string property on the parent object
  * @param {string} name - the name of the property on the source object (does not need to match the field name).
  * @param {object} [options={}] - Options for this field
  */
  exposeString(name, ...args) {
    const [options = {}] = args;
    return this.exposeField(name, {
      ...options,
      type: "String"
    });
  }
  /**
  * Create a Boolean list field from a boolean[] property on the parent object
  * @param {string} name - the name of the property on the source object (does not need to match the field name).
  * @param {object} [options={}] - Options for this field
  */
  exposeBooleanList(name, ...args) {
    const [options = {}] = args;
    return this.exposeField(name, {
      ...options,
      type: [
        "Boolean"
      ]
    });
  }
  /**
  * Create a Float list field from a number[] property on the parent object
  * @param {string} name - the name of the property on the source object (does not need to match the field name).
  * @param {object} [options={}] - Options for this field
  */
  exposeFloatList(name, ...args) {
    const [options = {}] = args;
    return this.exposeField(name, {
      ...options,
      type: [
        "Float"
      ]
    });
  }
  /**
  * Create an ID list field from an id[] property on the parent object
  * @param {string} name - the name of the property on the source object (does not need to match the field name).
  * @param {object} [options={}] - Options for this field
  */
  exposeIDList(name, ...args) {
    const [options = {}] = args;
    return this.exposeField(name, {
      ...options,
      type: [
        "ID"
      ]
    });
  }
  /**
  * Create a Int list field from a number[] property on the parent object
  * @param {string} name - the name of the property on the source object (does not need to match the field name).
  * @param {object} [options={}] - Options for this field
  */
  exposeIntList(name, ...args) {
    const [options = {}] = args;
    return this.exposeField(name, {
      ...options,
      type: [
        "Int"
      ]
    });
  }
  /**
  * Create a String list field from a string[] property on the parent object
  * @param {string} name - the name of the property on the source object (does not need to match the field name).
  * @param {object} [options={}] - Options for this field
  */
  exposeStringList(name, ...args) {
    const [options = {}] = args;
    return this.exposeField(name, {
      ...options,
      type: [
        "String"
      ]
    });
  }
  /**
  * Create a field that resolves to a property of the corresponding type on the parent object
  * @param {string} name - the name of the property on the source object (does not need to match the field name).
  * @param {object} [options={}] - Options for this field
  */
  expose(name, ...args) {
    const [options = {}] = args;
    return this.exposeField(name, options);
  }
};

// node_modules/@pothos/core/esm/fieldUtils/interface.js
var InterfaceFieldBuilder = class extends FieldBuilder {
  constructor(builder) {
    super(builder, "Interface", "Interface");
  }
};

// node_modules/@pothos/core/esm/fieldUtils/mutation.js
var MutationFieldBuilder = class extends RootFieldBuilder {
  constructor(builder) {
    super(builder, "Mutation", "Object");
  }
};

// node_modules/@pothos/core/esm/fieldUtils/object.js
var ObjectFieldBuilder = class extends FieldBuilder {
  constructor(builder) {
    super(builder, "Object", "Object");
  }
};

// node_modules/@pothos/core/esm/fieldUtils/query.js
var QueryFieldBuilder = class extends RootFieldBuilder {
  constructor(builder) {
    super(builder, "Query", "Object");
  }
};

// node_modules/@pothos/core/esm/fieldUtils/subscription.js
var SubscriptionFieldBuilder = class extends RootFieldBuilder {
  constructor(builder) {
    super(builder, "Subscription", "Object");
  }
};

// node_modules/@pothos/core/esm/refs/enum.js
function _define_property21(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
var _outputShapeKey5 = outputShapeKey;
var _inputShapeKey4 = inputShapeKey;
var EnumRef = class extends BaseTypeRef {
  constructor(name, config) {
    super("Enum", name, config), _define_property21(this, "kind", "Enum"), _define_property21(this, "$inferType", void 0), _define_property21(this, "$inferInput", void 0), _define_property21(this, _outputShapeKey5, void 0), _define_property21(this, _inputShapeKey4, void 0);
  }
};

// node_modules/@pothos/core/esm/refs/union.js
function _define_property22(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
var _outputShapeKey6 = outputShapeKey;
var _parentShapeKey5 = parentShapeKey;
var UnionRef = class extends BaseTypeRef {
  addTypes(types) {
    if (Array.isArray(types) && types.length === 0) {
      return;
    }
    if (this.preparedForBuild) {
      this.updateConfig((cfg) => ({
        ...cfg,
        types: [
          ...cfg.types,
          ...typeof types === "function" ? types() : types
        ]
      }));
    } else {
      this.types.push(() => Array.isArray(types) ? types : types());
    }
  }
  prepareForBuild() {
    if (this.preparedForBuild) {
      return;
    }
    super.prepareForBuild();
    if (this.types.length > 0) {
      this.updateConfig((cfg) => ({
        ...cfg,
        types: [
          ...cfg.types,
          ...this.types.flatMap((types) => types())
        ]
      }));
    }
  }
  constructor(name, config) {
    super("Union", name, config), _define_property22(this, "kind", "Union"), _define_property22(this, "$inferType", void 0), _define_property22(this, _outputShapeKey6, void 0), _define_property22(this, _parentShapeKey5, void 0), _define_property22(this, "types", []);
  }
};

// node_modules/@pothos/core/esm/builder.js
function _define_property23(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
var SchemaBuilder = class _SchemaBuilder {
  static registerPlugin(name, plugin, normalizeOptions) {
    if (!_SchemaBuilder.allowPluginReRegistration && _SchemaBuilder.plugins[name]) {
      throw new PothosError(`Received multiple implementations for plugin ${name}`);
    }
    _SchemaBuilder.plugins[name] = plugin;
    if (normalizeOptions) {
      _SchemaBuilder.optionNormalizers.set(name, normalizeOptions);
    }
  }
  objectType(param, options, fields) {
    verifyRef(param);
    verifyInterfaces(options.interfaces);
    var _options_name;
    const name = typeof param === "string" ? param : (_options_name = options.name) !== null && _options_name !== void 0 ? _options_name : param.name;
    const ref = param instanceof BaseTypeRef ? param : new ObjectRef(name);
    ref.updateConfig({
      kind: "Object",
      graphqlKind: "Object",
      name,
      interfaces: [],
      description: options.description,
      extensions: options.extensions,
      isTypeOf: options.isTypeOf,
      pothosOptions: options
    });
    if (options.interfaces) {
      ref.addInterfaces(options.interfaces);
    }
    if (ref !== param && typeof param !== "string") {
      this.configStore.associateParamWithRef(param, ref);
    }
    if (fields) {
      ref.addFields(() => fields(new ObjectFieldBuilder(this)));
    }
    if (options.fields) {
      ref.addFields(() => {
        const t = new ObjectFieldBuilder(this);
        return options.fields(t);
      });
    }
    this.configStore.addTypeRef(ref);
    return ref;
  }
  objectFields(param, fields) {
    verifyRef(param);
    this.configStore.addFields(param, () => fields(new ObjectFieldBuilder(this)));
  }
  objectField(param, fieldName, field) {
    verifyRef(param);
    this.configStore.addFields(param, () => ({
      [fieldName]: field(new ObjectFieldBuilder(this))
    }));
  }
  queryType(...args) {
    const [options = {}, fields] = args;
    var _options_name;
    this.queryRef.updateConfig({
      kind: "Query",
      graphqlKind: "Object",
      name: (_options_name = options.name) !== null && _options_name !== void 0 ? _options_name : "Query",
      description: options.description,
      pothosOptions: options,
      extensions: options.extensions
    });
    if (options.name) {
      this.queryRef.name = options.name;
    }
    this.configStore.addTypeRef(this.queryRef);
    if (fields) {
      this.queryRef.addFields(() => fields(new QueryFieldBuilder(this)));
    }
    if (options.fields) {
      this.queryRef.addFields(() => options.fields(new QueryFieldBuilder(this)));
    }
    return this.queryRef;
  }
  queryFields(fields) {
    this.configStore.addFields(this.queryRef, () => fields(new QueryFieldBuilder(this)));
  }
  queryField(name, field) {
    this.configStore.addFields(this.queryRef, () => ({
      [name]: field(new QueryFieldBuilder(this))
    }));
  }
  mutationType(...args) {
    const [options = {}, fields] = args;
    var _options_name;
    this.mutationRef.updateConfig({
      kind: "Mutation",
      graphqlKind: "Object",
      name: (_options_name = options.name) !== null && _options_name !== void 0 ? _options_name : "Mutation",
      description: options.description,
      pothosOptions: options,
      extensions: options.extensions
    });
    this.configStore.addTypeRef(this.mutationRef);
    if (options.name) {
      this.mutationRef.name = options.name;
    }
    if (fields) {
      this.configStore.addFields(this.mutationRef, () => fields(new MutationFieldBuilder(this)));
    }
    if (options.fields) {
      this.configStore.addFields(this.mutationRef, () => options.fields(new MutationFieldBuilder(this)));
    }
    return this.mutationRef;
  }
  mutationFields(fields) {
    this.configStore.addFields(this.mutationRef, () => fields(new MutationFieldBuilder(this)));
  }
  mutationField(name, field) {
    this.configStore.addFields(this.mutationRef, () => ({
      [name]: field(new MutationFieldBuilder(this))
    }));
  }
  subscriptionType(...args) {
    const [options = {}, fields] = args;
    var _options_name;
    this.subscriptionRef.updateConfig({
      kind: "Subscription",
      graphqlKind: "Object",
      name: (_options_name = options.name) !== null && _options_name !== void 0 ? _options_name : "Subscription",
      description: options.description,
      pothosOptions: options,
      extensions: options.extensions
    });
    this.configStore.addTypeRef(this.subscriptionRef);
    if (options.name) {
      this.subscriptionRef.name = options.name;
    }
    if (fields) {
      this.configStore.addFields(this.subscriptionRef, () => fields(new SubscriptionFieldBuilder(this)));
    }
    if (options.fields) {
      this.configStore.addFields(this.subscriptionRef, () => options.fields(new SubscriptionFieldBuilder(this)));
    }
    return this.subscriptionRef;
  }
  subscriptionFields(fields) {
    this.configStore.addFields(this.subscriptionRef, () => fields(new SubscriptionFieldBuilder(this)));
  }
  subscriptionField(name, field) {
    this.configStore.addFields(this.subscriptionRef, () => ({
      [name]: field(new SubscriptionFieldBuilder(this))
    }));
  }
  args(fields) {
    return fields(new InputFieldBuilder(this, "Arg"));
  }
  interfaceType(param, options, fields) {
    verifyRef(param);
    verifyInterfaces(options.interfaces);
    var _options_name;
    const name = typeof param === "string" ? param : (_options_name = options.name) !== null && _options_name !== void 0 ? _options_name : param.name;
    const ref = param instanceof BaseTypeRef ? param : new InterfaceRef(name);
    const typename = ref.name;
    ref.updateConfig({
      kind: "Interface",
      graphqlKind: "Interface",
      name: typename,
      interfaces: [],
      description: options.description,
      pothosOptions: options,
      extensions: options.extensions,
      resolveType: options.resolveType
    });
    this.configStore.addTypeRef(ref);
    if (options.interfaces) {
      ref.addInterfaces(options.interfaces);
    }
    if (ref !== param && typeof param !== "string") {
      this.configStore.associateParamWithRef(param, ref);
    }
    if (fields) {
      this.configStore.addFields(ref, () => fields(new InterfaceFieldBuilder(this)));
    }
    if (options.fields) {
      this.configStore.addFields(ref, () => options.fields(new InterfaceFieldBuilder(this)));
    }
    return ref;
  }
  interfaceFields(ref, fields) {
    verifyRef(ref);
    this.configStore.addFields(ref, () => fields(new InterfaceFieldBuilder(this)));
  }
  interfaceField(ref, fieldName, field) {
    verifyRef(ref);
    this.configStore.addFields(ref, () => ({
      [fieldName]: field(new InterfaceFieldBuilder(this))
    }));
  }
  unionType(name, options) {
    const ref = new UnionRef(name, {
      kind: "Union",
      graphqlKind: "Union",
      name,
      types: [],
      description: options.description,
      resolveType: options.resolveType,
      pothosOptions: options,
      extensions: options.extensions
    });
    if (Array.isArray(options.types)) {
      for (const type of options.types) {
        verifyRef(type);
      }
    }
    this.configStore.addTypeRef(ref);
    ref.addTypes(options.types);
    return ref;
  }
  enumType(param, options) {
    verifyRef(param);
    const name = typeof param === "string" ? param : options.name;
    const values = typeof param === "object" ? valuesFromEnum(param, options === null || options === void 0 ? void 0 : options.values) : normalizeEnumValues(options.values);
    const ref = new EnumRef(name, {
      kind: "Enum",
      graphqlKind: "Enum",
      name,
      values,
      description: options.description,
      pothosOptions: options,
      extensions: options.extensions
    });
    this.configStore.addTypeRef(ref);
    if (typeof param !== "string") {
      this.configStore.associateParamWithRef(param, ref);
    }
    return ref;
  }
  scalarType(name, options) {
    const ref = new ScalarRef(name, {
      kind: "Scalar",
      graphqlKind: "Scalar",
      name,
      description: options.description,
      parseLiteral: options.parseLiteral,
      parseValue: options.parseValue,
      serialize: options.serialize,
      pothosOptions: options,
      extensions: options.extensions
    });
    this.configStore.addTypeRef(ref);
    return ref;
  }
  addScalarType(name, scalar, ...args) {
    const [options = {}] = args;
    const config = scalar.toConfig();
    return this.scalarType(name, {
      ...config,
      ...options,
      extensions: {
        ...config.extensions,
        ...options.extensions
      }
    });
  }
  inputType(param, options) {
    verifyRef(param);
    const name = typeof param === "string" ? param : param.name;
    const ref = typeof param === "string" ? new InputObjectRef(name) : param;
    ref.updateConfig({
      kind: "InputObject",
      graphqlKind: "InputObject",
      name,
      isOneOf: options.isOneOf,
      description: options.description,
      pothosOptions: options,
      extensions: options.extensions
    });
    this.configStore.addTypeRef(ref);
    if (param !== ref && typeof param !== "string") {
      this.configStore.associateParamWithRef(param, ref);
    }
    this.configStore.addInputFields(ref, () => options.fields(new InputFieldBuilder(this, "InputObject")));
    return ref;
  }
  inputRef(name) {
    return new ImplementableInputObjectRef(this, name);
  }
  objectRef(name) {
    return new ImplementableObjectRef(this, name);
  }
  interfaceRef(name) {
    return new ImplementableInterfaceRef(this, name);
  }
  toSchema(...args) {
    const [options = {}] = args;
    const { directives, extensions } = options;
    const scalars = [
      GraphQLID,
      GraphQLInt,
      GraphQLFloat,
      GraphQLString,
      GraphQLBoolean
    ];
    for (const scalar of scalars) {
      if (!this.configStore.hasImplementation(scalar.name)) {
        this.addScalarType(scalar.name, scalar);
      }
    }
    const buildCache = new BuildCache(this, options);
    buildCache.plugin.beforeBuild();
    buildCache.buildAll();
    const builtTypes = [
      ...buildCache.types.values()
    ];
    const queryName = this.configStore.hasConfig(this.queryRef) ? this.configStore.getTypeConfig(this.queryRef).name : "Query";
    const mutationName = this.configStore.hasConfig(this.mutationRef) ? this.configStore.getTypeConfig(this.mutationRef).name : "Mutation";
    const subscriptionName = this.configStore.hasConfig(this.subscriptionRef) ? this.configStore.getTypeConfig(this.subscriptionRef).name : "Subscription";
    const schema = new GraphQLSchema({
      query: buildCache.types.get(queryName),
      mutation: buildCache.types.get(mutationName),
      subscription: buildCache.types.get(subscriptionName),
      extensions: extensions !== null && extensions !== void 0 ? extensions : {},
      directives,
      types: builtTypes
    });
    const processedSchema = buildCache.plugin.afterBuild(schema);
    return options.sortSchema === false ? processedSchema : lexicographicSortSchema(processedSchema);
  }
  constructor(options) {
    _define_property23(this, "$inferSchemaTypes", void 0);
    _define_property23(this, "queryRef", new QueryRef("Query"));
    _define_property23(this, "mutationRef", new MutationRef("Mutation"));
    _define_property23(this, "subscriptionRef", new SubscriptionRef("Subscription"));
    _define_property23(this, "configStore", void 0);
    _define_property23(this, "options", void 0);
    _define_property23(this, "defaultFieldNullability", void 0);
    _define_property23(this, "defaultInputFieldRequiredness", void 0);
    this.options = [
      ..._SchemaBuilder.optionNormalizers.values()
    ].reduce((opts, normalize) => {
      if (options.defaults && typeof normalize[options.defaults] === "function") {
        return Object.assign(opts, normalize[options.defaults](opts));
      }
      return opts;
    }, options);
    this.configStore = new ConfigStore(this);
    var _options_defaultFieldNullability;
    this.defaultFieldNullability = (_options_defaultFieldNullability = options.defaultFieldNullability) !== null && _options_defaultFieldNullability !== void 0 ? _options_defaultFieldNullability : options.defaults !== "v3";
    var _options_defaultInputFieldRequiredness;
    this.defaultInputFieldRequiredness = (_options_defaultInputFieldRequiredness = options.defaultInputFieldRequiredness) !== null && _options_defaultInputFieldRequiredness !== void 0 ? _options_defaultInputFieldRequiredness : false;
  }
};
_define_property23(SchemaBuilder, "plugins", {});
_define_property23(SchemaBuilder, "optionNormalizers", /* @__PURE__ */ new Map());
_define_property23(SchemaBuilder, "allowPluginReRegistration", false);

// node_modules/@pothos/core/esm/refs/input.js
function _define_property24(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
var _inputShapeKey5 = inputShapeKey;
var InputTypeRef = class extends BaseTypeRef {
  constructor(kind, name) {
    super(kind, name), _define_property24(this, "kind", void 0), _define_property24(this, "$inferInput", void 0), _define_property24(this, _inputShapeKey5, void 0);
    this.kind = kind;
  }
};

// node_modules/@pothos/core/esm/refs/output.js
function _define_property25(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
var _outputShapeKey7 = outputShapeKey;
var _parentShapeKey6 = parentShapeKey;
var OutputTypeRef = class extends BaseTypeRef {
  constructor(kind, name) {
    super(kind, name), _define_property25(this, "kind", void 0), _define_property25(this, "$inferType", void 0), _define_property25(this, _outputShapeKey7, void 0), _define_property25(this, _parentShapeKey6, void 0);
    this.kind = kind;
  }
};

// node_modules/@pothos/core/esm/index.js
var SchemaBuilder2 = SchemaBuilder;
var esm_default = SchemaBuilder2;
var FieldBuilder2 = FieldBuilder;
var RootFieldBuilder2 = RootFieldBuilder;
var QueryFieldBuilder2 = QueryFieldBuilder;
var MutationFieldBuilder2 = MutationFieldBuilder;
var SubscriptionFieldBuilder2 = SubscriptionFieldBuilder;
var ObjectFieldBuilder2 = ObjectFieldBuilder;
var InterfaceFieldBuilder2 = InterfaceFieldBuilder;
var InputFieldBuilder2 = InputFieldBuilder;
var BaseTypeRef2 = BaseTypeRef;
var EnumRef2 = EnumRef;
var InputObjectRef2 = InputObjectRef;
var InputListRef2 = InputListRef;
var InterfaceRef2 = InterfaceRef;
var ObjectRef2 = ObjectRef;
var ScalarRef2 = ScalarRef;
var UnionRef2 = UnionRef;
var ListRef2 = ListRef;
export {
  ArgumentRef,
  BasePlugin,
  BaseTypeRef2 as BaseTypeRef,
  BuildCache,
  BuiltinScalarRef,
  EnumRef2 as EnumRef,
  FieldBuilder2 as FieldBuilder,
  FieldRef,
  ImplementableInputObjectRef,
  ImplementableInterfaceRef,
  ImplementableObjectRef,
  InputFieldBuilder2 as InputFieldBuilder,
  InputFieldRef,
  InputListRef2 as InputListRef,
  InputObjectRef2 as InputObjectRef,
  InputTypeRef,
  InterfaceFieldBuilder2 as InterfaceFieldBuilder,
  InterfaceRef2 as InterfaceRef,
  ListRef2 as ListRef,
  MergedPlugins,
  MutationFieldBuilder2 as MutationFieldBuilder,
  MutationRef,
  ObjectFieldBuilder2 as ObjectFieldBuilder,
  ObjectRef2 as ObjectRef,
  OutputTypeRef,
  PothosError,
  PothosSchemaError,
  PothosValidationError,
  QueryFieldBuilder2 as QueryFieldBuilder,
  QueryRef,
  RootFieldBuilder2 as RootFieldBuilder,
  ScalarRef2 as ScalarRef,
  SubscriptionFieldBuilder2 as SubscriptionFieldBuilder,
  SubscriptionRef,
  UnionRef2 as UnionRef,
  abstractReturnShapeKey,
  assertArray,
  assertNever,
  brandWithType,
  classDepth,
  completeValue,
  contextCacheSymbol,
  createContextCache,
  createInputValueMapper,
  decodeBase64,
  esm_default as default,
  encodeBase64,
  getMappedArgumentValues,
  getTypeBrand,
  initContextCache,
  inputFieldShapeKey,
  inputShapeKey,
  inputTypeFromParam,
  isThenable,
  mapInputFields,
  normalizeEnumValues,
  outputFieldShapeKey,
  outputShapeKey,
  parentShapeKey,
  resolveInputTypeConfig,
  sortClasses,
  typeBrandKey,
  typeFromParam,
  unwrapInputFieldType,
  unwrapInputListParam,
  unwrapListParam,
  unwrapOutputFieldType,
  unwrapOutputListParam,
  valuesFromEnum,
  verifyInterfaces,
  verifyRef
};
//# sourceMappingURL=zudoku___@pothos_core.js.map
