// node_modules/@whatwg-node/promise-helpers/esm/index.js
var kFakePromise = Symbol.for("@whatwg-node/promise-helpers/FakePromise");
function isPromise(value) {
  return value?.then != null;
}
function isActualPromise(value) {
  const maybePromise = value;
  return maybePromise && maybePromise.then && maybePromise.catch && maybePromise.finally;
}
function handleMaybePromise(inputFactory, outputSuccessFactory, outputErrorFactory, finallyFactory) {
  let result$ = fakePromise().then(inputFactory).then(outputSuccessFactory, outputErrorFactory);
  if (finallyFactory) {
    result$ = result$.finally(finallyFactory);
  }
  return unfakePromise(result$);
}
function fakePromise(value) {
  if (value && isActualPromise(value)) {
    return value;
  }
  if (isPromise(value)) {
    return {
      then: (resolve, reject) => fakePromise(value.then(resolve, reject)),
      catch: (reject) => fakePromise(value.then((res) => res, reject)),
      finally: (cb) => fakePromise(cb ? promiseLikeFinally(value, cb) : value),
      [Symbol.toStringTag]: "Promise"
    };
  }
  return {
    then(resolve) {
      if (resolve) {
        try {
          return fakePromise(resolve(value));
        } catch (err) {
          return fakeRejectPromise(err);
        }
      }
      return this;
    },
    catch() {
      return this;
    },
    finally(cb) {
      if (cb) {
        try {
          return fakePromise(cb()).then(() => value, () => value);
        } catch (err) {
          return fakeRejectPromise(err);
        }
      }
      return this;
    },
    [Symbol.toStringTag]: "Promise",
    __fakePromiseValue: value,
    [kFakePromise]: "resolved"
  };
}
function createDeferredPromise() {
  if (Promise.withResolvers) {
    return Promise.withResolvers();
  }
  let resolveFn;
  let rejectFn;
  const promise = new Promise(function deferredPromiseExecutor(resolve, reject) {
    resolveFn = resolve;
    rejectFn = reject;
  });
  return {
    promise,
    get resolve() {
      return resolveFn;
    },
    get reject() {
      return rejectFn;
    }
  };
}
function iterateAsync(iterable, callback, results) {
  if (iterable?.length === 0) {
    return;
  }
  const iterator = iterable[Symbol.iterator]();
  let index = 0;
  function iterate() {
    const { done: endOfIterator, value } = iterator.next();
    if (endOfIterator) {
      return;
    }
    let endedEarly = false;
    function endEarly() {
      endedEarly = true;
    }
    return handleMaybePromise(function handleCallback() {
      return callback(value, endEarly, index++);
    }, function handleCallbackResult(result) {
      if (result) {
        results?.push(result);
      }
      if (endedEarly) {
        return;
      }
      return iterate();
    });
  }
  return iterate();
}
function fakeRejectPromise(error) {
  return {
    then(_resolve, reject) {
      if (reject) {
        try {
          return fakePromise(reject(error));
        } catch (err) {
          return fakeRejectPromise(err);
        }
      }
      return this;
    },
    catch(reject) {
      if (reject) {
        try {
          return fakePromise(reject(error));
        } catch (err) {
          return fakeRejectPromise(err);
        }
      }
      return this;
    },
    finally(cb) {
      if (cb) {
        try {
          cb();
        } catch (err) {
          return fakeRejectPromise(err);
        }
      }
      return this;
    },
    __fakeRejectError: error,
    [Symbol.toStringTag]: "Promise",
    [kFakePromise]: "rejected"
  };
}
function mapMaybePromise(input, onSuccess, onError) {
  return handleMaybePromise(() => input, onSuccess, onError);
}
function mapAsyncIterator(iterator, onNext, onError, onEnd) {
  if (Symbol.asyncIterator in iterator) {
    iterator = iterator[Symbol.asyncIterator]();
  }
  let $return;
  let abruptClose;
  let onEndWithValue;
  if (onEnd) {
    let onEndWithValueResult;
    onEndWithValue = (value) => {
      onEndWithValueResult ||= handleMaybePromise(onEnd, () => value, () => value);
      return onEndWithValueResult;
    };
  }
  if (typeof iterator.return === "function") {
    $return = iterator.return;
    abruptClose = (error) => {
      const rethrow = () => {
        throw error;
      };
      return $return.call(iterator).then(rethrow, rethrow);
    };
  }
  function mapResult(result) {
    if (result.done) {
      return onEndWithValue ? onEndWithValue(result) : result;
    }
    return handleMaybePromise(() => result.value, (value) => handleMaybePromise(() => onNext(value), iteratorResult, abruptClose));
  }
  let mapReject;
  if (onError) {
    let onErrorResult;
    const reject = onError;
    mapReject = (error) => {
      onErrorResult ||= handleMaybePromise(() => error, (error2) => handleMaybePromise(() => reject(error2), iteratorResult, abruptClose));
      return onErrorResult;
    };
  }
  return {
    next() {
      return iterator.next().then(mapResult, mapReject);
    },
    return() {
      const res$ = $return ? $return.call(iterator).then(mapResult, mapReject) : fakePromise({ value: void 0, done: true });
      return onEndWithValue ? res$.then(onEndWithValue) : res$;
    },
    throw(error) {
      if (typeof iterator.throw === "function") {
        return iterator.throw(error).then(mapResult, mapReject);
      }
      if (abruptClose) {
        return abruptClose(error);
      }
      return fakeRejectPromise(error);
    },
    [Symbol.asyncIterator]() {
      return this;
    }
  };
}
function iteratorResult(value) {
  return { value, done: false };
}
function isFakePromise(value) {
  return value?.[kFakePromise] === "resolved";
}
function isFakeRejectPromise(value) {
  return value?.[kFakePromise] === "rejected";
}
function promiseLikeFinally(value, onFinally) {
  if ("finally" in value) {
    return value.finally(onFinally);
  }
  return value.then((res) => {
    const finallyRes = onFinally();
    return isPromise(finallyRes) ? finallyRes.then(() => res) : res;
  }, (err) => {
    const finallyRes = onFinally();
    if (isPromise(finallyRes)) {
      return finallyRes.then(() => {
        throw err;
      });
    } else {
      throw err;
    }
  });
}
function unfakePromise(promise) {
  if (isFakePromise(promise)) {
    return promise.__fakePromiseValue;
  }
  if (isFakeRejectPromise(promise)) {
    throw promise.__fakeRejectError;
  }
  return promise;
}

// node_modules/@envelop/instrumentation/esm/instrumentation.js
function chain(first, next) {
  const merged = { ...next, ...first };
  for (const key of Object.keys(merged)) {
    if (key in first && key in next) {
      merged[key] = (payload, wrapped) => first[key](payload, () => next[key](payload, wrapped));
    }
  }
  return merged;
}
function composeInstrumentation(instrumentation) {
  return instrumentation.length > 0 ? instrumentation.reduce(chain) : void 0;
}
function getInstrumentationAndPlugin(plugins) {
  const pluginInstrumentation = [];
  const newPlugins = [];
  for (const { instrumentation, ...plugin } of plugins) {
    if (instrumentation) {
      pluginInstrumentation.push(instrumentation);
    }
    newPlugins.push(plugin);
  }
  return { pluginInstrumentation, plugins: newPlugins };
}
var getInstrumented = (payload) => ({
  /**
   * Wraps the `wrapped` function with the given `instrument` wrapper.
   * @returns The wrapped function, or `undefined` if the instrument is `undefined`.
   */
  fn(instrument, wrapped) {
    if (!instrument) {
      return wrapped;
    }
    return (...args) => {
      let result;
      instrument(payload, () => {
        result = wrapped(...args);
      });
      return result;
    };
  },
  /**
   * Wraps the `wrapped` function with the given `instrument` wrapper.
   * @returns The wrapped function, or `undefined` if the instrument is `undefined`.
   */
  asyncFn(instrument, wrapped) {
    if (!instrument) {
      return wrapped;
    }
    return (...args) => {
      let result;
      return handleMaybePromise(() => instrument(payload, () => {
        result = wrapped(...args);
        return isPromise(result) ? result.then(() => void 0) : void 0;
      }), () => {
        return result;
      });
    };
  }
});

// node_modules/@envelop/core/esm/document-string-map.js
var documentStringMap = /* @__PURE__ */ new WeakMap();
function getDocumentString(document, print) {
  let documentSource = documentStringMap.get(document);
  if (!documentSource && print) {
    documentSource = print(document);
    documentStringMap.set(document, documentSource);
  }
  return documentSource;
}

// node_modules/@envelop/core/esm/utils.js
var envelopIsIntrospectionSymbol = Symbol("ENVELOP_IS_INTROSPECTION");
function isIntrospectionOperationString(operation) {
  return (typeof operation === "string" ? operation : operation.body).indexOf("__schema") !== -1;
}
function getSubscribeArgs(args) {
  return args.length === 1 ? args[0] : {
    schema: args[0],
    document: args[1],
    rootValue: args[2],
    contextValue: args[3],
    variableValues: args[4],
    operationName: args[5],
    fieldResolver: args[6],
    subscribeFieldResolver: args[7]
  };
}
var makeSubscribe = (subscribeFn) => ((...polyArgs) => subscribeFn(getSubscribeArgs(polyArgs)));
function getExecuteArgs(args) {
  return args.length === 1 ? args[0] : {
    schema: args[0],
    document: args[1],
    rootValue: args[2],
    contextValue: args[3],
    variableValues: args[4],
    operationName: args[5],
    fieldResolver: args[6],
    typeResolver: args[7]
  };
}
var makeExecute = (executeFn) => ((...polyArgs) => executeFn(getExecuteArgs(polyArgs)));
function isAsyncIterable(maybeAsyncIterable) {
  return typeof maybeAsyncIterable === "object" && maybeAsyncIterable != null && typeof maybeAsyncIterable[Symbol.asyncIterator] === "function";
}
function handleStreamOrSingleExecutionResult(payload, fn) {
  if (isAsyncIterable(payload.result)) {
    return { onNext: fn };
  }
  fn({
    args: payload.args,
    result: payload.result,
    setResult: payload.setResult
  });
  return void 0;
}
function finalAsyncIterator(source, onFinal) {
  const iterator = source[Symbol.asyncIterator]();
  let isDone = false;
  const stream = {
    [Symbol.asyncIterator]() {
      return stream;
    },
    next() {
      return iterator.next().then((result) => {
        if (result.done && isDone === false) {
          isDone = true;
          onFinal();
        }
        return result;
      });
    },
    return() {
      const promise = iterator.return?.();
      if (isDone === false) {
        isDone = true;
        onFinal();
      }
      return promise || fakePromise({ done: true, value: void 0 });
    },
    throw(error) {
      const promise = iterator.throw?.();
      if (promise) {
        return promise;
      }
      throw error;
    }
  };
  return stream;
}
function errorAsyncIterator(source, onError) {
  const iterator = source[Symbol.asyncIterator]();
  const stream = {
    [Symbol.asyncIterator]() {
      return stream;
    },
    next() {
      return iterator.next().catch((error) => {
        onError(error);
        return { done: true, value: void 0 };
      });
    },
    return() {
      const promise = iterator.return?.();
      return promise || fakePromise({ done: true, value: void 0 });
    },
    throw(error) {
      const promise = iterator.throw?.();
      if (promise) {
        return promise;
      }
      throw error;
    }
  };
  return stream;
}

// node_modules/@envelop/core/esm/orchestrator.js
function throwEngineFunctionError(name) {
  throw Error(`No \`${name}\` function found! Register it using "useEngine" plugin.`);
}
function createEnvelopOrchestrator({ plugins }) {
  let schema = null;
  let initDone = false;
  const parse = () => throwEngineFunctionError("parse");
  const validate = () => throwEngineFunctionError("validate");
  const execute = () => throwEngineFunctionError("execute");
  const subscribe = () => throwEngineFunctionError("subscribe");
  let instrumentation;
  const replaceSchema = (newSchema, ignorePluginIndex = -1) => {
    if (schema === newSchema) {
      return;
    }
    schema = newSchema;
    if (initDone) {
      for (const [i, plugin] of plugins.entries()) {
        if (i !== ignorePluginIndex) {
          plugin.onSchemaChange && plugin.onSchemaChange({
            schema,
            replaceSchema: (schemaToSet) => {
              replaceSchema(schemaToSet, i);
            }
          });
        }
      }
    }
  };
  const contextErrorHandlers = [];
  for (let i = 0; i < plugins.length; i++) {
    const plugin = plugins[i];
    const pluginsToAdd = [];
    plugin.onPluginInit?.({
      plugins,
      addPlugin: (newPlugin) => {
        pluginsToAdd.push(newPlugin);
      },
      setSchema: (modifiedSchema) => replaceSchema(modifiedSchema, i),
      registerContextErrorHandler: (handler) => contextErrorHandlers.push(handler)
    });
    pluginsToAdd.length && plugins.splice(i + 1, 0, ...pluginsToAdd);
  }
  const beforeCallbacks = {
    init: [],
    parse: [],
    validate: [],
    subscribe: [],
    execute: [],
    context: []
  };
  for (const { onContextBuilding, onExecute, onParse, onSubscribe, onValidate, onEnveloped, instrumentation: pluginInstrumentation } of plugins) {
    onEnveloped && beforeCallbacks.init.push(onEnveloped);
    onContextBuilding && beforeCallbacks.context.push(onContextBuilding);
    onExecute && beforeCallbacks.execute.push(onExecute);
    onParse && beforeCallbacks.parse.push(onParse);
    onSubscribe && beforeCallbacks.subscribe.push(onSubscribe);
    onValidate && beforeCallbacks.validate.push(onValidate);
    if (pluginInstrumentation) {
      instrumentation = instrumentation ? chain(instrumentation, pluginInstrumentation) : pluginInstrumentation;
    }
  }
  const init = (initialContext) => {
    for (const [i, onEnveloped] of beforeCallbacks.init.entries()) {
      onEnveloped({
        context: initialContext,
        extendContext: (extension) => {
          if (!initialContext) {
            return;
          }
          Object.assign(initialContext, extension);
        },
        setSchema: (modifiedSchema) => replaceSchema(modifiedSchema, i)
      });
    }
  };
  const customParse = beforeCallbacks.parse.length ? (initialContext) => (source, parseOptions) => {
    let result = null;
    let parseFn = parse;
    const context = initialContext;
    const afterCalls = [];
    for (const onParse of beforeCallbacks.parse) {
      const afterFn = onParse({
        context,
        extendContext: (extension) => {
          Object.assign(context, extension);
        },
        params: { source, options: parseOptions },
        parseFn,
        setParseFn: (newFn) => {
          parseFn = newFn;
        },
        setParsedDocument: (newDoc) => {
          result = newDoc;
        }
      });
      if (afterFn) {
        afterCalls.push(afterFn);
      }
    }
    if (result === null) {
      try {
        result = parseFn(source, parseOptions);
      } catch (e) {
        result = e;
      }
    }
    for (const afterCb of afterCalls) {
      afterCb({
        context,
        extendContext: (extension) => {
          Object.assign(context, extension);
        },
        replaceParseResult: (newResult) => {
          result = newResult;
        },
        result
      });
    }
    if (result === null) {
      throw new Error(`Failed to parse document.`);
    }
    if (result instanceof Error) {
      throw result;
    }
    documentStringMap.set(result, source.toString());
    return result;
  } : () => parse;
  const customValidate = beforeCallbacks.validate.length ? (initialContext) => (schema2, documentAST, rules, typeInfo, validationOptions) => {
    let actualRules = rules ? [...rules] : void 0;
    let validateFn = validate;
    let result = null;
    const context = initialContext;
    const afterCalls = [];
    for (const onValidate of beforeCallbacks.validate) {
      const afterFn = onValidate({
        context,
        extendContext: (extension) => {
          Object.assign(context, extension);
        },
        params: {
          schema: schema2,
          documentAST,
          rules: actualRules,
          typeInfo,
          options: validationOptions
        },
        validateFn,
        addValidationRule: (rule) => {
          if (!actualRules) {
            actualRules = [];
          }
          actualRules.push(rule);
        },
        setValidationFn: (newFn) => {
          validateFn = newFn;
        },
        setResult: (newResults) => {
          result = newResults;
        }
      });
      afterFn && afterCalls.push(afterFn);
    }
    if (!result) {
      result = validateFn(schema2, documentAST, actualRules, typeInfo, validationOptions);
    }
    if (!result) {
      return;
    }
    const valid = result.length === 0;
    for (const afterCb of afterCalls) {
      afterCb({
        valid,
        result,
        context,
        extendContext: (extension) => {
          Object.assign(context, extension);
        },
        setResult: (newResult) => {
          result = newResult;
        }
      });
    }
    return result;
  } : () => validate;
  const customContextFactory = beforeCallbacks.context.length ? (initialContext) => (orchestratorCtx) => {
    const afterCalls = [];
    const context = initialContext;
    if (orchestratorCtx) {
      Object.assign(context, orchestratorCtx);
    }
    let isBreakingContextBuilding = false;
    return handleMaybePromise(() => iterateAsync(beforeCallbacks.context, (onContext, stopEarly) => onContext({
      context,
      extendContext: (extension) => {
        Object.assign(context, extension);
      },
      breakContextBuilding: () => {
        isBreakingContextBuilding = true;
        stopEarly();
      }
    }), afterCalls), () => {
      if (!isBreakingContextBuilding) {
        return handleMaybePromise(() => iterateAsync(afterCalls, (afterCb) => afterCb({
          context,
          extendContext(extension) {
            Object.assign(context, extension);
          }
        })), () => context);
      }
      return context;
    }, (err) => {
      let error = err;
      for (const errorCb of contextErrorHandlers) {
        errorCb({
          context,
          error,
          setError: (err2) => {
            error = err2;
          }
        });
      }
      throw error;
    });
  } : (initialContext) => (orchestratorCtx) => {
    if (orchestratorCtx) {
      Object.assign(initialContext, orchestratorCtx);
    }
    return initialContext;
  };
  const useCustomSubscribe = beforeCallbacks.subscribe.length;
  const customSubscribe = useCustomSubscribe ? makeSubscribe((args) => {
    let subscribeFn = subscribe;
    const afterCallbacks = [];
    const context = args.contextValue || {};
    let result;
    return handleMaybePromise(() => iterateAsync(beforeCallbacks.subscribe, (onSubscribe, endEarly) => onSubscribe({
      subscribeFn,
      setSubscribeFn: (newSubscribeFn) => {
        subscribeFn = newSubscribeFn;
      },
      context,
      extendContext: (extension) => {
        Object.assign(context, extension);
      },
      args,
      setResultAndStopExecution: (stopResult) => {
        result = stopResult;
        endEarly();
      }
    }), afterCallbacks), () => {
      const afterCalls = [];
      const subscribeErrorHandlers = [];
      for (const { onSubscribeResult, onSubscribeError } of afterCallbacks) {
        if (onSubscribeResult) {
          afterCalls.push(onSubscribeResult);
        }
        if (onSubscribeError) {
          subscribeErrorHandlers.push(onSubscribeError);
        }
      }
      return handleMaybePromise(() => result || subscribeFn(args), (result2) => {
        const onNextHandler = [];
        const onEndHandler = [];
        for (const afterCb of afterCalls) {
          const hookResult = afterCb({
            args,
            result: result2,
            setResult: (newResult) => {
              result2 = newResult;
            }
          });
          if (hookResult) {
            if (hookResult.onNext) {
              onNextHandler.push(hookResult.onNext);
            }
            if (hookResult.onEnd) {
              onEndHandler.push(hookResult.onEnd);
            }
          }
        }
        if (onNextHandler.length && isAsyncIterable(result2)) {
          result2 = mapAsyncIterator(result2, (result3) => handleMaybePromise(() => iterateAsync(onNextHandler, (onNext) => onNext({
            args,
            result: result3,
            setResult: (newResult) => result3 = newResult
          })), () => result3));
        }
        if (onEndHandler.length && isAsyncIterable(result2)) {
          result2 = finalAsyncIterator(result2, () => {
            for (const onEnd of onEndHandler) {
              onEnd();
            }
          });
        }
        if (subscribeErrorHandlers.length && isAsyncIterable(result2)) {
          result2 = errorAsyncIterator(result2, (err) => {
            let error = err;
            for (const handler of subscribeErrorHandlers) {
              handler({
                error,
                setError: (err2) => {
                  error = err2;
                }
              });
            }
            throw error;
          });
        }
        return result2;
      });
    });
  }) : makeSubscribe(subscribe);
  const useCustomExecute = beforeCallbacks.execute.length;
  const customExecute = useCustomExecute ? makeExecute((args) => {
    let executeFn = execute;
    let result;
    const afterCalls = [];
    const afterDoneCalls = [];
    const context = args.contextValue || {};
    return handleMaybePromise(() => iterateAsync(beforeCallbacks.execute, (onExecute, endEarly) => onExecute({
      executeFn,
      setExecuteFn: (newExecuteFn) => {
        executeFn = newExecuteFn;
      },
      setResultAndStopExecution: (stopResult) => {
        result = stopResult;
        endEarly();
      },
      context,
      extendContext: (extension) => {
        if (typeof extension === "object") {
          Object.assign(context, extension);
        } else {
          throw new Error(`Invalid context extension provided! Expected "object", got: "${JSON.stringify(extension)}" (${typeof extension})`);
        }
      },
      args
    }), afterCalls), () => handleMaybePromise(() => result || executeFn({
      ...args,
      contextValue: context
    }), (result2) => handleMaybePromise(() => iterateAsync(afterCalls, (afterCb) => afterCb.onExecuteDone?.({
      args,
      result: result2,
      setResult: (newResult) => {
        result2 = newResult;
      }
    }), afterDoneCalls), () => {
      const onNextHandler = [];
      const onEndHandler = [];
      for (const { onNext, onEnd } of afterDoneCalls) {
        if (onNext) {
          onNextHandler.push(onNext);
        }
        if (onEnd) {
          onEndHandler.push(onEnd);
        }
      }
      if (onNextHandler.length && isAsyncIterable(result2)) {
        result2 = mapAsyncIterator(result2, (result3) => handleMaybePromise(() => iterateAsync(onNextHandler, (onNext) => onNext({
          args,
          result: result3,
          setResult: (newResult) => {
            result3 = newResult;
          }
        })), () => result3));
      }
      if (onEndHandler.length && isAsyncIterable(result2)) {
        result2 = finalAsyncIterator(result2, () => {
          for (const onEnd of onEndHandler) {
            onEnd();
          }
        });
      }
      return result2;
    })));
  }) : makeExecute(execute);
  initDone = true;
  if (schema) {
    for (const [i, plugin] of plugins.entries()) {
      plugin.onSchemaChange?.({
        schema,
        replaceSchema: (modifiedSchema) => replaceSchema(modifiedSchema, i)
      });
    }
  }
  return {
    getCurrentSchema() {
      return schema;
    },
    init,
    parse: customParse,
    validate: customValidate,
    execute: customExecute,
    subscribe: customSubscribe,
    contextFactory: customContextFactory,
    instrumentation
  };
}

// node_modules/@envelop/core/esm/create.js
function notEmpty(value) {
  return value != null;
}
function envelop(options) {
  const plugins = options.plugins.filter(notEmpty);
  const orchestrator = createEnvelopOrchestrator({
    plugins
  });
  const instrumentation = orchestrator.instrumentation;
  const getEnveloped = (context = {}) => {
    const instrumented = getInstrumented({ context });
    const typedOrchestrator = orchestrator;
    instrumented.fn(instrumentation?.init, orchestrator.init)(context);
    return {
      parse: instrumented.fn(instrumentation?.parse, typedOrchestrator.parse(context)),
      validate: instrumented.fn(instrumentation?.validate, typedOrchestrator.validate(context)),
      contextFactory: instrumented.fn(instrumentation?.context, typedOrchestrator.contextFactory(context)),
      execute: instrumented.asyncFn(instrumentation?.execute, typedOrchestrator.execute),
      subscribe: instrumented.asyncFn(instrumentation?.subscribe, typedOrchestrator.subscribe),
      schema: typedOrchestrator.getCurrentSchema()
    };
  };
  getEnveloped._plugins = plugins;
  return getEnveloped;
}

// node_modules/@envelop/core/esm/plugins/use-envelop.js
var useEnvelop = (envelop2) => {
  let initialized = false;
  return {
    onPluginInit({ addPlugin }) {
      if (initialized) {
        return;
      }
      for (const plugin of envelop2._plugins) {
        addPlugin(plugin);
      }
      initialized = true;
    }
  };
};

// node_modules/@envelop/core/esm/plugins/use-logger.js
var DEFAULT_OPTIONS = {
  logFn: console.log
};
var useLogger = (rawOptions = DEFAULT_OPTIONS) => {
  const options = {
    DEFAULT_OPTIONS,
    ...rawOptions
  };
  return {
    onParse({ extendContext, params }) {
      if (options.skipIntrospection && isIntrospectionOperationString(params.source)) {
        extendContext({
          [envelopIsIntrospectionSymbol]: true
        });
      }
    },
    onExecute({ args }) {
      if (args.contextValue[envelopIsIntrospectionSymbol]) {
        return;
      }
      options.logFn("execute-start", { args });
      return {
        onExecuteDone: ({ result }) => {
          options.logFn("execute-end", { args, result });
        }
      };
    },
    onSubscribe({ args }) {
      if (args.contextValue[envelopIsIntrospectionSymbol]) {
        return;
      }
      options.logFn("subscribe-start", { args });
      return {
        onSubscribeResult: ({ result }) => {
          options.logFn("subscribe-end", { args, result });
        }
      };
    }
  };
};

// node_modules/@envelop/core/esm/plugins/use-schema.js
var useSchema = (schema) => {
  return {
    onPluginInit({ setSchema }) {
      setSchema(schema);
    }
  };
};
var useSchemaByContext = (schemaLoader) => {
  return {
    onEnveloped({ setSchema, context }) {
      setSchema(schemaLoader(context));
    }
  };
};

// node_modules/@envelop/core/esm/plugins/use-masked-errors.js
var DEFAULT_ERROR_MESSAGE = "Unexpected error.";
function isGraphQLError(error) {
  return error instanceof Error && error.name === "GraphQLError";
}
function isOriginalGraphQLError(error) {
  if (isGraphQLError(error)) {
    if (error.originalError != null) {
      return isOriginalGraphQLError(error.originalError);
    }
    return true;
  }
  return false;
}
function createSerializableGraphQLError(message, originalError, isDev2) {
  const error = new Error(message);
  error.name = "GraphQLError";
  if (isDev2) {
    const extensions = originalError instanceof Error ? { message: originalError.message, stack: originalError.stack } : { message: String(originalError) };
    Object.defineProperty(error, "extensions", {
      get() {
        return extensions;
      }
    });
  }
  Object.defineProperty(error, "toJSON", {
    value() {
      return {
        message: error.message,
        extensions: error.extensions
      };
    }
  });
  return error;
}
var createDefaultMaskError = (isDev2) => (error, message) => {
  if (isOriginalGraphQLError(error)) {
    return error;
  }
  return createSerializableGraphQLError(message, error, isDev2);
};
var isDev = globalThis.process?.env?.NODE_ENV === "development";
var defaultMaskError = createDefaultMaskError(isDev);
var makeHandleResult = (maskError, message) => ({ result, setResult }) => {
  if (result.errors != null) {
    setResult({ ...result, errors: result.errors.map((error) => maskError(error, message)) });
  }
};
function useMaskedErrors(opts) {
  const maskError = opts?.maskError ?? defaultMaskError;
  const message = opts?.errorMessage || DEFAULT_ERROR_MESSAGE;
  const handleResult = makeHandleResult(maskError, message);
  return {
    onPluginInit(context) {
      context.registerContextErrorHandler(({ error, setError }) => {
        setError(maskError(error, message));
      });
    },
    onExecute() {
      return {
        onExecuteDone(payload) {
          return handleStreamOrSingleExecutionResult(payload, handleResult);
        }
      };
    },
    onSubscribe() {
      return {
        onSubscribeResult(payload) {
          return handleStreamOrSingleExecutionResult(payload, handleResult);
        },
        onSubscribeError({ error, setError }) {
          setError(maskError(error, message));
        }
      };
    }
  };
}

// node_modules/@envelop/core/esm/plugins/use-error-handler.js
var makeHandleResult2 = (errorHandler) => ({ result, args }) => {
  if (result.errors?.length) {
    errorHandler({ errors: result.errors, context: args, phase: "execution" });
  }
};
var useErrorHandler = (errorHandler) => {
  const handleResult = makeHandleResult2(errorHandler);
  return {
    onParse() {
      return function onParseEnd({ result, context }) {
        if (result instanceof Error) {
          errorHandler({ errors: [result], context, phase: "parse" });
        }
      };
    },
    onValidate() {
      return function onValidateEnd({ valid, result, context }) {
        if (valid === false && result.length > 0) {
          errorHandler({ errors: result, context, phase: "validate" });
        }
      };
    },
    onPluginInit(context) {
      context.registerContextErrorHandler(({ error }) => {
        if (isGraphQLError(error)) {
          errorHandler({ errors: [error], context, phase: "context" });
        } else {
          errorHandler({ errors: [new Error(error)], context, phase: "context" });
        }
      });
    },
    onExecute() {
      return {
        onExecuteDone(payload) {
          return handleStreamOrSingleExecutionResult(payload, handleResult);
        }
      };
    },
    onSubscribe() {
      return {
        onSubscribeResult(payload) {
          return handleStreamOrSingleExecutionResult(payload, handleResult);
        }
      };
    }
  };
};

// node_modules/@envelop/core/esm/plugins/use-extend-context.js
var useExtendContext = (contextFactory) => ({
  onContextBuilding({ context, extendContext }) {
    return handleMaybePromise(() => contextFactory(context), (result) => extendContext(result));
  }
});

// node_modules/@envelop/core/esm/plugins/use-payload-formatter.js
var makeHandleResult3 = (formatter) => ({ args, result, setResult }) => {
  const modified = formatter(result, args);
  if (modified !== false) {
    setResult(modified);
  }
};
var usePayloadFormatter = (formatter) => ({
  onExecute() {
    const handleResult = makeHandleResult3(formatter);
    return {
      onExecuteDone(payload) {
        return handleStreamOrSingleExecutionResult(payload, handleResult);
      }
    };
  }
});

// node_modules/@envelop/core/esm/plugins/use-engine.js
var useEngine = (engine) => {
  return {
    onExecute: ({ setExecuteFn }) => {
      if (engine.execute) {
        setExecuteFn(engine.execute);
      }
    },
    onParse: ({ setParseFn }) => {
      if (engine.parse) {
        setParseFn(engine.parse);
      }
    },
    onValidate: ({ setValidationFn, addValidationRule }) => {
      if (engine.validate) {
        setValidationFn(engine.validate);
      }
      engine.specifiedRules?.map(addValidationRule);
    },
    onSubscribe: ({ setSubscribeFn }) => {
      if (engine.subscribe) {
        setSubscribeFn(engine.subscribe);
      }
    }
  };
};

// node_modules/@envelop/core/esm/plugins/use-validation-rule.js
var useValidationRule = (rule) => {
  return {
    onValidate({ addValidationRule }) {
      addValidationRule(rule);
    }
  };
};

export {
  isPromise,
  handleMaybePromise,
  fakePromise,
  createDeferredPromise,
  iterateAsync,
  fakeRejectPromise,
  mapMaybePromise,
  mapAsyncIterator,
  unfakePromise,
  chain,
  composeInstrumentation,
  getInstrumentationAndPlugin,
  getInstrumented,
  getDocumentString,
  envelopIsIntrospectionSymbol,
  isIntrospectionOperationString,
  makeSubscribe,
  makeExecute,
  isAsyncIterable,
  handleStreamOrSingleExecutionResult,
  finalAsyncIterator,
  errorAsyncIterator,
  envelop,
  useEnvelop,
  useLogger,
  useSchema,
  useSchemaByContext,
  DEFAULT_ERROR_MESSAGE,
  isGraphQLError,
  isOriginalGraphQLError,
  createDefaultMaskError,
  defaultMaskError,
  useMaskedErrors,
  useErrorHandler,
  useExtendContext,
  usePayloadFormatter,
  useEngine,
  useValidationRule
};
//# sourceMappingURL=chunk-K3LGC2CQ.js.map
