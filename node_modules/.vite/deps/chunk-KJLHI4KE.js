import {
  i
} from "./chunk-5CMMY7LK.js";
import {
  ae
} from "./chunk-XTV2HAPF.js";
import {
  B,
  N
} from "./chunk-YY6SLAPL.js";
import {
  require_react
} from "./chunk-S73QDKPN.js";
import {
  __toESM
} from "./chunk-G3PMV62Z.js";

// node_modules/zudoku/lib/index-DI5SPFK9.js
var m = (e) => typeof e == "boolean" ? `${e}` : e === 0 ? "0" : e;
var y = i;
var j = (e, a) => (n) => {
  var u;
  if (a?.variants == null) return y(e, n?.class, n?.className);
  const { variants: r, defaultVariants: s } = a, V2 = Object.keys(r).map((t) => {
    const l = n?.[t], d = s?.[t];
    if (l === null) return null;
    const i2 = m(l) || m(d);
    return r[t][i2];
  }), v = n && Object.entries(n).reduce((t, l) => {
    let [d, i2] = l;
    return i2 === void 0 || (t[d] = i2), t;
  }, {}), N3 = a == null || (u = a.compoundVariants) === null || u === void 0 ? void 0 : u.reduce((t, l) => {
    let { class: d, className: i2, ...f } = l;
    return Object.entries(f).every((C2) => {
      let [c, o] = C2;
      return Array.isArray(o) ? o.includes({
        ...s,
        ...v
      }[c]) : {
        ...s,
        ...v
      }[c] === o;
    }) ? [
      ...t,
      d,
      i2
    ] : t;
  }, []);
  return y(e, V2, N3, n?.class, n?.className);
};

// node_modules/zudoku/lib/hook-Bd0yS8M0.js
var S = __toESM(require_react(), 1);
var import_react = __toESM(require_react(), 1);
var $ = class {
  constructor() {
    this.listeners = /* @__PURE__ */ new Set(), this.subscribe = this.subscribe.bind(this);
  }
  subscribe(t) {
    return this.listeners.add(t), this.onSubscribe(), () => {
      this.listeners.delete(t), this.onUnsubscribe();
    };
  }
  hasListeners() {
    return this.listeners.size > 0;
  }
  onSubscribe() {
  }
  onUnsubscribe() {
  }
};
var C = typeof window > "u" || "Deno" in globalThis;
function Q() {
}
function be(t, e) {
  return typeof t == "function" ? t(e) : t;
}
function N2(t) {
  return typeof t == "number" && t >= 0 && t !== 1 / 0;
}
function ut(t, e) {
  return Math.max(t + (e || 0) - Date.now(), 0);
}
function A(t, e) {
  return typeof t == "function" ? t(e) : t;
}
function w(t, e) {
  return typeof t == "function" ? t(e) : t;
}
function Se(t, e) {
  const {
    type: s = "all",
    exact: r,
    fetchStatus: n,
    predicate: i2,
    queryKey: o,
    stale: a
  } = t;
  if (o) {
    if (r) {
      if (e.queryHash !== It(o, e.options))
        return false;
    } else if (!V(e.queryKey, o))
      return false;
  }
  if (s !== "all") {
    const u = e.isActive();
    if (s === "active" && !u || s === "inactive" && u)
      return false;
  }
  return !(typeof a == "boolean" && e.isStale() !== a || n && n !== e.state.fetchStatus || i2 && !i2(e));
}
function we(t, e) {
  const { exact: s, status: r, predicate: n, mutationKey: i2 } = t;
  if (i2) {
    if (!e.options.mutationKey)
      return false;
    if (s) {
      if (L(e.options.mutationKey) !== L(i2))
        return false;
    } else if (!V(e.options.mutationKey, i2))
      return false;
  }
  return !(r && e.state.status !== r || n && !n(e));
}
function It(t, e) {
  return (e?.queryKeyHashFn || L)(t);
}
function L(t) {
  return JSON.stringify(
    t,
    (e, s) => H(s) ? Object.keys(s).sort().reduce((r, n) => (r[n] = s[n], r), {}) : s
  );
}
function V(t, e) {
  return t === e ? true : typeof t != typeof e ? false : t && e && typeof t == "object" && typeof e == "object" ? Object.keys(e).every((s) => V(t[s], e[s])) : false;
}
function M(t, e) {
  if (t === e)
    return t;
  const s = et(t) && et(e);
  if (s || H(t) && H(e)) {
    const r = s ? t : Object.keys(t), n = r.length, i2 = s ? e : Object.keys(e), o = i2.length, a = s ? [] : {};
    let u = 0;
    for (let f = 0; f < o; f++) {
      const c = s ? f : i2[f];
      (!s && r.includes(c) || s) && t[c] === void 0 && e[c] === void 0 ? (a[c] = void 0, u++) : (a[c] = M(t[c], e[c]), a[c] === t[c] && t[c] !== void 0 && u++);
    }
    return n === o && u === n ? t : a;
  }
  return e;
}
function _(t, e) {
  if (!e || Object.keys(t).length !== Object.keys(e).length)
    return false;
  for (const s in t)
    if (t[s] !== e[s])
      return false;
  return true;
}
function et(t) {
  return Array.isArray(t) && t.length === Object.keys(t).length;
}
function H(t) {
  if (!st(t))
    return false;
  const e = t.constructor;
  if (e === void 0)
    return true;
  const s = e.prototype;
  return !(!st(s) || !s.hasOwnProperty("isPrototypeOf") || Object.getPrototypeOf(t) !== Object.prototype);
}
function st(t) {
  return Object.prototype.toString.call(t) === "[object Object]";
}
function Pt(t) {
  return new Promise((e) => {
    setTimeout(e, t);
  });
}
function K(t, e, s) {
  if (typeof s.structuralSharing == "function")
    return s.structuralSharing(t, e);
  if (s.structuralSharing !== false) {
    if (true)
      try {
        return M(t, e);
      } catch (r) {
        throw console.error(
          `Structural sharing requires data to be JSON serializable. To fix this, turn off structuralSharing or return JSON-serializable data from your queryFn. [${s.queryHash}]: ${r}`
        ), r;
      }
    return M(t, e);
  }
  return e;
}
function Re(t, e, s = 0) {
  const r = [...t, e];
  return s && r.length > s ? r.slice(1) : r;
}
function Ee(t, e, s = 0) {
  const r = [e, ...t];
  return s && r.length > s ? r.slice(0, -1) : r;
}
var k = Symbol();
function Tt(t, e) {
  return t.queryFn === k && console.error(
    `Attempted to invoke queryFn when set to skipToken. This is likely a configuration error. Query hash: '${t.queryHash}'`
  ), !t.queryFn && e?.initialPromise ? () => e.initialPromise : !t.queryFn || t.queryFn === k ? () => Promise.reject(new Error(`Missing queryFn: '${t.queryHash}'`)) : t.queryFn;
}
var Dt = class extends $ {
  #e;
  #t;
  #s;
  constructor() {
    super(), this.#s = (t) => {
      if (!C && window.addEventListener) {
        const e = () => t();
        return window.addEventListener("visibilitychange", e, false), () => {
          window.removeEventListener("visibilitychange", e);
        };
      }
    };
  }
  onSubscribe() {
    this.#t || this.setEventListener(this.#s);
  }
  onUnsubscribe() {
    this.hasListeners() || (this.#t?.(), this.#t = void 0);
  }
  setEventListener(t) {
    this.#s = t, this.#t?.(), this.#t = t((e) => {
      typeof e == "boolean" ? this.setFocused(e) : this.onFocus();
    });
  }
  setFocused(t) {
    this.#e !== t && (this.#e = t, this.onFocus());
  }
  onFocus() {
    const t = this.isFocused();
    this.listeners.forEach((e) => {
      e(t);
    });
  }
  isFocused() {
    return typeof this.#e == "boolean" ? this.#e : globalThis.document?.visibilityState !== "hidden";
  }
};
var ct = new Dt();
var At = class extends $ {
  #e = true;
  #t;
  #s;
  constructor() {
    super(), this.#s = (t) => {
      if (!C && window.addEventListener) {
        const e = () => t(true), s = () => t(false);
        return window.addEventListener("online", e, false), window.addEventListener("offline", s, false), () => {
          window.removeEventListener("online", e), window.removeEventListener("offline", s);
        };
      }
    };
  }
  onSubscribe() {
    this.#t || this.setEventListener(this.#s);
  }
  onUnsubscribe() {
    this.hasListeners() || (this.#t?.(), this.#t = void 0);
  }
  setEventListener(t) {
    this.#s = t, this.#t?.(), this.#t = t(this.setOnline.bind(this));
  }
  setOnline(t) {
    this.#e !== t && (this.#e = t, this.listeners.forEach((s) => {
      s(t);
    }));
  }
  isOnline() {
    return this.#e;
  }
};
var ht = new At();
function B2() {
  let t, e;
  const s = new Promise((n, i2) => {
    t = n, e = i2;
  });
  s.status = "pending", s.catch(() => {
  });
  function r(n) {
    Object.assign(s, n), delete s.resolve, delete s.reject;
  }
  return s.resolve = (n) => {
    r({
      status: "fulfilled",
      value: n
    }), t(n);
  }, s.reject = (n) => {
    r({
      status: "rejected",
      reason: n
    }), e(n);
  }, s;
}
function kt(t) {
  return Math.min(1e3 * 2 ** t, 3e4);
}
function lt(t) {
  return (t ?? "online") === "online" ? ht.isOnline() : true;
}
var ft = class extends Error {
  constructor(t) {
    super("CancelledError"), this.revert = t?.revert, this.silent = t?.silent;
  }
};
function q(t) {
  return t instanceof ft;
}
function xt(t) {
  let e = false, s = 0, r = false, n;
  const i2 = B2(), o = (h) => {
    r || (l(new ft(h)), t.abort?.());
  }, a = () => {
    e = true;
  }, u = () => {
    e = false;
  }, f = () => ct.isFocused() && (t.networkMode === "always" || ht.isOnline()) && t.canRun(), c = () => lt(t.networkMode) && t.canRun(), d = (h) => {
    r || (r = true, t.onSuccess?.(h), n?.(), i2.resolve(h));
  }, l = (h) => {
    r || (r = true, t.onError?.(h), n?.(), i2.reject(h));
  }, g = () => new Promise((h) => {
    n = (m2) => {
      (r || f()) && h(m2);
    }, t.onPause?.();
  }).then(() => {
    n = void 0, r || t.onContinue?.();
  }), R = () => {
    if (r)
      return;
    let h;
    const m2 = s === 0 ? t.initialPromise : void 0;
    try {
      h = m2 ?? t.fn();
    } catch (v) {
      h = Promise.reject(v);
    }
    Promise.resolve(h).then(d).catch((v) => {
      if (r)
        return;
      const p = t.retry ?? (C ? 0 : 3), y2 = t.retryDelay ?? kt, E = typeof y2 == "function" ? y2(s, v) : y2, I = p === true || typeof p == "number" && s < p || typeof p == "function" && p(s, v);
      if (e || !I) {
        l(v);
        return;
      }
      s++, t.onFail?.(s, v), Pt(E).then(() => f() ? void 0 : g()).then(() => {
        e ? l(v) : R();
      });
    });
  };
  return {
    promise: i2,
    cancel: o,
    continue: () => (n?.(), i2),
    cancelRetry: a,
    continueRetry: u,
    canStart: c,
    start: () => (c() ? R() : g().then(R), i2)
  };
}
var jt = (t) => setTimeout(t, 0);
function qt() {
  let t = [], e = 0, s = (a) => {
    a();
  }, r = (a) => {
    a();
  }, n = jt;
  const i2 = (a) => {
    e ? t.push(a) : n(() => {
      s(a);
    });
  }, o = () => {
    const a = t;
    t = [], a.length && n(() => {
      r(() => {
        a.forEach((u) => {
          s(u);
        });
      });
    });
  };
  return {
    batch: (a) => {
      let u;
      e++;
      try {
        u = a();
      } finally {
        e--, e || o();
      }
      return u;
    },
    /**
     * All calls to the wrapped function will be batched.
     */
    batchCalls: (a) => (...u) => {
      i2(() => {
        a(...u);
      });
    },
    schedule: i2,
    /**
     * Use this method to set a custom notify function.
     * This can be used to for example wrap notifications with `React.act` while running tests.
     */
    setNotifyFunction: (a) => {
      s = a;
    },
    /**
     * Use this method to set a custom function to batch notifications together into a single tick.
     * By default React Query will use the batch function provided by ReactDOM or React Native.
     */
    setBatchNotifyFunction: (a) => {
      r = a;
    },
    setScheduler: (a) => {
      n = a;
    }
  };
}
var J = qt();
var Ut = class {
  #e;
  destroy() {
    this.clearGcTimeout();
  }
  scheduleGc() {
    this.clearGcTimeout(), N2(this.gcTime) && (this.#e = setTimeout(() => {
      this.optionalRemove();
    }, this.gcTime));
  }
  updateGcTime(t) {
    this.gcTime = Math.max(
      this.gcTime || 0,
      t ?? (C ? 1 / 0 : 5 * 60 * 1e3)
    );
  }
  clearGcTimeout() {
    this.#e && (clearTimeout(this.#e), this.#e = void 0);
  }
};
var Ce = class extends Ut {
  #e;
  #t;
  #s;
  #n;
  #r;
  #o;
  #a;
  constructor(t) {
    super(), this.#a = false, this.#o = t.defaultOptions, this.setOptions(t.options), this.observers = [], this.#n = t.client, this.#s = this.#n.getQueryCache(), this.queryKey = t.queryKey, this.queryHash = t.queryHash, this.#e = Qt(this.options), this.state = t.state ?? this.#e, this.scheduleGc();
  }
  get meta() {
    return this.options.meta;
  }
  get promise() {
    return this.#r?.promise;
  }
  setOptions(t) {
    this.options = { ...this.#o, ...t }, this.updateGcTime(this.options.gcTime);
  }
  optionalRemove() {
    !this.observers.length && this.state.fetchStatus === "idle" && this.#s.remove(this);
  }
  setData(t, e) {
    const s = K(this.state.data, t, this.options);
    return this.#i({
      data: s,
      type: "success",
      dataUpdatedAt: e?.updatedAt,
      manual: e?.manual
    }), s;
  }
  setState(t, e) {
    this.#i({ type: "setState", state: t, setStateOptions: e });
  }
  cancel(t) {
    const e = this.#r?.promise;
    return this.#r?.cancel(t), e ? e.then(Q).catch(Q) : Promise.resolve();
  }
  destroy() {
    super.destroy(), this.cancel({ silent: true });
  }
  reset() {
    this.destroy(), this.setState(this.#e);
  }
  isActive() {
    return this.observers.some(
      (t) => w(t.options.enabled, this) !== false
    );
  }
  isDisabled() {
    return this.getObserversCount() > 0 ? !this.isActive() : this.options.queryFn === k || this.state.dataUpdateCount + this.state.errorUpdateCount === 0;
  }
  isStale() {
    return this.state.isInvalidated ? true : this.getObserversCount() > 0 ? this.observers.some(
      (t) => t.getCurrentResult().isStale
    ) : this.state.data === void 0;
  }
  isStaleByTime(t = 0) {
    return this.state.isInvalidated || this.state.data === void 0 || !ut(this.state.dataUpdatedAt, t);
  }
  onFocus() {
    this.observers.find((e) => e.shouldFetchOnWindowFocus())?.refetch({ cancelRefetch: false }), this.#r?.continue();
  }
  onOnline() {
    this.observers.find((e) => e.shouldFetchOnReconnect())?.refetch({ cancelRefetch: false }), this.#r?.continue();
  }
  addObserver(t) {
    this.observers.includes(t) || (this.observers.push(t), this.clearGcTimeout(), this.#s.notify({ type: "observerAdded", query: this, observer: t }));
  }
  removeObserver(t) {
    this.observers.includes(t) && (this.observers = this.observers.filter((e) => e !== t), this.observers.length || (this.#r && (this.#a ? this.#r.cancel({ revert: true }) : this.#r.cancelRetry()), this.scheduleGc()), this.#s.notify({ type: "observerRemoved", query: this, observer: t }));
  }
  getObserversCount() {
    return this.observers.length;
  }
  invalidate() {
    this.state.isInvalidated || this.#i({ type: "invalidate" });
  }
  fetch(t, e) {
    if (this.state.fetchStatus !== "idle") {
      if (this.state.data !== void 0 && e?.cancelRefetch)
        this.cancel({ silent: true });
      else if (this.#r)
        return this.#r.continueRetry(), this.#r.promise;
    }
    if (t && this.setOptions(t), !this.options.queryFn) {
      const a = this.observers.find((u) => u.options.queryFn);
      a && this.setOptions(a.options);
    }
    Array.isArray(this.options.queryKey) || console.error(
      "As of v4, queryKey needs to be an Array. If you are using a string like 'repoData', please change it to an Array, e.g. ['repoData']"
    );
    const s = new AbortController(), r = (a) => {
      Object.defineProperty(a, "signal", {
        enumerable: true,
        get: () => (this.#a = true, s.signal)
      });
    }, n = () => {
      const a = Tt(this.options, e), u = {
        client: this.#n,
        queryKey: this.queryKey,
        meta: this.meta
      };
      return r(u), this.#a = false, this.options.persister ? this.options.persister(
        a,
        u,
        this
      ) : a(u);
    }, i2 = {
      fetchOptions: e,
      options: this.options,
      queryKey: this.queryKey,
      client: this.#n,
      state: this.state,
      fetchFn: n
    };
    r(i2), this.options.behavior?.onFetch(
      i2,
      this
    ), this.#t = this.state, (this.state.fetchStatus === "idle" || this.state.fetchMeta !== i2.fetchOptions?.meta) && this.#i({ type: "fetch", meta: i2.fetchOptions?.meta });
    const o = (a) => {
      q(a) && a.silent || this.#i({
        type: "error",
        error: a
      }), q(a) || (this.#s.config.onError?.(
        a,
        this
      ), this.#s.config.onSettled?.(
        this.state.data,
        a,
        this
      )), this.scheduleGc();
    };
    return this.#r = xt({
      initialPromise: e?.initialPromise,
      fn: i2.fetchFn,
      abort: s.abort.bind(s),
      onSuccess: (a) => {
        if (a === void 0) {
          console.error(
            `Query data cannot be undefined. Please make sure to return a value other than undefined from your query function. Affected query key: ${this.queryHash}`
          ), o(new Error(`${this.queryHash} data is undefined`));
          return;
        }
        try {
          this.setData(a);
        } catch (u) {
          o(u);
          return;
        }
        this.#s.config.onSuccess?.(a, this), this.#s.config.onSettled?.(
          a,
          this.state.error,
          this
        ), this.scheduleGc();
      },
      onError: o,
      onFail: (a, u) => {
        this.#i({ type: "failed", failureCount: a, error: u });
      },
      onPause: () => {
        this.#i({ type: "pause" });
      },
      onContinue: () => {
        this.#i({ type: "continue" });
      },
      retry: i2.options.retry,
      retryDelay: i2.options.retryDelay,
      networkMode: i2.options.networkMode,
      canRun: () => true
    }), this.#r.start();
  }
  #i(t) {
    const e = (s) => {
      switch (t.type) {
        case "failed":
          return {
            ...s,
            fetchFailureCount: t.failureCount,
            fetchFailureReason: t.error
          };
        case "pause":
          return {
            ...s,
            fetchStatus: "paused"
          };
        case "continue":
          return {
            ...s,
            fetchStatus: "fetching"
          };
        case "fetch":
          return {
            ...s,
            ...dt(s.data, this.options),
            fetchMeta: t.meta ?? null
          };
        case "success":
          return {
            ...s,
            data: t.data,
            dataUpdateCount: s.dataUpdateCount + 1,
            dataUpdatedAt: t.dataUpdatedAt ?? Date.now(),
            error: null,
            isInvalidated: false,
            status: "success",
            ...!t.manual && {
              fetchStatus: "idle",
              fetchFailureCount: 0,
              fetchFailureReason: null
            }
          };
        case "error":
          const r = t.error;
          return q(r) && r.revert && this.#t ? { ...this.#t, fetchStatus: "idle" } : {
            ...s,
            error: r,
            errorUpdateCount: s.errorUpdateCount + 1,
            errorUpdatedAt: Date.now(),
            fetchFailureCount: s.fetchFailureCount + 1,
            fetchFailureReason: r,
            fetchStatus: "idle",
            status: "error"
          };
        case "invalidate":
          return {
            ...s,
            isInvalidated: true
          };
        case "setState":
          return {
            ...s,
            ...t.state
          };
      }
    };
    this.state = e(this.state), J.batch(() => {
      this.observers.forEach((s) => {
        s.onQueryUpdate();
      }), this.#s.notify({ query: this, type: "updated", action: t });
    });
  }
};
function dt(t, e) {
  return {
    fetchFailureCount: 0,
    fetchFailureReason: null,
    fetchStatus: lt(e.networkMode) ? "fetching" : "paused",
    ...t === void 0 && {
      error: null,
      status: "pending"
    }
  };
}
function Qt(t) {
  const e = typeof t.initialData == "function" ? t.initialData() : t.initialData, s = e !== void 0, r = s ? typeof t.initialDataUpdatedAt == "function" ? t.initialDataUpdatedAt() : t.initialDataUpdatedAt : 0;
  return {
    data: e,
    dataUpdateCount: 0,
    dataUpdatedAt: s ? r ?? Date.now() : 0,
    error: null,
    errorUpdateCount: 0,
    errorUpdatedAt: 0,
    fetchFailureCount: 0,
    fetchFailureReason: null,
    fetchMeta: null,
    isInvalidated: false,
    status: s ? "success" : "pending",
    fetchStatus: "idle"
  };
}
var pt = class extends $ {
  constructor(t, e) {
    super(), this.options = e, this.#e = t, this.#i = null, this.#a = B2(), this.options.experimental_prefetchInRender || this.#a.reject(
      new Error("experimental_prefetchInRender feature flag is not enabled")
    ), this.bindMethods(), this.setOptions(e);
  }
  #e;
  #t = void 0;
  #s = void 0;
  #n = void 0;
  #r;
  #o;
  #a;
  #i;
  #y;
  #f;
  // This property keeps track of the last query with defined data.
  // It will be used to pass the previous data and query to the placeholder function between renders.
  #d;
  #c;
  #h;
  #u;
  #p = /* @__PURE__ */ new Set();
  bindMethods() {
    this.refetch = this.refetch.bind(this);
  }
  onSubscribe() {
    this.listeners.size === 1 && (this.#t.addObserver(this), rt(this.#t, this.options) ? this.#l() : this.updateResult(), this.#b());
  }
  onUnsubscribe() {
    this.hasListeners() || this.destroy();
  }
  shouldFetchOnReconnect() {
    return G(
      this.#t,
      this.options,
      this.options.refetchOnReconnect
    );
  }
  shouldFetchOnWindowFocus() {
    return G(
      this.#t,
      this.options,
      this.options.refetchOnWindowFocus
    );
  }
  destroy() {
    this.listeners = /* @__PURE__ */ new Set(), this.#S(), this.#w(), this.#t.removeObserver(this);
  }
  setOptions(t) {
    const e = this.options, s = this.#t;
    if (this.options = this.#e.defaultQueryOptions(t), this.options.enabled !== void 0 && typeof this.options.enabled != "boolean" && typeof this.options.enabled != "function" && typeof w(this.options.enabled, this.#t) != "boolean")
      throw new Error(
        "Expected enabled to be a boolean or a callback that returns a boolean"
      );
    this.#O(), this.#t.setOptions(this.options), e._defaulted && !_(this.options, e) && this.#e.getQueryCache().notify({
      type: "observerOptionsUpdated",
      query: this.#t,
      observer: this
    });
    const r = this.hasListeners();
    r && nt(
      this.#t,
      s,
      this.options,
      e
    ) && this.#l(), this.updateResult(), r && (this.#t !== s || w(this.options.enabled, this.#t) !== w(e.enabled, this.#t) || A(this.options.staleTime, this.#t) !== A(e.staleTime, this.#t)) && this.#v();
    const n = this.#g();
    r && (this.#t !== s || w(this.options.enabled, this.#t) !== w(e.enabled, this.#t) || n !== this.#u) && this.#m(n);
  }
  getOptimisticResult(t) {
    const e = this.#e.getQueryCache().build(this.#e, t), s = this.createResult(e, t);
    return Lt(this, s) && (this.#n = s, this.#o = this.options, this.#r = this.#t.state), s;
  }
  getCurrentResult() {
    return this.#n;
  }
  trackResult(t, e) {
    const s = {};
    return Object.keys(t).forEach((r) => {
      Object.defineProperty(s, r, {
        configurable: false,
        enumerable: true,
        get: () => (this.trackProp(r), e?.(r), t[r])
      });
    }), s;
  }
  trackProp(t) {
    this.#p.add(t);
  }
  getCurrentQuery() {
    return this.#t;
  }
  refetch({ ...t } = {}) {
    return this.fetch({
      ...t
    });
  }
  fetchOptimistic(t) {
    const e = this.#e.defaultQueryOptions(t), s = this.#e.getQueryCache().build(this.#e, e);
    return s.fetch().then(() => this.createResult(s, e));
  }
  fetch(t) {
    return this.#l({
      ...t,
      cancelRefetch: t.cancelRefetch ?? true
    }).then(() => (this.updateResult(), this.#n));
  }
  #l(t) {
    this.#O();
    let e = this.#t.fetch(
      this.options,
      t
    );
    return t?.throwOnError || (e = e.catch(Q)), e;
  }
  #v() {
    this.#S();
    const t = A(
      this.options.staleTime,
      this.#t
    );
    if (C || this.#n.isStale || !N2(t))
      return;
    const s = ut(this.#n.dataUpdatedAt, t) + 1;
    this.#c = setTimeout(() => {
      this.#n.isStale || this.updateResult();
    }, s);
  }
  #g() {
    return (typeof this.options.refetchInterval == "function" ? this.options.refetchInterval(this.#t) : this.options.refetchInterval) ?? false;
  }
  #m(t) {
    this.#w(), this.#u = t, !(C || w(this.options.enabled, this.#t) === false || !N2(this.#u) || this.#u === 0) && (this.#h = setInterval(() => {
      (this.options.refetchIntervalInBackground || ct.isFocused()) && this.#l();
    }, this.#u));
  }
  #b() {
    this.#v(), this.#m(this.#g());
  }
  #S() {
    this.#c && (clearTimeout(this.#c), this.#c = void 0);
  }
  #w() {
    this.#h && (clearInterval(this.#h), this.#h = void 0);
  }
  createResult(t, e) {
    const s = this.#t, r = this.options, n = this.#n, i2 = this.#r, o = this.#o, u = t !== s ? t.state : this.#s, { state: f } = t;
    let c = { ...f }, d = false, l;
    if (e._optimisticResults) {
      const b = this.hasListeners(), T = !b && rt(t, e), P = b && nt(t, s, e, r);
      (T || P) && (c = {
        ...c,
        ...dt(f.data, t.options)
      }), e._optimisticResults === "isRestoring" && (c.fetchStatus = "idle");
    }
    let { error: g, errorUpdatedAt: R, status: h } = c;
    l = c.data;
    let m2 = false;
    if (e.placeholderData !== void 0 && l === void 0 && h === "pending") {
      let b;
      n?.isPlaceholderData && e.placeholderData === o?.placeholderData ? (b = n.data, m2 = true) : b = typeof e.placeholderData == "function" ? e.placeholderData(
        this.#d?.state.data,
        this.#d
      ) : e.placeholderData, b !== void 0 && (h = "success", l = K(
        n?.data,
        b,
        e
      ), d = true);
    }
    if (e.select && l !== void 0 && !m2)
      if (n && l === i2?.data && e.select === this.#y)
        l = this.#f;
      else
        try {
          this.#y = e.select, l = e.select(l), l = K(n?.data, l, e), this.#f = l, this.#i = null;
        } catch (b) {
          this.#i = b;
        }
    this.#i && (g = this.#i, l = this.#f, R = Date.now(), h = "error");
    const v = c.fetchStatus === "fetching", p = h === "pending", y2 = h === "error", E = p && v, I = l !== void 0, O = {
      status: h,
      fetchStatus: c.fetchStatus,
      isPending: p,
      isSuccess: h === "success",
      isError: y2,
      isInitialLoading: E,
      isLoading: E,
      data: l,
      dataUpdatedAt: c.dataUpdatedAt,
      error: g,
      errorUpdatedAt: R,
      failureCount: c.fetchFailureCount,
      failureReason: c.fetchFailureReason,
      errorUpdateCount: c.errorUpdateCount,
      isFetched: c.dataUpdateCount > 0 || c.errorUpdateCount > 0,
      isFetchedAfterMount: c.dataUpdateCount > u.dataUpdateCount || c.errorUpdateCount > u.errorUpdateCount,
      isFetching: v,
      isRefetching: v && !p,
      isLoadingError: y2 && !I,
      isPaused: c.fetchStatus === "paused",
      isPlaceholderData: d,
      isRefetchError: y2 && I,
      isStale: Z(t, e),
      refetch: this.refetch,
      promise: this.#a
    };
    if (this.options.experimental_prefetchInRender) {
      const b = (D) => {
        O.status === "error" ? D.reject(O.error) : O.data !== void 0 && D.resolve(O.data);
      }, T = () => {
        const D = this.#a = O.promise = B2();
        b(D);
      }, P = this.#a;
      switch (P.status) {
        case "pending":
          t.queryHash === s.queryHash && b(P);
          break;
        case "fulfilled":
          (O.status === "error" || O.data !== P.value) && T();
          break;
        case "rejected":
          (O.status !== "error" || O.error !== P.reason) && T();
          break;
      }
    }
    return O;
  }
  updateResult() {
    const t = this.#n, e = this.createResult(this.#t, this.options);
    if (this.#r = this.#t.state, this.#o = this.options, this.#r.data !== void 0 && (this.#d = this.#t), _(e, t))
      return;
    this.#n = e;
    const s = () => {
      if (!t)
        return true;
      const { notifyOnChangeProps: r } = this.options, n = typeof r == "function" ? r() : r;
      if (n === "all" || !n && !this.#p.size)
        return true;
      const i2 = new Set(
        n ?? this.#p
      );
      return this.options.throwOnError && i2.add("error"), Object.keys(this.#n).some((o) => {
        const a = o;
        return this.#n[a] !== t[a] && i2.has(a);
      });
    };
    this.#R({ listeners: s() });
  }
  #O() {
    const t = this.#e.getQueryCache().build(this.#e, this.options);
    if (t === this.#t)
      return;
    const e = this.#t;
    this.#t = t, this.#s = t.state, this.hasListeners() && (e?.removeObserver(this), t.addObserver(this));
  }
  onQueryUpdate() {
    this.updateResult(), this.hasListeners() && this.#b();
  }
  #R(t) {
    J.batch(() => {
      t.listeners && this.listeners.forEach((e) => {
        e(this.#n);
      }), this.#e.getQueryCache().notify({
        query: this.#t,
        type: "observerResultsUpdated"
      });
    });
  }
};
function Nt(t, e) {
  return w(e.enabled, t) !== false && t.state.data === void 0 && !(t.state.status === "error" && e.retryOnMount === false);
}
function rt(t, e) {
  return Nt(t, e) || t.state.data !== void 0 && G(t, e, e.refetchOnMount);
}
function G(t, e, s) {
  if (w(e.enabled, t) !== false) {
    const r = typeof s == "function" ? s(t) : s;
    return r === "always" || r !== false && Z(t, e);
  }
  return false;
}
function nt(t, e, s, r) {
  return (t !== e || w(r.enabled, t) === false) && (!s.suspense || t.state.status !== "error") && Z(t, s);
}
function Z(t, e) {
  return w(e.enabled, t) !== false && t.isStaleByTime(A(e.staleTime, t));
}
function Lt(t, e) {
  return !_(t.getCurrentResult(), e);
}
var yt = S.createContext(
  void 0
);
var vt = (t) => {
  const e = S.useContext(yt);
  if (t)
    return t;
  if (!e)
    throw new Error("No QueryClient set, use QueryClientProvider to set one");
  return e;
};
var Fe = ({
  client: t,
  children: e
}) => (S.useEffect(() => (t.mount(), () => {
  t.unmount();
}), [t]), ae.jsx(yt.Provider, { value: t, children: e }));
var gt = S.createContext(false);
var Mt = () => S.useContext(gt);
gt.Provider;
function _t() {
  let t = false;
  return {
    clearReset: () => {
      t = false;
    },
    reset: () => {
      t = true;
    },
    isReset: () => t
  };
}
var Ht = S.createContext(_t());
var Kt = () => S.useContext(Ht);
function Bt(t, e) {
  return typeof t == "function" ? t(...e) : !!t;
}
function it() {
}
var Gt = (t, e) => {
  (t.suspense || t.throwOnError || t.experimental_prefetchInRender) && (e.isReset() || (t.retryOnMount = false));
};
var zt = (t) => {
  S.useEffect(() => {
    t.clearReset();
  }, [t]);
};
var $t = ({
  result: t,
  errorResetBoundary: e,
  throwOnError: s,
  query: r,
  suspense: n
}) => t.isError && !e.isReset() && !t.isFetching && r && (n && t.data === void 0 || Bt(s, [t.error, r]));
var Vt = (t, e) => e.state.data === void 0;
var Jt = (t) => {
  const e = t.staleTime;
  t.suspense && (t.staleTime = typeof e == "function" ? (...s) => Math.max(e(...s), 1e3) : Math.max(e ?? 1e3, 1e3), typeof t.gcTime == "number" && (t.gcTime = Math.max(t.gcTime, 1e3)));
};
var Zt = (t, e) => t.isLoading && t.isFetching && !e;
var Wt = (t, e) => t?.suspense && e.isPending;
var at = (t, e, s) => e.fetchOptimistic(t).catch(() => {
  s.clearReset();
});
function mt(t, e, s) {
  if (typeof t != "object" || Array.isArray(t))
    throw new Error(
      'Bad argument type. Starting with v5, only the "Object" form is allowed when calling query related functions. Please use the error stack to find the culprit call. More info here: https://tanstack.com/query/latest/docs/react/guides/migrating-to-v5#supports-a-single-signature-one-object'
    );
  const r = vt(s), n = Mt(), i2 = Kt(), o = r.defaultQueryOptions(t);
  r.getDefaultOptions().queries?._experimental_beforeQuery?.(
    o
  ), o.queryFn || console.error(
    `[${o.queryHash}]: No queryFn was passed as an option, and no default queryFn was found. The queryFn parameter is only optional when using a default queryFn. More info here: https://tanstack.com/query/latest/docs/framework/react/guides/default-query-function`
  ), o._optimisticResults = n ? "isRestoring" : "optimistic", Jt(o), Gt(o, i2), zt(i2);
  const a = !r.getQueryCache().get(o.queryHash), [u] = S.useState(
    () => new e(
      r,
      o
    )
  ), f = u.getOptimisticResult(o), c = !n && t.subscribed !== false;
  if (S.useSyncExternalStore(
    S.useCallback(
      (d) => {
        const l = c ? u.subscribe(J.batchCalls(d)) : it;
        return u.updateResult(), l;
      },
      [u, c]
    ),
    () => u.getCurrentResult(),
    () => u.getCurrentResult()
  ), S.useEffect(() => {
    u.setOptions(o);
  }, [o, u]), Wt(o, f))
    throw at(o, u, i2);
  if ($t({
    result: f,
    errorResetBoundary: i2,
    throwOnError: o.throwOnError,
    query: r.getQueryCache().get(o.queryHash),
    suspense: o.suspense
  }))
    throw f.error;
  return r.getDefaultOptions().queries?._experimental_afterQuery?.(
    o,
    f
  ), o.experimental_prefetchInRender && !C && Zt(f, n) && (a ? (
    // Fetch immediately on render in order to ensure `.promise` is resolved even if the component is unmounted
    at(o, u, i2)
  ) : (
    // subscribe to the "cache promise" so that we can finalize the currentThenable once data comes in
    r.getQueryCache().get(o.queryHash)?.promise
  ))?.catch(it).finally(() => {
    u.updateResult();
  }), o.notifyOnChangeProps ? f : u.trackResult(f);
}
function Yt(t, e) {
  return mt(t, pt, e);
}
function Xt(t, e) {
  return t.queryFn === k && console.error("skipToken is not allowed for useSuspenseQuery"), mt(
    {
      ...t,
      enabled: true,
      suspense: true,
      throwOnError: Vt,
      placeholderData: void 0
    },
    pt,
    e
  );
}
var te = /^(\w+:\/\/[^/?]+)?([^?]*)(\?.*)?$/;
var ee = (t) => t.filter(
  (e) => e != null && e !== false && (typeof e == "string" || typeof e == "number")
).map((e) => `${e}`).filter((e) => e);
var se = (t) => {
  const e = t.join("/"), [, s = "", r = ""] = e.match(te) ?? [];
  return {
    prefix: s,
    pathname: r.split("/").filter((n) => n !== "")
  };
};
var re = (t) => {
  const { prefix: e, pathname: s } = t;
  let r = e;
  return s.length > 0 ? (r ? r += "/" : r = "/", r += s.join("/")) : r || (r = "/"), r;
};
var F = (...t) => {
  const e = ee(t), s = se(e);
  return re(s);
};
var bt = Object.freeze({
  API_IDENTITIES: ["api-identities"]
});
var Ie = () => {
  const t = vt();
  return {
    invalidateCache: async (e) => {
      await t.invalidateQueries({ queryKey: bt[e] });
    }
  };
};
var Pe = "no-dehydrate";
var W = (t, e) => {
  for (const s of t) {
    const r = Y(s, e);
    if (r !== void 0) return r;
  }
};
var Y = (t, e, s = []) => {
  const r = e(t, s);
  if (r !== void 0) return r;
  if (t.type === "category")
    for (const n of t.items) {
      const i2 = Y(n, e, [
        ...s,
        t
      ]);
      if (i2 !== void 0) return i2;
    }
};
var Te = () => {
  const t = N(), { navigation: e } = St();
  return W(e, (s) => {
    if (s.type === "doc" && F(s.path) === t.pathname)
      return s;
  });
};
var De = (t) => {
  const e = N();
  return Y(t, (s) => {
    if (s.type === "category" && s.link && F(s.link.path) === e.pathname || s.type === "doc" && F(s.path) === e.pathname)
      return true;
  });
};
var Ae = () => {
  const t = N().pathname, { navigation: e } = St();
  let s, r, n = false;
  return W(e, (i2) => {
    const o = i2.type === "doc" ? F(i2.path) : i2.type === "category" && i2.link ? F(i2.link.path) : void 0;
    if (o) {
      if (n)
        return r = { label: i2.label, id: o }, true;
      t === o ? n = true : s = { label: i2.label, id: o };
    }
  }), { prev: s, next: r };
};
var ke = j(
  "relative flex items-center gap-2 px-(--padding-nav-item) my-0.5 py-1.5 rounded-lg hover:bg-accent tabular-nums",
  {
    variants: {
      isActive: {
        true: "bg-accent font-medium",
        false: "text-foreground/80"
      },
      isMuted: {
        true: "text-foreground/30",
        false: ""
      },
      isPending: {
        true: "bg-accent animate-pulse",
        false: ""
      }
    },
    defaultVariants: {
      isActive: false
    }
  }
);
var xe = (t) => (e) => e.display === "hide" || !e.label ? false : e.display === "auth" && t || e.display === "anon" && !t || !e.display || e.display === "always";
var ne = (0, import_react.createContext)(
  void 0
);
var X = () => {
  const t = (0, import_react.useContext)(ne);
  if (!t)
    throw new Error("useZudoku must be used within a ZudokuProvider.");
  return t;
};
var je = () => {
  const { getApiIdentities: t } = X();
  return Yt({
    queryFn: t,
    queryKey: bt.API_IDENTITIES
  });
};
var U = (t) => {
  switch (t.type) {
    case "doc":
      return F(t.path);
    case "category":
      return t.link ? F(t.link.path) : void 0;
    case "link":
      return t.to;
    case "custom-page":
      return t.path;
    default:
      return;
  }
};
var St = () => {
  const { getPluginNavigation: t, navigation: e, options: s } = X(), r = N(), n = de(), i2 = s.protectedRoutes?.some(
    (c) => B(c, r.pathname)
  ), o = W(e, (c, d) => {
    if (U(c) === r.pathname)
      return d.at(0) ?? c;
  }), { data: a } = Xt({
    queryFn: () => t(r.pathname),
    queryKey: ["plugin-navigation", r.pathname]
  });
  let u = o;
  if (!o && a.length > 0) {
    const c = a.flatMap((d) => U(d)?.split("?").at(0)?.split("#").at(0) ?? []);
    u = e.flatMap((d) => {
      const l = U(d);
      return l ? [{ item: d, path: l }] : [];
    }).sort((d, l) => l.path.length - d.path.length).find(({ path: d }) => c.some(
      (l) => B({ path: d, end: false }, l) ?? B({ path: l, end: false }, d)
    ))?.item;
  }
  return {
    navigation: n.isAuthEnabled && !n.isAuthenticated && i2 ? [] : [...o?.type === "category" ? o.items : [], ...a],
    topNavItem: u
  };
};
var ot = (t) => {
  let e;
  const s = /* @__PURE__ */ new Set(), r = (f, c) => {
    const d = typeof f == "function" ? f(e) : f;
    if (!Object.is(d, e)) {
      const l = e;
      e = c ?? (typeof d != "object" || d === null) ? d : Object.assign({}, e, d), s.forEach((g) => g(e, l));
    }
  }, n = () => e, a = { setState: r, getState: n, getInitialState: () => u, subscribe: (f) => (s.add(f), () => s.delete(f)) }, u = e = t(r, n, a);
  return a;
};
var ie = (t) => t ? ot(t) : ot;
var ae2 = (t) => t;
function oe(t, e = ae2) {
  const s = import_react.default.useSyncExternalStore(
    t.subscribe,
    () => e(t.getState()),
    () => e(t.getInitialState())
  );
  return import_react.default.useDebugValue(s), s;
}
var ue = (t) => {
  const e = ie(t), s = (r) => oe(e, r);
  return Object.assign(s, e), s;
};
var ce = (t) => ue;
function wt(t, e) {
  let s;
  try {
    s = t();
  } catch {
    return;
  }
  return {
    getItem: (n) => {
      var i2;
      const o = (u) => u === null ? null : JSON.parse(u, void 0), a = (i2 = s.getItem(n)) != null ? i2 : null;
      return a instanceof Promise ? a.then(o) : o(a);
    },
    setItem: (n, i2) => s.setItem(n, JSON.stringify(i2, void 0)),
    removeItem: (n) => s.removeItem(n)
  };
}
var z = (t) => (e) => {
  try {
    const s = t(e);
    return s instanceof Promise ? s : {
      then(r) {
        return z(r)(s);
      },
      catch(r) {
        return this;
      }
    };
  } catch (s) {
    return {
      then(r) {
        return this;
      },
      catch(r) {
        return z(r)(s);
      }
    };
  }
};
var he = (t, e) => (s, r, n) => {
  let i2 = {
    storage: wt(() => localStorage),
    partialize: (h) => h,
    version: 0,
    merge: (h, m2) => ({
      ...m2,
      ...h
    }),
    ...e
  }, o = false;
  const a = /* @__PURE__ */ new Set(), u = /* @__PURE__ */ new Set();
  let f = i2.storage;
  if (!f)
    return t(
      (...h) => {
        console.warn(
          `[zustand persist middleware] Unable to update item '${i2.name}', the given storage is currently unavailable.`
        ), s(...h);
      },
      r,
      n
    );
  const c = () => {
    const h = i2.partialize({ ...r() });
    return f.setItem(i2.name, {
      state: h,
      version: i2.version
    });
  }, d = n.setState;
  n.setState = (h, m2) => {
    d(h, m2), c();
  };
  const l = t(
    (...h) => {
      s(...h), c();
    },
    r,
    n
  );
  n.getInitialState = () => l;
  let g;
  const R = () => {
    var h, m2;
    if (!f) return;
    o = false, a.forEach((p) => {
      var y2;
      return p((y2 = r()) != null ? y2 : l);
    });
    const v = ((m2 = i2.onRehydrateStorage) == null ? void 0 : m2.call(i2, (h = r()) != null ? h : l)) || void 0;
    return z(f.getItem.bind(f))(i2.name).then((p) => {
      if (p)
        if (typeof p.version == "number" && p.version !== i2.version) {
          if (i2.migrate) {
            const y2 = i2.migrate(
              p.state,
              p.version
            );
            return y2 instanceof Promise ? y2.then((E) => [true, E]) : [true, y2];
          }
          console.error(
            "State loaded from storage couldn't be migrated since no migrate function was provided"
          );
        } else
          return [false, p.state];
      return [false, void 0];
    }).then((p) => {
      var y2;
      const [E, I] = p;
      if (g = i2.merge(
        I,
        (y2 = r()) != null ? y2 : l
      ), s(g, true), E)
        return c();
    }).then(() => {
      v?.(g, void 0), g = r(), o = true, u.forEach((p) => p(g));
    }).catch((p) => {
      v?.(void 0, p);
    });
  };
  return n.persist = {
    setOptions: (h) => {
      i2 = {
        ...i2,
        ...h
      }, h.storage && (f = h.storage);
    },
    clearStorage: () => {
      f?.removeItem(i2.name);
    },
    getOptions: () => i2,
    rehydrate: () => R(),
    hasHydrated: () => o,
    onHydrate: (h) => (a.add(h), () => {
      a.delete(h);
    }),
    onFinishHydration: (h) => (u.add(h), () => {
      u.delete(h);
    })
  }, i2.skipHydration || R(), g || l;
};
var le = he;
var fe = (t) => {
  const e = (s) => {
    s.key === t.persist.getOptions().name && s.newValue && t.persist.rehydrate();
  };
  return window.addEventListener("storage", e), () => {
    window.removeEventListener("storage", e);
  };
};
var Ot = ce()(
  le(
    (t) => ({
      isAuthenticated: false,
      isPending: true,
      profile: null,
      providerData: null,
      setAuthenticationPending: () => t(() => ({
        isAuthenticated: false,
        isPending: false,
        profile: null,
        providerData: null
      })),
      setLoggedOut: () => t(() => ({
        isAuthenticated: false,
        isPending: false,
        profile: null,
        providerData: null
      })),
      setLoggedIn: ({
        profile: e,
        providerData: s
      }) => t(() => ({
        isAuthenticated: true,
        isPending: false,
        profile: e,
        providerData: s
      }))
    }),
    {
      merge: (t, e) => ({
        ...e,
        isPending: false,
        ...typeof t == "object" ? t : {}
      }),
      name: "auth-state",
      storage: wt(() => localStorage)
    }
  )
);
typeof window < "u" && fe(Ot);
var de = () => {
  const { authentication: t } = X(), e = Ot(), s = typeof t < "u";
  return {
    isAuthEnabled: s,
    ...e,
    login: async () => {
      if (!s)
        throw new Error("Authentication is not enabled.");
      await t.signIn({
        redirectTo: window.location.href
      });
    },
    logout: async () => {
      if (!s)
        throw new Error("Authentication is not enabled.");
      await t.signOut(), window.location.href = "/";
    },
    signup: async () => {
      if (!s)
        throw new Error("Authentication is not enabled.");
      await t.signUp({
        redirectTo: window.location.href
      });
    }
  };
};

export {
  y,
  j,
  $,
  Q,
  be,
  A,
  Se,
  we,
  It,
  L,
  V,
  _,
  Re,
  Ee,
  k,
  Tt,
  ct,
  ht,
  xt,
  J,
  Ut,
  Ce,
  vt,
  Fe,
  Bt,
  it,
  Yt,
  Xt,
  F,
  bt,
  Ie,
  Pe,
  W,
  Y,
  Te,
  De,
  Ae,
  ke,
  xe,
  ne,
  X,
  je,
  St,
  ie,
  oe,
  ce,
  wt,
  le,
  Ot,
  de
};
//# sourceMappingURL=chunk-KJLHI4KE.js.map
