import rehypeShikiFromHighlighter from "@shikijs/rehype/core";
import { transformerMetaHighlight, transformerMetaWordHighlight, } from "@shikijs/transformers";
import { toJsxRuntime } from "hast-util-to-jsx-runtime";
import { createElement, Fragment } from "react";
import { jsx, jsxs } from "react/jsx-runtime";
import { createHighlighterCore } from "shiki/core";
import { createJavaScriptRegexEngine } from "shiki/engine/javascript";
import { visit } from "unist-util-visit";
import { cn } from "./util/cn.js";
export const HIGHLIGHT_CODE_BLOCK_CLASS = "overflow-x-auto scrollbar not-inline";
const engine = createJavaScriptRegexEngine({ forgiving: true });
const shikiPromise = import.meta.hot?.data.shiki
    ? import.meta.hot.data.shiki
    : createHighlighterCore({
        engine,
        langAlias: {
            markup: "html",
            svg: "xml",
            mathml: "xml",
            atom: "xml",
            ssml: "xml",
            rss: "xml",
            webmanifest: "json",
        },
    });
if (import.meta.hot) {
    import.meta.hot.data.shiki = shikiPromise;
}
export const highlighter = await shikiPromise;
export const defaultHighlightOptions = {
    themes: {
        light: "github-light",
        dark: "github-dark",
    },
    defaultColor: false,
    defaultLanguage: "text",
    fallbackLanguage: "text",
    inline: "tailing-curly-colon",
    addLanguageClass: true,
    transformers: [transformerMetaHighlight(), transformerMetaWordHighlight()],
    parseMetaString: (str) => {
        // Matches key="value", key=value, or key attributes
        const matches = str.matchAll(/([a-z0-9]+)(?:=(["'])(.*?)\2|=(.*?)(?:\s|$)|(?:\s|$))/gi);
        return Object.fromEntries(Array.from(matches).map((match) => {
            const key = match[1];
            const value = match[3] || match[4] || true;
            return [key, value];
        }));
    },
};
export const defaultLanguages = [
    "shellscript",
    "javascript",
    "jsx",
    "typescript",
    "tsx",
    "graphql",
    "jsonc",
    "json",
    "python",
    "java",
    "go",
    "csharp",
    "kotlin",
    "objective-c",
    "php",
    "ruby",
    "swift",
    "css",
    "html",
    "xml",
    "yaml",
    "toml",
    "rust",
    "markdown",
    "mdx",
    "zig",
    "scala",
    "dart",
    "ocaml",
    "c",
    "cpp",
    "common-lisp",
    "elixir",
    "powershell",
];
const rehypeCodeBlockPlugin = () => (tree) => {
    visit(tree, "element", (node, _index, parent) => {
        if (node.tagName !== "code")
            return;
        const isCodeBlock = parent?.type === "element" && parent.tagName === "pre";
        node.properties.inline = JSON.stringify(!isCodeBlock);
        // Pass through properties from <pre> to <code> so we can handle it in `code` only
        if (isCodeBlock) {
            node.properties = {
                ...node.properties,
                ...structuredClone(parent.properties),
                class: cn(node.properties.class, parent.properties.class),
            };
            parent.properties = {};
        }
    });
};
export const createConfiguredShikiRehypePlugins = (themes = defaultHighlightOptions.themes, highlighterInstance = highlighter) => [
    [
        rehypeShikiFromHighlighter,
        highlighterInstance,
        { ...defaultHighlightOptions, themes },
    ],
    rehypeCodeBlockPlugin,
];
export const highlight = (highlighter, code, lang = "text", themes = defaultHighlightOptions.themes) => {
    const value = highlighter.codeToHast(code, {
        lang,
        ...defaultHighlightOptions,
        themes,
    });
    return toJsxRuntime(value, {
        Fragment,
        jsx,
        jsxs,
        components: {
            code: (props) => createElement("code", {
                ...props,
                className: cn(props.className, HIGHLIGHT_CODE_BLOCK_CLASS),
            }),
        },
    });
};
//# sourceMappingURL=shiki.js.map