import { startTransition, useCallback, useEffect, useRef, } from "react";
import { useFieldArray, useFormContext } from "react-hook-form";
export const useKeyValueFieldManager = (options) => {
    const { control, name, defaultValue, isEmpty: customIsEmpty, shouldSetActive: customShouldSetActive, } = options;
    const { setValue: internalSetValue, watch, setFocus, register, } = useFormContext();
    const { fields, append, remove } = useFieldArray({ control, name });
    const watchedFields = watch(name);
    const lastEditedIndexRef = useRef(-1);
    const prevLengthRef = useRef(-1);
    const setValue = useCallback((index, field, value, options) => {
        if (field === "value" || field === "name") {
            lastEditedIndexRef.current = index;
        }
        // biome-ignore lint/suspicious/noExplicitAny: Can't infer the type of the value here
        internalSetValue(`${name}.${index}.${field}`, value);
        if (options?.focus === "next") {
            setFocus(field === "name"
                ? `${name}.${index}.value`
                : `${name}.${index + 1}.name`);
        }
        else if (options?.focus === "previous") {
            setFocus(field === "name"
                ? `${name}.${index - 1}.value`
                : `${name}.${index}.name`);
        }
    }, [name, internalSetValue, setFocus]);
    const isEmpty = useCallback((item) => {
        if (customIsEmpty)
            return customIsEmpty(item);
        return !item.name && !item.value;
    }, [customIsEmpty]);
    const shouldSetActive = useCallback((item) => {
        if (customShouldSetActive)
            return customShouldSetActive(item);
        return Boolean(item.name || item.value);
    }, [customShouldSetActive]);
    // Handle auto append/remove of rows
    useEffect(() => {
        if (!watchedFields)
            return;
        // Prevents double-appending in Strict Mode
        if (prevLengthRef.current === -1) {
            prevLengthRef.current = watchedFields.length;
            if (watchedFields.length === 0) {
                // biome-ignore lint/suspicious/noExplicitAny: Generic field array type
                append(defaultValue, {
                    shouldFocus: false,
                });
            }
            return;
        }
        prevLengthRef.current = watchedFields.length;
        // If no fields, append one
        if (watchedFields.length === 0) {
            // biome-ignore lint/suspicious/noExplicitAny: Generic field array type
            append(defaultValue, {
                shouldFocus: false,
            });
            return;
        }
        // Auto-remove empty fields (except the last one, keep at least one)
        if (watchedFields.length > 1) {
            const emptyIndices = [];
            // Check all fields except the last one
            for (let i = 0; i < watchedFields.length - 1; i++) {
                const field = watchedFields[i];
                if (field && isEmpty(field) && !shouldSetActive(field)) {
                    emptyIndices.push(i);
                }
            }
            // Remove from highest index to lowest to avoid index shifting
            if (emptyIndices.length > 0) {
                const lowestRemovedIndex = emptyIndices[0];
                if (lowestRemovedIndex === undefined)
                    return;
                for (let i = emptyIndices.length - 1; i >= 0; i--) {
                    const indexToRemove = emptyIndices[i];
                    if (indexToRemove !== undefined) {
                        remove(indexToRemove);
                    }
                }
                // If we just edited this field, focus the name field at the same index
                // (which now contains what was the next row), or previous row if needed
                if (lastEditedIndexRef.current === lowestRemovedIndex) {
                    const newLength = watchedFields.length - emptyIndices.length;
                    if (lowestRemovedIndex < newLength) {
                        // Next row moved into this position, focus its name field
                        setFocus(`${name}.${lowestRemovedIndex}.name`);
                    }
                    else if (lowestRemovedIndex > 0) {
                        // Removed row was at the end, focus previous row's name
                        setFocus(`${name}.${lowestRemovedIndex - 1}.name`);
                    }
                    else {
                        setFocus(`${name}.0.name`);
                    }
                }
                lastEditedIndexRef.current = -1;
            }
        }
        // If last field has content, append empty one
        const lastField = watchedFields[watchedFields.length - 1];
        if (lastField && !isEmpty(lastField)) {
            // biome-ignore lint/suspicious/noExplicitAny: Generic field array type
            append(defaultValue, {
                shouldFocus: false,
            });
        }
    }, [
        watchedFields,
        append,
        remove,
        defaultValue,
        isEmpty,
        name,
        setFocus,
        shouldSetActive,
    ]);
    // Auto set active state of row checkbox
    useEffect(() => {
        if (!watchedFields)
            return;
        const updates = [];
        for (let i = 0; i < watchedFields.length; i++) {
            const field = watchedFields[i];
            if (!field)
                continue;
            const shouldBeActive = shouldSetActive(field);
            if (field.active === shouldBeActive)
                continue;
            updates.push(() => setValue(i, "active", shouldBeActive));
        }
        if (updates.length === 0)
            return;
        startTransition(() => updates.forEach((update) => update()));
    }, [watchedFields, shouldSetActive, setValue]);
    const isFieldEmpty = useCallback((index) => {
        const field = watchedFields?.[index];
        return field ? isEmpty(field) : true;
    }, [watchedFields, isEmpty]);
    const createKeyDownHandler = useCallback((index, field) => {
        const next = field === "name"
            ? `${name}.${index}.value`
            : `${name}.${index + 1}.name`;
        const previous = field === "name"
            ? `${name}.${index - 1}.value`
            : `${name}.${index}.name`;
        const canNavigatePrevious = field === "value" || index > 0;
        return (e) => {
            if (!(e.target instanceof HTMLInputElement))
                return;
            const isAtStart = e.target.selectionStart === 0;
            const isAtEnd = e.target.selectionStart === e.target.value.length;
            const isEmpty = !e.target.value;
            if (e.key === "Enter") {
                setFocus(next);
            }
            else if (e.key === "Backspace" && isEmpty && canNavigatePrevious) {
                e.preventDefault();
                setFocus(previous);
            }
            else if (e.key === "ArrowLeft" && isAtStart && canNavigatePrevious) {
                e.preventDefault();
                setFocus(previous);
            }
            else if (e.key === "ArrowRight" && isAtEnd) {
                e.preventDefault();
                setFocus(next);
            }
        };
    }, [name, setFocus]);
    const getNameInputProps = useCallback((index) => ({
        ...register(`${name}.${index}.name`),
        onChange: (e) => setValue(index, "name", e.target.value),
        onKeyDown: createKeyDownHandler(index, "name"),
    }), [register, name, setValue, createKeyDownHandler]);
    const getValueInputProps = useCallback((index) => ({
        ...register(`${name}.${index}.value`),
        onChange: (e) => setValue(index, "value", e.target.value),
        onKeyDown: createKeyDownHandler(index, "value"),
    }), [register, name, setValue, createKeyDownHandler]);
    const getCheckboxProps = useCallback((index) => ({
        ...register(`${name}.${index}.active`),
        checked: watch(`${name}.${index}.active`) ?? false,
        disabled: isFieldEmpty(index),
        onCheckedChange: (checked) => {
            setValue(index, "active", checked === true);
        },
    }), [name, register, isFieldEmpty, watch, setValue]);
    const getValue = useCallback((index, field) => watchedFields?.[index]?.[field], [watchedFields]);
    const getRemoveButtonProps = useCallback((index) => ({
        onClick: () => remove(index),
        disabled: index === fields.length - 1,
    }), [remove, fields.length]);
    return {
        fields,
        getNameInputProps,
        getValueInputProps,
        getCheckboxProps,
        getRemoveButtonProps,
        setValue,
        getValue,
    };
};
//# sourceMappingURL=useKeyValueFieldManager.js.map