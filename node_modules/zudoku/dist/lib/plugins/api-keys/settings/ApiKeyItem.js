import { jsx as _jsx, jsxs as _jsxs, Fragment as _Fragment } from "react/jsx-runtime";
import { useMutation, useQueryClient } from "@tanstack/react-query";
import { CheckIcon, CircleSlashIcon, PencilLineIcon, RefreshCwIcon, XIcon, } from "lucide-react";
import { AnimatePresence } from "motion/react";
import { useState } from "react";
import { Alert, AlertTitle } from "zudoku/ui/Alert.js";
import { Button } from "zudoku/ui/Button.js";
import { Dialog, DialogClose, DialogContent, DialogDescription, DialogFooter, DialogHeader, DialogTitle, DialogTrigger, } from "zudoku/ui/Dialog.js";
import { Frame, FrameDescription, FrameHeader, FramePanel, FrameTitle, } from "zudoku/ui/Frame.js";
import { Input } from "zudoku/ui/Input.js";
import { useZudoku } from "../../../components/context/ZudokuContext.js";
import { cn } from "../../../util/cn.js";
import { RevealApiKey } from "./RevealApiKey.js";
const ApiKeyItem = ({ consumer, onUpdate, onRollKey, onDeleteKey, }) => {
    const [isEditing, setIsEditing] = useState(false);
    const [editingLabel, setEditingLabel] = useState(consumer.label);
    const queryClient = useQueryClient();
    const context = useZudoku();
    const rollKeyMutation = useMutation({
        mutationFn: async (id) => {
            if (!onRollKey) {
                throw new Error("rollKey not implemented");
            }
            return await onRollKey?.(id, context);
        },
        onSuccess: () => void queryClient.invalidateQueries({ queryKey: ["api-keys"] }),
    });
    const deleteKeyMutation = useMutation({
        mutationFn: ({ consumerId, keyId, }) => {
            if (!onDeleteKey) {
                throw new Error("deleteKey not implemented");
            }
            return onDeleteKey(consumerId, keyId, context);
        },
        onMutate: async ({ consumerId, keyId }) => {
            await queryClient.cancelQueries({ queryKey: ["api-keys"] });
            const previousData = queryClient.getQueryData([
                "api-keys",
            ]);
            queryClient.setQueryData(["api-keys"], (old) => {
                if (!old) {
                    return old;
                }
                return old.map((consumer) => {
                    if (consumer.id === consumerId) {
                        return {
                            ...consumer,
                            apiKeys: consumer.apiKeys.filter((key) => key.id !== keyId),
                        };
                    }
                    return consumer;
                });
            });
            return { previousData };
        },
        onError: (_err, _variables, context) => {
            if (context?.previousData) {
                queryClient.setQueryData(["api-keys"], context.previousData);
            }
        },
        onSuccess: () => {
            void queryClient.invalidateQueries({ queryKey: ["api-keys"] });
        },
    });
    const updateConsumerMutation = useMutation({
        mutationFn: ({ consumerId, label, }) => {
            if (!onUpdate) {
                throw new Error("updateConsumer not implemented");
            }
            return onUpdate({ id: consumerId, label }, context);
        },
        onMutate: async ({ consumerId, label }) => {
            await queryClient.cancelQueries({ queryKey: ["api-keys"] });
            const previousData = queryClient.getQueryData(["api-keys"]);
            queryClient.setQueryData(["api-keys"], (old) => {
                if (!old) {
                    return old;
                }
                return old.map((consumer) => {
                    if (consumer.id === consumerId) {
                        return {
                            ...consumer,
                            label,
                        };
                    }
                    return consumer;
                });
            });
            return { previousData };
        },
        onError: (_err, _variables, context) => {
            if (context?.previousData) {
                queryClient.setQueryData(["api-keys"], context.previousData);
            }
        },
        onSuccess: () => {
            void queryClient.invalidateQueries({ queryKey: ["api-keys"] });
        },
    });
    const handleStartEdit = () => {
        setIsEditing(true);
        setEditingLabel(consumer.label);
    };
    const handleSaveEdit = () => {
        if (editingLabel.trim()) {
            updateConsumerMutation.mutate({
                label: editingLabel.trim(),
                consumerId: consumer.id,
            });
        }
        setIsEditing(false);
    };
    return (_jsxs(_Fragment, { children: [rollKeyMutation.isError && (_jsxs(Alert, { variant: "destructive", className: "mb-4", children: [_jsx(CircleSlashIcon, { size: 16 }), _jsx(AlertTitle, { children: rollKeyMutation.error.message })] })), updateConsumerMutation.isError && (_jsxs(Alert, { variant: "destructive", className: "mb-4", children: [_jsx(CircleSlashIcon, { size: 16 }), _jsx(AlertTitle, { children: updateConsumerMutation.error.message })] })), deleteKeyMutation.isError && (_jsxs(Alert, { variant: "destructive", className: "mb-4", children: [_jsx(CircleSlashIcon, { size: 16 }), _jsx(AlertTitle, { children: deleteKeyMutation.error.message })] })), _jsxs(Frame, { className: "grid grid-cols-subgrid col-span-full items-center mb-4 group", children: [_jsxs(FrameHeader, { className: "col-span-full flex-row items-start justify-between gap-4", children: [_jsxs("div", { className: "flex flex-col gap-1", children: [isEditing ? (_jsxs("div", { className: "flex items-center gap-2", children: [_jsx(Input, { maxLength: 32, value: editingLabel, onChange: (e) => setEditingLabel(e.target.value), onKeyDown: (e) => {
                                                    if (e.key === "Enter") {
                                                        handleSaveEdit();
                                                    }
                                                    else if (e.key === "Escape") {
                                                        setIsEditing(false);
                                                    }
                                                }, autoFocus: true }), _jsxs("div", { className: "flex items-center", children: [_jsx(Button, { size: "icon", variant: "ghost", onClick: handleSaveEdit, disabled: !editingLabel.trim(), children: _jsx(CheckIcon, { size: 16 }) }), _jsx(Button, { size: "icon", variant: "ghost", onClick: () => setIsEditing(false), children: _jsx(XIcon, { size: 16 }) })] })] })) : (_jsx(FrameTitle, { children: consumer.label })), _jsxs(FrameDescription, { children: [consumer.createdOn && (_jsxs("div", { children: ["Created on ", new Date(consumer.createdOn).toLocaleDateString()] })), consumer.expiresOn && (_jsxs("div", { children: ["Expires on ", new Date(consumer.expiresOn).toLocaleDateString()] }))] })] }), _jsxs("div", { className: "flex gap-1", children: [onUpdate && (_jsxs(Button, { variant: "ghost", onClick: handleStartEdit, className: cn("flex gap-2", isEditing && "opacity-0! pointer-events-none"), disabled: isEditing, children: [_jsx(PencilLineIcon, { size: 16 }), _jsx("span", { className: "hidden md:block", children: "Edit label" })] })), onRollKey && (_jsxs(Dialog, { children: [_jsx(DialogTrigger, { asChild: true, children: _jsxs(Button, { title: "Roll this key", variant: "ghost", disabled: rollKeyMutation.isPending, className: "flex items-center gap-2", children: [_jsx(RefreshCwIcon, { size: 16, className: rollKeyMutation.isPending ? "animate-spin" : undefined }), _jsx("span", { className: "hidden md:block", children: "Roll key" })] }) }), _jsxs(DialogContent, { children: [_jsxs(DialogHeader, { children: [_jsx(DialogTitle, { children: "Roll API Key" }), _jsx(DialogDescription, { children: "Are you sure you want to roll this API key?" })] }), _jsxs(DialogFooter, { children: [_jsx(DialogClose, { asChild: true, children: _jsx(Button, { variant: "outline", children: "Cancel" }) }), _jsx(DialogClose, { asChild: true, children: _jsx(Button, { onClick: () => {
                                                                        rollKeyMutation.mutate(consumer.id);
                                                                    }, children: "Roll Key" }) })] })] })] }))] })] }), _jsx(FramePanel, { className: "p-0 grid grid-cols-subgrid col-span-full divide-y divide-border", children: _jsx(AnimatePresence, { children: consumer.apiKeys.map((apiKey) => (_jsx(RevealApiKey, { apiKey: apiKey, onDeleteKey: () => {
                                    deleteKeyMutation.mutate({
                                        consumerId: consumer.id,
                                        keyId: apiKey.id,
                                    });
                                }, className: deleteKeyMutation.variables?.keyId === apiKey.id &&
                                    deleteKeyMutation.isPending
                                    ? "opacity-10!"
                                    : undefined }, apiKey.id))) }) })] }, consumer.id)] }));
};
export default ApiKeyItem;
//# sourceMappingURL=ApiKeyItem.js.map