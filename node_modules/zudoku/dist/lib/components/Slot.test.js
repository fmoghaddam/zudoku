import { jsx as _jsx, Fragment as _Fragment, jsxs as _jsxs } from "react/jsx-runtime";
import { QueryClient, QueryClientProvider } from "@tanstack/react-query";
import { act, screen, render as testRender, } from "@testing-library/react";
import { useEffect, useState } from "react";
import { MemoryRouter } from "react-router";
import { describe, expect, it } from "vitest";
import { ZudokuContext } from "../core/ZudokuContext.js";
import { SlotProvider } from "./context/SlotProvider.js";
import { ZudokuProvider } from "./context/ZudokuProvider.js";
import { Slot } from "./Slot.js";
/**
 * @vitest-environment happy-dom
 */
const createWrapper = (slots = {}) => {
    const queryClient = new QueryClient();
    const context = new ZudokuContext({}, queryClient, {});
    const wrapper = ({ children }) => (_jsx(MemoryRouter, { initialEntries: ["/", "/page"], children: _jsx(QueryClientProvider, { client: queryClient, children: _jsx(ZudokuProvider, { context: context, children: _jsx(SlotProvider, { slots: slots, children: children }) }) }) }));
    return { context, wrapper };
};
// We wrap every render function with `act` because of Suspense:
// https://github.com/testing-library/react-testing-library/issues/1375
const render = async (element, slots = {}) => {
    let renderResult;
    const { wrapper } = createWrapper(slots);
    await act(async () => {
        renderResult = testRender(element, { wrapper });
    });
    return renderResult;
};
describe("Slot", () => {
    describe("Slot.Target", () => {
        it("renders fallback when no slot content is provided", async () => {
            await render(_jsx(Slot.Target, { name: "footer-after", fallback: _jsx("div", { children: "Fallback content" }) }));
            expect(screen.getByText("Fallback content")).toBeInTheDocument();
        });
        it("renders nothing when no slot content and no fallback", async () => {
            const { container } = await render(_jsx(Slot.Target, { name: "footer-after" }));
            expect(container.firstChild).toBeNull();
        });
        it("renders slot content when provided via SlotProvider", async () => {
            await render(_jsx(Slot.Target, { name: "footer-after", fallback: _jsx("div", { children: "Fallback content" }) }), { "footer-after": _jsx("div", { children: "Provider content" }) });
            expect(screen.getByText("Provider content")).toBeInTheDocument();
            expect(screen.queryByText("Fallback content")).not.toBeInTheDocument();
        });
    });
    describe("Slot.Source", () => {
        it("renders content in target slot with replace type (default)", async () => {
            await render(_jsxs(_Fragment, { children: [_jsx(Slot.Source, { name: "footer-after", children: _jsx("div", { children: "Source content" }) }), _jsx(Slot.Target, { name: "footer-after", fallback: _jsx("div", { children: "Fallback content" }) })] }));
            expect(screen.getByText("Source content")).toBeInTheDocument();
            expect(screen.queryByText("Fallback content")).not.toBeInTheDocument();
        });
        it("renders content in target slot with explicit replace type", async () => {
            await render(_jsxs(_Fragment, { children: [_jsx(Slot.Source, { name: "footer-after", type: "replace", children: _jsx("div", { children: "Replace content" }) }), _jsx(Slot.Target, { name: "footer-after" })] }));
            expect(screen.getByText("Replace content")).toBeInTheDocument();
        });
        it("prepends content when type is prepend", async () => {
            const { container } = await render(_jsxs(_Fragment, { children: [_jsx(Slot.Source, { name: "footer-after", type: "prepend", children: _jsx("span", { children: "Prepended" }) }), _jsx(Slot.Target, { name: "footer-after" })] }), {
                "footer-after": _jsx("span", { children: "Original" }),
            });
            expect(container.textContent).toBe("PrependedOriginal");
        });
        it("appends content when type is append", async () => {
            const { container } = await render(_jsxs(_Fragment, { children: [_jsx(Slot.Source, { name: "footer-after", type: "append", children: _jsx("span", { children: "Appended" }) }), _jsx(Slot.Target, { name: "footer-after" })] }), { "footer-after": _jsx("span", { children: "Original" }) });
            expect(container.textContent).toBe("OriginalAppended");
        });
        it("handles multiple sources with different types in correct order", async () => {
            const { container } = await render(_jsxs(_Fragment, { children: [_jsx(Slot.Source, { name: "footer-after", type: "append", children: _jsx("span", { children: "Appended" }) }), _jsx(Slot.Source, { name: "footer-after", type: "prepend", children: _jsx("span", { children: "Prepended" }) }), _jsx(Slot.Target, { name: "footer-after" })] }), {
                "footer-after": _jsx("span", { children: "Original" }),
            });
            expect(container.textContent).toBe("PrependedOriginalAppended");
        });
        it("replaces content when multiple replace sources are provided", async () => {
            await render(_jsxs(_Fragment, { children: [_jsx(Slot.Source, { name: "footer-after", type: "replace", children: _jsx("span", { children: "First replace" }) }), _jsx(Slot.Source, { name: "footer-after", type: "replace", children: _jsx("span", { children: "Second replace" }) }), _jsx(Slot.Target, { name: "footer-after" })] }));
            expect(screen.getByText("Second replace")).toBeInTheDocument();
            expect(screen.queryByText("First replace")).not.toBeInTheDocument();
        });
        it("cleans up slot content when component unmounts", async () => {
            const { rerender } = await render(_jsxs(_Fragment, { children: [_jsx(Slot.Source, { name: "footer-after", children: _jsx("div", { children: "Source content" }) }), _jsx(Slot.Target, { name: "footer-after", fallback: _jsx("div", { children: "Fallback content" }) })] }));
            expect(screen.getByText("Source content")).toBeInTheDocument();
            rerender(_jsx(Slot.Target, { name: "footer-after", fallback: _jsx("div", { children: "Fallback content" }) }));
            expect(screen.getByText("Fallback content")).toBeInTheDocument();
            expect(screen.queryByText("Source content")).not.toBeInTheDocument();
        });
        it("handles multiple prepend sources in correct order", async () => {
            const { container } = await render(_jsxs(_Fragment, { children: [_jsx(Slot.Source, { name: "footer-after", type: "prepend", children: _jsx("span", { children: "First prepend" }) }), _jsx(Slot.Source, { name: "footer-after", type: "prepend", children: _jsx("span", { children: "Second prepend" }) }), _jsx(Slot.Target, { name: "footer-after" })] }), { "footer-after": _jsx("span", { children: "Original" }) });
            expect(container.textContent).toBe("Second prependFirst prependOriginal");
        });
        it("handles multiple append sources in correct order", async () => {
            const { container } = await render(_jsxs(_Fragment, { children: [_jsx(Slot.Source, { name: "footer-after", type: "append", children: _jsx("span", { children: "First append" }) }), _jsx(Slot.Source, { name: "footer-after", type: "append", children: _jsx("span", { children: "Second append" }) }), _jsx(Slot.Target, { name: "footer-after" })] }), { "footer-after": _jsx("span", { children: "Original" }) });
            expect(container.textContent).toBe("OriginalFirst appendSecond append");
        });
        it("handles empty children in Source", async () => {
            const { container } = await render(_jsxs(_Fragment, { children: [_jsx(Slot.Source, { name: "footer-after", children: null }), _jsx(Slot.Target, { name: "footer-after", fallback: _jsx("span", { children: "Fallback" }) })] }));
            // Empty children should be ignored, showing fallback
            expect(container.textContent).toBe("Fallback");
        });
        it("renders content when Target is defined before Source", async () => {
            await render(_jsxs(_Fragment, { children: [_jsx(Slot.Target, { name: "footer-after" }), _jsx(Slot.Source, { name: "footer-after", children: _jsx("div", { children: "Source content" }) })] }));
            expect(screen.getByText("Source content")).toBeInTheDocument();
        });
        it("renders content when Source is defined before Target", async () => {
            await render(_jsxs(_Fragment, { children: [_jsx(Slot.Source, { name: "footer-after", children: _jsx("div", { children: "Source content" }) }), _jsx(Slot.Target, { name: "footer-after" })] }));
            expect(screen.getByText("Source content")).toBeInTheDocument();
        });
    });
    describe("Multiple slots", () => {
        it("handles multiple independent slots", async () => {
            await render(_jsxs(_Fragment, { children: [_jsx(Slot.Source, { name: "footer-before", children: _jsx("div", { children: "Content 1" }) }), _jsx(Slot.Source, { name: "footer-after", children: _jsx("div", { children: "Content 2" }) }), _jsx(Slot.Target, { name: "footer-before" }), _jsx(Slot.Target, { name: "footer-after" })] }));
            expect(screen.getByText("Content 1")).toBeInTheDocument();
            expect(screen.getByText("Content 2")).toBeInTheDocument();
        });
        it("handles slots with same name but different targets", async () => {
            await render(_jsxs(_Fragment, { children: [_jsx(Slot.Source, { name: "footer-after", children: _jsx("div", { children: "Shared content" }) }), _jsx("div", { "data-testid": "target-1", children: _jsx(Slot.Target, { name: "footer-after" }) }), _jsx("div", { "data-testid": "target-2", children: _jsx(Slot.Target, { name: "footer-after" }) })] }));
            const targets = screen.getAllByText("Shared content");
            expect(targets).toHaveLength(2);
        });
        it("handles nested slots", async () => {
            await render(_jsxs(_Fragment, { children: [_jsx(Slot.Source, { name: "content-before", children: _jsxs("div", { children: ["Outer content", _jsx(Slot.Source, { name: "content-after", children: _jsx("div", { children: "Inner content" }) })] }) }), _jsx(Slot.Target, { name: "content-before" }), _jsx(Slot.Target, { name: "content-after" })] }));
            expect(screen.getByText("Outer content")).toBeInTheDocument();
            expect(screen.getByText("Inner content")).toBeInTheDocument();
        });
    });
    describe("Edge cases", () => {
        it("handles deep nesting of slots", async () => {
            await render(_jsxs(_Fragment, { children: [_jsx(Slot.Source, { name: "content-before", children: _jsxs("div", { children: ["Level 1", _jsx(Slot.Source, { name: "content-after", children: _jsxs("div", { children: ["Level 2", _jsx(Slot.Source, { name: "navigation-before", children: _jsx("div", { children: "Level 3" }) })] }) })] }) }), _jsx(Slot.Target, { name: "content-before" }), _jsx(Slot.Target, { name: "content-after" }), _jsx(Slot.Target, { name: "navigation-before" })] }));
            expect(screen.getByText("Level 1")).toBeInTheDocument();
            expect(screen.getByText("Level 2")).toBeInTheDocument();
            expect(screen.getByText("Level 3")).toBeInTheDocument();
        });
        it("handles many slots", async () => {
            const manySlots = Array.from({ length: 50 }, (_, i) => `slot-${i}`);
            await render(_jsxs(_Fragment, { children: [manySlots.map((name) => (
                    // biome-ignore lint/suspicious/noExplicitAny: Allow any type
                    _jsx(Slot.Source, { name: name, children: _jsxs("div", { children: ["Content ", name] }) }, name))), manySlots.map((name) => (
                    // biome-ignore lint/suspicious/noExplicitAny: Allow any type
                    _jsx(Slot.Target, { name: name }, name)))] }));
            manySlots.forEach((name) => {
                expect(screen.getByText(`Content ${name}`)).toBeInTheDocument();
            });
        });
    });
    describe("Integration cases", () => {
        it("handles updates", async () => {
            const { rerender } = await render(_jsxs(_Fragment, { children: [_jsx(Slot.Source, { name: "content-before", children: _jsx("div", { children: "Initial content" }) }), _jsx(Slot.Target, { name: "content-before" })] }));
            expect(screen.getByText("Initial content")).toBeInTheDocument();
            rerender(_jsxs(_Fragment, { children: [_jsx(Slot.Source, { name: "content-before", children: _jsx("div", { children: "Updated content" }) }), _jsx(Slot.Target, { name: "content-before" })] }));
            expect(screen.getByText("Updated content")).toBeInTheDocument();
        });
        it("handles async content", async () => {
            vi.useFakeTimers();
            const AsyncContent = () => {
                const [content, setContent] = useState("Loading...");
                useEffect(() => {
                    setTimeout(() => setContent("Loaded content"), 250);
                }, []);
                return _jsx("div", { children: content });
            };
            await render(_jsxs(_Fragment, { children: [_jsx(Slot.Source, { name: "content-before", children: _jsx(AsyncContent, {}) }), _jsx(Slot.Target, { name: "content-before" })] }));
            expect(screen.getByText("Loading...")).toBeInTheDocument();
            await act(async () => {
                vi.advanceTimersToNextTimer();
            });
            expect(screen.getByText("Loaded content")).toBeInTheDocument();
            vi.useRealTimers();
        });
        it("renders render functions", async () => {
            await render(_jsxs(_Fragment, { children: [_jsx(Slot.Source, { name: "content-before", children: (props) => `Current path: ${props.location.pathname}` }), _jsx(Slot.Target, { name: "content-before" })] }), {});
            expect(screen.getByText("Current path: /page")).toBeInTheDocument();
        });
    });
});
//# sourceMappingURL=Slot.test.js.map