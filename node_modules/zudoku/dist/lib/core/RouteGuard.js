import { jsx as _jsx, jsxs as _jsxs, Fragment as _Fragment } from "react/jsx-runtime";
import { Helmet } from "@zudoku/react-helmet-async";
import { use, useCallback, useEffect, useMemo } from "react";
import { matchPath, Outlet, useBlocker, useLocation, useNavigate, } from "react-router";
import { Button } from "zudoku/ui/Button.js";
import { Dialog, DialogContent, DialogDescription, DialogFooter, DialogHeader, DialogTitle, } from "zudoku/ui/Dialog.js";
import { useAuth } from "../authentication/hook.js";
import { BypassProtectedRoutesContext } from "../components/context/BypassProtectedRoutesContext.js";
import { useZudoku } from "../components/context/ZudokuContext.js";
import { ZudokuError } from "../util/invariant.js";
export const SEARCH_PROTECTED_SECTION = "protected";
const LoginDialog = ({ open, onCancel, onLogin, onRegister, }) => (_jsx(Dialog, { open: open, onOpenChange: (nextOpen) => !nextOpen && onCancel(), children: _jsxs(DialogContent, { children: [_jsx(DialogHeader, { children: _jsx(DialogTitle, { children: "Login to continue" }) }), _jsx(DialogDescription, { children: "Please login to access this page." }), _jsxs(DialogFooter, { children: [_jsx(Button, { variant: "outline", onClick: onCancel, children: "Cancel" }), _jsx("div", { className: "w-full" }), _jsx(Button, { variant: "secondary", onClick: onRegister, children: "Register" }), _jsx(Button, { onClick: onLogin, children: "Login" })] })] }) }));
const BypassRoute = ({ isProtectedRoute }) => (_jsxs(_Fragment, { children: [isProtectedRoute && (_jsx(Helmet, { children: _jsx("meta", { name: "pagefind", "data-pagefind-filter": `section:${SEARCH_PROTECTED_SECTION}`, content: "true" }) })), _jsx(Outlet, {})] }));
export const RouteGuard = () => {
    const auth = useAuth();
    const zudoku = useZudoku();
    const navigate = useNavigate();
    const location = useLocation();
    const shouldBypass = use(BypassProtectedRoutesContext);
    const authCheckContext = useMemo(() => ({ auth, context: zudoku }), [auth, zudoku]);
    const { protectedRoutes } = zudoku;
    const getAuthCheck = useCallback((pathname) => {
        if (!protectedRoutes)
            return;
        for (const [pattern, check] of Object.entries(protectedRoutes)) {
            if (matchPath({ path: pattern, end: true }, pathname)) {
                return check;
            }
        }
    }, [protectedRoutes]);
    const currentAuthCheck = getAuthCheck(location.pathname);
    const isProtectedRoute = currentAuthCheck !== undefined;
    const isAuthorized = currentAuthCheck?.(authCheckContext) ?? true;
    const needsToSignIn = isProtectedRoute && !isAuthorized;
    const blocker = useBlocker(({ nextLocation }) => {
        if (shouldBypass)
            return false;
        const check = getAuthCheck(nextLocation.pathname);
        return check !== undefined && !check(authCheckContext);
    });
    const isBlocked = blocker.state === "blocked";
    const intendedPath = isBlocked ? blocker.location.pathname : undefined;
    // Proceed after successful login
    useEffect(() => {
        if (!auth.isAuthenticated || !intendedPath)
            return;
        const check = getAuthCheck(intendedPath);
        if (!check || check(authCheckContext)) {
            blocker.proceed?.();
        }
    }, [
        auth.isAuthenticated,
        intendedPath,
        blocker,
        authCheckContext,
        getAuthCheck,
    ]);
    if (shouldBypass) {
        return _jsx(BypassRoute, { isProtectedRoute: isProtectedRoute });
    }
    if (isProtectedRoute && !auth.isAuthEnabled) {
        throw new ZudokuError("Authentication is not enabled", {
            title: "Authentication is not enabled",
            developerHint: "To use protectedRoutes you need authentication to be enabled",
        });
    }
    if (needsToSignIn && auth.isPending && typeof window !== "undefined") {
        return null;
    }
    const showDialog = needsToSignIn || isBlocked;
    const redirectTo = intendedPath ?? location.pathname;
    return (_jsxs(_Fragment, { children: [!needsToSignIn && _jsx(Outlet, {}), _jsx(LoginDialog, { open: showDialog, onCancel: needsToSignIn ? () => navigate(-1) : () => blocker.reset?.(), onLogin: () => void auth.login({ redirectTo }), onRegister: () => void auth.signup({ redirectTo }) })] }));
};
//# sourceMappingURL=RouteGuard.js.map