import type { QueryClient } from "@tanstack/react-query";
import type { ReactNode } from "react";
import type { Location } from "react-router";
import type { BundledTheme, HighlighterCore } from "shiki";
import type { z } from "zod";
import type { Navigation } from "../../config/validators/NavigationSchema.js";
import type { CallbackContext, ProtectedRoutesInput } from "../../config/validators/ProtectedRoutesSchema.js";
import type { FooterSchema } from "../../config/validators/validate.js";
import type { AuthenticationPlugin } from "../authentication/authentication.js";
import { type AuthState } from "../authentication/state.js";
import type { ComponentsContextType } from "../components/context/ComponentsContext.js";
import type { SlotType } from "../components/context/SlotProvider.js";
import type { MdxComponentsType } from "../util/MdxComponents.js";
import { type ProfileNavigationItem, type ZudokuPlugin } from "./plugins.js";
export interface ZudokuEvents {
    location: (event: {
        from?: Location;
        to: Location;
    }) => void;
    auth: (auth: {
        prev: AuthState;
        next: AuthState;
    }) => void;
}
export interface ApiIdentity {
    authorizeRequest: (request: Request) => Promise<Request> | Request;
    authorizationFields?: {
        headers?: string[];
        queryParams?: string[];
    };
    label: string;
    id: string;
}
export type ApiKeyCache = "api-keys";
type Metadata = Partial<{
    title: string;
    defaultTitle?: string;
    description: string;
    logo: string;
    favicon: string;
    generator: string;
    applicationName: string;
    referrer: string;
    keywords: string[];
    authors: string[];
    creator: string;
    publisher: string;
}>;
type Site = Partial<{
    dir?: "ltr" | "rtl";
    showPoweredBy?: boolean;
    title?: string;
    logo?: {
        src: {
            light: string;
            dark: string;
        };
        width?: string | number;
        alt?: string;
        href?: string;
    };
    banner?: {
        message: ReactNode;
        color?: "note" | "tip" | "info" | "caution" | "danger" | (string & {});
        dismissible?: boolean;
    };
    footer?: z.infer<typeof FooterSchema>;
}>;
export type ZudokuContextOptions = {
    basePath?: string;
    canonicalUrlOrigin?: string;
    metadata?: Metadata;
    site?: Site;
    authentication?: AuthenticationPlugin;
    navigation?: Navigation;
    plugins?: ZudokuPlugin[];
    slots?: Record<string, SlotType>;
    /**
     * @deprecated Use `slots` instead
     */
    UNSAFE_slotlets?: Record<string, SlotType>;
    mdx?: {
        components?: MdxComponentsType;
    };
    overrides?: ComponentsContextType;
    protectedRoutes?: ProtectedRoutesInput;
    syntaxHighlighting?: {
        highlighter: HighlighterCore;
        themes?: {
            light: BundledTheme;
            dark: BundledTheme;
        };
    };
};
export declare const normalizeProtectedRoutes: (val: ProtectedRoutesInput) => Record<string, (c: CallbackContext) => boolean> | undefined;
export declare class ZudokuContext {
    readonly authentication?: AuthenticationPlugin;
    readonly getAuthState: () => AuthState;
    readonly queryClient: QueryClient;
    readonly options: ZudokuContextOptions;
    readonly env: Record<string, string | undefined>;
    readonly protectedRoutes: ReturnType<typeof normalizeProtectedRoutes>;
    private readonly plugins;
    private readonly emitter;
    constructor(options: ZudokuContextOptions, queryClient: QueryClient, env: Record<string, string | undefined>);
    initialize: () => Promise<void>;
    getApiIdentities: () => Promise<ApiIdentity[]>;
    addEventListener<E extends keyof ZudokuEvents>(event: E, callback: ZudokuEvents[E]): import("nanoevents").Unsubscribe;
    emitEvent: <E extends keyof ZudokuEvents>(event: E, ...data: Parameters<ZudokuEvents[E]>) => void;
    getPluginNavigation: (path: string) => Promise<import("../../config/validators/NavigationSchema.js").NavigationItem[]>;
    getProfileMenuItems: () => ProfileNavigationItem[];
    signRequest: (request: Request) => Promise<Request>;
}
export {};
