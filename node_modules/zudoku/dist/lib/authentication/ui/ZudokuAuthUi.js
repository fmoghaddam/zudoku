import { jsx as _jsx, jsxs as _jsxs, Fragment as _Fragment } from "react/jsx-runtime";
import { useMutation } from "@tanstack/react-query";
import React from "react";
import { useForm } from "react-hook-form";
import { Link, useNavigate, useSearchParams } from "react-router";
import { ActionButton } from "zudoku/ui/ActionButton.js";
import { Alert, AlertDescription, AlertTitle } from "zudoku/ui/Alert.js";
import { Button } from "zudoku/ui/Button.js";
import { Card, CardContent, CardDescription, CardHeader, CardTitle, } from "zudoku/ui/Card.js";
import { Input } from "zudoku/ui/Input.js";
import { Separator } from "zudoku/ui/Separator.js";
import { Form, FormControl, FormItem, FormLabel, FormMessage, } from "../../ui/Form.js";
import { cn } from "../../util/cn.js";
import createVariantComponent from "../../util/createVariantComponent.js";
import { getRelativeRedirectUrl } from "../utils/relativeRedirectUrl.js";
import AppleIcon from "./icons/Apple.js";
import FacebookIcon from "./icons/Facebook.js";
import GithubIcon from "./icons/Github.js";
import GoogleIcon from "./icons/Google.js";
import MicrosoftIcon from "./icons/Microsoft.js";
import XIcon from "./icons/X.js";
export const AUTH_PROVIDER_NAMES = {
    google: "Google",
    github: "GitHub",
    facebook: "Facebook",
    twitter: "X",
    x: "X",
    microsoft: "Microsoft",
    apple: "Apple",
    yahoo: "Yahoo",
};
const ProviderIcons = {
    google: GoogleIcon,
    github: GithubIcon,
    facebook: FacebookIcon,
    twitter: XIcon,
    x: XIcon,
    apple: AppleIcon,
    microsoft: MicrosoftIcon,
    yahoo: React.Fragment,
};
const isValidAuthProviderId = (provider) => {
    return provider in ProviderIcons;
};
const isAuthProviderIdArray = (providers) => {
    return providers.every(isValidAuthProviderId);
};
const AuthProviderButton = ({ providerId, onClick, ...buttonProps }) => {
    const IconRenderer = ProviderIcons[providerId];
    return (_jsxs(Button, { variant: "outline", className: "gap-2", onClick: onClick, ...buttonProps, children: [_jsx(IconRenderer, { className: "w-4 h-4 fill-foreground" }), AUTH_PROVIDER_NAMES[providerId]] }));
};
const EmailPasswordForm = ({ form, onSubmit, submitLabel, isPending, }) => {
    return (_jsx(Form, { ...form, children: _jsxs("form", { onSubmit: form.handleSubmit(onSubmit), className: "flex flex-col gap-2", children: [_jsxs(FormItem, { children: [_jsx(FormLabel, { children: "E-Mail" }), _jsx(FormControl, { children: _jsx(Input, { placeholder: "Email", ...form.register("email") }) }), _jsx(FormMessage, {})] }), _jsxs(FormItem, { children: [_jsx(FormLabel, { children: "Password" }), _jsx(FormControl, { children: _jsx(Input, { placeholder: "Password", ...form.register("password"), type: "password" }) }), _jsx(FormMessage, {})] }), _jsx(ActionButton, { type: "submit", isPending: isPending, children: submitLabel })] }) }));
};
export const ZudokuSignInUi = ({ providers, onOAuthSignIn, onUsernamePasswordSignIn, enableUsernamePassword, }) => {
    const navigate = useNavigate();
    const [searchParams] = useSearchParams();
    const redirectTo = searchParams.get("redirectTo");
    const relativeRedirectTo = getRelativeRedirectUrl(redirectTo);
    const invalidProviders = providers.filter((provider) => !isValidAuthProviderId(provider));
    if (invalidProviders.length > 0) {
        throw new Error(`Unsupported auth provider: ${invalidProviders.join(", ")}`);
    }
    if (!isAuthProviderIdArray(providers)) {
        throw new Error(`Unsupported auth provider: ${providers.join(", ")}`);
    }
    const signInUsernameMutation = useMutation({
        mutationFn: async ({ email, password }) => {
            await onUsernamePasswordSignIn(email, password);
        },
        onSuccess: () => {
            void navigate(relativeRedirectTo);
        },
    });
    const signInByProviderMutation = useMutation({
        mutationFn: async ({ providerId }) => {
            await onOAuthSignIn(providerId);
        },
        onSuccess: () => {
            void navigate(relativeRedirectTo);
        },
    });
    const form = useForm({
        defaultValues: {
            email: "",
            password: "",
        },
    });
    const pending = signInUsernameMutation.isPending || signInByProviderMutation.isPending;
    const error = signInUsernameMutation.error ?? signInByProviderMutation.error;
    return (_jsxs(AuthCard, { children: [_jsxs(CardHeader, { children: [_jsx(CardTitle, { children: "Sign in" }), _jsx(CardDescription, { children: "Sign in to your account to continue." })] }), _jsxs(CardContent, { className: "flex flex-col gap-4", children: [error && (_jsxs(Alert, { variant: "destructive", children: [_jsx(AlertTitle, { children: "Error" }), _jsx(AlertDescription, { children: error?.message })] })), enableUsernamePassword && (_jsxs(_Fragment, { children: [_jsx(EmailPasswordForm, { form: form, onSubmit: (data) => void signInUsernameMutation.mutate({
                                    email: data.email,
                                    password: data.password,
                                }), submitLabel: "Sign in", isPending: pending }), _jsx(Link, { to: "/reset-password", className: "text-sm text-muted-foreground text-right -mt-2", children: "Forgot password?" })] })), enableUsernamePassword && providers.length > 0 && (_jsx(ProviderSeparator, { providers: providers })), providers.length > 0 && (_jsx(ProviderButtons, { providers: providers, onClick: (providerId) => signInByProviderMutation.mutate({ providerId }) })), _jsx(Link, { to: "/signup", className: "text-sm text-muted-foreground", children: "Don't have an account? Sign up." })] })] }));
};
export const ZudokuSignUpUi = ({ providers, enableUsernamePassword, onOAuthSignUp, onUsernamePasswordSignUp, }) => {
    const navigate = useNavigate();
    const [searchParams] = useSearchParams();
    const redirectTo = searchParams.get("redirectTo");
    const relativeRedirectTo = redirectTo?.replace(window.location.origin, "");
    if (!isAuthProviderIdArray(providers)) {
        throw new Error("Invalid auth provider IDs");
    }
    const signUpUsernameMutation = useMutation({
        mutationFn: async ({ email, password }) => {
            await onUsernamePasswordSignUp(email, password);
        },
        onSuccess: () => {
            void navigate(relativeRedirectTo ?? "/");
        },
    });
    const signUpByProviderMutation = useMutation({
        mutationFn: async ({ providerId }) => {
            await onOAuthSignUp(providerId);
        },
        onSuccess: () => {
            void navigate(relativeRedirectTo ?? "/");
        },
    });
    const form = useForm({
        defaultValues: {
            email: "",
            password: "",
        },
    });
    const pending = signUpUsernameMutation.isPending || signUpByProviderMutation.isPending;
    const error = signUpUsernameMutation.error ?? signUpByProviderMutation.error;
    return (_jsxs(AuthCard, { children: [_jsxs(CardHeader, { children: [_jsx(CardTitle, { children: "Sign up" }), _jsx(CardDescription, { children: "Sign up to your account to continue." })] }), _jsxs(CardContent, { className: "flex flex-col gap-4", children: [error && (_jsxs(Alert, { variant: "destructive", children: [_jsx(AlertTitle, { children: "Error" }), _jsx(AlertDescription, { children: error?.message })] })), enableUsernamePassword && (_jsx(EmailPasswordForm, { form: form, onSubmit: (data) => void signUpUsernameMutation.mutate({
                            email: data.email,
                            password: data.password,
                        }), submitLabel: "Sign up", isPending: pending })), enableUsernamePassword && providers.length > 0 && (_jsx(ProviderSeparator, { providers: providers })), providers.length > 0 && (_jsx(ProviderButtons, { providers: providers, onClick: (providerId) => signUpByProviderMutation.mutate({ providerId }) })), _jsx(Link, { to: "/signin", className: "text-sm text-muted-foreground", children: "Already have an account? Sign in." })] })] }));
};
const AuthCard = createVariantComponent(Card, "max-w-md w-full mt-10 mx-auto");
const ProviderButtons = ({ providers, onClick, }) => {
    return (_jsx("div", { className: cn("grid grid-cols-2 gap-2", providers.length % 2 === 0 ? "grid-cols-2" : "grid-cols-1"), children: providers.map((provider) => (_jsx(AuthProviderButton, { providerId: provider, onClick: () => onClick(provider) }, provider))) }));
};
const ProviderSeparator = ({ providers }) => {
    return (providers.length > 0 && (_jsx(Separator, { className: "my-3 relative", children: _jsx("span", { className: "bg-card text-muted-foreground text-sm px-2 absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2", children: "or continue with" }) })));
};
export const ZudokuPasswordResetUi = ({ onPasswordReset, }) => {
    const [isSubmitted, setIsSubmitted] = React.useState(false);
    const passwordResetMutation = useMutation({
        mutationFn: async ({ email }) => {
            await onPasswordReset(email);
        },
        onSuccess: () => {
            setIsSubmitted(true);
        },
    });
    const form = useForm({
        defaultValues: {
            email: "",
        },
    });
    const error = passwordResetMutation.error;
    return (_jsxs(AuthCard, { children: [_jsxs(CardHeader, { children: [_jsx(CardTitle, { children: "Reset password" }), _jsx(CardDescription, { children: isSubmitted
                            ? "Check your email for a password reset link."
                            : "Enter your email address and we'll send you a link to reset your password." })] }), _jsxs(CardContent, { className: "flex flex-col gap-4", children: [error && (_jsxs(Alert, { variant: "destructive", children: [_jsx(AlertTitle, { children: "Error" }), _jsx(AlertDescription, { children: error?.message })] })), isSubmitted ? (_jsxs("div", { className: "flex flex-col gap-4", children: [_jsxs(Alert, { children: [_jsx(AlertTitle, { children: "Email sent" }), _jsx(AlertDescription, { children: "If an account exists with that email address, you will receive a password reset link shortly." })] }), _jsx(Link, { to: "/signin", children: _jsx(Button, { variant: "outline", className: "w-full", children: "Back to sign in" }) })] })) : (_jsxs(_Fragment, { children: [_jsx(Form, { ...form, children: _jsxs("form", { onSubmit: form.handleSubmit((data) => passwordResetMutation.mutate({ email: data.email })), className: "flex flex-col gap-2", children: [_jsxs(FormItem, { children: [_jsx(FormLabel, { children: "Email" }), _jsx(FormControl, { children: _jsx(Input, { placeholder: "you@example.com", ...form.register("email") }) }), _jsx(FormMessage, {})] }), _jsx(ActionButton, { type: "submit", isPending: passwordResetMutation.isPending, children: "Reset password" })] }) }), _jsx(Link, { to: "/signin", className: "text-sm text-muted-foreground", children: "Sign in" })] }))] })] }));
};
//# sourceMappingURL=ZudokuAuthUi.js.map