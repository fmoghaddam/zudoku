import path from "node:path";
import { glob } from "glob";
import { readFrontmatter } from "../../lib/util/readFrontmatter.js";
import { DocsConfigSchema } from "./validate.js";
const extractTitleFromContent = (content) => content.match(/^\s*#\s(.*)$/m)?.at(1);
const isNavigationItem = (item) => item !== undefined;
const toPosixPath = (filePath) => filePath.split(path.win32.sep).join(path.posix.sep);
export class NavigationResolver {
    rootDir;
    globPatterns;
    globFiles = [];
    items = [];
    itemIndex = 0;
    constructor(config) {
        this.rootDir = config.__meta.rootDir;
        this.globPatterns = DocsConfigSchema.parse(config.docs ?? {}).files;
        this.items = config.navigation ?? [];
    }
    async resolve() {
        this.globFiles = await glob(this.globPatterns, {
            root: this.rootDir,
            ignore: ["**/node_modules/**", "**/.git/**", "**/dist/**"],
        }).then((files) => files.map(toPosixPath));
        const resolvedItems = await Promise.all(this.items.map((item) => this.resolveItem(item)));
        return resolvedItems.filter(isNavigationItem);
    }
    async resolveDoc(filePath, categoryLabel) {
        const fileNoExt = toPosixPath(filePath).replace(/\.mdx?$/, "");
        const foundMatches = this.globFiles.find((file) => file.endsWith(`${fileNoExt}.md`) || file.endsWith(`${fileNoExt}.mdx`));
        if (!foundMatches) {
            throw new Error(`File not found for document '${filePath}'. Navigation items of type 'doc' must point to a valid .md or .mdx file. Do you mean 'link' or 'custom-page'? Check navigation configuration documentation for more information: https://zudoku.dev/docs/configuration/navigation`);
        }
        const { data, content } = await readFrontmatter(foundMatches);
        const label = data.navigation_label ??
            data.sidebar_label ??
            data.title ??
            extractTitleFromContent(content) ??
            filePath;
        const icon = data.navigation_icon ?? data.sidebar_icon;
        const doc = {
            type: "doc",
            file: filePath,
            label,
            icon,
            display: data.navigation_display,
            categoryLabel,
            path: fileNoExt,
        };
        return doc;
    }
    async resolveLink(file) {
        const doc = await this.resolveDoc(file);
        return doc
            ? { type: "doc", file, label: doc.label, icon: doc.icon, path: doc.path }
            : undefined;
    }
    async resolveItemCategoryLinkDoc(item) {
        if (typeof item === "string") {
            return this.resolveLink(item);
        }
        const doc = await this.resolveDoc(item.file);
        return doc
            ? {
                ...item,
                label: doc.label,
                icon: doc.icon,
                path: item.path ?? doc.path,
            }
            : undefined;
    }
    async resolveNavigationItemDoc(item, categoryLabel) {
        if (typeof item === "string") {
            return this.resolveDoc(item, categoryLabel);
        }
        const doc = await this.resolveDoc(item.file, categoryLabel);
        return doc ? { ...doc, ...item, path: item.path ?? doc.path } : undefined;
    }
    async resolveItem(item, categoryLabel) {
        if (typeof item === "string") {
            return this.resolveDoc(item, categoryLabel);
        }
        switch (item.type) {
            case "doc":
                return this.resolveNavigationItemDoc(item, categoryLabel);
            case "link":
            case "custom-page":
            case "section":
                return item;
            case "separator":
                return { ...item, label: `separator-${this.itemIndex++}` };
            case "filter":
                return { ...item, label: `filter-${this.itemIndex++}` };
            case "category": {
                const categoryItem = item;
                const items = (await Promise.all(categoryItem.items.map((subItem) => this.resolveItem(subItem, categoryItem.label)))).filter(isNavigationItem);
                const resolvedLink = categoryItem.link
                    ? await this.resolveItemCategoryLinkDoc(categoryItem.link)
                    : undefined;
                return {
                    ...categoryItem,
                    items,
                    link: resolvedLink,
                };
            }
        }
    }
}
//# sourceMappingURL=NavigationSchema.js.map