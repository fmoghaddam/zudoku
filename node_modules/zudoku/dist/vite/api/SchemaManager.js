import fs from "node:fs/promises";
import path from "node:path";
import { $RefParser, } from "@apidevtools/json-schema-ref-parser";
import { upgrade, validate } from "@scalar/openapi-parser";
import slugify from "@sindresorhus/slugify";
import { ensureArray } from "../../lib/util/ensureArray.js";
import { flattenAllOfProcessor } from "../../lib/util/flattenAllOfProcessor.js";
import { joinUrl } from "../../lib/util/joinUrl.js";
import { generateCode } from "./schema-codegen.js";
const FALLBACK_VERSION = "default";
const normalizeInputs = (inputs) => ensureArray(inputs).map((i) => (typeof i === "string" ? { input: i } : i));
export class SchemaManager {
    storeDir;
    processors;
    processedSchemas = {};
    fileToPath = new Map();
    referencedBy = new Map();
    config;
    schemaMap = new Map();
    constructor({ storeDir, config, processors, }) {
        this.storeDir = storeDir;
        this.config = config;
        this.processors = [
            ({ schema }) => upgrade(schema).specification,
            flattenAllOfProcessor,
            ...processors,
        ];
    }
    getPathForFile = (input) => {
        const filePath = path.resolve(this.config.__meta.rootDir, input);
        if (this.fileToPath.has(filePath)) {
            return this.fileToPath.get(filePath);
        }
        const apis = ensureArray(this.config.apis ?? []);
        for (const apiConfig of apis) {
            if (!apiConfig || apiConfig.type !== "file" || !apiConfig.path)
                continue;
            const inputs = normalizeInputs(apiConfig.input).map((i) => path.resolve(this.config.__meta.rootDir, i.input));
            if (inputs.includes(filePath)) {
                this.fileToPath.set(filePath, apiConfig.path);
                return apiConfig.path;
            }
        }
    };
    processSchema = async (input) => {
        const filePath = path.resolve(this.config.__meta.rootDir, input.input);
        const configuredPath = this.getPathForFile(filePath);
        if (!configuredPath) {
            // biome-ignore lint/suspicious/noConsole: Logging allowed here
            console.warn(`No path found for file ${input.input}`);
            return;
        }
        const parser = new $RefParser();
        const schema = await parser.bundle(filePath, {
            dereference: { preservedProperties: ["description", "summary"] },
        });
        this.referencedBy.set(filePath, new Set());
        parser.$refs
            .paths()
            .filter((file) => file !== filePath)
            .forEach((file) => {
            if (!this.referencedBy.has(file)) {
                this.referencedBy.set(file, new Set());
            }
            this.referencedBy.get(file)?.add(filePath);
        });
        const validatedSchema = await this.validateSchema(schema, filePath);
        const processedSchema = await this.processors.reduce(async (schema, processor) => processor({
            schema: await schema,
            file: filePath,
            dereference: (schema) => new $RefParser().dereference(schema, {
                dereference: {
                    preservedProperties: ["description", "summary"],
                    circular: "ignore",
                },
            }),
        }), Promise.resolve(validatedSchema));
        const processedTime = Date.now();
        const code = await generateCode(processedSchema, filePath);
        // Create a unique filename using the configuredPath to avoid collisions
        // when multiple APIs use the same basename (e.g., index.json)
        const prefixPath = slugify(configuredPath, { separator: "_" });
        const processedFilePath = path.posix.join(this.storeDir, `${prefixPath}-${path.basename(filePath)}.js`);
        await fs.writeFile(processedFilePath, code);
        this.schemaMap.set(filePath, {
            filePath: processedFilePath,
            processedTime,
        });
        const schemas = this.processedSchemas[configuredPath];
        if (!schemas) {
            throw new Error(`No schemas found for navigation ID ${configuredPath}.`);
        }
        const index = schemas.findIndex((s) => s.inputPath === filePath);
        const existingSchema = schemas[index];
        const schemaVersion = processedSchema.info.version ?? FALLBACK_VERSION;
        const versionPath = existingSchema?.path && existingSchema.path.length > 0
            ? existingSchema.path
            : schemaVersion;
        const processed = {
            schema: processedSchema,
            version: schemaVersion,
            path: versionPath,
            label: existingSchema?.label,
            inputPath: filePath,
            downloadUrl: this.createSchemaPath(filePath, versionPath, configuredPath),
        };
        if (index > -1) {
            schemas[index] = processed;
        }
        else {
            throw new Error(`Schema with input path ${filePath} was not pre-initialized for ${configuredPath}.`);
        }
        this.fileToPath.set(filePath, configuredPath);
        return processed;
    };
    getAllTrackedFiles = () => Array.from(this.referencedBy.keys());
    getFilesToReprocess = (changedFile) => {
        const resolvedPath = path.resolve(this.config.__meta.rootDir, changedFile);
        const referencedBy = this.referencedBy.get(resolvedPath);
        if (!referencedBy)
            return [];
        if (referencedBy.size === 0)
            return [resolvedPath];
        return Array.from(referencedBy);
    };
    processAllSchemas = async () => {
        this.schemaMap.clear();
        this.fileToPath.clear();
        this.referencedBy.clear();
        this.processedSchemas = {};
        const apis = ensureArray(this.config.apis ?? []);
        for (const apiConfig of apis) {
            if (apiConfig.type !== "file" || !apiConfig.path)
                continue;
            const inputs = normalizeInputs(apiConfig.input);
            if (inputs.length === 0)
                throw new Error("No schema found");
            this.processedSchemas[apiConfig.path] = inputs.map((input) => ({
                schema: {},
                version: "",
                path: input.path ?? "",
                label: input.label,
                inputPath: path.resolve(this.config.__meta.rootDir, input.input),
                downloadUrl: "",
            }));
            const results = await Promise.allSettled(inputs.map((input) => this.processSchema(input)));
            const errors = results.flatMap((r) => r.status === "rejected" ? r.reason : []);
            if (errors.length > 0) {
                throw new Error(`Failed to process schemas for ${apiConfig.path}: ${errors.join(", ")}`);
            }
        }
    };
    getLatestSchema = (path) => this.processedSchemas[path]?.at(0);
    getBySchemaFilepath = (schemaPath) => this.schemaMap.get(path.resolve(this.config.__meta.rootDir, schemaPath));
    getSchemasForPath = (path) => this.processedSchemas[path];
    getUrlToFilePathMap = () => {
        const map = new Map();
        const apis = ensureArray(this.config.apis ?? []);
        for (const apiConfig of apis) {
            if (apiConfig.type !== "file" || !apiConfig.path)
                continue;
            const downloadEnabled = apiConfig.options?.schemaDownload?.enabled ??
                this.config.defaults?.apis?.schemaDownload?.enabled ??
                false;
            if (!downloadEnabled)
                continue;
            const schemas = this.processedSchemas[apiConfig.path];
            if (!schemas || schemas.length === 0)
                continue;
            for (const schema of schemas) {
                map.set(schema.downloadUrl, schema.inputPath);
            }
        }
        return map;
    };
    createSchemaPath = (inputPath, versionPath, apiPath) => {
        const extension = path.extname(inputPath);
        return joinUrl(this.config.basePath, apiPath, versionPath, `schema${extension}`);
    };
    validateSchema = async (schema, filePath) => {
        const validated = await validate(schema);
        if (validated.errors?.length) {
            // biome-ignore lint/suspicious/noConsole: Logging allowed here
            console.warn(`Schema warnings in ${filePath}:`);
            for (const error of validated.errors) {
                // biome-ignore lint/suspicious/noConsole: Logging allowed here
                console.warn(error);
            }
        }
        return schema;
    };
}
//# sourceMappingURL=SchemaManager.js.map