import { Q as xo, t as mi, q as Ee, n as Ce, v as Yo, m as Je, w as Jo, x as zo, p as en, o as Xo } from "./index-Ckdk300F.js";
var ye;
(function(e) {
  e.NAME = "Name", e.DOCUMENT = "Document", e.OPERATION_DEFINITION = "OperationDefinition", e.VARIABLE_DEFINITION = "VariableDefinition", e.SELECTION_SET = "SelectionSet", e.FIELD = "Field", e.ARGUMENT = "Argument", e.FRAGMENT_SPREAD = "FragmentSpread", e.INLINE_FRAGMENT = "InlineFragment", e.FRAGMENT_DEFINITION = "FragmentDefinition", e.VARIABLE = "Variable", e.INT = "IntValue", e.FLOAT = "FloatValue", e.STRING = "StringValue", e.BOOLEAN = "BooleanValue", e.NULL = "NullValue", e.ENUM = "EnumValue", e.LIST = "ListValue", e.OBJECT = "ObjectValue", e.OBJECT_FIELD = "ObjectField", e.DIRECTIVE = "Directive", e.NAMED_TYPE = "NamedType", e.LIST_TYPE = "ListType", e.NON_NULL_TYPE = "NonNullType", e.SCHEMA_DEFINITION = "SchemaDefinition", e.OPERATION_TYPE_DEFINITION = "OperationTypeDefinition", e.SCALAR_TYPE_DEFINITION = "ScalarTypeDefinition", e.OBJECT_TYPE_DEFINITION = "ObjectTypeDefinition", e.FIELD_DEFINITION = "FieldDefinition", e.INPUT_VALUE_DEFINITION = "InputValueDefinition", e.INTERFACE_TYPE_DEFINITION = "InterfaceTypeDefinition", e.UNION_TYPE_DEFINITION = "UnionTypeDefinition", e.ENUM_TYPE_DEFINITION = "EnumTypeDefinition", e.ENUM_VALUE_DEFINITION = "EnumValueDefinition", e.INPUT_OBJECT_TYPE_DEFINITION = "InputObjectTypeDefinition", e.DIRECTIVE_DEFINITION = "DirectiveDefinition", e.SCHEMA_EXTENSION = "SchemaExtension", e.SCALAR_TYPE_EXTENSION = "ScalarTypeExtension", e.OBJECT_TYPE_EXTENSION = "ObjectTypeExtension", e.INTERFACE_TYPE_EXTENSION = "InterfaceTypeExtension", e.UNION_TYPE_EXTENSION = "UnionTypeExtension", e.ENUM_TYPE_EXTENSION = "EnumTypeExtension", e.INPUT_OBJECT_TYPE_EXTENSION = "InputObjectTypeExtension", e.TYPE_COORDINATE = "TypeCoordinate", e.MEMBER_COORDINATE = "MemberCoordinate", e.ARGUMENT_COORDINATE = "ArgumentCoordinate", e.DIRECTIVE_COORDINATE = "DirectiveCoordinate", e.DIRECTIVE_ARGUMENT_COORDINATE = "DirectiveArgumentCoordinate";
})(ye || (ye = {}));
const Ho = 5;
function Wo(e, n) {
  const [a, i] = n ? [e, n] : [void 0, e];
  let t = " Did you mean ";
  a && (t += a + " ");
  const r = i.map((l) => `"${l}"`);
  switch (r.length) {
    case 0:
      return "";
    case 1:
      return t + r[0] + "?";
    case 2:
      return t + r[0] + " or " + r[1] + "?";
  }
  const o = r.slice(0, Ho), s = o.pop();
  return t + o.join(", ") + ", or " + s + "?";
}
function yi(e) {
  return e;
}
function Zo(e, n) {
  const a = /* @__PURE__ */ Object.create(null);
  for (const i of e)
    a[n(i)] = i;
  return a;
}
function Hr(e, n, a) {
  const i = /* @__PURE__ */ Object.create(null);
  for (const t of e)
    i[n(t)] = a(t);
  return i;
}
function _r(e, n) {
  const a = /* @__PURE__ */ Object.create(null);
  for (const i of Object.keys(e))
    a[i] = n(e[i], i);
  return a;
}
function eu(e, n) {
  let a = 0, i = 0;
  for (; a < e.length && i < n.length; ) {
    let t = e.charCodeAt(a), r = n.charCodeAt(i);
    if (Hn(t) && Hn(r)) {
      let o = 0;
      do
        ++a, o = o * 10 + t - zr, t = e.charCodeAt(a);
      while (Hn(t) && o > 0);
      let s = 0;
      do
        ++i, s = s * 10 + r - zr, r = n.charCodeAt(i);
      while (Hn(r) && s > 0);
      if (o < s)
        return -1;
      if (o > s)
        return 1;
    } else {
      if (t < r)
        return -1;
      if (t > r)
        return 1;
      ++a, ++i;
    }
  }
  return e.length - n.length;
}
const zr = 48, nu = 57;
function Hn(e) {
  return !isNaN(e) && zr <= e && e <= nu;
}
function tu(e, n) {
  const a = /* @__PURE__ */ Object.create(null), i = new ru(e), t = Math.floor(e.length * 0.4) + 1;
  for (const r of n) {
    const o = i.measure(r, t);
    o !== void 0 && (a[r] = o);
  }
  return Object.keys(a).sort((r, o) => {
    const s = a[r] - a[o];
    return s !== 0 ? s : eu(r, o);
  });
}
class ru {
  constructor(n) {
    this._input = n, this._inputLowerCase = n.toLowerCase(), this._inputArray = hi(this._inputLowerCase), this._rows = [
      new Array(n.length + 1).fill(0),
      new Array(n.length + 1).fill(0),
      new Array(n.length + 1).fill(0)
    ];
  }
  measure(n, a) {
    if (this._input === n)
      return 0;
    const i = n.toLowerCase();
    if (this._inputLowerCase === i)
      return 1;
    let t = hi(i), r = this._inputArray;
    if (t.length < r.length) {
      const f = t;
      t = r, r = f;
    }
    const o = t.length, s = r.length;
    if (o - s > a)
      return;
    const l = this._rows;
    for (let f = 0; f <= s; f++)
      l[0][f] = f;
    for (let f = 1; f <= o; f++) {
      const u = l[(f - 1) % 3], c = l[f % 3];
      let m = c[0] = f;
      for (let p = 1; p <= s; p++) {
        const b = t[f - 1] === r[p - 1] ? 0 : 1;
        let T = Math.min(
          u[p] + 1,
          // delete
          c[p - 1] + 1,
          // insert
          u[p - 1] + b
          // substitute
        );
        if (f > 1 && p > 1 && t[f - 1] === r[p - 2] && t[f - 2] === r[p - 1]) {
          const y = l[(f - 2) % 3][p - 2];
          T = Math.min(T, y + 1);
        }
        T < m && (m = T), c[p] = T;
      }
      if (m > a)
        return;
    }
    const d = l[o % 3][s];
    return d <= a ? d : void 0;
  }
}
function hi(e) {
  const n = e.length, a = new Array(n);
  for (let i = 0; i < n; ++i)
    a[i] = e.charCodeAt(i);
  return a;
}
function $e(e) {
  if (e == null)
    return /* @__PURE__ */ Object.create(null);
  if (Object.getPrototypeOf(e) === null)
    return e;
  const n = /* @__PURE__ */ Object.create(null);
  for (const [a, i] of Object.entries(e))
    n[a] = i;
  return n;
}
function iu(e) {
  return `"${e.replace(au, su)}"`;
}
const au = /[\x00-\x1f\x22\x5c\x7f-\x9f]/g;
function su(e) {
  return ou[e.charCodeAt(0)];
}
const ou = [
  "\\u0000",
  "\\u0001",
  "\\u0002",
  "\\u0003",
  "\\u0004",
  "\\u0005",
  "\\u0006",
  "\\u0007",
  "\\b",
  "\\t",
  "\\n",
  "\\u000B",
  "\\f",
  "\\r",
  "\\u000E",
  "\\u000F",
  "\\u0010",
  "\\u0011",
  "\\u0012",
  "\\u0013",
  "\\u0014",
  "\\u0015",
  "\\u0016",
  "\\u0017",
  "\\u0018",
  "\\u0019",
  "\\u001A",
  "\\u001B",
  "\\u001C",
  "\\u001D",
  "\\u001E",
  "\\u001F",
  "",
  "",
  '\\"',
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  // 2F
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  // 3F
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  // 4F
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "\\\\",
  "",
  "",
  "",
  // 5F
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  // 6F
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "\\u007F",
  "\\u0080",
  "\\u0081",
  "\\u0082",
  "\\u0083",
  "\\u0084",
  "\\u0085",
  "\\u0086",
  "\\u0087",
  "\\u0088",
  "\\u0089",
  "\\u008A",
  "\\u008B",
  "\\u008C",
  "\\u008D",
  "\\u008E",
  "\\u008F",
  "\\u0090",
  "\\u0091",
  "\\u0092",
  "\\u0093",
  "\\u0094",
  "\\u0095",
  "\\u0096",
  "\\u0097",
  "\\u0098",
  "\\u0099",
  "\\u009A",
  "\\u009B",
  "\\u009C",
  "\\u009D",
  "\\u009E",
  "\\u009F"
], qn = Object.freeze({});
function uu(e, n, a = xo) {
  const i = /* @__PURE__ */ new Map();
  for (const y of Object.values(ye))
    i.set(y, Ms(n, y));
  let t, r = Array.isArray(e), o = [e], s = -1, l = [], d = e, f, u;
  const c = [], m = [];
  do {
    s++;
    const y = s === o.length, h = y && l.length !== 0;
    if (y) {
      if (f = m.length === 0 ? void 0 : c[c.length - 1], d = u, u = m.pop(), h)
        if (r) {
          d = d.slice();
          let S = 0;
          for (const [E, k] of l) {
            const M = E - S;
            k === null ? (d.splice(M, 1), S++) : d[M] = k;
          }
        } else {
          d = { ...d };
          for (const [S, E] of l)
            d[S] = E;
        }
      s = t.index, o = t.keys, l = t.edits, r = t.inArray, t = t.prev;
    } else if (u) {
      if (f = r ? s : o[s], d = u[f], d == null)
        continue;
      c.push(f);
    }
    let I;
    if (!Array.isArray(d)) {
      var p, b;
      mi(d) || Ee(!1, `Invalid AST Node: ${Ce(d)}.`);
      const S = y ? (p = i.get(d.kind)) === null || p === void 0 ? void 0 : p.leave : (b = i.get(d.kind)) === null || b === void 0 ? void 0 : b.enter;
      if (I = S?.call(n, d, f, u, c, m), I === qn)
        break;
      if (I === !1) {
        if (!y) {
          c.pop();
          continue;
        }
      } else if (I !== void 0 && (l.push([f, I]), !y))
        if (mi(I))
          d = I;
        else {
          c.pop();
          continue;
        }
    }
    if (I === void 0 && h && l.push([f, d]), y)
      c.pop();
    else {
      var T;
      t = {
        inArray: r,
        index: s,
        keys: o,
        edits: l,
        prev: t
      }, r = Array.isArray(d), o = r ? d : (T = a[d.kind]) !== null && T !== void 0 ? T : [], s = -1, l = [], u && m.push(u), u = d;
    }
  } while (t !== void 0);
  return l.length !== 0 ? l[l.length - 1][1] : e;
}
function pc(e) {
  const n = new Array(e.length).fill(null), a = /* @__PURE__ */ Object.create(null);
  for (const i of Object.values(ye)) {
    let t = !1;
    const r = new Array(e.length).fill(void 0), o = new Array(e.length).fill(void 0);
    for (let l = 0; l < e.length; ++l) {
      const { enter: d, leave: f } = Ms(e[l], i);
      t || (t = d != null || f != null), r[l] = d, o[l] = f;
    }
    if (!t)
      continue;
    const s = {
      enter(...l) {
        const d = l[0];
        for (let u = 0; u < e.length; u++)
          if (n[u] === null) {
            var f;
            const c = (f = r[u]) === null || f === void 0 ? void 0 : f.apply(e[u], l);
            if (c === !1)
              n[u] = d;
            else if (c === qn)
              n[u] = qn;
            else if (c !== void 0)
              return c;
          }
      },
      leave(...l) {
        const d = l[0];
        for (let u = 0; u < e.length; u++)
          if (n[u] === null) {
            var f;
            const c = (f = o[u]) === null || f === void 0 ? void 0 : f.apply(e[u], l);
            if (c === qn)
              n[u] = qn;
            else if (c !== void 0 && c !== !1)
              return c;
          } else n[u] === d && (n[u] = null);
      }
    };
    a[i] = s;
  }
  return a;
}
function Ms(e, n) {
  const a = e[n];
  return typeof a == "object" ? a : typeof a == "function" ? {
    enter: a,
    leave: void 0
  } : {
    enter: e.enter,
    leave: e.leave
  };
}
function Or(e) {
  return uu(e, lu);
}
const cu = 80, lu = {
  Name: {
    leave: (e) => e.value
  },
  Variable: {
    leave: (e) => "$" + e.name
  },
  // Document
  Document: {
    leave: (e) => J(e.definitions, `

`)
  },
  OperationDefinition: {
    leave(e) {
      const n = Ur(e.variableDefinitions) ? re(`(
`, J(e.variableDefinitions, `
`), `
)`) : re("(", J(e.variableDefinitions, ", "), ")"), a = re("", e.description, `
`) + J(
        [
          e.operation,
          J([e.name, n]),
          J(e.directives, " ")
        ],
        " "
      );
      return (a === "query" ? "" : a + " ") + e.selectionSet;
    }
  },
  VariableDefinition: {
    leave: ({ variable: e, type: n, defaultValue: a, directives: i, description: t }) => re("", t, `
`) + e + ": " + n + re(" = ", a) + re(" ", J(i, " "))
  },
  SelectionSet: {
    leave: ({ selections: e }) => we(e)
  },
  Field: {
    leave({ alias: e, name: n, arguments: a, directives: i, selectionSet: t }) {
      const r = re("", e, ": ") + n;
      let o = r + re("(", J(a, ", "), ")");
      return o.length > cu && (o = r + re(`(
`, Nr(J(a, `
`)), `
)`)), J([o, J(i, " "), t], " ");
    }
  },
  Argument: {
    leave: ({ name: e, value: n }) => e + ": " + n
  },
  // Fragments
  FragmentSpread: {
    leave: ({ name: e, directives: n }) => "..." + e + re(" ", J(n, " "))
  },
  InlineFragment: {
    leave: ({ typeCondition: e, directives: n, selectionSet: a }) => J(
      [
        "...",
        re("on ", e),
        J(n, " "),
        a
      ],
      " "
    )
  },
  FragmentDefinition: {
    leave: ({
      name: e,
      typeCondition: n,
      variableDefinitions: a,
      directives: i,
      selectionSet: t,
      description: r
    }) => re("", r, `
`) + // Note: fragment variable definitions are experimental and may be changed
    // or removed in the future.
    `fragment ${e}${re("(", J(a, ", "), ")")} on ${n} ${re("", J(i, " "), " ")}` + t
  },
  // Value
  IntValue: {
    leave: ({ value: e }) => e
  },
  FloatValue: {
    leave: ({ value: e }) => e
  },
  StringValue: {
    leave: ({ value: e, block: n }) => n ? Yo(e) : iu(e)
  },
  BooleanValue: {
    leave: ({ value: e }) => e ? "true" : "false"
  },
  NullValue: {
    leave: () => "null"
  },
  EnumValue: {
    leave: ({ value: e }) => e
  },
  ListValue: {
    leave: ({ values: e }) => "[" + J(e, ", ") + "]"
  },
  ObjectValue: {
    leave: ({ fields: e }) => "{" + J(e, ", ") + "}"
  },
  ObjectField: {
    leave: ({ name: e, value: n }) => e + ": " + n
  },
  // Directive
  Directive: {
    leave: ({ name: e, arguments: n }) => "@" + e + re("(", J(n, ", "), ")")
  },
  // Type
  NamedType: {
    leave: ({ name: e }) => e
  },
  ListType: {
    leave: ({ type: e }) => "[" + e + "]"
  },
  NonNullType: {
    leave: ({ type: e }) => e + "!"
  },
  // Type System Definitions
  SchemaDefinition: {
    leave: ({ description: e, directives: n, operationTypes: a }) => re("", e, `
`) + J(["schema", J(n, " "), we(a)], " ")
  },
  OperationTypeDefinition: {
    leave: ({ operation: e, type: n }) => e + ": " + n
  },
  ScalarTypeDefinition: {
    leave: ({ description: e, name: n, directives: a }) => re("", e, `
`) + J(["scalar", n, J(a, " ")], " ")
  },
  ObjectTypeDefinition: {
    leave: ({ description: e, name: n, interfaces: a, directives: i, fields: t }) => re("", e, `
`) + J(
      [
        "type",
        n,
        re("implements ", J(a, " & ")),
        J(i, " "),
        we(t)
      ],
      " "
    )
  },
  FieldDefinition: {
    leave: ({ description: e, name: n, arguments: a, type: i, directives: t }) => re("", e, `
`) + n + (Ur(a) ? re(`(
`, Nr(J(a, `
`)), `
)`) : re("(", J(a, ", "), ")")) + ": " + i + re(" ", J(t, " "))
  },
  InputValueDefinition: {
    leave: ({ description: e, name: n, type: a, defaultValue: i, directives: t }) => re("", e, `
`) + J(
      [n + ": " + a, re("= ", i), J(t, " ")],
      " "
    )
  },
  InterfaceTypeDefinition: {
    leave: ({ description: e, name: n, interfaces: a, directives: i, fields: t }) => re("", e, `
`) + J(
      [
        "interface",
        n,
        re("implements ", J(a, " & ")),
        J(i, " "),
        we(t)
      ],
      " "
    )
  },
  UnionTypeDefinition: {
    leave: ({ description: e, name: n, directives: a, types: i }) => re("", e, `
`) + J(
      ["union", n, J(a, " "), re("= ", J(i, " | "))],
      " "
    )
  },
  EnumTypeDefinition: {
    leave: ({ description: e, name: n, directives: a, values: i }) => re("", e, `
`) + J(["enum", n, J(a, " "), we(i)], " ")
  },
  EnumValueDefinition: {
    leave: ({ description: e, name: n, directives: a }) => re("", e, `
`) + J([n, J(a, " ")], " ")
  },
  InputObjectTypeDefinition: {
    leave: ({ description: e, name: n, directives: a, fields: i }) => re("", e, `
`) + J(["input", n, J(a, " "), we(i)], " ")
  },
  DirectiveDefinition: {
    leave: ({ description: e, name: n, arguments: a, repeatable: i, locations: t }) => re("", e, `
`) + "directive @" + n + (Ur(a) ? re(`(
`, Nr(J(a, `
`)), `
)`) : re("(", J(a, ", "), ")")) + (i ? " repeatable" : "") + " on " + J(t, " | ")
  },
  SchemaExtension: {
    leave: ({ directives: e, operationTypes: n }) => J(
      ["extend schema", J(e, " "), we(n)],
      " "
    )
  },
  ScalarTypeExtension: {
    leave: ({ name: e, directives: n }) => J(["extend scalar", e, J(n, " ")], " ")
  },
  ObjectTypeExtension: {
    leave: ({ name: e, interfaces: n, directives: a, fields: i }) => J(
      [
        "extend type",
        e,
        re("implements ", J(n, " & ")),
        J(a, " "),
        we(i)
      ],
      " "
    )
  },
  InterfaceTypeExtension: {
    leave: ({ name: e, interfaces: n, directives: a, fields: i }) => J(
      [
        "extend interface",
        e,
        re("implements ", J(n, " & ")),
        J(a, " "),
        we(i)
      ],
      " "
    )
  },
  UnionTypeExtension: {
    leave: ({ name: e, directives: n, types: a }) => J(
      [
        "extend union",
        e,
        J(n, " "),
        re("= ", J(a, " | "))
      ],
      " "
    )
  },
  EnumTypeExtension: {
    leave: ({ name: e, directives: n, values: a }) => J(["extend enum", e, J(n, " "), we(a)], " ")
  },
  InputObjectTypeExtension: {
    leave: ({ name: e, directives: n, fields: a }) => J(["extend input", e, J(n, " "), we(a)], " ")
  },
  // Schema Coordinates
  TypeCoordinate: {
    leave: ({ name: e }) => e
  },
  MemberCoordinate: {
    leave: ({ name: e, memberName: n }) => J([e, re(".", n)])
  },
  ArgumentCoordinate: {
    leave: ({ name: e, fieldName: n, argumentName: a }) => J([e, re(".", n), re("(", a, ":)")])
  },
  DirectiveCoordinate: {
    leave: ({ name: e }) => J(["@", e])
  },
  DirectiveArgumentCoordinate: {
    leave: ({ name: e, argumentName: n }) => J(["@", e, re("(", n, ":)")])
  }
};
function J(e, n = "") {
  var a;
  return (a = e?.filter((i) => i).join(n)) !== null && a !== void 0 ? a : "";
}
function we(e) {
  return re(`{
`, Nr(J(e, `
`)), `
}`);
}
function re(e, n, a = "") {
  return n != null && n !== "" ? e + n + a : "";
}
function Nr(e) {
  return re("  ", e.replace(/\n/g, `
  `));
}
function Ur(e) {
  var n;
  return (n = e?.some((a) => a.includes(`
`))) !== null && n !== void 0 ? n : !1;
}
function Xr(e, n) {
  switch (e.kind) {
    case ye.NULL:
      return null;
    case ye.INT:
      return parseInt(e.value, 10);
    case ye.FLOAT:
      return parseFloat(e.value);
    case ye.STRING:
    case ye.ENUM:
    case ye.BOOLEAN:
      return e.value;
    case ye.LIST:
      return e.values.map(
        (a) => Xr(a, n)
      );
    case ye.OBJECT:
      return Hr(
        e.fields,
        (a) => a.name.value,
        (a) => Xr(a.value, n)
      );
    case ye.VARIABLE:
      return n?.[e.name.value];
  }
}
function Ue(e) {
  if (e != null || Ee(!1, "Must provide name."), typeof e == "string" || Ee(!1, "Expected name to be a string."), e.length === 0)
    throw new Je("Expected name to be a non-empty string.");
  for (let n = 1; n < e.length; ++n)
    if (!Jo(e.charCodeAt(n)))
      throw new Je(
        `Names must only contain [_a-zA-Z0-9] but "${e}" does not.`
      );
  if (!zo(e.charCodeAt(0)))
    throw new Je(
      `Names must start with [_a-zA-Z] but "${e}" does not.`
    );
  return e;
}
function pu(e) {
  if (e === "true" || e === "false" || e === "null")
    throw new Je(`Enum values cannot be named: ${e}`);
  return Ue(e);
}
function $s(e) {
  return Kn(e) || Ir(e) || Bn(e) || xn(e) || Yn(e) || Wr(e) || Us(e) || Nn(e);
}
function Kn(e) {
  return en(e, ei);
}
function Ir(e) {
  return en(e, vu);
}
function Bn(e) {
  return en(e, Eu);
}
function xn(e) {
  return en(e, gu);
}
function Yn(e) {
  return en(e, Ou);
}
function Wr(e) {
  return en(e, _u);
}
function Us(e) {
  return en(e, mu);
}
function Nn(e) {
  return en(e, yu);
}
function du(e) {
  return Kn(e) || Yn(e) || Wr(e) || Zr(e) && du(e.ofType);
}
function fu(e) {
  return Kn(e) || Ir(e) || Bn(e) || xn(e) || Yn(e) || Zr(e) && fu(e.ofType);
}
function dc(e) {
  return Kn(e) || Yn(e);
}
function fc(e) {
  return Ir(e) || Bn(e) || xn(e);
}
function mc(e) {
  return Bn(e) || xn(e);
}
class mu {
  constructor(n) {
    $s(n) || Ee(!1, `Expected ${Ce(n)} to be a GraphQL type.`), this.ofType = n;
  }
  get [Symbol.toStringTag]() {
    return "GraphQLList";
  }
  toString() {
    return "[" + String(this.ofType) + "]";
  }
  toJSON() {
    return this.toString();
  }
}
class yu {
  constructor(n) {
    hu(n) || Ee(
      !1,
      `Expected ${Ce(n)} to be a GraphQL nullable type.`
    ), this.ofType = n;
  }
  get [Symbol.toStringTag]() {
    return "GraphQLNonNull";
  }
  toString() {
    return String(this.ofType) + "!";
  }
  toJSON() {
    return this.toString();
  }
}
function Zr(e) {
  return Us(e) || Nn(e);
}
function hu(e) {
  return $s(e) && !Nn(e);
}
function yc(e) {
  if (e)
    return Nn(e) ? e.ofType : e;
}
function hc(e) {
  return Kn(e) || Ir(e) || Bn(e) || xn(e) || Yn(e) || Wr(e);
}
function vc(e) {
  if (e) {
    let n = e;
    for (; Zr(n); )
      n = n.ofType;
    return n;
  }
}
function Qs(e) {
  return typeof e == "function" ? e() : e;
}
function qs(e) {
  return typeof e == "function" ? e() : e;
}
class ei {
  constructor(n) {
    var a, i, t, r;
    const o = (a = n.parseValue) !== null && a !== void 0 ? a : yi;
    this.name = Ue(n.name), this.description = n.description, this.specifiedByURL = n.specifiedByURL, this.serialize = (i = n.serialize) !== null && i !== void 0 ? i : yi, this.parseValue = o, this.parseLiteral = (t = n.parseLiteral) !== null && t !== void 0 ? t : (s, l) => o(Xr(s, l)), this.extensions = $e(n.extensions), this.astNode = n.astNode, this.extensionASTNodes = (r = n.extensionASTNodes) !== null && r !== void 0 ? r : [], n.specifiedByURL == null || typeof n.specifiedByURL == "string" || Ee(
      !1,
      `${this.name} must provide "specifiedByURL" as a string, but got: ${Ce(n.specifiedByURL)}.`
    ), n.serialize == null || typeof n.serialize == "function" || Ee(
      !1,
      `${this.name} must provide "serialize" function. If this custom Scalar is also used as an input type, ensure "parseValue" and "parseLiteral" functions are also provided.`
    ), n.parseLiteral && (typeof n.parseValue == "function" && typeof n.parseLiteral == "function" || Ee(
      !1,
      `${this.name} must provide both "parseValue" and "parseLiteral" functions.`
    ));
  }
  get [Symbol.toStringTag]() {
    return "GraphQLScalarType";
  }
  toConfig() {
    return {
      name: this.name,
      description: this.description,
      specifiedByURL: this.specifiedByURL,
      serialize: this.serialize,
      parseValue: this.parseValue,
      parseLiteral: this.parseLiteral,
      extensions: this.extensions,
      astNode: this.astNode,
      extensionASTNodes: this.extensionASTNodes
    };
  }
  toString() {
    return this.name;
  }
  toJSON() {
    return this.toString();
  }
}
class vu {
  constructor(n) {
    var a;
    this.name = Ue(n.name), this.description = n.description, this.isTypeOf = n.isTypeOf, this.extensions = $e(n.extensions), this.astNode = n.astNode, this.extensionASTNodes = (a = n.extensionASTNodes) !== null && a !== void 0 ? a : [], this._fields = () => Bs(n), this._interfaces = () => Ks(n), n.isTypeOf == null || typeof n.isTypeOf == "function" || Ee(
      !1,
      `${this.name} must provide "isTypeOf" as a function, but got: ${Ce(n.isTypeOf)}.`
    );
  }
  get [Symbol.toStringTag]() {
    return "GraphQLObjectType";
  }
  getFields() {
    return typeof this._fields == "function" && (this._fields = this._fields()), this._fields;
  }
  getInterfaces() {
    return typeof this._interfaces == "function" && (this._interfaces = this._interfaces()), this._interfaces;
  }
  toConfig() {
    return {
      name: this.name,
      description: this.description,
      interfaces: this.getInterfaces(),
      fields: xs(this.getFields()),
      isTypeOf: this.isTypeOf,
      extensions: this.extensions,
      astNode: this.astNode,
      extensionASTNodes: this.extensionASTNodes
    };
  }
  toString() {
    return this.name;
  }
  toJSON() {
    return this.toString();
  }
}
function Ks(e) {
  var n;
  const a = Qs(
    (n = e.interfaces) !== null && n !== void 0 ? n : []
  );
  return Array.isArray(a) || Ee(
    !1,
    `${e.name} interfaces must be an Array or a function which returns an Array.`
  ), a;
}
function Bs(e) {
  const n = qs(e.fields);
  return gn(n) || Ee(
    !1,
    `${e.name} fields must be an object with field names as keys or a function which returns such an object.`
  ), _r(n, (a, i) => {
    var t;
    gn(a) || Ee(
      !1,
      `${e.name}.${i} field config must be an object.`
    ), a.resolve == null || typeof a.resolve == "function" || Ee(
      !1,
      `${e.name}.${i} field resolver must be a function if provided, but got: ${Ce(a.resolve)}.`
    );
    const r = (t = a.args) !== null && t !== void 0 ? t : {};
    return gn(r) || Ee(
      !1,
      `${e.name}.${i} args must be an object with argument names as keys.`
    ), {
      name: Ue(i),
      description: a.description,
      type: a.type,
      args: Tu(r),
      resolve: a.resolve,
      subscribe: a.subscribe,
      deprecationReason: a.deprecationReason,
      extensions: $e(a.extensions),
      astNode: a.astNode
    };
  });
}
function Tu(e) {
  return Object.entries(e).map(([n, a]) => ({
    name: Ue(n),
    description: a.description,
    type: a.type,
    defaultValue: a.defaultValue,
    deprecationReason: a.deprecationReason,
    extensions: $e(a.extensions),
    astNode: a.astNode
  }));
}
function gn(e) {
  return Xo(e) && !Array.isArray(e);
}
function xs(e) {
  return _r(e, (n) => ({
    description: n.description,
    type: n.type,
    args: bu(n.args),
    resolve: n.resolve,
    subscribe: n.subscribe,
    deprecationReason: n.deprecationReason,
    extensions: n.extensions,
    astNode: n.astNode
  }));
}
function bu(e) {
  return Hr(
    e,
    (n) => n.name,
    (n) => ({
      description: n.description,
      type: n.type,
      defaultValue: n.defaultValue,
      deprecationReason: n.deprecationReason,
      extensions: n.extensions,
      astNode: n.astNode
    })
  );
}
function Tc(e) {
  return Nn(e.type) && e.defaultValue === void 0;
}
class Eu {
  constructor(n) {
    var a;
    this.name = Ue(n.name), this.description = n.description, this.resolveType = n.resolveType, this.extensions = $e(n.extensions), this.astNode = n.astNode, this.extensionASTNodes = (a = n.extensionASTNodes) !== null && a !== void 0 ? a : [], this._fields = Bs.bind(void 0, n), this._interfaces = Ks.bind(void 0, n), n.resolveType == null || typeof n.resolveType == "function" || Ee(
      !1,
      `${this.name} must provide "resolveType" as a function, but got: ${Ce(n.resolveType)}.`
    );
  }
  get [Symbol.toStringTag]() {
    return "GraphQLInterfaceType";
  }
  getFields() {
    return typeof this._fields == "function" && (this._fields = this._fields()), this._fields;
  }
  getInterfaces() {
    return typeof this._interfaces == "function" && (this._interfaces = this._interfaces()), this._interfaces;
  }
  toConfig() {
    return {
      name: this.name,
      description: this.description,
      interfaces: this.getInterfaces(),
      fields: xs(this.getFields()),
      resolveType: this.resolveType,
      extensions: this.extensions,
      astNode: this.astNode,
      extensionASTNodes: this.extensionASTNodes
    };
  }
  toString() {
    return this.name;
  }
  toJSON() {
    return this.toString();
  }
}
class gu {
  constructor(n) {
    var a;
    this.name = Ue(n.name), this.description = n.description, this.resolveType = n.resolveType, this.extensions = $e(n.extensions), this.astNode = n.astNode, this.extensionASTNodes = (a = n.extensionASTNodes) !== null && a !== void 0 ? a : [], this._types = Nu.bind(void 0, n), n.resolveType == null || typeof n.resolveType == "function" || Ee(
      !1,
      `${this.name} must provide "resolveType" as a function, but got: ${Ce(n.resolveType)}.`
    );
  }
  get [Symbol.toStringTag]() {
    return "GraphQLUnionType";
  }
  getTypes() {
    return typeof this._types == "function" && (this._types = this._types()), this._types;
  }
  toConfig() {
    return {
      name: this.name,
      description: this.description,
      types: this.getTypes(),
      resolveType: this.resolveType,
      extensions: this.extensions,
      astNode: this.astNode,
      extensionASTNodes: this.extensionASTNodes
    };
  }
  toString() {
    return this.name;
  }
  toJSON() {
    return this.toString();
  }
}
function Nu(e) {
  const n = Qs(e.types);
  return Array.isArray(n) || Ee(
    !1,
    `Must provide Array of types or a function which returns such an array for Union ${e.name}.`
  ), n;
}
class Ou {
  /* <T> */
  constructor(n) {
    var a;
    this.name = Ue(n.name), this.description = n.description, this.extensions = $e(n.extensions), this.astNode = n.astNode, this.extensionASTNodes = (a = n.extensionASTNodes) !== null && a !== void 0 ? a : [], this._values = typeof n.values == "function" ? n.values : vi(this.name, n.values), this._valueLookup = null, this._nameLookup = null;
  }
  get [Symbol.toStringTag]() {
    return "GraphQLEnumType";
  }
  getValues() {
    return typeof this._values == "function" && (this._values = vi(this.name, this._values())), this._values;
  }
  getValue(n) {
    return this._nameLookup === null && (this._nameLookup = Zo(this.getValues(), (a) => a.name)), this._nameLookup[n];
  }
  serialize(n) {
    this._valueLookup === null && (this._valueLookup = new Map(
      this.getValues().map((i) => [i.value, i])
    ));
    const a = this._valueLookup.get(n);
    if (a === void 0)
      throw new Je(
        `Enum "${this.name}" cannot represent value: ${Ce(n)}`
      );
    return a.name;
  }
  parseValue(n) {
    if (typeof n != "string") {
      const i = Ce(n);
      throw new Je(
        `Enum "${this.name}" cannot represent non-string value: ${i}.` + Wn(this, i)
      );
    }
    const a = this.getValue(n);
    if (a == null)
      throw new Je(
        `Value "${n}" does not exist in "${this.name}" enum.` + Wn(this, n)
      );
    return a.value;
  }
  parseLiteral(n, a) {
    if (n.kind !== ye.ENUM) {
      const t = Or(n);
      throw new Je(
        `Enum "${this.name}" cannot represent non-enum value: ${t}.` + Wn(this, t),
        {
          nodes: n
        }
      );
    }
    const i = this.getValue(n.value);
    if (i == null) {
      const t = Or(n);
      throw new Je(
        `Value "${t}" does not exist in "${this.name}" enum.` + Wn(this, t),
        {
          nodes: n
        }
      );
    }
    return i.value;
  }
  toConfig() {
    const n = Hr(
      this.getValues(),
      (a) => a.name,
      (a) => ({
        description: a.description,
        value: a.value,
        deprecationReason: a.deprecationReason,
        extensions: a.extensions,
        astNode: a.astNode
      })
    );
    return {
      name: this.name,
      description: this.description,
      values: n,
      extensions: this.extensions,
      astNode: this.astNode,
      extensionASTNodes: this.extensionASTNodes
    };
  }
  toString() {
    return this.name;
  }
  toJSON() {
    return this.toString();
  }
}
function Wn(e, n) {
  const a = e.getValues().map((t) => t.name), i = tu(n, a);
  return Wo("the enum value", i);
}
function vi(e, n) {
  return gn(n) || Ee(
    !1,
    `${e} values must be an object with value names as keys.`
  ), Object.entries(n).map(([a, i]) => (gn(i) || Ee(
    !1,
    `${e}.${a} must refer to an object with a "value" key representing an internal value but got: ${Ce(i)}.`
  ), {
    name: pu(a),
    description: i.description,
    value: i.value !== void 0 ? i.value : a,
    deprecationReason: i.deprecationReason,
    extensions: $e(i.extensions),
    astNode: i.astNode
  }));
}
class _u {
  constructor(n) {
    var a, i;
    this.name = Ue(n.name), this.description = n.description, this.extensions = $e(n.extensions), this.astNode = n.astNode, this.extensionASTNodes = (a = n.extensionASTNodes) !== null && a !== void 0 ? a : [], this.isOneOf = (i = n.isOneOf) !== null && i !== void 0 ? i : !1, this._fields = Iu.bind(void 0, n);
  }
  get [Symbol.toStringTag]() {
    return "GraphQLInputObjectType";
  }
  getFields() {
    return typeof this._fields == "function" && (this._fields = this._fields()), this._fields;
  }
  toConfig() {
    const n = _r(this.getFields(), (a) => ({
      description: a.description,
      type: a.type,
      defaultValue: a.defaultValue,
      deprecationReason: a.deprecationReason,
      extensions: a.extensions,
      astNode: a.astNode
    }));
    return {
      name: this.name,
      description: this.description,
      fields: n,
      extensions: this.extensions,
      astNode: this.astNode,
      extensionASTNodes: this.extensionASTNodes,
      isOneOf: this.isOneOf
    };
  }
  toString() {
    return this.name;
  }
  toJSON() {
    return this.toString();
  }
}
function Iu(e) {
  const n = qs(e.fields);
  return gn(n) || Ee(
    !1,
    `${e.name} fields must be an object with field names as keys or a function which returns such an object.`
  ), _r(n, (a, i) => (!("resolve" in a) || Ee(
    !1,
    `${e.name}.${i} field has a resolve property, but Input Types cannot define resolvers.`
  ), {
    name: Ue(i),
    description: a.description,
    type: a.type,
    defaultValue: a.defaultValue,
    deprecationReason: a.deprecationReason,
    extensions: $e(a.extensions),
    astNode: a.astNode
  }));
}
function bc(e) {
  return Nn(e.type) && e.defaultValue === void 0;
}
function Ti(e) {
  return e;
}
function bi(e) {
  if (typeof e != "object" || e === null || Array.isArray(e))
    throw new TypeError("JSONObject cannot represent non-object value: " + e);
  return e;
}
function Ys(e, n, a) {
  var i = /* @__PURE__ */ Object.create(null);
  return n.fields.forEach(function(t) {
    i[t.name.value] = ni(e, t.value, a);
  }), i;
}
function ni(e, n, a) {
  switch (n.kind) {
    case ye.STRING:
    case ye.BOOLEAN:
      return n.value;
    case ye.INT:
    case ye.FLOAT:
      return parseFloat(n.value);
    case ye.OBJECT:
      return Ys(e, n, a);
    case ye.LIST:
      return n.values.map(function(i) {
        return ni(e, i, a);
      });
    case ye.NULL:
      return null;
    case ye.VARIABLE:
      return a ? a[n.name.value] : void 0;
    default:
      throw new TypeError(e + " cannot represent value: " + Or(n));
  }
}
var Ei = new ei({
  name: "JSON",
  description: "The `JSON` scalar type represents JSON values as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).",
  specifiedByUrl: "http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf",
  serialize: Ti,
  parseValue: Ti,
  parseLiteral: function(n, a) {
    return ni("JSON", n, a);
  }
}), Ec = new ei({
  name: "JSONObject",
  description: "The `JSONObject` scalar type represents JSON objects as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).",
  specifiedByUrl: "http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf",
  serialize: bi,
  parseValue: bi,
  parseLiteral: function(n, a) {
    if (n.kind !== ye.OBJECT)
      throw new TypeError("JSONObject cannot represent non-object value: " + Or(n));
    return Ys("JSONObject", n, a);
  }
}), Qr = {}, tn = {}, Zn = {}, gi;
function ze() {
  if (gi) return Zn;
  gi = 1, Object.defineProperty(Zn, "__esModule", {
    value: !0
  }), Zn.isObjectLike = e;
  function e(n) {
    return typeof n == "object" && n !== null;
  }
  return Zn;
}
var et = {}, nt = {}, Ni;
function Le() {
  if (Ni) return nt;
  Ni = 1, Object.defineProperty(nt, "__esModule", {
    value: !0
  }), nt.invariant = e;
  function e(n, a) {
    if (!!!n)
      throw new Error(
        a ?? "Unexpected invariant triggered."
      );
  }
  return nt;
}
var Oi;
function ti() {
  if (Oi) return et;
  Oi = 1, Object.defineProperty(et, "__esModule", {
    value: !0
  }), et.getLocation = a;
  var e = /* @__PURE__ */ Le();
  const n = /\r\n|[\n\r]/g;
  function a(i, t) {
    let r = 0, o = 1;
    for (const s of i.body.matchAll(n)) {
      if (typeof s.index == "number" || (0, e.invariant)(!1), s.index >= t)
        break;
      r = s.index + s[0].length, o += 1;
    }
    return {
      line: o,
      column: t + 1 - r
    };
  }
  return et;
}
var Rn = {}, _i;
function Js() {
  if (_i) return Rn;
  _i = 1, Object.defineProperty(Rn, "__esModule", {
    value: !0
  }), Rn.printLocation = n, Rn.printSourceLocation = a;
  var e = /* @__PURE__ */ ti();
  function n(t) {
    return a(
      t.source,
      (0, e.getLocation)(t.source, t.start)
    );
  }
  function a(t, r) {
    const o = t.locationOffset.column - 1, s = "".padStart(o) + t.body, l = r.line - 1, d = t.locationOffset.line - 1, f = r.line + d, u = r.line === 1 ? o : 0, c = r.column + u, m = `${t.name}:${f}:${c}
`, p = s.split(/\r\n|[\n\r]/g), b = p[l];
    if (b.length > 120) {
      const T = Math.floor(c / 80), y = c % 80, h = [];
      for (let I = 0; I < b.length; I += 80)
        h.push(b.slice(I, I + 80));
      return m + i([
        [`${f} |`, h[0]],
        ...h.slice(1, T + 1).map((I) => ["|", I]),
        ["|", "^".padStart(y)],
        ["|", h[T + 1]]
      ]);
    }
    return m + i([
      // Lines specified like this: ["prefix", "string"],
      [`${f - 1} |`, p[l - 1]],
      [`${f} |`, b],
      ["|", "^".padStart(c)],
      [`${f + 1} |`, p[l + 1]]
    ]);
  }
  function i(t) {
    const r = t.filter(([s, l]) => l !== void 0), o = Math.max(...r.map(([s]) => s.length));
    return r.map(([s, l]) => s.padStart(o) + (l ? " " + l : "")).join(`
`);
  }
  return Rn;
}
var Ii;
function ne() {
  if (Ii) return tn;
  Ii = 1, Object.defineProperty(tn, "__esModule", {
    value: !0
  }), tn.GraphQLError = void 0, tn.formatError = s, tn.printError = o;
  var e = /* @__PURE__ */ ze(), n = /* @__PURE__ */ ti(), a = /* @__PURE__ */ Js();
  function i(l) {
    const d = l[0];
    return d == null || "kind" in d || "length" in d ? {
      nodes: d,
      source: l[1],
      positions: l[2],
      path: l[3],
      originalError: l[4],
      extensions: l[5]
    } : d;
  }
  let t = class zs extends Error {
    /**
     * An array of `{ line, column }` locations within the source GraphQL document
     * which correspond to this error.
     *
     * Errors during validation often contain multiple locations, for example to
     * point out two things with the same name. Errors during execution include a
     * single location, the field which produced the error.
     *
     * Enumerable, and appears in the result of JSON.stringify().
     */
    /**
     * An array describing the JSON-path into the execution response which
     * corresponds to this error. Only included for errors during execution.
     *
     * Enumerable, and appears in the result of JSON.stringify().
     */
    /**
     * An array of GraphQL AST Nodes corresponding to this error.
     */
    /**
     * The source GraphQL document for the first location of this error.
     *
     * Note that if this Error represents more than one node, the source may not
     * represent nodes after the first node.
     */
    /**
     * An array of character offsets within the source GraphQL document
     * which correspond to this error.
     */
    /**
     * The original error thrown from a field resolver during execution.
     */
    /**
     * Extension fields to add to the formatted error.
     */
    /**
     * @deprecated Please use the `GraphQLErrorOptions` constructor overload instead.
     */
    constructor(d, ...f) {
      var u, c, m;
      const { nodes: p, source: b, positions: T, path: y, originalError: h, extensions: I } = i(f);
      super(d), this.name = "GraphQLError", this.path = y ?? void 0, this.originalError = h ?? void 0, this.nodes = r(
        Array.isArray(p) ? p : p ? [p] : void 0
      );
      const S = r(
        (u = this.nodes) === null || u === void 0 ? void 0 : u.map((k) => k.loc).filter((k) => k != null)
      );
      this.source = b ?? (S == null || (c = S[0]) === null || c === void 0 ? void 0 : c.source), this.positions = T ?? S?.map((k) => k.start), this.locations = T && b ? T.map((k) => (0, n.getLocation)(b, k)) : S?.map(
        (k) => (0, n.getLocation)(k.source, k.start)
      );
      const E = (0, e.isObjectLike)(
        h?.extensions
      ) ? h?.extensions : void 0;
      this.extensions = (m = I ?? E) !== null && m !== void 0 ? m : /* @__PURE__ */ Object.create(null), Object.defineProperties(this, {
        message: {
          writable: !0,
          enumerable: !0
        },
        name: {
          enumerable: !1
        },
        nodes: {
          enumerable: !1
        },
        source: {
          enumerable: !1
        },
        positions: {
          enumerable: !1
        },
        originalError: {
          enumerable: !1
        }
      }), h != null && h.stack ? Object.defineProperty(this, "stack", {
        value: h.stack,
        writable: !0,
        configurable: !0
      }) : Error.captureStackTrace ? Error.captureStackTrace(this, zs) : Object.defineProperty(this, "stack", {
        value: Error().stack,
        writable: !0,
        configurable: !0
      });
    }
    get [Symbol.toStringTag]() {
      return "GraphQLError";
    }
    toString() {
      let d = this.message;
      if (this.nodes)
        for (const f of this.nodes)
          f.loc && (d += `

` + (0, a.printLocation)(f.loc));
      else if (this.source && this.locations)
        for (const f of this.locations)
          d += `

` + (0, a.printSourceLocation)(this.source, f);
      return d;
    }
    toJSON() {
      const d = {
        message: this.message
      };
      return this.locations != null && (d.locations = this.locations), this.path != null && (d.path = this.path), this.extensions != null && Object.keys(this.extensions).length > 0 && (d.extensions = this.extensions), d;
    }
  };
  tn.GraphQLError = t;
  function r(l) {
    return l === void 0 || l.length === 0 ? void 0 : l;
  }
  function o(l) {
    return l.toString();
  }
  function s(l) {
    return l.toJSON();
  }
  return tn;
}
var tt = {}, Si;
function Sr() {
  if (Si) return tt;
  Si = 1, Object.defineProperty(tt, "__esModule", {
    value: !0
  }), tt.syntaxError = n;
  var e = /* @__PURE__ */ ne();
  function n(a, i, t) {
    return new e.GraphQLError(`Syntax Error: ${t}`, {
      source: a,
      positions: [i]
    });
  }
  return tt;
}
var rt = {}, it = {}, at = {}, Li;
function de() {
  if (Li) return at;
  Li = 1, Object.defineProperty(at, "__esModule", {
    value: !0
  }), at.inspect = a;
  const e = 10, n = 2;
  function a(d) {
    return i(d, []);
  }
  function i(d, f) {
    switch (typeof d) {
      case "string":
        return JSON.stringify(d);
      case "function":
        return d.name ? `[function ${d.name}]` : "[function]";
      case "object":
        return t(d, f);
      default:
        return String(d);
    }
  }
  function t(d, f) {
    if (d === null)
      return "null";
    if (f.includes(d))
      return "[Circular]";
    const u = [...f, d];
    if (r(d)) {
      const c = d.toJSON();
      if (c !== d)
        return typeof c == "string" ? c : i(c, u);
    } else if (Array.isArray(d))
      return s(d, u);
    return o(d, u);
  }
  function r(d) {
    return typeof d.toJSON == "function";
  }
  function o(d, f) {
    const u = Object.entries(d);
    return u.length === 0 ? "{}" : f.length > n ? "[" + l(d) + "]" : "{ " + u.map(
      ([m, p]) => m + ": " + i(p, f)
    ).join(", ") + " }";
  }
  function s(d, f) {
    if (d.length === 0)
      return "[]";
    if (f.length > n)
      return "[Array]";
    const u = Math.min(e, d.length), c = d.length - u, m = [];
    for (let p = 0; p < u; ++p)
      m.push(i(d[p], f));
    return c === 1 ? m.push("... 1 more item") : c > 1 && m.push(`... ${c} more items`), "[" + m.join(", ") + "]";
  }
  function l(d) {
    const f = Object.prototype.toString.call(d).replace(/^\[object /, "").replace(/]$/, "");
    if (f === "Object" && typeof d.constructor == "function") {
      const u = d.constructor.name;
      if (typeof u == "string" && u !== "")
        return u;
    }
    return f;
  }
  return at;
}
var Ri;
function Su() {
  if (Ri) return it;
  Ri = 1, Object.defineProperty(it, "__esModule", {
    value: !0
  }), it.toError = n;
  var e = /* @__PURE__ */ de();
  function n(i) {
    return i instanceof Error ? i : new a(i);
  }
  class a extends Error {
    constructor(t) {
      super("Unexpected error value: " + (0, e.inspect)(t)), this.name = "NonErrorThrown", this.thrownValue = t;
    }
  }
  return it;
}
var Di;
function ri() {
  if (Di) return rt;
  Di = 1, Object.defineProperty(rt, "__esModule", {
    value: !0
  }), rt.locatedError = a;
  var e = /* @__PURE__ */ Su(), n = /* @__PURE__ */ ne();
  function a(t, r, o) {
    var s;
    const l = (0, e.toError)(t);
    return i(l) ? l : new n.GraphQLError(l.message, {
      nodes: (s = l.nodes) !== null && s !== void 0 ? s : r,
      source: l.source,
      positions: l.positions,
      path: o,
      originalError: l
    });
  }
  function i(t) {
    return Array.isArray(t.path);
  }
  return rt;
}
var Ai;
function Lu() {
  return Ai || (Ai = 1, (function(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), Object.defineProperty(e, "GraphQLError", {
      enumerable: !0,
      get: function() {
        return n.GraphQLError;
      }
    }), Object.defineProperty(e, "formatError", {
      enumerable: !0,
      get: function() {
        return n.formatError;
      }
    }), Object.defineProperty(e, "locatedError", {
      enumerable: !0,
      get: function() {
        return i.locatedError;
      }
    }), Object.defineProperty(e, "printError", {
      enumerable: !0,
      get: function() {
        return n.printError;
      }
    }), Object.defineProperty(e, "syntaxError", {
      enumerable: !0,
      get: function() {
        return a.syntaxError;
      }
    });
    var n = /* @__PURE__ */ ne(), a = /* @__PURE__ */ Sr(), i = /* @__PURE__ */ ri();
  })(Qr)), Qr;
}
var qr = {}, rn = {}, ji;
function Ru() {
  if (ji) return rn;
  ji = 1, Object.defineProperty(rn, "__esModule", {
    value: !0
  }), rn.versionInfo = rn.version = void 0;
  const e = "16.12.0";
  rn.version = e;
  const n = Object.freeze({
    major: 16,
    minor: 12,
    patch: 0,
    preReleaseTag: null
  });
  return rn.versionInfo = n, rn;
}
var Dn = {}, st = {}, Pi;
function De() {
  if (Pi) return st;
  Pi = 1, Object.defineProperty(st, "__esModule", {
    value: !0
  }), st.devAssert = e;
  function e(n, a) {
    if (!!!n)
      throw new Error(a);
  }
  return st;
}
var ot = {}, ki;
function ii() {
  if (ki) return ot;
  ki = 1, Object.defineProperty(ot, "__esModule", {
    value: !0
  }), ot.isPromise = e;
  function e(n) {
    return typeof n?.then == "function";
  }
  return ot;
}
var Me = {}, Ae = {}, Fi;
function Qe() {
  if (Fi) return Ae;
  Fi = 1, Object.defineProperty(Ae, "__esModule", {
    value: !0
  }), Ae.Token = Ae.QueryDocumentKeys = Ae.OperationTypeNode = Ae.Location = void 0, Ae.isNode = t;
  class e {
    /**
     * The character offset at which this Node begins.
     */
    /**
     * The character offset at which this Node ends.
     */
    /**
     * The Token at which this Node begins.
     */
    /**
     * The Token at which this Node ends.
     */
    /**
     * The Source document the AST represents.
     */
    constructor(s, l, d) {
      this.start = s.start, this.end = l.end, this.startToken = s, this.endToken = l, this.source = d;
    }
    get [Symbol.toStringTag]() {
      return "Location";
    }
    toJSON() {
      return {
        start: this.start,
        end: this.end
      };
    }
  }
  Ae.Location = e;
  class n {
    /**
     * The kind of Token.
     */
    /**
     * The character offset at which this Node begins.
     */
    /**
     * The character offset at which this Node ends.
     */
    /**
     * The 1-indexed line number on which this Token appears.
     */
    /**
     * The 1-indexed column number at which this Token begins.
     */
    /**
     * For non-punctuation tokens, represents the interpreted value of the token.
     *
     * Note: is undefined for punctuation tokens, but typed as string for
     * convenience in the parser.
     */
    /**
     * Tokens exist as nodes in a double-linked-list amongst all tokens
     * including ignored tokens. <SOF> is always the first node and <EOF>
     * the last.
     */
    constructor(s, l, d, f, u, c) {
      this.kind = s, this.start = l, this.end = d, this.line = f, this.column = u, this.value = c, this.prev = null, this.next = null;
    }
    get [Symbol.toStringTag]() {
      return "Token";
    }
    toJSON() {
      return {
        kind: this.kind,
        value: this.value,
        line: this.line,
        column: this.column
      };
    }
  }
  Ae.Token = n;
  const a = {
    Name: [],
    Document: ["definitions"],
    OperationDefinition: [
      "description",
      "name",
      "variableDefinitions",
      "directives",
      "selectionSet"
    ],
    VariableDefinition: [
      "description",
      "variable",
      "type",
      "defaultValue",
      "directives"
    ],
    Variable: ["name"],
    SelectionSet: ["selections"],
    Field: ["alias", "name", "arguments", "directives", "selectionSet"],
    Argument: ["name", "value"],
    FragmentSpread: ["name", "directives"],
    InlineFragment: ["typeCondition", "directives", "selectionSet"],
    FragmentDefinition: [
      "description",
      "name",
      // Note: fragment variable definitions are deprecated and will removed in v17.0.0
      "variableDefinitions",
      "typeCondition",
      "directives",
      "selectionSet"
    ],
    IntValue: [],
    FloatValue: [],
    StringValue: [],
    BooleanValue: [],
    NullValue: [],
    EnumValue: [],
    ListValue: ["values"],
    ObjectValue: ["fields"],
    ObjectField: ["name", "value"],
    Directive: ["name", "arguments"],
    NamedType: ["name"],
    ListType: ["type"],
    NonNullType: ["type"],
    SchemaDefinition: ["description", "directives", "operationTypes"],
    OperationTypeDefinition: ["type"],
    ScalarTypeDefinition: ["description", "name", "directives"],
    ObjectTypeDefinition: [
      "description",
      "name",
      "interfaces",
      "directives",
      "fields"
    ],
    FieldDefinition: ["description", "name", "arguments", "type", "directives"],
    InputValueDefinition: [
      "description",
      "name",
      "type",
      "defaultValue",
      "directives"
    ],
    InterfaceTypeDefinition: [
      "description",
      "name",
      "interfaces",
      "directives",
      "fields"
    ],
    UnionTypeDefinition: ["description", "name", "directives", "types"],
    EnumTypeDefinition: ["description", "name", "directives", "values"],
    EnumValueDefinition: ["description", "name", "directives"],
    InputObjectTypeDefinition: ["description", "name", "directives", "fields"],
    DirectiveDefinition: ["description", "name", "arguments", "locations"],
    SchemaExtension: ["directives", "operationTypes"],
    ScalarTypeExtension: ["name", "directives"],
    ObjectTypeExtension: ["name", "interfaces", "directives", "fields"],
    InterfaceTypeExtension: ["name", "interfaces", "directives", "fields"],
    UnionTypeExtension: ["name", "directives", "types"],
    EnumTypeExtension: ["name", "directives", "values"],
    InputObjectTypeExtension: ["name", "directives", "fields"],
    TypeCoordinate: ["name"],
    MemberCoordinate: ["name", "memberName"],
    ArgumentCoordinate: ["name", "fieldName", "argumentName"],
    DirectiveCoordinate: ["name"],
    DirectiveArgumentCoordinate: ["name", "argumentName"]
  };
  Ae.QueryDocumentKeys = a;
  const i = new Set(Object.keys(a));
  function t(o) {
    const s = o?.kind;
    return typeof s == "string" && i.has(s);
  }
  var r;
  return Ae.OperationTypeNode = r, (function(o) {
    o.QUERY = "query", o.MUTATION = "mutation", o.SUBSCRIPTION = "subscription";
  })(r || (Ae.OperationTypeNode = r = {})), Ae;
}
var dn = {}, wi;
function Jn() {
  if (wi) return dn;
  wi = 1, Object.defineProperty(dn, "__esModule", {
    value: !0
  }), dn.DirectiveLocation = void 0;
  var e;
  return dn.DirectiveLocation = e, (function(n) {
    n.QUERY = "QUERY", n.MUTATION = "MUTATION", n.SUBSCRIPTION = "SUBSCRIPTION", n.FIELD = "FIELD", n.FRAGMENT_DEFINITION = "FRAGMENT_DEFINITION", n.FRAGMENT_SPREAD = "FRAGMENT_SPREAD", n.INLINE_FRAGMENT = "INLINE_FRAGMENT", n.VARIABLE_DEFINITION = "VARIABLE_DEFINITION", n.SCHEMA = "SCHEMA", n.SCALAR = "SCALAR", n.OBJECT = "OBJECT", n.FIELD_DEFINITION = "FIELD_DEFINITION", n.ARGUMENT_DEFINITION = "ARGUMENT_DEFINITION", n.INTERFACE = "INTERFACE", n.UNION = "UNION", n.ENUM = "ENUM", n.ENUM_VALUE = "ENUM_VALUE", n.INPUT_OBJECT = "INPUT_OBJECT", n.INPUT_FIELD_DEFINITION = "INPUT_FIELD_DEFINITION";
  })(e || (dn.DirectiveLocation = e = {})), dn;
}
var fn = {}, Vi;
function se() {
  if (Vi) return fn;
  Vi = 1, Object.defineProperty(fn, "__esModule", {
    value: !0
  }), fn.Kind = void 0;
  var e;
  return fn.Kind = e, (function(n) {
    n.NAME = "Name", n.DOCUMENT = "Document", n.OPERATION_DEFINITION = "OperationDefinition", n.VARIABLE_DEFINITION = "VariableDefinition", n.SELECTION_SET = "SelectionSet", n.FIELD = "Field", n.ARGUMENT = "Argument", n.FRAGMENT_SPREAD = "FragmentSpread", n.INLINE_FRAGMENT = "InlineFragment", n.FRAGMENT_DEFINITION = "FragmentDefinition", n.VARIABLE = "Variable", n.INT = "IntValue", n.FLOAT = "FloatValue", n.STRING = "StringValue", n.BOOLEAN = "BooleanValue", n.NULL = "NullValue", n.ENUM = "EnumValue", n.LIST = "ListValue", n.OBJECT = "ObjectValue", n.OBJECT_FIELD = "ObjectField", n.DIRECTIVE = "Directive", n.NAMED_TYPE = "NamedType", n.LIST_TYPE = "ListType", n.NON_NULL_TYPE = "NonNullType", n.SCHEMA_DEFINITION = "SchemaDefinition", n.OPERATION_TYPE_DEFINITION = "OperationTypeDefinition", n.SCALAR_TYPE_DEFINITION = "ScalarTypeDefinition", n.OBJECT_TYPE_DEFINITION = "ObjectTypeDefinition", n.FIELD_DEFINITION = "FieldDefinition", n.INPUT_VALUE_DEFINITION = "InputValueDefinition", n.INTERFACE_TYPE_DEFINITION = "InterfaceTypeDefinition", n.UNION_TYPE_DEFINITION = "UnionTypeDefinition", n.ENUM_TYPE_DEFINITION = "EnumTypeDefinition", n.ENUM_VALUE_DEFINITION = "EnumValueDefinition", n.INPUT_OBJECT_TYPE_DEFINITION = "InputObjectTypeDefinition", n.DIRECTIVE_DEFINITION = "DirectiveDefinition", n.SCHEMA_EXTENSION = "SchemaExtension", n.SCALAR_TYPE_EXTENSION = "ScalarTypeExtension", n.OBJECT_TYPE_EXTENSION = "ObjectTypeExtension", n.INTERFACE_TYPE_EXTENSION = "InterfaceTypeExtension", n.UNION_TYPE_EXTENSION = "UnionTypeExtension", n.ENUM_TYPE_EXTENSION = "EnumTypeExtension", n.INPUT_OBJECT_TYPE_EXTENSION = "InputObjectTypeExtension", n.TYPE_COORDINATE = "TypeCoordinate", n.MEMBER_COORDINATE = "MemberCoordinate", n.ARGUMENT_COORDINATE = "ArgumentCoordinate", n.DIRECTIVE_COORDINATE = "DirectiveCoordinate", n.DIRECTIVE_ARGUMENT_COORDINATE = "DirectiveArgumentCoordinate";
  })(e || (fn.Kind = e = {})), fn;
}
var Ke = {}, mn = {}, Ze = {}, Ci;
function Lr() {
  if (Ci) return Ze;
  Ci = 1, Object.defineProperty(Ze, "__esModule", {
    value: !0
  }), Ze.isDigit = n, Ze.isLetter = a, Ze.isNameContinue = t, Ze.isNameStart = i, Ze.isWhiteSpace = e;
  function e(r) {
    return r === 9 || r === 32;
  }
  function n(r) {
    return r >= 48 && r <= 57;
  }
  function a(r) {
    return r >= 97 && r <= 122 || // A-Z
    r >= 65 && r <= 90;
  }
  function i(r) {
    return a(r) || r === 95;
  }
  function t(r) {
    return a(r) || n(r) || r === 95;
  }
  return Ze;
}
var Gi;
function Rr() {
  if (Gi) return mn;
  Gi = 1, Object.defineProperty(mn, "__esModule", {
    value: !0
  }), mn.dedentBlockStringLines = n, mn.isPrintableAsBlockString = i, mn.printBlockString = t;
  var e = /* @__PURE__ */ Lr();
  function n(r) {
    var o;
    let s = Number.MAX_SAFE_INTEGER, l = null, d = -1;
    for (let u = 0; u < r.length; ++u) {
      var f;
      const c = r[u], m = a(c);
      m !== c.length && (l = (f = l) !== null && f !== void 0 ? f : u, d = u, u !== 0 && m < s && (s = m));
    }
    return r.map((u, c) => c === 0 ? u : u.slice(s)).slice(
      (o = l) !== null && o !== void 0 ? o : 0,
      d + 1
    );
  }
  function a(r) {
    let o = 0;
    for (; o < r.length && (0, e.isWhiteSpace)(r.charCodeAt(o)); )
      ++o;
    return o;
  }
  function i(r) {
    if (r === "")
      return !0;
    let o = !0, s = !1, l = !0, d = !1;
    for (let f = 0; f < r.length; ++f)
      switch (r.codePointAt(f)) {
        case 0:
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
        case 6:
        case 7:
        case 8:
        case 11:
        case 12:
        case 14:
        case 15:
          return !1;
        // Has non-printable characters
        case 13:
          return !1;
        // Has \r or \r\n which will be replaced as \n
        case 10:
          if (o && !d)
            return !1;
          d = !0, o = !0, s = !1;
          break;
        case 9:
        //   \t
        case 32:
          s || (s = o);
          break;
        default:
          l && (l = s), o = !1;
      }
    return !(o || l && d);
  }
  function t(r, o) {
    const s = r.replace(/"""/g, '\\"""'), l = s.split(/\r\n|[\n\r]/g), d = l.length === 1, f = l.length > 1 && l.slice(1).every(
      (h) => h.length === 0 || (0, e.isWhiteSpace)(h.charCodeAt(0))
    ), u = s.endsWith('\\"""'), c = r.endsWith('"') && !u, m = r.endsWith("\\"), p = c || m, b = !(o != null && o.minimize) && // add leading and trailing new lines only if it improves readability
    (!d || r.length > 70 || p || f || u);
    let T = "";
    const y = d && (0, e.isWhiteSpace)(r.charCodeAt(0));
    return (b && !y || f) && (T += `
`), T += s, (b || p) && (T += `
`), '"""' + T + '"""';
  }
  return mn;
}
var yn = {}, Mi;
function zn() {
  if (Mi) return yn;
  Mi = 1, Object.defineProperty(yn, "__esModule", {
    value: !0
  }), yn.TokenKind = void 0;
  var e;
  return yn.TokenKind = e, (function(n) {
    n.SOF = "<SOF>", n.EOF = "<EOF>", n.BANG = "!", n.DOLLAR = "$", n.AMP = "&", n.PAREN_L = "(", n.PAREN_R = ")", n.DOT = ".", n.SPREAD = "...", n.COLON = ":", n.EQUALS = "=", n.AT = "@", n.BRACKET_L = "[", n.BRACKET_R = "]", n.BRACE_L = "{", n.PIPE = "|", n.BRACE_R = "}", n.NAME = "Name", n.INT = "Int", n.FLOAT = "Float", n.STRING = "String", n.BLOCK_STRING = "BlockString", n.COMMENT = "Comment";
  })(e || (yn.TokenKind = e = {})), yn;
}
var $i;
function Dr() {
  if ($i) return Ke;
  $i = 1, Object.defineProperty(Ke, "__esModule", {
    value: !0
  }), Ke.Lexer = void 0, Ke.createToken = c, Ke.isPunctuatorTokenKind = o, Ke.printCodePointAt = u, Ke.readName = C;
  var e = /* @__PURE__ */ Sr(), n = /* @__PURE__ */ Qe(), a = /* @__PURE__ */ Rr(), i = /* @__PURE__ */ Lr(), t = /* @__PURE__ */ zn();
  class r {
    /**
     * The previously focused non-ignored token.
     */
    /**
     * The currently focused non-ignored token.
     */
    /**
     * The (1-indexed) line containing the current token.
     */
    /**
     * The character offset at which the current line begins.
     */
    constructor(N) {
      const D = new n.Token(
        t.TokenKind.SOF,
        0,
        0,
        0,
        0
      );
      this.source = N, this.lastToken = D, this.token = D, this.line = 1, this.lineStart = 0;
    }
    get [Symbol.toStringTag]() {
      return "Lexer";
    }
    /**
     * Advances the token stream to the next non-ignored token.
     */
    advance() {
      return this.lastToken = this.token, this.token = this.lookahead();
    }
    /**
     * Looks ahead and returns the next non-ignored token, but does not change
     * the state of Lexer.
     */
    lookahead() {
      let N = this.token;
      if (N.kind !== t.TokenKind.EOF)
        do
          if (N.next)
            N = N.next;
          else {
            const D = m(this, N.end);
            N.next = D, D.prev = N, N = D;
          }
        while (N.kind === t.TokenKind.COMMENT);
      return N;
    }
  }
  Ke.Lexer = r;
  function o(_) {
    return _ === t.TokenKind.BANG || _ === t.TokenKind.DOLLAR || _ === t.TokenKind.AMP || _ === t.TokenKind.PAREN_L || _ === t.TokenKind.PAREN_R || _ === t.TokenKind.DOT || _ === t.TokenKind.SPREAD || _ === t.TokenKind.COLON || _ === t.TokenKind.EQUALS || _ === t.TokenKind.AT || _ === t.TokenKind.BRACKET_L || _ === t.TokenKind.BRACKET_R || _ === t.TokenKind.BRACE_L || _ === t.TokenKind.PIPE || _ === t.TokenKind.BRACE_R;
  }
  function s(_) {
    return _ >= 0 && _ <= 55295 || _ >= 57344 && _ <= 1114111;
  }
  function l(_, N) {
    return d(_.charCodeAt(N)) && f(_.charCodeAt(N + 1));
  }
  function d(_) {
    return _ >= 55296 && _ <= 56319;
  }
  function f(_) {
    return _ >= 56320 && _ <= 57343;
  }
  function u(_, N) {
    const D = _.source.body.codePointAt(N);
    if (D === void 0)
      return t.TokenKind.EOF;
    if (D >= 32 && D <= 126) {
      const O = String.fromCodePoint(D);
      return O === '"' ? `'"'` : `"${O}"`;
    }
    return "U+" + D.toString(16).toUpperCase().padStart(4, "0");
  }
  function c(_, N, D, O, v) {
    const g = _.line, L = 1 + D - _.lineStart;
    return new n.Token(N, D, O, g, L, v);
  }
  function m(_, N) {
    const D = _.source.body, O = D.length;
    let v = N;
    for (; v < O; ) {
      const g = D.charCodeAt(v);
      switch (g) {
        // Ignored ::
        //   - UnicodeBOM
        //   - WhiteSpace
        //   - LineTerminator
        //   - Comment
        //   - Comma
        //
        // UnicodeBOM :: "Byte Order Mark (U+FEFF)"
        //
        // WhiteSpace ::
        //   - "Horizontal Tab (U+0009)"
        //   - "Space (U+0020)"
        //
        // Comma :: ,
        case 65279:
        // <BOM>
        case 9:
        // \t
        case 32:
        // <space>
        case 44:
          ++v;
          continue;
        // LineTerminator ::
        //   - "New Line (U+000A)"
        //   - "Carriage Return (U+000D)" [lookahead != "New Line (U+000A)"]
        //   - "Carriage Return (U+000D)" "New Line (U+000A)"
        case 10:
          ++v, ++_.line, _.lineStart = v;
          continue;
        case 13:
          D.charCodeAt(v + 1) === 10 ? v += 2 : ++v, ++_.line, _.lineStart = v;
          continue;
        // Comment
        case 35:
          return p(_, v);
        // Token ::
        //   - Punctuator
        //   - Name
        //   - IntValue
        //   - FloatValue
        //   - StringValue
        //
        // Punctuator :: one of ! $ & ( ) ... : = @ [ ] { | }
        case 33:
          return c(
            _,
            t.TokenKind.BANG,
            v,
            v + 1
          );
        case 36:
          return c(
            _,
            t.TokenKind.DOLLAR,
            v,
            v + 1
          );
        case 38:
          return c(
            _,
            t.TokenKind.AMP,
            v,
            v + 1
          );
        case 40:
          return c(
            _,
            t.TokenKind.PAREN_L,
            v,
            v + 1
          );
        case 41:
          return c(
            _,
            t.TokenKind.PAREN_R,
            v,
            v + 1
          );
        case 46:
          if (D.charCodeAt(v + 1) === 46 && D.charCodeAt(v + 2) === 46)
            return c(
              _,
              t.TokenKind.SPREAD,
              v,
              v + 3
            );
          break;
        case 58:
          return c(
            _,
            t.TokenKind.COLON,
            v,
            v + 1
          );
        case 61:
          return c(
            _,
            t.TokenKind.EQUALS,
            v,
            v + 1
          );
        case 64:
          return c(
            _,
            t.TokenKind.AT,
            v,
            v + 1
          );
        case 91:
          return c(
            _,
            t.TokenKind.BRACKET_L,
            v,
            v + 1
          );
        case 93:
          return c(
            _,
            t.TokenKind.BRACKET_R,
            v,
            v + 1
          );
        case 123:
          return c(
            _,
            t.TokenKind.BRACE_L,
            v,
            v + 1
          );
        case 124:
          return c(
            _,
            t.TokenKind.PIPE,
            v,
            v + 1
          );
        case 125:
          return c(
            _,
            t.TokenKind.BRACE_R,
            v,
            v + 1
          );
        // StringValue
        case 34:
          return D.charCodeAt(v + 1) === 34 && D.charCodeAt(v + 2) === 34 ? M(_, v) : y(_, v);
      }
      if ((0, i.isDigit)(g) || g === 45)
        return b(_, v, g);
      if ((0, i.isNameStart)(g))
        return C(_, v);
      throw (0, e.syntaxError)(
        _.source,
        v,
        g === 39 ? `Unexpected single quote character ('), did you mean to use a double quote (")?` : s(g) || l(D, v) ? `Unexpected character: ${u(_, v)}.` : `Invalid character: ${u(_, v)}.`
      );
    }
    return c(_, t.TokenKind.EOF, O, O);
  }
  function p(_, N) {
    const D = _.source.body, O = D.length;
    let v = N + 1;
    for (; v < O; ) {
      const g = D.charCodeAt(v);
      if (g === 10 || g === 13)
        break;
      if (s(g))
        ++v;
      else if (l(D, v))
        v += 2;
      else
        break;
    }
    return c(
      _,
      t.TokenKind.COMMENT,
      N,
      v,
      D.slice(N + 1, v)
    );
  }
  function b(_, N, D) {
    const O = _.source.body;
    let v = N, g = D, L = !1;
    if (g === 45 && (g = O.charCodeAt(++v)), g === 48) {
      if (g = O.charCodeAt(++v), (0, i.isDigit)(g))
        throw (0, e.syntaxError)(
          _.source,
          v,
          `Invalid number, unexpected digit after 0: ${u(
            _,
            v
          )}.`
        );
    } else
      v = T(_, v, g), g = O.charCodeAt(v);
    if (g === 46 && (L = !0, g = O.charCodeAt(++v), v = T(_, v, g), g = O.charCodeAt(v)), (g === 69 || g === 101) && (L = !0, g = O.charCodeAt(++v), (g === 43 || g === 45) && (g = O.charCodeAt(++v)), v = T(_, v, g), g = O.charCodeAt(v)), g === 46 || (0, i.isNameStart)(g))
      throw (0, e.syntaxError)(
        _.source,
        v,
        `Invalid number, expected digit but got: ${u(
          _,
          v
        )}.`
      );
    return c(
      _,
      L ? t.TokenKind.FLOAT : t.TokenKind.INT,
      N,
      v,
      O.slice(N, v)
    );
  }
  function T(_, N, D) {
    if (!(0, i.isDigit)(D))
      throw (0, e.syntaxError)(
        _.source,
        N,
        `Invalid number, expected digit but got: ${u(
          _,
          N
        )}.`
      );
    const O = _.source.body;
    let v = N + 1;
    for (; (0, i.isDigit)(O.charCodeAt(v)); )
      ++v;
    return v;
  }
  function y(_, N) {
    const D = _.source.body, O = D.length;
    let v = N + 1, g = v, L = "";
    for (; v < O; ) {
      const R = D.charCodeAt(v);
      if (R === 34)
        return L += D.slice(g, v), c(
          _,
          t.TokenKind.STRING,
          N,
          v + 1,
          L
        );
      if (R === 92) {
        L += D.slice(g, v);
        const j = D.charCodeAt(v + 1) === 117 ? D.charCodeAt(v + 2) === 123 ? h(_, v) : I(_, v) : k(_, v);
        L += j.value, v += j.size, g = v;
        continue;
      }
      if (R === 10 || R === 13)
        break;
      if (s(R))
        ++v;
      else if (l(D, v))
        v += 2;
      else
        throw (0, e.syntaxError)(
          _.source,
          v,
          `Invalid character within String: ${u(
            _,
            v
          )}.`
        );
    }
    throw (0, e.syntaxError)(
      _.source,
      v,
      "Unterminated string."
    );
  }
  function h(_, N) {
    const D = _.source.body;
    let O = 0, v = 3;
    for (; v < 12; ) {
      const g = D.charCodeAt(N + v++);
      if (g === 125) {
        if (v < 5 || !s(O))
          break;
        return {
          value: String.fromCodePoint(O),
          size: v
        };
      }
      if (O = O << 4 | E(g), O < 0)
        break;
    }
    throw (0, e.syntaxError)(
      _.source,
      N,
      `Invalid Unicode escape sequence: "${D.slice(
        N,
        N + v
      )}".`
    );
  }
  function I(_, N) {
    const D = _.source.body, O = S(D, N + 2);
    if (s(O))
      return {
        value: String.fromCodePoint(O),
        size: 6
      };
    if (d(O) && D.charCodeAt(N + 6) === 92 && D.charCodeAt(N + 7) === 117) {
      const v = S(D, N + 8);
      if (f(v))
        return {
          value: String.fromCodePoint(O, v),
          size: 12
        };
    }
    throw (0, e.syntaxError)(
      _.source,
      N,
      `Invalid Unicode escape sequence: "${D.slice(N, N + 6)}".`
    );
  }
  function S(_, N) {
    return E(_.charCodeAt(N)) << 12 | E(_.charCodeAt(N + 1)) << 8 | E(_.charCodeAt(N + 2)) << 4 | E(_.charCodeAt(N + 3));
  }
  function E(_) {
    return _ >= 48 && _ <= 57 ? _ - 48 : _ >= 65 && _ <= 70 ? _ - 55 : _ >= 97 && _ <= 102 ? _ - 87 : -1;
  }
  function k(_, N) {
    const D = _.source.body;
    switch (D.charCodeAt(N + 1)) {
      case 34:
        return {
          value: '"',
          size: 2
        };
      case 92:
        return {
          value: "\\",
          size: 2
        };
      case 47:
        return {
          value: "/",
          size: 2
        };
      case 98:
        return {
          value: "\b",
          size: 2
        };
      case 102:
        return {
          value: "\f",
          size: 2
        };
      case 110:
        return {
          value: `
`,
          size: 2
        };
      case 114:
        return {
          value: "\r",
          size: 2
        };
      case 116:
        return {
          value: "	",
          size: 2
        };
    }
    throw (0, e.syntaxError)(
      _.source,
      N,
      `Invalid character escape sequence: "${D.slice(
        N,
        N + 2
      )}".`
    );
  }
  function M(_, N) {
    const D = _.source.body, O = D.length;
    let v = _.lineStart, g = N + 3, L = g, R = "";
    const j = [];
    for (; g < O; ) {
      const V = D.charCodeAt(g);
      if (V === 34 && D.charCodeAt(g + 1) === 34 && D.charCodeAt(g + 2) === 34) {
        R += D.slice(L, g), j.push(R);
        const U = c(
          _,
          t.TokenKind.BLOCK_STRING,
          N,
          g + 3,
          // Return a string of the lines joined with U+000A.
          (0, a.dedentBlockStringLines)(j).join(`
`)
        );
        return _.line += j.length - 1, _.lineStart = v, U;
      }
      if (V === 92 && D.charCodeAt(g + 1) === 34 && D.charCodeAt(g + 2) === 34 && D.charCodeAt(g + 3) === 34) {
        R += D.slice(L, g), L = g + 1, g += 4;
        continue;
      }
      if (V === 10 || V === 13) {
        R += D.slice(L, g), j.push(R), V === 13 && D.charCodeAt(g + 1) === 10 ? g += 2 : ++g, R = "", L = g, v = g;
        continue;
      }
      if (s(V))
        ++g;
      else if (l(D, g))
        g += 2;
      else
        throw (0, e.syntaxError)(
          _.source,
          g,
          `Invalid character within String: ${u(
            _,
            g
          )}.`
        );
    }
    throw (0, e.syntaxError)(
      _.source,
      g,
      "Unterminated string."
    );
  }
  function C(_, N) {
    const D = _.source.body, O = D.length;
    let v = N + 1;
    for (; v < O; ) {
      const g = D.charCodeAt(v);
      if ((0, i.isNameContinue)(g))
        ++v;
      else
        break;
    }
    return c(
      _,
      t.TokenKind.NAME,
      N,
      v,
      D.slice(N, v)
    );
  }
  return Ke;
}
var An = {}, Ui;
function Du() {
  if (Ui) return An;
  Ui = 1, Object.defineProperty(An, "__esModule", {
    value: !0
  }), An.SchemaCoordinateLexer = void 0;
  var e = /* @__PURE__ */ Sr(), n = /* @__PURE__ */ Qe(), a = /* @__PURE__ */ Lr(), i = /* @__PURE__ */ Dr(), t = /* @__PURE__ */ zn();
  class r {
    /**
     * The previously focused non-ignored token.
     */
    /**
     * The currently focused non-ignored token.
     */
    /**
     * The (1-indexed) line containing the current token.
     * Since a schema coordinate may not contain newline, this value is always 1.
     */
    line = 1;
    /**
     * The character offset at which the current line begins.
     * Since a schema coordinate may not contain newline, this value is always 0.
     */
    lineStart = 0;
    constructor(l) {
      const d = new n.Token(
        t.TokenKind.SOF,
        0,
        0,
        0,
        0
      );
      this.source = l, this.lastToken = d, this.token = d;
    }
    get [Symbol.toStringTag]() {
      return "SchemaCoordinateLexer";
    }
    /**
     * Advances the token stream to the next non-ignored token.
     */
    advance() {
      return this.lastToken = this.token, this.token = this.lookahead();
    }
    /**
     * Looks ahead and returns the next non-ignored token, but does not change
     * the current Lexer token.
     */
    lookahead() {
      let l = this.token;
      if (l.kind !== t.TokenKind.EOF) {
        const d = o(this, l.end);
        l.next = d, d.prev = l, l = d;
      }
      return l;
    }
  }
  An.SchemaCoordinateLexer = r;
  function o(s, l) {
    const d = s.source.body, f = d.length, u = l;
    if (u < f) {
      const c = d.charCodeAt(u);
      switch (c) {
        case 46:
          return (0, i.createToken)(
            s,
            t.TokenKind.DOT,
            u,
            u + 1
          );
        case 40:
          return (0, i.createToken)(
            s,
            t.TokenKind.PAREN_L,
            u,
            u + 1
          );
        case 41:
          return (0, i.createToken)(
            s,
            t.TokenKind.PAREN_R,
            u,
            u + 1
          );
        case 58:
          return (0, i.createToken)(
            s,
            t.TokenKind.COLON,
            u,
            u + 1
          );
        case 64:
          return (0, i.createToken)(
            s,
            t.TokenKind.AT,
            u,
            u + 1
          );
      }
      if ((0, a.isNameStart)(c))
        return (0, i.readName)(s, u);
      throw (0, e.syntaxError)(
        s.source,
        u,
        `Invalid character: ${(0, i.printCodePointAt)(s, u)}.`
      );
    }
    return (0, i.createToken)(
      s,
      t.TokenKind.EOF,
      f,
      f
    );
  }
  return An;
}
var hn = {}, jn = {}, Qi;
function Ar() {
  if (Qi) return jn;
  Qi = 1, Object.defineProperty(jn, "__esModule", {
    value: !0
  }), jn.instanceOf = void 0;
  var e = /* @__PURE__ */ de();
  const a = (
    /* c8 ignore next 6 */
    // FIXME: https://github.com/graphql/graphql-js/issues/2317
    globalThis.process && // eslint-disable-next-line no-undef
    process.env.NODE_ENV === "production" ? function(t, r) {
      return t instanceof r;
    } : function(t, r) {
      if (t instanceof r)
        return !0;
      if (typeof t == "object" && t !== null) {
        var o;
        const s = r.prototype[Symbol.toStringTag], l = (
          // We still need to support constructor's name to detect conflicts with older versions of this library.
          Symbol.toStringTag in t ? t[Symbol.toStringTag] : (o = t.constructor) === null || o === void 0 ? void 0 : o.name
        );
        if (s === l) {
          const d = (0, e.inspect)(t);
          throw new Error(`Cannot use ${s} "${d}" from another module or realm.

Ensure that there is only one instance of "graphql" in the node_modules
directory. If different versions of "graphql" are the dependencies of other
relied on modules, use "resolutions" to ensure only one version is installed.

https://yarnpkg.com/en/docs/selective-version-resolutions

Duplicate "graphql" modules cannot be used at the same time since different
versions may have different capabilities and behavior. The data from one
version used in the function from another could produce confusing and
spurious results.`);
        }
      }
      return !1;
    }
  );
  return jn.instanceOf = a, jn;
}
var qi;
function ai() {
  if (qi) return hn;
  qi = 1, Object.defineProperty(hn, "__esModule", {
    value: !0
  }), hn.Source = void 0, hn.isSource = t;
  var e = /* @__PURE__ */ De(), n = /* @__PURE__ */ de(), a = /* @__PURE__ */ Ar();
  class i {
    constructor(o, s = "GraphQL request", l = {
      line: 1,
      column: 1
    }) {
      typeof o == "string" || (0, e.devAssert)(
        !1,
        `Body must be a string. Received: ${(0, n.inspect)(o)}.`
      ), this.body = o, this.name = s, this.locationOffset = l, this.locationOffset.line > 0 || (0, e.devAssert)(
        !1,
        "line in locationOffset is 1-indexed and must be positive."
      ), this.locationOffset.column > 0 || (0, e.devAssert)(
        !1,
        "column in locationOffset is 1-indexed and must be positive."
      );
    }
    get [Symbol.toStringTag]() {
      return "Source";
    }
  }
  hn.Source = i;
  function t(r) {
    return (0, a.instanceOf)(r, i);
  }
  return hn;
}
var Ki;
function On() {
  if (Ki) return Me;
  Ki = 1, Object.defineProperty(Me, "__esModule", {
    value: !0
  }), Me.Parser = void 0, Me.parse = l, Me.parseConstValue = f, Me.parseSchemaCoordinate = c, Me.parseType = u, Me.parseValue = d;
  var e = /* @__PURE__ */ Sr(), n = /* @__PURE__ */ Qe(), a = /* @__PURE__ */ Jn(), i = /* @__PURE__ */ se(), t = /* @__PURE__ */ Dr(), r = /* @__PURE__ */ Du(), o = /* @__PURE__ */ ai(), s = /* @__PURE__ */ zn();
  function l(T, y) {
    const h = new m(T, y), I = h.parseDocument();
    return Object.defineProperty(I, "tokenCount", {
      enumerable: !1,
      value: h.tokenCount
    }), I;
  }
  function d(T, y) {
    const h = new m(T, y);
    h.expectToken(s.TokenKind.SOF);
    const I = h.parseValueLiteral(!1);
    return h.expectToken(s.TokenKind.EOF), I;
  }
  function f(T, y) {
    const h = new m(T, y);
    h.expectToken(s.TokenKind.SOF);
    const I = h.parseConstValueLiteral();
    return h.expectToken(s.TokenKind.EOF), I;
  }
  function u(T, y) {
    const h = new m(T, y);
    h.expectToken(s.TokenKind.SOF);
    const I = h.parseTypeReference();
    return h.expectToken(s.TokenKind.EOF), I;
  }
  function c(T) {
    const y = (0, o.isSource)(T) ? T : new o.Source(T), h = new r.SchemaCoordinateLexer(y), I = new m(T, {
      lexer: h
    });
    I.expectToken(s.TokenKind.SOF);
    const S = I.parseSchemaCoordinate();
    return I.expectToken(s.TokenKind.EOF), S;
  }
  class m {
    constructor(y, h = {}) {
      const { lexer: I, ...S } = h;
      if (I)
        this._lexer = I;
      else {
        const E = (0, o.isSource)(y) ? y : new o.Source(y);
        this._lexer = new t.Lexer(E);
      }
      this._options = S, this._tokenCounter = 0;
    }
    get tokenCount() {
      return this._tokenCounter;
    }
    /**
     * Converts a name lex token into a name parse node.
     */
    parseName() {
      const y = this.expectToken(s.TokenKind.NAME);
      return this.node(y, {
        kind: i.Kind.NAME,
        value: y.value
      });
    }
    // Implements the parsing rules in the Document section.
    /**
     * Document : Definition+
     */
    parseDocument() {
      return this.node(this._lexer.token, {
        kind: i.Kind.DOCUMENT,
        definitions: this.many(
          s.TokenKind.SOF,
          this.parseDefinition,
          s.TokenKind.EOF
        )
      });
    }
    /**
     * Definition :
     *   - ExecutableDefinition
     *   - TypeSystemDefinition
     *   - TypeSystemExtension
     *
     * ExecutableDefinition :
     *   - OperationDefinition
     *   - FragmentDefinition
     *
     * TypeSystemDefinition :
     *   - SchemaDefinition
     *   - TypeDefinition
     *   - DirectiveDefinition
     *
     * TypeDefinition :
     *   - ScalarTypeDefinition
     *   - ObjectTypeDefinition
     *   - InterfaceTypeDefinition
     *   - UnionTypeDefinition
     *   - EnumTypeDefinition
     *   - InputObjectTypeDefinition
     */
    parseDefinition() {
      if (this.peek(s.TokenKind.BRACE_L))
        return this.parseOperationDefinition();
      const y = this.peekDescription(), h = y ? this._lexer.lookahead() : this._lexer.token;
      if (y && h.kind === s.TokenKind.BRACE_L)
        throw (0, e.syntaxError)(
          this._lexer.source,
          this._lexer.token.start,
          "Unexpected description, descriptions are not supported on shorthand queries."
        );
      if (h.kind === s.TokenKind.NAME) {
        switch (h.value) {
          case "schema":
            return this.parseSchemaDefinition();
          case "scalar":
            return this.parseScalarTypeDefinition();
          case "type":
            return this.parseObjectTypeDefinition();
          case "interface":
            return this.parseInterfaceTypeDefinition();
          case "union":
            return this.parseUnionTypeDefinition();
          case "enum":
            return this.parseEnumTypeDefinition();
          case "input":
            return this.parseInputObjectTypeDefinition();
          case "directive":
            return this.parseDirectiveDefinition();
        }
        switch (h.value) {
          case "query":
          case "mutation":
          case "subscription":
            return this.parseOperationDefinition();
          case "fragment":
            return this.parseFragmentDefinition();
        }
        if (y)
          throw (0, e.syntaxError)(
            this._lexer.source,
            this._lexer.token.start,
            "Unexpected description, only GraphQL definitions support descriptions."
          );
        switch (h.value) {
          case "extend":
            return this.parseTypeSystemExtension();
        }
      }
      throw this.unexpected(h);
    }
    // Implements the parsing rules in the Operations section.
    /**
     * OperationDefinition :
     *  - SelectionSet
     *  - OperationType Name? VariableDefinitions? Directives? SelectionSet
     */
    parseOperationDefinition() {
      const y = this._lexer.token;
      if (this.peek(s.TokenKind.BRACE_L))
        return this.node(y, {
          kind: i.Kind.OPERATION_DEFINITION,
          operation: n.OperationTypeNode.QUERY,
          description: void 0,
          name: void 0,
          variableDefinitions: [],
          directives: [],
          selectionSet: this.parseSelectionSet()
        });
      const h = this.parseDescription(), I = this.parseOperationType();
      let S;
      return this.peek(s.TokenKind.NAME) && (S = this.parseName()), this.node(y, {
        kind: i.Kind.OPERATION_DEFINITION,
        operation: I,
        description: h,
        name: S,
        variableDefinitions: this.parseVariableDefinitions(),
        directives: this.parseDirectives(!1),
        selectionSet: this.parseSelectionSet()
      });
    }
    /**
     * OperationType : one of query mutation subscription
     */
    parseOperationType() {
      const y = this.expectToken(s.TokenKind.NAME);
      switch (y.value) {
        case "query":
          return n.OperationTypeNode.QUERY;
        case "mutation":
          return n.OperationTypeNode.MUTATION;
        case "subscription":
          return n.OperationTypeNode.SUBSCRIPTION;
      }
      throw this.unexpected(y);
    }
    /**
     * VariableDefinitions : ( VariableDefinition+ )
     */
    parseVariableDefinitions() {
      return this.optionalMany(
        s.TokenKind.PAREN_L,
        this.parseVariableDefinition,
        s.TokenKind.PAREN_R
      );
    }
    /**
     * VariableDefinition : Variable : Type DefaultValue? Directives[Const]?
     */
    parseVariableDefinition() {
      return this.node(this._lexer.token, {
        kind: i.Kind.VARIABLE_DEFINITION,
        description: this.parseDescription(),
        variable: this.parseVariable(),
        type: (this.expectToken(s.TokenKind.COLON), this.parseTypeReference()),
        defaultValue: this.expectOptionalToken(s.TokenKind.EQUALS) ? this.parseConstValueLiteral() : void 0,
        directives: this.parseConstDirectives()
      });
    }
    /**
     * Variable : $ Name
     */
    parseVariable() {
      const y = this._lexer.token;
      return this.expectToken(s.TokenKind.DOLLAR), this.node(y, {
        kind: i.Kind.VARIABLE,
        name: this.parseName()
      });
    }
    /**
     * ```
     * SelectionSet : { Selection+ }
     * ```
     */
    parseSelectionSet() {
      return this.node(this._lexer.token, {
        kind: i.Kind.SELECTION_SET,
        selections: this.many(
          s.TokenKind.BRACE_L,
          this.parseSelection,
          s.TokenKind.BRACE_R
        )
      });
    }
    /**
     * Selection :
     *   - Field
     *   - FragmentSpread
     *   - InlineFragment
     */
    parseSelection() {
      return this.peek(s.TokenKind.SPREAD) ? this.parseFragment() : this.parseField();
    }
    /**
     * Field : Alias? Name Arguments? Directives? SelectionSet?
     *
     * Alias : Name :
     */
    parseField() {
      const y = this._lexer.token, h = this.parseName();
      let I, S;
      return this.expectOptionalToken(s.TokenKind.COLON) ? (I = h, S = this.parseName()) : S = h, this.node(y, {
        kind: i.Kind.FIELD,
        alias: I,
        name: S,
        arguments: this.parseArguments(!1),
        directives: this.parseDirectives(!1),
        selectionSet: this.peek(s.TokenKind.BRACE_L) ? this.parseSelectionSet() : void 0
      });
    }
    /**
     * Arguments[Const] : ( Argument[?Const]+ )
     */
    parseArguments(y) {
      const h = y ? this.parseConstArgument : this.parseArgument;
      return this.optionalMany(
        s.TokenKind.PAREN_L,
        h,
        s.TokenKind.PAREN_R
      );
    }
    /**
     * Argument[Const] : Name : Value[?Const]
     */
    parseArgument(y = !1) {
      const h = this._lexer.token, I = this.parseName();
      return this.expectToken(s.TokenKind.COLON), this.node(h, {
        kind: i.Kind.ARGUMENT,
        name: I,
        value: this.parseValueLiteral(y)
      });
    }
    parseConstArgument() {
      return this.parseArgument(!0);
    }
    // Implements the parsing rules in the Fragments section.
    /**
     * Corresponds to both FragmentSpread and InlineFragment in the spec.
     *
     * FragmentSpread : ... FragmentName Directives?
     *
     * InlineFragment : ... TypeCondition? Directives? SelectionSet
     */
    parseFragment() {
      const y = this._lexer.token;
      this.expectToken(s.TokenKind.SPREAD);
      const h = this.expectOptionalKeyword("on");
      return !h && this.peek(s.TokenKind.NAME) ? this.node(y, {
        kind: i.Kind.FRAGMENT_SPREAD,
        name: this.parseFragmentName(),
        directives: this.parseDirectives(!1)
      }) : this.node(y, {
        kind: i.Kind.INLINE_FRAGMENT,
        typeCondition: h ? this.parseNamedType() : void 0,
        directives: this.parseDirectives(!1),
        selectionSet: this.parseSelectionSet()
      });
    }
    /**
     * FragmentDefinition :
     *   - fragment FragmentName on TypeCondition Directives? SelectionSet
     *
     * TypeCondition : NamedType
     */
    parseFragmentDefinition() {
      const y = this._lexer.token, h = this.parseDescription();
      return this.expectKeyword("fragment"), this._options.allowLegacyFragmentVariables === !0 ? this.node(y, {
        kind: i.Kind.FRAGMENT_DEFINITION,
        description: h,
        name: this.parseFragmentName(),
        variableDefinitions: this.parseVariableDefinitions(),
        typeCondition: (this.expectKeyword("on"), this.parseNamedType()),
        directives: this.parseDirectives(!1),
        selectionSet: this.parseSelectionSet()
      }) : this.node(y, {
        kind: i.Kind.FRAGMENT_DEFINITION,
        description: h,
        name: this.parseFragmentName(),
        typeCondition: (this.expectKeyword("on"), this.parseNamedType()),
        directives: this.parseDirectives(!1),
        selectionSet: this.parseSelectionSet()
      });
    }
    /**
     * FragmentName : Name but not `on`
     */
    parseFragmentName() {
      if (this._lexer.token.value === "on")
        throw this.unexpected();
      return this.parseName();
    }
    // Implements the parsing rules in the Values section.
    /**
     * Value[Const] :
     *   - [~Const] Variable
     *   - IntValue
     *   - FloatValue
     *   - StringValue
     *   - BooleanValue
     *   - NullValue
     *   - EnumValue
     *   - ListValue[?Const]
     *   - ObjectValue[?Const]
     *
     * BooleanValue : one of `true` `false`
     *
     * NullValue : `null`
     *
     * EnumValue : Name but not `true`, `false` or `null`
     */
    parseValueLiteral(y) {
      const h = this._lexer.token;
      switch (h.kind) {
        case s.TokenKind.BRACKET_L:
          return this.parseList(y);
        case s.TokenKind.BRACE_L:
          return this.parseObject(y);
        case s.TokenKind.INT:
          return this.advanceLexer(), this.node(h, {
            kind: i.Kind.INT,
            value: h.value
          });
        case s.TokenKind.FLOAT:
          return this.advanceLexer(), this.node(h, {
            kind: i.Kind.FLOAT,
            value: h.value
          });
        case s.TokenKind.STRING:
        case s.TokenKind.BLOCK_STRING:
          return this.parseStringLiteral();
        case s.TokenKind.NAME:
          switch (this.advanceLexer(), h.value) {
            case "true":
              return this.node(h, {
                kind: i.Kind.BOOLEAN,
                value: !0
              });
            case "false":
              return this.node(h, {
                kind: i.Kind.BOOLEAN,
                value: !1
              });
            case "null":
              return this.node(h, {
                kind: i.Kind.NULL
              });
            default:
              return this.node(h, {
                kind: i.Kind.ENUM,
                value: h.value
              });
          }
        case s.TokenKind.DOLLAR:
          if (y)
            if (this.expectToken(s.TokenKind.DOLLAR), this._lexer.token.kind === s.TokenKind.NAME) {
              const I = this._lexer.token.value;
              throw (0, e.syntaxError)(
                this._lexer.source,
                h.start,
                `Unexpected variable "$${I}" in constant value.`
              );
            } else
              throw this.unexpected(h);
          return this.parseVariable();
        default:
          throw this.unexpected();
      }
    }
    parseConstValueLiteral() {
      return this.parseValueLiteral(!0);
    }
    parseStringLiteral() {
      const y = this._lexer.token;
      return this.advanceLexer(), this.node(y, {
        kind: i.Kind.STRING,
        value: y.value,
        block: y.kind === s.TokenKind.BLOCK_STRING
      });
    }
    /**
     * ListValue[Const] :
     *   - [ ]
     *   - [ Value[?Const]+ ]
     */
    parseList(y) {
      const h = () => this.parseValueLiteral(y);
      return this.node(this._lexer.token, {
        kind: i.Kind.LIST,
        values: this.any(
          s.TokenKind.BRACKET_L,
          h,
          s.TokenKind.BRACKET_R
        )
      });
    }
    /**
     * ```
     * ObjectValue[Const] :
     *   - { }
     *   - { ObjectField[?Const]+ }
     * ```
     */
    parseObject(y) {
      const h = () => this.parseObjectField(y);
      return this.node(this._lexer.token, {
        kind: i.Kind.OBJECT,
        fields: this.any(
          s.TokenKind.BRACE_L,
          h,
          s.TokenKind.BRACE_R
        )
      });
    }
    /**
     * ObjectField[Const] : Name : Value[?Const]
     */
    parseObjectField(y) {
      const h = this._lexer.token, I = this.parseName();
      return this.expectToken(s.TokenKind.COLON), this.node(h, {
        kind: i.Kind.OBJECT_FIELD,
        name: I,
        value: this.parseValueLiteral(y)
      });
    }
    // Implements the parsing rules in the Directives section.
    /**
     * Directives[Const] : Directive[?Const]+
     */
    parseDirectives(y) {
      const h = [];
      for (; this.peek(s.TokenKind.AT); )
        h.push(this.parseDirective(y));
      return h;
    }
    parseConstDirectives() {
      return this.parseDirectives(!0);
    }
    /**
     * ```
     * Directive[Const] : @ Name Arguments[?Const]?
     * ```
     */
    parseDirective(y) {
      const h = this._lexer.token;
      return this.expectToken(s.TokenKind.AT), this.node(h, {
        kind: i.Kind.DIRECTIVE,
        name: this.parseName(),
        arguments: this.parseArguments(y)
      });
    }
    // Implements the parsing rules in the Types section.
    /**
     * Type :
     *   - NamedType
     *   - ListType
     *   - NonNullType
     */
    parseTypeReference() {
      const y = this._lexer.token;
      let h;
      if (this.expectOptionalToken(s.TokenKind.BRACKET_L)) {
        const I = this.parseTypeReference();
        this.expectToken(s.TokenKind.BRACKET_R), h = this.node(y, {
          kind: i.Kind.LIST_TYPE,
          type: I
        });
      } else
        h = this.parseNamedType();
      return this.expectOptionalToken(s.TokenKind.BANG) ? this.node(y, {
        kind: i.Kind.NON_NULL_TYPE,
        type: h
      }) : h;
    }
    /**
     * NamedType : Name
     */
    parseNamedType() {
      return this.node(this._lexer.token, {
        kind: i.Kind.NAMED_TYPE,
        name: this.parseName()
      });
    }
    // Implements the parsing rules in the Type Definition section.
    peekDescription() {
      return this.peek(s.TokenKind.STRING) || this.peek(s.TokenKind.BLOCK_STRING);
    }
    /**
     * Description : StringValue
     */
    parseDescription() {
      if (this.peekDescription())
        return this.parseStringLiteral();
    }
    /**
     * ```
     * SchemaDefinition : Description? schema Directives[Const]? { OperationTypeDefinition+ }
     * ```
     */
    parseSchemaDefinition() {
      const y = this._lexer.token, h = this.parseDescription();
      this.expectKeyword("schema");
      const I = this.parseConstDirectives(), S = this.many(
        s.TokenKind.BRACE_L,
        this.parseOperationTypeDefinition,
        s.TokenKind.BRACE_R
      );
      return this.node(y, {
        kind: i.Kind.SCHEMA_DEFINITION,
        description: h,
        directives: I,
        operationTypes: S
      });
    }
    /**
     * OperationTypeDefinition : OperationType : NamedType
     */
    parseOperationTypeDefinition() {
      const y = this._lexer.token, h = this.parseOperationType();
      this.expectToken(s.TokenKind.COLON);
      const I = this.parseNamedType();
      return this.node(y, {
        kind: i.Kind.OPERATION_TYPE_DEFINITION,
        operation: h,
        type: I
      });
    }
    /**
     * ScalarTypeDefinition : Description? scalar Name Directives[Const]?
     */
    parseScalarTypeDefinition() {
      const y = this._lexer.token, h = this.parseDescription();
      this.expectKeyword("scalar");
      const I = this.parseName(), S = this.parseConstDirectives();
      return this.node(y, {
        kind: i.Kind.SCALAR_TYPE_DEFINITION,
        description: h,
        name: I,
        directives: S
      });
    }
    /**
     * ObjectTypeDefinition :
     *   Description?
     *   type Name ImplementsInterfaces? Directives[Const]? FieldsDefinition?
     */
    parseObjectTypeDefinition() {
      const y = this._lexer.token, h = this.parseDescription();
      this.expectKeyword("type");
      const I = this.parseName(), S = this.parseImplementsInterfaces(), E = this.parseConstDirectives(), k = this.parseFieldsDefinition();
      return this.node(y, {
        kind: i.Kind.OBJECT_TYPE_DEFINITION,
        description: h,
        name: I,
        interfaces: S,
        directives: E,
        fields: k
      });
    }
    /**
     * ImplementsInterfaces :
     *   - implements `&`? NamedType
     *   - ImplementsInterfaces & NamedType
     */
    parseImplementsInterfaces() {
      return this.expectOptionalKeyword("implements") ? this.delimitedMany(s.TokenKind.AMP, this.parseNamedType) : [];
    }
    /**
     * ```
     * FieldsDefinition : { FieldDefinition+ }
     * ```
     */
    parseFieldsDefinition() {
      return this.optionalMany(
        s.TokenKind.BRACE_L,
        this.parseFieldDefinition,
        s.TokenKind.BRACE_R
      );
    }
    /**
     * FieldDefinition :
     *   - Description? Name ArgumentsDefinition? : Type Directives[Const]?
     */
    parseFieldDefinition() {
      const y = this._lexer.token, h = this.parseDescription(), I = this.parseName(), S = this.parseArgumentDefs();
      this.expectToken(s.TokenKind.COLON);
      const E = this.parseTypeReference(), k = this.parseConstDirectives();
      return this.node(y, {
        kind: i.Kind.FIELD_DEFINITION,
        description: h,
        name: I,
        arguments: S,
        type: E,
        directives: k
      });
    }
    /**
     * ArgumentsDefinition : ( InputValueDefinition+ )
     */
    parseArgumentDefs() {
      return this.optionalMany(
        s.TokenKind.PAREN_L,
        this.parseInputValueDef,
        s.TokenKind.PAREN_R
      );
    }
    /**
     * InputValueDefinition :
     *   - Description? Name : Type DefaultValue? Directives[Const]?
     */
    parseInputValueDef() {
      const y = this._lexer.token, h = this.parseDescription(), I = this.parseName();
      this.expectToken(s.TokenKind.COLON);
      const S = this.parseTypeReference();
      let E;
      this.expectOptionalToken(s.TokenKind.EQUALS) && (E = this.parseConstValueLiteral());
      const k = this.parseConstDirectives();
      return this.node(y, {
        kind: i.Kind.INPUT_VALUE_DEFINITION,
        description: h,
        name: I,
        type: S,
        defaultValue: E,
        directives: k
      });
    }
    /**
     * InterfaceTypeDefinition :
     *   - Description? interface Name Directives[Const]? FieldsDefinition?
     */
    parseInterfaceTypeDefinition() {
      const y = this._lexer.token, h = this.parseDescription();
      this.expectKeyword("interface");
      const I = this.parseName(), S = this.parseImplementsInterfaces(), E = this.parseConstDirectives(), k = this.parseFieldsDefinition();
      return this.node(y, {
        kind: i.Kind.INTERFACE_TYPE_DEFINITION,
        description: h,
        name: I,
        interfaces: S,
        directives: E,
        fields: k
      });
    }
    /**
     * UnionTypeDefinition :
     *   - Description? union Name Directives[Const]? UnionMemberTypes?
     */
    parseUnionTypeDefinition() {
      const y = this._lexer.token, h = this.parseDescription();
      this.expectKeyword("union");
      const I = this.parseName(), S = this.parseConstDirectives(), E = this.parseUnionMemberTypes();
      return this.node(y, {
        kind: i.Kind.UNION_TYPE_DEFINITION,
        description: h,
        name: I,
        directives: S,
        types: E
      });
    }
    /**
     * UnionMemberTypes :
     *   - = `|`? NamedType
     *   - UnionMemberTypes | NamedType
     */
    parseUnionMemberTypes() {
      return this.expectOptionalToken(s.TokenKind.EQUALS) ? this.delimitedMany(s.TokenKind.PIPE, this.parseNamedType) : [];
    }
    /**
     * EnumTypeDefinition :
     *   - Description? enum Name Directives[Const]? EnumValuesDefinition?
     */
    parseEnumTypeDefinition() {
      const y = this._lexer.token, h = this.parseDescription();
      this.expectKeyword("enum");
      const I = this.parseName(), S = this.parseConstDirectives(), E = this.parseEnumValuesDefinition();
      return this.node(y, {
        kind: i.Kind.ENUM_TYPE_DEFINITION,
        description: h,
        name: I,
        directives: S,
        values: E
      });
    }
    /**
     * ```
     * EnumValuesDefinition : { EnumValueDefinition+ }
     * ```
     */
    parseEnumValuesDefinition() {
      return this.optionalMany(
        s.TokenKind.BRACE_L,
        this.parseEnumValueDefinition,
        s.TokenKind.BRACE_R
      );
    }
    /**
     * EnumValueDefinition : Description? EnumValue Directives[Const]?
     */
    parseEnumValueDefinition() {
      const y = this._lexer.token, h = this.parseDescription(), I = this.parseEnumValueName(), S = this.parseConstDirectives();
      return this.node(y, {
        kind: i.Kind.ENUM_VALUE_DEFINITION,
        description: h,
        name: I,
        directives: S
      });
    }
    /**
     * EnumValue : Name but not `true`, `false` or `null`
     */
    parseEnumValueName() {
      if (this._lexer.token.value === "true" || this._lexer.token.value === "false" || this._lexer.token.value === "null")
        throw (0, e.syntaxError)(
          this._lexer.source,
          this._lexer.token.start,
          `${p(
            this._lexer.token
          )} is reserved and cannot be used for an enum value.`
        );
      return this.parseName();
    }
    /**
     * InputObjectTypeDefinition :
     *   - Description? input Name Directives[Const]? InputFieldsDefinition?
     */
    parseInputObjectTypeDefinition() {
      const y = this._lexer.token, h = this.parseDescription();
      this.expectKeyword("input");
      const I = this.parseName(), S = this.parseConstDirectives(), E = this.parseInputFieldsDefinition();
      return this.node(y, {
        kind: i.Kind.INPUT_OBJECT_TYPE_DEFINITION,
        description: h,
        name: I,
        directives: S,
        fields: E
      });
    }
    /**
     * ```
     * InputFieldsDefinition : { InputValueDefinition+ }
     * ```
     */
    parseInputFieldsDefinition() {
      return this.optionalMany(
        s.TokenKind.BRACE_L,
        this.parseInputValueDef,
        s.TokenKind.BRACE_R
      );
    }
    /**
     * TypeSystemExtension :
     *   - SchemaExtension
     *   - TypeExtension
     *
     * TypeExtension :
     *   - ScalarTypeExtension
     *   - ObjectTypeExtension
     *   - InterfaceTypeExtension
     *   - UnionTypeExtension
     *   - EnumTypeExtension
     *   - InputObjectTypeDefinition
     */
    parseTypeSystemExtension() {
      const y = this._lexer.lookahead();
      if (y.kind === s.TokenKind.NAME)
        switch (y.value) {
          case "schema":
            return this.parseSchemaExtension();
          case "scalar":
            return this.parseScalarTypeExtension();
          case "type":
            return this.parseObjectTypeExtension();
          case "interface":
            return this.parseInterfaceTypeExtension();
          case "union":
            return this.parseUnionTypeExtension();
          case "enum":
            return this.parseEnumTypeExtension();
          case "input":
            return this.parseInputObjectTypeExtension();
        }
      throw this.unexpected(y);
    }
    /**
     * ```
     * SchemaExtension :
     *  - extend schema Directives[Const]? { OperationTypeDefinition+ }
     *  - extend schema Directives[Const]
     * ```
     */
    parseSchemaExtension() {
      const y = this._lexer.token;
      this.expectKeyword("extend"), this.expectKeyword("schema");
      const h = this.parseConstDirectives(), I = this.optionalMany(
        s.TokenKind.BRACE_L,
        this.parseOperationTypeDefinition,
        s.TokenKind.BRACE_R
      );
      if (h.length === 0 && I.length === 0)
        throw this.unexpected();
      return this.node(y, {
        kind: i.Kind.SCHEMA_EXTENSION,
        directives: h,
        operationTypes: I
      });
    }
    /**
     * ScalarTypeExtension :
     *   - extend scalar Name Directives[Const]
     */
    parseScalarTypeExtension() {
      const y = this._lexer.token;
      this.expectKeyword("extend"), this.expectKeyword("scalar");
      const h = this.parseName(), I = this.parseConstDirectives();
      if (I.length === 0)
        throw this.unexpected();
      return this.node(y, {
        kind: i.Kind.SCALAR_TYPE_EXTENSION,
        name: h,
        directives: I
      });
    }
    /**
     * ObjectTypeExtension :
     *  - extend type Name ImplementsInterfaces? Directives[Const]? FieldsDefinition
     *  - extend type Name ImplementsInterfaces? Directives[Const]
     *  - extend type Name ImplementsInterfaces
     */
    parseObjectTypeExtension() {
      const y = this._lexer.token;
      this.expectKeyword("extend"), this.expectKeyword("type");
      const h = this.parseName(), I = this.parseImplementsInterfaces(), S = this.parseConstDirectives(), E = this.parseFieldsDefinition();
      if (I.length === 0 && S.length === 0 && E.length === 0)
        throw this.unexpected();
      return this.node(y, {
        kind: i.Kind.OBJECT_TYPE_EXTENSION,
        name: h,
        interfaces: I,
        directives: S,
        fields: E
      });
    }
    /**
     * InterfaceTypeExtension :
     *  - extend interface Name ImplementsInterfaces? Directives[Const]? FieldsDefinition
     *  - extend interface Name ImplementsInterfaces? Directives[Const]
     *  - extend interface Name ImplementsInterfaces
     */
    parseInterfaceTypeExtension() {
      const y = this._lexer.token;
      this.expectKeyword("extend"), this.expectKeyword("interface");
      const h = this.parseName(), I = this.parseImplementsInterfaces(), S = this.parseConstDirectives(), E = this.parseFieldsDefinition();
      if (I.length === 0 && S.length === 0 && E.length === 0)
        throw this.unexpected();
      return this.node(y, {
        kind: i.Kind.INTERFACE_TYPE_EXTENSION,
        name: h,
        interfaces: I,
        directives: S,
        fields: E
      });
    }
    /**
     * UnionTypeExtension :
     *   - extend union Name Directives[Const]? UnionMemberTypes
     *   - extend union Name Directives[Const]
     */
    parseUnionTypeExtension() {
      const y = this._lexer.token;
      this.expectKeyword("extend"), this.expectKeyword("union");
      const h = this.parseName(), I = this.parseConstDirectives(), S = this.parseUnionMemberTypes();
      if (I.length === 0 && S.length === 0)
        throw this.unexpected();
      return this.node(y, {
        kind: i.Kind.UNION_TYPE_EXTENSION,
        name: h,
        directives: I,
        types: S
      });
    }
    /**
     * EnumTypeExtension :
     *   - extend enum Name Directives[Const]? EnumValuesDefinition
     *   - extend enum Name Directives[Const]
     */
    parseEnumTypeExtension() {
      const y = this._lexer.token;
      this.expectKeyword("extend"), this.expectKeyword("enum");
      const h = this.parseName(), I = this.parseConstDirectives(), S = this.parseEnumValuesDefinition();
      if (I.length === 0 && S.length === 0)
        throw this.unexpected();
      return this.node(y, {
        kind: i.Kind.ENUM_TYPE_EXTENSION,
        name: h,
        directives: I,
        values: S
      });
    }
    /**
     * InputObjectTypeExtension :
     *   - extend input Name Directives[Const]? InputFieldsDefinition
     *   - extend input Name Directives[Const]
     */
    parseInputObjectTypeExtension() {
      const y = this._lexer.token;
      this.expectKeyword("extend"), this.expectKeyword("input");
      const h = this.parseName(), I = this.parseConstDirectives(), S = this.parseInputFieldsDefinition();
      if (I.length === 0 && S.length === 0)
        throw this.unexpected();
      return this.node(y, {
        kind: i.Kind.INPUT_OBJECT_TYPE_EXTENSION,
        name: h,
        directives: I,
        fields: S
      });
    }
    /**
     * ```
     * DirectiveDefinition :
     *   - Description? directive @ Name ArgumentsDefinition? `repeatable`? on DirectiveLocations
     * ```
     */
    parseDirectiveDefinition() {
      const y = this._lexer.token, h = this.parseDescription();
      this.expectKeyword("directive"), this.expectToken(s.TokenKind.AT);
      const I = this.parseName(), S = this.parseArgumentDefs(), E = this.expectOptionalKeyword("repeatable");
      this.expectKeyword("on");
      const k = this.parseDirectiveLocations();
      return this.node(y, {
        kind: i.Kind.DIRECTIVE_DEFINITION,
        description: h,
        name: I,
        arguments: S,
        repeatable: E,
        locations: k
      });
    }
    /**
     * DirectiveLocations :
     *   - `|`? DirectiveLocation
     *   - DirectiveLocations | DirectiveLocation
     */
    parseDirectiveLocations() {
      return this.delimitedMany(
        s.TokenKind.PIPE,
        this.parseDirectiveLocation
      );
    }
    /*
     * DirectiveLocation :
     *   - ExecutableDirectiveLocation
     *   - TypeSystemDirectiveLocation
     *
     * ExecutableDirectiveLocation : one of
     *   `QUERY`
     *   `MUTATION`
     *   `SUBSCRIPTION`
     *   `FIELD`
     *   `FRAGMENT_DEFINITION`
     *   `FRAGMENT_SPREAD`
     *   `INLINE_FRAGMENT`
     *
     * TypeSystemDirectiveLocation : one of
     *   `SCHEMA`
     *   `SCALAR`
     *   `OBJECT`
     *   `FIELD_DEFINITION`
     *   `ARGUMENT_DEFINITION`
     *   `INTERFACE`
     *   `UNION`
     *   `ENUM`
     *   `ENUM_VALUE`
     *   `INPUT_OBJECT`
     *   `INPUT_FIELD_DEFINITION`
     */
    parseDirectiveLocation() {
      const y = this._lexer.token, h = this.parseName();
      if (Object.prototype.hasOwnProperty.call(
        a.DirectiveLocation,
        h.value
      ))
        return h;
      throw this.unexpected(y);
    }
    // Schema Coordinates
    /**
     * SchemaCoordinate :
     *   - Name
     *   - Name . Name
     *   - Name . Name ( Name : )
     *   - \@ Name
     *   - \@ Name ( Name : )
     */
    parseSchemaCoordinate() {
      const y = this._lexer.token, h = this.expectOptionalToken(s.TokenKind.AT), I = this.parseName();
      let S;
      !h && this.expectOptionalToken(s.TokenKind.DOT) && (S = this.parseName());
      let E;
      return (h || S) && this.expectOptionalToken(s.TokenKind.PAREN_L) && (E = this.parseName(), this.expectToken(s.TokenKind.COLON), this.expectToken(s.TokenKind.PAREN_R)), h ? E ? this.node(y, {
        kind: i.Kind.DIRECTIVE_ARGUMENT_COORDINATE,
        name: I,
        argumentName: E
      }) : this.node(y, {
        kind: i.Kind.DIRECTIVE_COORDINATE,
        name: I
      }) : S ? E ? this.node(y, {
        kind: i.Kind.ARGUMENT_COORDINATE,
        name: I,
        fieldName: S,
        argumentName: E
      }) : this.node(y, {
        kind: i.Kind.MEMBER_COORDINATE,
        name: I,
        memberName: S
      }) : this.node(y, {
        kind: i.Kind.TYPE_COORDINATE,
        name: I
      });
    }
    // Core parsing utility functions
    /**
     * Returns a node that, if configured to do so, sets a "loc" field as a
     * location object, used to identify the place in the source that created a
     * given parsed object.
     */
    node(y, h) {
      return this._options.noLocation !== !0 && (h.loc = new n.Location(
        y,
        this._lexer.lastToken,
        this._lexer.source
      )), h;
    }
    /**
     * Determines if the next token is of a given kind
     */
    peek(y) {
      return this._lexer.token.kind === y;
    }
    /**
     * If the next token is of the given kind, return that token after advancing the lexer.
     * Otherwise, do not change the parser state and throw an error.
     */
    expectToken(y) {
      const h = this._lexer.token;
      if (h.kind === y)
        return this.advanceLexer(), h;
      throw (0, e.syntaxError)(
        this._lexer.source,
        h.start,
        `Expected ${b(y)}, found ${p(h)}.`
      );
    }
    /**
     * If the next token is of the given kind, return "true" after advancing the lexer.
     * Otherwise, do not change the parser state and return "false".
     */
    expectOptionalToken(y) {
      return this._lexer.token.kind === y ? (this.advanceLexer(), !0) : !1;
    }
    /**
     * If the next token is a given keyword, advance the lexer.
     * Otherwise, do not change the parser state and throw an error.
     */
    expectKeyword(y) {
      const h = this._lexer.token;
      if (h.kind === s.TokenKind.NAME && h.value === y)
        this.advanceLexer();
      else
        throw (0, e.syntaxError)(
          this._lexer.source,
          h.start,
          `Expected "${y}", found ${p(h)}.`
        );
    }
    /**
     * If the next token is a given keyword, return "true" after advancing the lexer.
     * Otherwise, do not change the parser state and return "false".
     */
    expectOptionalKeyword(y) {
      const h = this._lexer.token;
      return h.kind === s.TokenKind.NAME && h.value === y ? (this.advanceLexer(), !0) : !1;
    }
    /**
     * Helper function for creating an error when an unexpected lexed token is encountered.
     */
    unexpected(y) {
      const h = y ?? this._lexer.token;
      return (0, e.syntaxError)(
        this._lexer.source,
        h.start,
        `Unexpected ${p(h)}.`
      );
    }
    /**
     * Returns a possibly empty list of parse nodes, determined by the parseFn.
     * This list begins with a lex token of openKind and ends with a lex token of closeKind.
     * Advances the parser to the next lex token after the closing token.
     */
    any(y, h, I) {
      this.expectToken(y);
      const S = [];
      for (; !this.expectOptionalToken(I); )
        S.push(h.call(this));
      return S;
    }
    /**
     * Returns a list of parse nodes, determined by the parseFn.
     * It can be empty only if open token is missing otherwise it will always return non-empty list
     * that begins with a lex token of openKind and ends with a lex token of closeKind.
     * Advances the parser to the next lex token after the closing token.
     */
    optionalMany(y, h, I) {
      if (this.expectOptionalToken(y)) {
        const S = [];
        do
          S.push(h.call(this));
        while (!this.expectOptionalToken(I));
        return S;
      }
      return [];
    }
    /**
     * Returns a non-empty list of parse nodes, determined by the parseFn.
     * This list begins with a lex token of openKind and ends with a lex token of closeKind.
     * Advances the parser to the next lex token after the closing token.
     */
    many(y, h, I) {
      this.expectToken(y);
      const S = [];
      do
        S.push(h.call(this));
      while (!this.expectOptionalToken(I));
      return S;
    }
    /**
     * Returns a non-empty list of parse nodes, determined by the parseFn.
     * This list may begin with a lex token of delimiterKind followed by items separated by lex tokens of tokenKind.
     * Advances the parser to the next lex token after last item in the list.
     */
    delimitedMany(y, h) {
      this.expectOptionalToken(y);
      const I = [];
      do
        I.push(h.call(this));
      while (this.expectOptionalToken(y));
      return I;
    }
    advanceLexer() {
      const { maxTokens: y } = this._options, h = this._lexer.advance();
      if (h.kind !== s.TokenKind.EOF && (++this._tokenCounter, y !== void 0 && this._tokenCounter > y))
        throw (0, e.syntaxError)(
          this._lexer.source,
          h.start,
          `Document contains more that ${y} tokens. Parsing aborted.`
        );
    }
  }
  Me.Parser = m;
  function p(T) {
    const y = T.value;
    return b(T.kind) + (y != null ? ` "${y}"` : "");
  }
  function b(T) {
    return (0, t.isPunctuatorTokenKind)(T) ? `"${T}"` : T;
  }
  return Me;
}
var Pn = {}, vn = {}, H = {}, ut = {}, Bi;
function on() {
  if (Bi) return ut;
  Bi = 1, Object.defineProperty(ut, "__esModule", {
    value: !0
  }), ut.didYouMean = n;
  const e = 5;
  function n(a, i) {
    const [t, r] = i ? [a, i] : [void 0, a];
    let o = " Did you mean ";
    t && (o += t + " ");
    const s = r.map((f) => `"${f}"`);
    switch (s.length) {
      case 0:
        return "";
      case 1:
        return o + s[0] + "?";
      case 2:
        return o + s[0] + " or " + s[1] + "?";
    }
    const l = s.slice(0, e), d = l.pop();
    return o + l.join(", ") + ", or " + d + "?";
  }
  return ut;
}
var ct = {}, xi;
function Au() {
  if (xi) return ct;
  xi = 1, Object.defineProperty(ct, "__esModule", {
    value: !0
  }), ct.identityFunc = e;
  function e(n) {
    return n;
  }
  return ct;
}
var lt = {}, Yi;
function un() {
  if (Yi) return lt;
  Yi = 1, Object.defineProperty(lt, "__esModule", {
    value: !0
  }), lt.keyMap = e;
  function e(n, a) {
    const i = /* @__PURE__ */ Object.create(null);
    for (const t of n)
      i[a(t)] = t;
    return i;
  }
  return lt;
}
var pt = {}, Ji;
function jr() {
  if (Ji) return pt;
  Ji = 1, Object.defineProperty(pt, "__esModule", {
    value: !0
  }), pt.keyValMap = e;
  function e(n, a, i) {
    const t = /* @__PURE__ */ Object.create(null);
    for (const r of n)
      t[a(r)] = i(r);
    return t;
  }
  return pt;
}
var dt = {}, zi;
function Xs() {
  if (zi) return dt;
  zi = 1, Object.defineProperty(dt, "__esModule", {
    value: !0
  }), dt.mapValue = e;
  function e(n, a) {
    const i = /* @__PURE__ */ Object.create(null);
    for (const t of Object.keys(n))
      i[t] = a(n[t], t);
    return i;
  }
  return dt;
}
var ft = {}, mt = {}, Xi;
function Pr() {
  if (Xi) return mt;
  Xi = 1, Object.defineProperty(mt, "__esModule", {
    value: !0
  }), mt.naturalCompare = e;
  function e(t, r) {
    let o = 0, s = 0;
    for (; o < t.length && s < r.length; ) {
      let l = t.charCodeAt(o), d = r.charCodeAt(s);
      if (i(l) && i(d)) {
        let f = 0;
        do
          ++o, f = f * 10 + l - n, l = t.charCodeAt(o);
        while (i(l) && f > 0);
        let u = 0;
        do
          ++s, u = u * 10 + d - n, d = r.charCodeAt(s);
        while (i(d) && u > 0);
        if (f < u)
          return -1;
        if (f > u)
          return 1;
      } else {
        if (l < d)
          return -1;
        if (l > d)
          return 1;
        ++o, ++s;
      }
    }
    return t.length - r.length;
  }
  const n = 48, a = 57;
  function i(t) {
    return !isNaN(t) && n <= t && t <= a;
  }
  return mt;
}
var Hi;
function cn() {
  if (Hi) return ft;
  Hi = 1, Object.defineProperty(ft, "__esModule", {
    value: !0
  }), ft.suggestionList = n;
  var e = /* @__PURE__ */ Pr();
  function n(t, r) {
    const o = /* @__PURE__ */ Object.create(null), s = new a(t), l = Math.floor(t.length * 0.4) + 1;
    for (const d of r) {
      const f = s.measure(d, l);
      f !== void 0 && (o[d] = f);
    }
    return Object.keys(o).sort((d, f) => {
      const u = o[d] - o[f];
      return u !== 0 ? u : (0, e.naturalCompare)(d, f);
    });
  }
  class a {
    constructor(r) {
      this._input = r, this._inputLowerCase = r.toLowerCase(), this._inputArray = i(this._inputLowerCase), this._rows = [
        new Array(r.length + 1).fill(0),
        new Array(r.length + 1).fill(0),
        new Array(r.length + 1).fill(0)
      ];
    }
    measure(r, o) {
      if (this._input === r)
        return 0;
      const s = r.toLowerCase();
      if (this._inputLowerCase === s)
        return 1;
      let l = i(s), d = this._inputArray;
      if (l.length < d.length) {
        const p = l;
        l = d, d = p;
      }
      const f = l.length, u = d.length;
      if (f - u > o)
        return;
      const c = this._rows;
      for (let p = 0; p <= u; p++)
        c[0][p] = p;
      for (let p = 1; p <= f; p++) {
        const b = c[(p - 1) % 3], T = c[p % 3];
        let y = T[0] = p;
        for (let h = 1; h <= u; h++) {
          const I = l[p - 1] === d[h - 1] ? 0 : 1;
          let S = Math.min(
            b[h] + 1,
            // delete
            T[h - 1] + 1,
            // insert
            b[h - 1] + I
            // substitute
          );
          if (p > 1 && h > 1 && l[p - 1] === d[h - 2] && l[p - 2] === d[h - 1]) {
            const E = c[(p - 2) % 3][h - 2];
            S = Math.min(S, E + 1);
          }
          S < y && (y = S), T[h] = S;
        }
        if (y > o)
          return;
      }
      const m = c[f % 3][u];
      return m <= o ? m : void 0;
    }
  }
  function i(t) {
    const r = t.length, o = new Array(r);
    for (let s = 0; s < r; ++s)
      o[s] = t.charCodeAt(s);
    return o;
  }
  return ft;
}
var yt = {}, Wi;
function si() {
  if (Wi) return yt;
  Wi = 1, Object.defineProperty(yt, "__esModule", {
    value: !0
  }), yt.toObjMap = e;
  function e(n) {
    if (n == null)
      return /* @__PURE__ */ Object.create(null);
    if (Object.getPrototypeOf(n) === null)
      return n;
    const a = /* @__PURE__ */ Object.create(null);
    for (const [i, t] of Object.entries(n))
      a[i] = t;
    return a;
  }
  return yt;
}
var ht = {}, vt = {}, Zi;
function ju() {
  if (Zi) return vt;
  Zi = 1, Object.defineProperty(vt, "__esModule", {
    value: !0
  }), vt.printString = e;
  function e(t) {
    return `"${t.replace(n, a)}"`;
  }
  const n = /[\x00-\x1f\x22\x5c\x7f-\x9f]/g;
  function a(t) {
    return i[t.charCodeAt(0)];
  }
  const i = [
    "\\u0000",
    "\\u0001",
    "\\u0002",
    "\\u0003",
    "\\u0004",
    "\\u0005",
    "\\u0006",
    "\\u0007",
    "\\b",
    "\\t",
    "\\n",
    "\\u000B",
    "\\f",
    "\\r",
    "\\u000E",
    "\\u000F",
    "\\u0010",
    "\\u0011",
    "\\u0012",
    "\\u0013",
    "\\u0014",
    "\\u0015",
    "\\u0016",
    "\\u0017",
    "\\u0018",
    "\\u0019",
    "\\u001A",
    "\\u001B",
    "\\u001C",
    "\\u001D",
    "\\u001E",
    "\\u001F",
    "",
    "",
    '\\"',
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    // 2F
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    // 3F
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    // 4F
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "\\\\",
    "",
    "",
    "",
    // 5F
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    // 6F
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "\\u007F",
    "\\u0080",
    "\\u0081",
    "\\u0082",
    "\\u0083",
    "\\u0084",
    "\\u0085",
    "\\u0086",
    "\\u0087",
    "\\u0088",
    "\\u0089",
    "\\u008A",
    "\\u008B",
    "\\u008C",
    "\\u008D",
    "\\u008E",
    "\\u008F",
    "\\u0090",
    "\\u0091",
    "\\u0092",
    "\\u0093",
    "\\u0094",
    "\\u0095",
    "\\u0096",
    "\\u0097",
    "\\u0098",
    "\\u0099",
    "\\u009A",
    "\\u009B",
    "\\u009C",
    "\\u009D",
    "\\u009E",
    "\\u009F"
  ];
  return vt;
}
var Be = {}, ea;
function _n() {
  if (ea) return Be;
  ea = 1, Object.defineProperty(Be, "__esModule", {
    value: !0
  }), Be.BREAK = void 0, Be.getEnterLeaveForKind = s, Be.getVisitFn = l, Be.visit = r, Be.visitInParallel = o;
  var e = /* @__PURE__ */ De(), n = /* @__PURE__ */ de(), a = /* @__PURE__ */ Qe(), i = /* @__PURE__ */ se();
  const t = Object.freeze({});
  Be.BREAK = t;
  function r(d, f, u = a.QueryDocumentKeys) {
    const c = /* @__PURE__ */ new Map();
    for (const N of Object.values(i.Kind))
      c.set(N, s(f, N));
    let m, p = Array.isArray(d), b = [d], T = -1, y = [], h = d, I, S;
    const E = [], k = [];
    do {
      T++;
      const N = T === b.length, D = N && y.length !== 0;
      if (N) {
        if (I = k.length === 0 ? void 0 : E[E.length - 1], h = S, S = k.pop(), D)
          if (p) {
            h = h.slice();
            let v = 0;
            for (const [g, L] of y) {
              const R = g - v;
              L === null ? (h.splice(R, 1), v++) : h[R] = L;
            }
          } else {
            h = { ...h };
            for (const [v, g] of y)
              h[v] = g;
          }
        T = m.index, b = m.keys, y = m.edits, p = m.inArray, m = m.prev;
      } else if (S) {
        if (I = p ? T : b[T], h = S[I], h == null)
          continue;
        E.push(I);
      }
      let O;
      if (!Array.isArray(h)) {
        var M, C;
        (0, a.isNode)(h) || (0, e.devAssert)(
          !1,
          `Invalid AST Node: ${(0, n.inspect)(h)}.`
        );
        const v = N ? (M = c.get(h.kind)) === null || M === void 0 ? void 0 : M.leave : (C = c.get(h.kind)) === null || C === void 0 ? void 0 : C.enter;
        if (O = v?.call(f, h, I, S, E, k), O === t)
          break;
        if (O === !1) {
          if (!N) {
            E.pop();
            continue;
          }
        } else if (O !== void 0 && (y.push([I, O]), !N))
          if ((0, a.isNode)(O))
            h = O;
          else {
            E.pop();
            continue;
          }
      }
      if (O === void 0 && D && y.push([I, h]), N)
        E.pop();
      else {
        var _;
        m = {
          inArray: p,
          index: T,
          keys: b,
          edits: y,
          prev: m
        }, p = Array.isArray(h), b = p ? h : (_ = u[h.kind]) !== null && _ !== void 0 ? _ : [], T = -1, y = [], S && k.push(S), S = h;
      }
    } while (m !== void 0);
    return y.length !== 0 ? y[y.length - 1][1] : d;
  }
  function o(d) {
    const f = new Array(d.length).fill(null), u = /* @__PURE__ */ Object.create(null);
    for (const c of Object.values(i.Kind)) {
      let m = !1;
      const p = new Array(d.length).fill(void 0), b = new Array(d.length).fill(void 0);
      for (let y = 0; y < d.length; ++y) {
        const { enter: h, leave: I } = s(d[y], c);
        m || (m = h != null || I != null), p[y] = h, b[y] = I;
      }
      if (!m)
        continue;
      const T = {
        enter(...y) {
          const h = y[0];
          for (let S = 0; S < d.length; S++)
            if (f[S] === null) {
              var I;
              const E = (I = p[S]) === null || I === void 0 ? void 0 : I.apply(d[S], y);
              if (E === !1)
                f[S] = h;
              else if (E === t)
                f[S] = t;
              else if (E !== void 0)
                return E;
            }
        },
        leave(...y) {
          const h = y[0];
          for (let S = 0; S < d.length; S++)
            if (f[S] === null) {
              var I;
              const E = (I = b[S]) === null || I === void 0 ? void 0 : I.apply(d[S], y);
              if (E === t)
                f[S] = t;
              else if (E !== void 0 && E !== !1)
                return E;
            } else f[S] === h && (f[S] = null);
        }
      };
      u[c] = T;
    }
    return u;
  }
  function s(d, f) {
    const u = d[f];
    return typeof u == "object" ? u : typeof u == "function" ? {
      enter: u,
      leave: void 0
    } : {
      enter: d.enter,
      leave: d.leave
    };
  }
  function l(d, f, u) {
    const { enter: c, leave: m } = s(d, f);
    return u ? m : c;
  }
  return Be;
}
var na;
function Fe() {
  if (na) return ht;
  na = 1, Object.defineProperty(ht, "__esModule", {
    value: !0
  }), ht.print = i;
  var e = /* @__PURE__ */ Rr(), n = /* @__PURE__ */ ju(), a = /* @__PURE__ */ _n();
  function i(u) {
    return (0, a.visit)(u, r);
  }
  const t = 80, r = {
    Name: {
      leave: (u) => u.value
    },
    Variable: {
      leave: (u) => "$" + u.name
    },
    // Document
    Document: {
      leave: (u) => o(u.definitions, `

`)
    },
    OperationDefinition: {
      leave(u) {
        const c = f(u.variableDefinitions) ? l(`(
`, o(u.variableDefinitions, `
`), `
)`) : l("(", o(u.variableDefinitions, ", "), ")"), m = l("", u.description, `
`) + o(
          [
            u.operation,
            o([u.name, c]),
            o(u.directives, " ")
          ],
          " "
        );
        return (m === "query" ? "" : m + " ") + u.selectionSet;
      }
    },
    VariableDefinition: {
      leave: ({ variable: u, type: c, defaultValue: m, directives: p, description: b }) => l("", b, `
`) + u + ": " + c + l(" = ", m) + l(" ", o(p, " "))
    },
    SelectionSet: {
      leave: ({ selections: u }) => s(u)
    },
    Field: {
      leave({ alias: u, name: c, arguments: m, directives: p, selectionSet: b }) {
        const T = l("", u, ": ") + c;
        let y = T + l("(", o(m, ", "), ")");
        return y.length > t && (y = T + l(`(
`, d(o(m, `
`)), `
)`)), o([y, o(p, " "), b], " ");
      }
    },
    Argument: {
      leave: ({ name: u, value: c }) => u + ": " + c
    },
    // Fragments
    FragmentSpread: {
      leave: ({ name: u, directives: c }) => "..." + u + l(" ", o(c, " "))
    },
    InlineFragment: {
      leave: ({ typeCondition: u, directives: c, selectionSet: m }) => o(
        [
          "...",
          l("on ", u),
          o(c, " "),
          m
        ],
        " "
      )
    },
    FragmentDefinition: {
      leave: ({
        name: u,
        typeCondition: c,
        variableDefinitions: m,
        directives: p,
        selectionSet: b,
        description: T
      }) => l("", T, `
`) + // Note: fragment variable definitions are experimental and may be changed
      // or removed in the future.
      `fragment ${u}${l("(", o(m, ", "), ")")} on ${c} ${l("", o(p, " "), " ")}` + b
    },
    // Value
    IntValue: {
      leave: ({ value: u }) => u
    },
    FloatValue: {
      leave: ({ value: u }) => u
    },
    StringValue: {
      leave: ({ value: u, block: c }) => c ? (0, e.printBlockString)(u) : (0, n.printString)(u)
    },
    BooleanValue: {
      leave: ({ value: u }) => u ? "true" : "false"
    },
    NullValue: {
      leave: () => "null"
    },
    EnumValue: {
      leave: ({ value: u }) => u
    },
    ListValue: {
      leave: ({ values: u }) => "[" + o(u, ", ") + "]"
    },
    ObjectValue: {
      leave: ({ fields: u }) => "{" + o(u, ", ") + "}"
    },
    ObjectField: {
      leave: ({ name: u, value: c }) => u + ": " + c
    },
    // Directive
    Directive: {
      leave: ({ name: u, arguments: c }) => "@" + u + l("(", o(c, ", "), ")")
    },
    // Type
    NamedType: {
      leave: ({ name: u }) => u
    },
    ListType: {
      leave: ({ type: u }) => "[" + u + "]"
    },
    NonNullType: {
      leave: ({ type: u }) => u + "!"
    },
    // Type System Definitions
    SchemaDefinition: {
      leave: ({ description: u, directives: c, operationTypes: m }) => l("", u, `
`) + o(["schema", o(c, " "), s(m)], " ")
    },
    OperationTypeDefinition: {
      leave: ({ operation: u, type: c }) => u + ": " + c
    },
    ScalarTypeDefinition: {
      leave: ({ description: u, name: c, directives: m }) => l("", u, `
`) + o(["scalar", c, o(m, " ")], " ")
    },
    ObjectTypeDefinition: {
      leave: ({ description: u, name: c, interfaces: m, directives: p, fields: b }) => l("", u, `
`) + o(
        [
          "type",
          c,
          l("implements ", o(m, " & ")),
          o(p, " "),
          s(b)
        ],
        " "
      )
    },
    FieldDefinition: {
      leave: ({ description: u, name: c, arguments: m, type: p, directives: b }) => l("", u, `
`) + c + (f(m) ? l(`(
`, d(o(m, `
`)), `
)`) : l("(", o(m, ", "), ")")) + ": " + p + l(" ", o(b, " "))
    },
    InputValueDefinition: {
      leave: ({ description: u, name: c, type: m, defaultValue: p, directives: b }) => l("", u, `
`) + o(
        [c + ": " + m, l("= ", p), o(b, " ")],
        " "
      )
    },
    InterfaceTypeDefinition: {
      leave: ({ description: u, name: c, interfaces: m, directives: p, fields: b }) => l("", u, `
`) + o(
        [
          "interface",
          c,
          l("implements ", o(m, " & ")),
          o(p, " "),
          s(b)
        ],
        " "
      )
    },
    UnionTypeDefinition: {
      leave: ({ description: u, name: c, directives: m, types: p }) => l("", u, `
`) + o(
        ["union", c, o(m, " "), l("= ", o(p, " | "))],
        " "
      )
    },
    EnumTypeDefinition: {
      leave: ({ description: u, name: c, directives: m, values: p }) => l("", u, `
`) + o(["enum", c, o(m, " "), s(p)], " ")
    },
    EnumValueDefinition: {
      leave: ({ description: u, name: c, directives: m }) => l("", u, `
`) + o([c, o(m, " ")], " ")
    },
    InputObjectTypeDefinition: {
      leave: ({ description: u, name: c, directives: m, fields: p }) => l("", u, `
`) + o(["input", c, o(m, " "), s(p)], " ")
    },
    DirectiveDefinition: {
      leave: ({ description: u, name: c, arguments: m, repeatable: p, locations: b }) => l("", u, `
`) + "directive @" + c + (f(m) ? l(`(
`, d(o(m, `
`)), `
)`) : l("(", o(m, ", "), ")")) + (p ? " repeatable" : "") + " on " + o(b, " | ")
    },
    SchemaExtension: {
      leave: ({ directives: u, operationTypes: c }) => o(
        ["extend schema", o(u, " "), s(c)],
        " "
      )
    },
    ScalarTypeExtension: {
      leave: ({ name: u, directives: c }) => o(["extend scalar", u, o(c, " ")], " ")
    },
    ObjectTypeExtension: {
      leave: ({ name: u, interfaces: c, directives: m, fields: p }) => o(
        [
          "extend type",
          u,
          l("implements ", o(c, " & ")),
          o(m, " "),
          s(p)
        ],
        " "
      )
    },
    InterfaceTypeExtension: {
      leave: ({ name: u, interfaces: c, directives: m, fields: p }) => o(
        [
          "extend interface",
          u,
          l("implements ", o(c, " & ")),
          o(m, " "),
          s(p)
        ],
        " "
      )
    },
    UnionTypeExtension: {
      leave: ({ name: u, directives: c, types: m }) => o(
        [
          "extend union",
          u,
          o(c, " "),
          l("= ", o(m, " | "))
        ],
        " "
      )
    },
    EnumTypeExtension: {
      leave: ({ name: u, directives: c, values: m }) => o(["extend enum", u, o(c, " "), s(m)], " ")
    },
    InputObjectTypeExtension: {
      leave: ({ name: u, directives: c, fields: m }) => o(["extend input", u, o(c, " "), s(m)], " ")
    },
    // Schema Coordinates
    TypeCoordinate: {
      leave: ({ name: u }) => u
    },
    MemberCoordinate: {
      leave: ({ name: u, memberName: c }) => o([u, l(".", c)])
    },
    ArgumentCoordinate: {
      leave: ({ name: u, fieldName: c, argumentName: m }) => o([u, l(".", c), l("(", m, ":)")])
    },
    DirectiveCoordinate: {
      leave: ({ name: u }) => o(["@", u])
    },
    DirectiveArgumentCoordinate: {
      leave: ({ name: u, argumentName: c }) => o(["@", u, l("(", c, ":)")])
    }
  };
  function o(u, c = "") {
    var m;
    return (m = u?.filter((p) => p).join(c)) !== null && m !== void 0 ? m : "";
  }
  function s(u) {
    return l(`{
`, d(o(u, `
`)), `
}`);
  }
  function l(u, c, m = "") {
    return c != null && c !== "" ? u + c + m : "";
  }
  function d(u) {
    return l("  ", u.replace(/\n/g, `
  `));
  }
  function f(u) {
    var c;
    return (c = u?.some((m) => m.includes(`
`))) !== null && c !== void 0 ? c : !1;
  }
  return ht;
}
var Tt = {}, ta;
function Hs() {
  if (ta) return Tt;
  ta = 1, Object.defineProperty(Tt, "__esModule", {
    value: !0
  }), Tt.valueFromASTUntyped = a;
  var e = /* @__PURE__ */ jr(), n = /* @__PURE__ */ se();
  function a(i, t) {
    switch (i.kind) {
      case n.Kind.NULL:
        return null;
      case n.Kind.INT:
        return parseInt(i.value, 10);
      case n.Kind.FLOAT:
        return parseFloat(i.value);
      case n.Kind.STRING:
      case n.Kind.ENUM:
      case n.Kind.BOOLEAN:
        return i.value;
      case n.Kind.LIST:
        return i.values.map(
          (r) => a(r, t)
        );
      case n.Kind.OBJECT:
        return (0, e.keyValMap)(
          i.fields,
          (r) => r.name.value,
          (r) => a(r.value, t)
        );
      case n.Kind.VARIABLE:
        return t?.[i.name.value];
    }
  }
  return Tt;
}
var kn = {}, ra;
function kr() {
  if (ra) return kn;
  ra = 1, Object.defineProperty(kn, "__esModule", {
    value: !0
  }), kn.assertEnumValueName = t, kn.assertName = i;
  var e = /* @__PURE__ */ De(), n = /* @__PURE__ */ ne(), a = /* @__PURE__ */ Lr();
  function i(r) {
    if (r != null || (0, e.devAssert)(!1, "Must provide name."), typeof r == "string" || (0, e.devAssert)(!1, "Expected name to be a string."), r.length === 0)
      throw new n.GraphQLError(
        "Expected name to be a non-empty string."
      );
    for (let o = 1; o < r.length; ++o)
      if (!(0, a.isNameContinue)(r.charCodeAt(o)))
        throw new n.GraphQLError(
          `Names must only contain [_a-zA-Z0-9] but "${r}" does not.`
        );
    if (!(0, a.isNameStart)(r.charCodeAt(0)))
      throw new n.GraphQLError(
        `Names must start with [_a-zA-Z] but "${r}" does not.`
      );
    return r;
  }
  function t(r) {
    if (r === "true" || r === "false" || r === "null")
      throw new n.GraphQLError(
        `Enum values cannot be named: ${r}`
      );
    return i(r);
  }
  return kn;
}
var ia;
function oe() {
  if (ia) return H;
  ia = 1, Object.defineProperty(H, "__esModule", {
    value: !0
  }), H.GraphQLUnionType = H.GraphQLScalarType = H.GraphQLObjectType = H.GraphQLNonNull = H.GraphQLList = H.GraphQLInterfaceType = H.GraphQLInputObjectType = H.GraphQLEnumType = void 0, H.argsToArgsConfig = fe, H.assertAbstractType = x, H.assertCompositeType = G, H.assertEnumType = D, H.assertInputObjectType = v, H.assertInputType = U, H.assertInterfaceType = M, H.assertLeafType = te, H.assertListType = L, H.assertNamedType = Oe, H.assertNonNullType = j, H.assertNullableType = ue, H.assertObjectType = E, H.assertOutputType = P, H.assertScalarType = I, H.assertType = y, H.assertUnionType = _, H.assertWrappingType = ee, H.defineArguments = z, H.getNamedType = ge, H.getNullableType = ce, H.isAbstractType = $, H.isCompositeType = pe, H.isEnumType = N, H.isInputObjectType = O, H.isInputType = V, H.isInterfaceType = k, H.isLeafType = K, H.isListType = g, H.isNamedType = he, H.isNonNullType = R, H.isNullableType = ie, H.isObjectType = S, H.isOutputType = W, H.isRequiredArgument = be, H.isRequiredInputField = qo, H.isScalarType = h, H.isType = T, H.isUnionType = C, H.isWrappingType = B, H.resolveObjMapThunk = _e, H.resolveReadonlyArrayThunk = ve;
  var e = /* @__PURE__ */ De(), n = /* @__PURE__ */ on(), a = /* @__PURE__ */ Au(), i = /* @__PURE__ */ de(), t = /* @__PURE__ */ Ar(), r = /* @__PURE__ */ ze(), o = /* @__PURE__ */ un(), s = /* @__PURE__ */ jr(), l = /* @__PURE__ */ Xs(), d = /* @__PURE__ */ cn(), f = /* @__PURE__ */ si(), u = /* @__PURE__ */ ne(), c = /* @__PURE__ */ se(), m = /* @__PURE__ */ Fe(), p = /* @__PURE__ */ Hs(), b = /* @__PURE__ */ kr();
  function T(A) {
    return h(A) || S(A) || k(A) || C(A) || N(A) || O(A) || g(A) || R(A);
  }
  function y(A) {
    if (!T(A))
      throw new Error(
        `Expected ${(0, i.inspect)(A)} to be a GraphQL type.`
      );
    return A;
  }
  function h(A) {
    return (0, t.instanceOf)(A, ke);
  }
  function I(A) {
    if (!h(A))
      throw new Error(
        `Expected ${(0, i.inspect)(A)} to be a GraphQL Scalar type.`
      );
    return A;
  }
  function S(A) {
    return (0, t.instanceOf)(A, nn);
  }
  function E(A) {
    if (!S(A))
      throw new Error(
        `Expected ${(0, i.inspect)(A)} to be a GraphQL Object type.`
      );
    return A;
  }
  function k(A) {
    return (0, t.instanceOf)(A, me);
  }
  function M(A) {
    if (!k(A))
      throw new Error(
        `Expected ${(0, i.inspect)(A)} to be a GraphQL Interface type.`
      );
    return A;
  }
  function C(A) {
    return (0, t.instanceOf)(A, qe);
  }
  function _(A) {
    if (!C(A))
      throw new Error(
        `Expected ${(0, i.inspect)(A)} to be a GraphQL Union type.`
      );
    return A;
  }
  function N(A) {
    return (0, t.instanceOf)(A, ln);
  }
  function D(A) {
    if (!N(A))
      throw new Error(
        `Expected ${(0, i.inspect)(A)} to be a GraphQL Enum type.`
      );
    return A;
  }
  function O(A) {
    return (0, t.instanceOf)(A, di);
  }
  function v(A) {
    if (!O(A))
      throw new Error(
        `Expected ${(0, i.inspect)(
          A
        )} to be a GraphQL Input Object type.`
      );
    return A;
  }
  function g(A) {
    return (0, t.instanceOf)(A, Y);
  }
  function L(A) {
    if (!g(A))
      throw new Error(
        `Expected ${(0, i.inspect)(A)} to be a GraphQL List type.`
      );
    return A;
  }
  function R(A) {
    return (0, t.instanceOf)(A, Z);
  }
  function j(A) {
    if (!R(A))
      throw new Error(
        `Expected ${(0, i.inspect)(A)} to be a GraphQL Non-Null type.`
      );
    return A;
  }
  function V(A) {
    return h(A) || N(A) || O(A) || B(A) && V(A.ofType);
  }
  function U(A) {
    if (!V(A))
      throw new Error(
        `Expected ${(0, i.inspect)(A)} to be a GraphQL input type.`
      );
    return A;
  }
  function W(A) {
    return h(A) || S(A) || k(A) || C(A) || N(A) || B(A) && W(A.ofType);
  }
  function P(A) {
    if (!W(A))
      throw new Error(
        `Expected ${(0, i.inspect)(A)} to be a GraphQL output type.`
      );
    return A;
  }
  function K(A) {
    return h(A) || N(A);
  }
  function te(A) {
    if (!K(A))
      throw new Error(
        `Expected ${(0, i.inspect)(A)} to be a GraphQL leaf type.`
      );
    return A;
  }
  function pe(A) {
    return S(A) || k(A) || C(A);
  }
  function G(A) {
    if (!pe(A))
      throw new Error(
        `Expected ${(0, i.inspect)(A)} to be a GraphQL composite type.`
      );
    return A;
  }
  function $(A) {
    return k(A) || C(A);
  }
  function x(A) {
    if (!$(A))
      throw new Error(
        `Expected ${(0, i.inspect)(A)} to be a GraphQL abstract type.`
      );
    return A;
  }
  class Y {
    constructor(F) {
      T(F) || (0, e.devAssert)(
        !1,
        `Expected ${(0, i.inspect)(F)} to be a GraphQL type.`
      ), this.ofType = F;
    }
    get [Symbol.toStringTag]() {
      return "GraphQLList";
    }
    toString() {
      return "[" + String(this.ofType) + "]";
    }
    toJSON() {
      return this.toString();
    }
  }
  H.GraphQLList = Y;
  class Z {
    constructor(F) {
      ie(F) || (0, e.devAssert)(
        !1,
        `Expected ${(0, i.inspect)(
          F
        )} to be a GraphQL nullable type.`
      ), this.ofType = F;
    }
    get [Symbol.toStringTag]() {
      return "GraphQLNonNull";
    }
    toString() {
      return String(this.ofType) + "!";
    }
    toJSON() {
      return this.toString();
    }
  }
  H.GraphQLNonNull = Z;
  function B(A) {
    return g(A) || R(A);
  }
  function ee(A) {
    if (!B(A))
      throw new Error(
        `Expected ${(0, i.inspect)(A)} to be a GraphQL wrapping type.`
      );
    return A;
  }
  function ie(A) {
    return T(A) && !R(A);
  }
  function ue(A) {
    if (!ie(A))
      throw new Error(
        `Expected ${(0, i.inspect)(A)} to be a GraphQL nullable type.`
      );
    return A;
  }
  function ce(A) {
    if (A)
      return R(A) ? A.ofType : A;
  }
  function he(A) {
    return h(A) || S(A) || k(A) || C(A) || N(A) || O(A);
  }
  function Oe(A) {
    if (!he(A))
      throw new Error(
        `Expected ${(0, i.inspect)(A)} to be a GraphQL named type.`
      );
    return A;
  }
  function ge(A) {
    if (A) {
      let F = A;
      for (; B(F); )
        F = F.ofType;
      return F;
    }
  }
  function ve(A) {
    return typeof A == "function" ? A() : A;
  }
  function _e(A) {
    return typeof A == "function" ? A() : A;
  }
  class ke {
    constructor(F) {
      var Q, ae, Se, pn;
      const fi = (Q = F.parseValue) !== null && Q !== void 0 ? Q : a.identityFunc;
      this.name = (0, b.assertName)(F.name), this.description = F.description, this.specifiedByURL = F.specifiedByURL, this.serialize = (ae = F.serialize) !== null && ae !== void 0 ? ae : a.identityFunc, this.parseValue = fi, this.parseLiteral = (Se = F.parseLiteral) !== null && Se !== void 0 ? Se : (Ko, Bo) => fi(
        (0, p.valueFromASTUntyped)(Ko, Bo)
      ), this.extensions = (0, f.toObjMap)(F.extensions), this.astNode = F.astNode, this.extensionASTNodes = (pn = F.extensionASTNodes) !== null && pn !== void 0 ? pn : [], F.specifiedByURL == null || typeof F.specifiedByURL == "string" || (0, e.devAssert)(
        !1,
        `${this.name} must provide "specifiedByURL" as a string, but got: ${(0, i.inspect)(F.specifiedByURL)}.`
      ), F.serialize == null || typeof F.serialize == "function" || (0, e.devAssert)(
        !1,
        `${this.name} must provide "serialize" function. If this custom Scalar is also used as an input type, ensure "parseValue" and "parseLiteral" functions are also provided.`
      ), F.parseLiteral && (typeof F.parseValue == "function" && typeof F.parseLiteral == "function" || (0, e.devAssert)(
        !1,
        `${this.name} must provide both "parseValue" and "parseLiteral" functions.`
      ));
    }
    get [Symbol.toStringTag]() {
      return "GraphQLScalarType";
    }
    toConfig() {
      return {
        name: this.name,
        description: this.description,
        specifiedByURL: this.specifiedByURL,
        serialize: this.serialize,
        parseValue: this.parseValue,
        parseLiteral: this.parseLiteral,
        extensions: this.extensions,
        astNode: this.astNode,
        extensionASTNodes: this.extensionASTNodes
      };
    }
    toString() {
      return this.name;
    }
    toJSON() {
      return this.toString();
    }
  }
  H.GraphQLScalarType = ke;
  class nn {
    constructor(F) {
      var Q;
      this.name = (0, b.assertName)(F.name), this.description = F.description, this.isTypeOf = F.isTypeOf, this.extensions = (0, f.toObjMap)(F.extensions), this.astNode = F.astNode, this.extensionASTNodes = (Q = F.extensionASTNodes) !== null && Q !== void 0 ? Q : [], this._fields = () => w(F), this._interfaces = () => We(F), F.isTypeOf == null || typeof F.isTypeOf == "function" || (0, e.devAssert)(
        !1,
        `${this.name} must provide "isTypeOf" as a function, but got: ${(0, i.inspect)(F.isTypeOf)}.`
      );
    }
    get [Symbol.toStringTag]() {
      return "GraphQLObjectType";
    }
    getFields() {
      return typeof this._fields == "function" && (this._fields = this._fields()), this._fields;
    }
    getInterfaces() {
      return typeof this._interfaces == "function" && (this._interfaces = this._interfaces()), this._interfaces;
    }
    toConfig() {
      return {
        name: this.name,
        description: this.description,
        interfaces: this.getInterfaces(),
        fields: X(this.getFields()),
        isTypeOf: this.isTypeOf,
        extensions: this.extensions,
        astNode: this.astNode,
        extensionASTNodes: this.extensionASTNodes
      };
    }
    toString() {
      return this.name;
    }
    toJSON() {
      return this.toString();
    }
  }
  H.GraphQLObjectType = nn;
  function We(A) {
    var F;
    const Q = ve(
      (F = A.interfaces) !== null && F !== void 0 ? F : []
    );
    return Array.isArray(Q) || (0, e.devAssert)(
      !1,
      `${A.name} interfaces must be an Array or a function which returns an Array.`
    ), Q;
  }
  function w(A) {
    const F = _e(A.fields);
    return q(F) || (0, e.devAssert)(
      !1,
      `${A.name} fields must be an object with field names as keys or a function which returns such an object.`
    ), (0, l.mapValue)(F, (Q, ae) => {
      var Se;
      q(Q) || (0, e.devAssert)(
        !1,
        `${A.name}.${ae} field config must be an object.`
      ), Q.resolve == null || typeof Q.resolve == "function" || (0, e.devAssert)(
        !1,
        `${A.name}.${ae} field resolver must be a function if provided, but got: ${(0, i.inspect)(Q.resolve)}.`
      );
      const pn = (Se = Q.args) !== null && Se !== void 0 ? Se : {};
      return q(pn) || (0, e.devAssert)(
        !1,
        `${A.name}.${ae} args must be an object with argument names as keys.`
      ), {
        name: (0, b.assertName)(ae),
        description: Q.description,
        type: Q.type,
        args: z(pn),
        resolve: Q.resolve,
        subscribe: Q.subscribe,
        deprecationReason: Q.deprecationReason,
        extensions: (0, f.toObjMap)(Q.extensions),
        astNode: Q.astNode
      };
    });
  }
  function z(A) {
    return Object.entries(A).map(([F, Q]) => ({
      name: (0, b.assertName)(F),
      description: Q.description,
      type: Q.type,
      defaultValue: Q.defaultValue,
      deprecationReason: Q.deprecationReason,
      extensions: (0, f.toObjMap)(Q.extensions),
      astNode: Q.astNode
    }));
  }
  function q(A) {
    return (0, r.isObjectLike)(A) && !Array.isArray(A);
  }
  function X(A) {
    return (0, l.mapValue)(A, (F) => ({
      description: F.description,
      type: F.type,
      args: fe(F.args),
      resolve: F.resolve,
      subscribe: F.subscribe,
      deprecationReason: F.deprecationReason,
      extensions: F.extensions,
      astNode: F.astNode
    }));
  }
  function fe(A) {
    return (0, s.keyValMap)(
      A,
      (F) => F.name,
      (F) => ({
        description: F.description,
        type: F.type,
        defaultValue: F.defaultValue,
        deprecationReason: F.deprecationReason,
        extensions: F.extensions,
        astNode: F.astNode
      })
    );
  }
  function be(A) {
    return R(A.type) && A.defaultValue === void 0;
  }
  class me {
    constructor(F) {
      var Q;
      this.name = (0, b.assertName)(F.name), this.description = F.description, this.resolveType = F.resolveType, this.extensions = (0, f.toObjMap)(F.extensions), this.astNode = F.astNode, this.extensionASTNodes = (Q = F.extensionASTNodes) !== null && Q !== void 0 ? Q : [], this._fields = w.bind(void 0, F), this._interfaces = We.bind(void 0, F), F.resolveType == null || typeof F.resolveType == "function" || (0, e.devAssert)(
        !1,
        `${this.name} must provide "resolveType" as a function, but got: ${(0, i.inspect)(F.resolveType)}.`
      );
    }
    get [Symbol.toStringTag]() {
      return "GraphQLInterfaceType";
    }
    getFields() {
      return typeof this._fields == "function" && (this._fields = this._fields()), this._fields;
    }
    getInterfaces() {
      return typeof this._interfaces == "function" && (this._interfaces = this._interfaces()), this._interfaces;
    }
    toConfig() {
      return {
        name: this.name,
        description: this.description,
        interfaces: this.getInterfaces(),
        fields: X(this.getFields()),
        resolveType: this.resolveType,
        extensions: this.extensions,
        astNode: this.astNode,
        extensionASTNodes: this.extensionASTNodes
      };
    }
    toString() {
      return this.name;
    }
    toJSON() {
      return this.toString();
    }
  }
  H.GraphQLInterfaceType = me;
  class qe {
    constructor(F) {
      var Q;
      this.name = (0, b.assertName)(F.name), this.description = F.description, this.resolveType = F.resolveType, this.extensions = (0, f.toObjMap)(F.extensions), this.astNode = F.astNode, this.extensionASTNodes = (Q = F.extensionASTNodes) !== null && Q !== void 0 ? Q : [], this._types = Ln.bind(void 0, F), F.resolveType == null || typeof F.resolveType == "function" || (0, e.devAssert)(
        !1,
        `${this.name} must provide "resolveType" as a function, but got: ${(0, i.inspect)(F.resolveType)}.`
      );
    }
    get [Symbol.toStringTag]() {
      return "GraphQLUnionType";
    }
    getTypes() {
      return typeof this._types == "function" && (this._types = this._types()), this._types;
    }
    toConfig() {
      return {
        name: this.name,
        description: this.description,
        types: this.getTypes(),
        resolveType: this.resolveType,
        extensions: this.extensions,
        astNode: this.astNode,
        extensionASTNodes: this.extensionASTNodes
      };
    }
    toString() {
      return this.name;
    }
    toJSON() {
      return this.toString();
    }
  }
  H.GraphQLUnionType = qe;
  function Ln(A) {
    const F = ve(A.types);
    return Array.isArray(F) || (0, e.devAssert)(
      !1,
      `Must provide Array of types or a function which returns such an array for Union ${A.name}.`
    ), F;
  }
  class ln {
    /* <T> */
    constructor(F) {
      var Q;
      this.name = (0, b.assertName)(F.name), this.description = F.description, this.extensions = (0, f.toObjMap)(F.extensions), this.astNode = F.astNode, this.extensionASTNodes = (Q = F.extensionASTNodes) !== null && Q !== void 0 ? Q : [], this._values = typeof F.values == "function" ? F.values : pi(this.name, F.values), this._valueLookup = null, this._nameLookup = null;
    }
    get [Symbol.toStringTag]() {
      return "GraphQLEnumType";
    }
    getValues() {
      return typeof this._values == "function" && (this._values = pi(this.name, this._values())), this._values;
    }
    getValue(F) {
      return this._nameLookup === null && (this._nameLookup = (0, o.keyMap)(
        this.getValues(),
        (Q) => Q.name
      )), this._nameLookup[F];
    }
    serialize(F) {
      this._valueLookup === null && (this._valueLookup = new Map(
        this.getValues().map((ae) => [ae.value, ae])
      ));
      const Q = this._valueLookup.get(F);
      if (Q === void 0)
        throw new u.GraphQLError(
          `Enum "${this.name}" cannot represent value: ${(0, i.inspect)(
            F
          )}`
        );
      return Q.name;
    }
    parseValue(F) {
      if (typeof F != "string") {
        const ae = (0, i.inspect)(F);
        throw new u.GraphQLError(
          `Enum "${this.name}" cannot represent non-string value: ${ae}.` + Ie(this, ae)
        );
      }
      const Q = this.getValue(F);
      if (Q == null)
        throw new u.GraphQLError(
          `Value "${F}" does not exist in "${this.name}" enum.` + Ie(this, F)
        );
      return Q.value;
    }
    parseLiteral(F, Q) {
      if (F.kind !== c.Kind.ENUM) {
        const Se = (0, m.print)(F);
        throw new u.GraphQLError(
          `Enum "${this.name}" cannot represent non-enum value: ${Se}.` + Ie(this, Se),
          {
            nodes: F
          }
        );
      }
      const ae = this.getValue(F.value);
      if (ae == null) {
        const Se = (0, m.print)(F);
        throw new u.GraphQLError(
          `Value "${Se}" does not exist in "${this.name}" enum.` + Ie(this, Se),
          {
            nodes: F
          }
        );
      }
      return ae.value;
    }
    toConfig() {
      const F = (0, s.keyValMap)(
        this.getValues(),
        (Q) => Q.name,
        (Q) => ({
          description: Q.description,
          value: Q.value,
          deprecationReason: Q.deprecationReason,
          extensions: Q.extensions,
          astNode: Q.astNode
        })
      );
      return {
        name: this.name,
        description: this.description,
        values: F,
        extensions: this.extensions,
        astNode: this.astNode,
        extensionASTNodes: this.extensionASTNodes
      };
    }
    toString() {
      return this.name;
    }
    toJSON() {
      return this.toString();
    }
  }
  H.GraphQLEnumType = ln;
  function Ie(A, F) {
    const Q = A.getValues().map((Se) => Se.name), ae = (0, d.suggestionList)(
      F,
      Q
    );
    return (0, n.didYouMean)("the enum value", ae);
  }
  function pi(A, F) {
    return q(F) || (0, e.devAssert)(
      !1,
      `${A} values must be an object with value names as keys.`
    ), Object.entries(F).map(([Q, ae]) => (q(ae) || (0, e.devAssert)(
      !1,
      `${A}.${Q} must refer to an object with a "value" key representing an internal value but got: ${(0, i.inspect)(
        ae
      )}.`
    ), {
      name: (0, b.assertEnumValueName)(Q),
      description: ae.description,
      value: ae.value !== void 0 ? ae.value : Q,
      deprecationReason: ae.deprecationReason,
      extensions: (0, f.toObjMap)(ae.extensions),
      astNode: ae.astNode
    }));
  }
  class di {
    constructor(F) {
      var Q, ae;
      this.name = (0, b.assertName)(F.name), this.description = F.description, this.extensions = (0, f.toObjMap)(F.extensions), this.astNode = F.astNode, this.extensionASTNodes = (Q = F.extensionASTNodes) !== null && Q !== void 0 ? Q : [], this.isOneOf = (ae = F.isOneOf) !== null && ae !== void 0 ? ae : !1, this._fields = Qo.bind(void 0, F);
    }
    get [Symbol.toStringTag]() {
      return "GraphQLInputObjectType";
    }
    getFields() {
      return typeof this._fields == "function" && (this._fields = this._fields()), this._fields;
    }
    toConfig() {
      const F = (0, l.mapValue)(this.getFields(), (Q) => ({
        description: Q.description,
        type: Q.type,
        defaultValue: Q.defaultValue,
        deprecationReason: Q.deprecationReason,
        extensions: Q.extensions,
        astNode: Q.astNode
      }));
      return {
        name: this.name,
        description: this.description,
        fields: F,
        extensions: this.extensions,
        astNode: this.astNode,
        extensionASTNodes: this.extensionASTNodes,
        isOneOf: this.isOneOf
      };
    }
    toString() {
      return this.name;
    }
    toJSON() {
      return this.toString();
    }
  }
  H.GraphQLInputObjectType = di;
  function Qo(A) {
    const F = _e(A.fields);
    return q(F) || (0, e.devAssert)(
      !1,
      `${A.name} fields must be an object with field names as keys or a function which returns such an object.`
    ), (0, l.mapValue)(F, (Q, ae) => (!("resolve" in Q) || (0, e.devAssert)(
      !1,
      `${A.name}.${ae} field has a resolve property, but Input Types cannot define resolvers.`
    ), {
      name: (0, b.assertName)(ae),
      description: Q.description,
      type: Q.type,
      defaultValue: Q.defaultValue,
      deprecationReason: Q.deprecationReason,
      extensions: (0, f.toObjMap)(Q.extensions),
      astNode: Q.astNode
    }));
  }
  function qo(A) {
    return R(A.type) && A.defaultValue === void 0;
  }
  return H;
}
var aa;
function Fr() {
  if (aa) return vn;
  aa = 1, Object.defineProperty(vn, "__esModule", {
    value: !0
  }), vn.doTypesOverlap = i, vn.isEqualType = n, vn.isTypeSubTypeOf = a;
  var e = /* @__PURE__ */ oe();
  function n(t, r) {
    return t === r ? !0 : (0, e.isNonNullType)(t) && (0, e.isNonNullType)(r) || (0, e.isListType)(t) && (0, e.isListType)(r) ? n(t.ofType, r.ofType) : !1;
  }
  function a(t, r, o) {
    return r === o ? !0 : (0, e.isNonNullType)(o) ? (0, e.isNonNullType)(r) ? a(t, r.ofType, o.ofType) : !1 : (0, e.isNonNullType)(r) ? a(t, r.ofType, o) : (0, e.isListType)(o) ? (0, e.isListType)(r) ? a(t, r.ofType, o.ofType) : !1 : (0, e.isListType)(r) ? !1 : (0, e.isAbstractType)(o) && ((0, e.isInterfaceType)(r) || (0, e.isObjectType)(r)) && t.isSubType(o, r);
  }
  function i(t, r, o) {
    return r === o ? !0 : (0, e.isAbstractType)(r) ? (0, e.isAbstractType)(o) ? t.getPossibleTypes(r).some((s) => t.isSubType(o, s)) : t.isSubType(r, o) : (0, e.isAbstractType)(o) ? t.isSubType(o, r) : !1;
  }
  return vn;
}
var Te = {}, Ne = {}, sa;
function Xe() {
  if (sa) return Ne;
  sa = 1, Object.defineProperty(Ne, "__esModule", {
    value: !0
  }), Ne.GraphQLString = Ne.GraphQLInt = Ne.GraphQLID = Ne.GraphQLFloat = Ne.GraphQLBoolean = Ne.GRAPHQL_MIN_INT = Ne.GRAPHQL_MAX_INT = void 0, Ne.isSpecifiedScalarType = p, Ne.specifiedScalarTypes = void 0;
  var e = /* @__PURE__ */ de(), n = /* @__PURE__ */ ze(), a = /* @__PURE__ */ ne(), i = /* @__PURE__ */ se(), t = /* @__PURE__ */ Fe(), r = /* @__PURE__ */ oe();
  const o = 2147483647;
  Ne.GRAPHQL_MAX_INT = o;
  const s = -2147483648;
  Ne.GRAPHQL_MIN_INT = s;
  const l = new r.GraphQLScalarType({
    name: "Int",
    description: "The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.",
    serialize(T) {
      const y = b(T);
      if (typeof y == "boolean")
        return y ? 1 : 0;
      let h = y;
      if (typeof y == "string" && y !== "" && (h = Number(y)), typeof h != "number" || !Number.isInteger(h))
        throw new a.GraphQLError(
          `Int cannot represent non-integer value: ${(0, e.inspect)(
            y
          )}`
        );
      if (h > o || h < s)
        throw new a.GraphQLError(
          "Int cannot represent non 32-bit signed integer value: " + (0, e.inspect)(y)
        );
      return h;
    },
    parseValue(T) {
      if (typeof T != "number" || !Number.isInteger(T))
        throw new a.GraphQLError(
          `Int cannot represent non-integer value: ${(0, e.inspect)(
            T
          )}`
        );
      if (T > o || T < s)
        throw new a.GraphQLError(
          `Int cannot represent non 32-bit signed integer value: ${T}`
        );
      return T;
    },
    parseLiteral(T) {
      if (T.kind !== i.Kind.INT)
        throw new a.GraphQLError(
          `Int cannot represent non-integer value: ${(0, t.print)(
            T
          )}`,
          {
            nodes: T
          }
        );
      const y = parseInt(T.value, 10);
      if (y > o || y < s)
        throw new a.GraphQLError(
          `Int cannot represent non 32-bit signed integer value: ${T.value}`,
          {
            nodes: T
          }
        );
      return y;
    }
  });
  Ne.GraphQLInt = l;
  const d = new r.GraphQLScalarType({
    name: "Float",
    description: "The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](https://en.wikipedia.org/wiki/IEEE_floating_point).",
    serialize(T) {
      const y = b(T);
      if (typeof y == "boolean")
        return y ? 1 : 0;
      let h = y;
      if (typeof y == "string" && y !== "" && (h = Number(y)), typeof h != "number" || !Number.isFinite(h))
        throw new a.GraphQLError(
          `Float cannot represent non numeric value: ${(0, e.inspect)(
            y
          )}`
        );
      return h;
    },
    parseValue(T) {
      if (typeof T != "number" || !Number.isFinite(T))
        throw new a.GraphQLError(
          `Float cannot represent non numeric value: ${(0, e.inspect)(
            T
          )}`
        );
      return T;
    },
    parseLiteral(T) {
      if (T.kind !== i.Kind.FLOAT && T.kind !== i.Kind.INT)
        throw new a.GraphQLError(
          `Float cannot represent non numeric value: ${(0, t.print)(
            T
          )}`,
          T
        );
      return parseFloat(T.value);
    }
  });
  Ne.GraphQLFloat = d;
  const f = new r.GraphQLScalarType({
    name: "String",
    description: "The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.",
    serialize(T) {
      const y = b(T);
      if (typeof y == "string")
        return y;
      if (typeof y == "boolean")
        return y ? "true" : "false";
      if (typeof y == "number" && Number.isFinite(y))
        return y.toString();
      throw new a.GraphQLError(
        `String cannot represent value: ${(0, e.inspect)(T)}`
      );
    },
    parseValue(T) {
      if (typeof T != "string")
        throw new a.GraphQLError(
          `String cannot represent a non string value: ${(0, e.inspect)(
            T
          )}`
        );
      return T;
    },
    parseLiteral(T) {
      if (T.kind !== i.Kind.STRING)
        throw new a.GraphQLError(
          `String cannot represent a non string value: ${(0, t.print)(
            T
          )}`,
          {
            nodes: T
          }
        );
      return T.value;
    }
  });
  Ne.GraphQLString = f;
  const u = new r.GraphQLScalarType({
    name: "Boolean",
    description: "The `Boolean` scalar type represents `true` or `false`.",
    serialize(T) {
      const y = b(T);
      if (typeof y == "boolean")
        return y;
      if (Number.isFinite(y))
        return y !== 0;
      throw new a.GraphQLError(
        `Boolean cannot represent a non boolean value: ${(0, e.inspect)(
          y
        )}`
      );
    },
    parseValue(T) {
      if (typeof T != "boolean")
        throw new a.GraphQLError(
          `Boolean cannot represent a non boolean value: ${(0, e.inspect)(
            T
          )}`
        );
      return T;
    },
    parseLiteral(T) {
      if (T.kind !== i.Kind.BOOLEAN)
        throw new a.GraphQLError(
          `Boolean cannot represent a non boolean value: ${(0, t.print)(
            T
          )}`,
          {
            nodes: T
          }
        );
      return T.value;
    }
  });
  Ne.GraphQLBoolean = u;
  const c = new r.GraphQLScalarType({
    name: "ID",
    description: 'The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.',
    serialize(T) {
      const y = b(T);
      if (typeof y == "string")
        return y;
      if (Number.isInteger(y))
        return String(y);
      throw new a.GraphQLError(
        `ID cannot represent value: ${(0, e.inspect)(T)}`
      );
    },
    parseValue(T) {
      if (typeof T == "string")
        return T;
      if (typeof T == "number" && Number.isInteger(T))
        return T.toString();
      throw new a.GraphQLError(
        `ID cannot represent value: ${(0, e.inspect)(T)}`
      );
    },
    parseLiteral(T) {
      if (T.kind !== i.Kind.STRING && T.kind !== i.Kind.INT)
        throw new a.GraphQLError(
          "ID cannot represent a non-string and non-integer value: " + (0, t.print)(T),
          {
            nodes: T
          }
        );
      return T.value;
    }
  });
  Ne.GraphQLID = c;
  const m = Object.freeze([
    f,
    l,
    d,
    u,
    c
  ]);
  Ne.specifiedScalarTypes = m;
  function p(T) {
    return m.some(({ name: y }) => T.name === y);
  }
  function b(T) {
    if ((0, n.isObjectLike)(T)) {
      if (typeof T.valueOf == "function") {
        const y = T.valueOf();
        if (!(0, n.isObjectLike)(y))
          return y;
      }
      if (typeof T.toJSON == "function")
        return T.toJSON();
    }
    return T;
  }
  return Ne;
}
var oa;
function Pe() {
  if (oa) return Te;
  oa = 1, Object.defineProperty(Te, "__esModule", {
    value: !0
  }), Te.GraphQLSpecifiedByDirective = Te.GraphQLSkipDirective = Te.GraphQLOneOfDirective = Te.GraphQLIncludeDirective = Te.GraphQLDirective = Te.GraphQLDeprecatedDirective = Te.DEFAULT_DEPRECATION_REASON = void 0, Te.assertDirective = f, Te.isDirective = d, Te.isSpecifiedDirective = I, Te.specifiedDirectives = void 0;
  var e = /* @__PURE__ */ De(), n = /* @__PURE__ */ de(), a = /* @__PURE__ */ Ar(), i = /* @__PURE__ */ ze(), t = /* @__PURE__ */ si(), r = /* @__PURE__ */ Jn(), o = /* @__PURE__ */ kr(), s = /* @__PURE__ */ oe(), l = /* @__PURE__ */ Xe();
  function d(S) {
    return (0, a.instanceOf)(S, u);
  }
  function f(S) {
    if (!d(S))
      throw new Error(
        `Expected ${(0, n.inspect)(S)} to be a GraphQL directive.`
      );
    return S;
  }
  class u {
    constructor(E) {
      var k, M;
      this.name = (0, o.assertName)(E.name), this.description = E.description, this.locations = E.locations, this.isRepeatable = (k = E.isRepeatable) !== null && k !== void 0 ? k : !1, this.extensions = (0, t.toObjMap)(E.extensions), this.astNode = E.astNode, Array.isArray(E.locations) || (0, e.devAssert)(
        !1,
        `@${E.name} locations must be an Array.`
      );
      const C = (M = E.args) !== null && M !== void 0 ? M : {};
      (0, i.isObjectLike)(C) && !Array.isArray(C) || (0, e.devAssert)(
        !1,
        `@${E.name} args must be an object with argument names as keys.`
      ), this.args = (0, s.defineArguments)(C);
    }
    get [Symbol.toStringTag]() {
      return "GraphQLDirective";
    }
    toConfig() {
      return {
        name: this.name,
        description: this.description,
        locations: this.locations,
        args: (0, s.argsToArgsConfig)(this.args),
        isRepeatable: this.isRepeatable,
        extensions: this.extensions,
        astNode: this.astNode
      };
    }
    toString() {
      return "@" + this.name;
    }
    toJSON() {
      return this.toString();
    }
  }
  Te.GraphQLDirective = u;
  const c = new u({
    name: "include",
    description: "Directs the executor to include this field or fragment only when the `if` argument is true.",
    locations: [
      r.DirectiveLocation.FIELD,
      r.DirectiveLocation.FRAGMENT_SPREAD,
      r.DirectiveLocation.INLINE_FRAGMENT
    ],
    args: {
      if: {
        type: new s.GraphQLNonNull(l.GraphQLBoolean),
        description: "Included when true."
      }
    }
  });
  Te.GraphQLIncludeDirective = c;
  const m = new u({
    name: "skip",
    description: "Directs the executor to skip this field or fragment when the `if` argument is true.",
    locations: [
      r.DirectiveLocation.FIELD,
      r.DirectiveLocation.FRAGMENT_SPREAD,
      r.DirectiveLocation.INLINE_FRAGMENT
    ],
    args: {
      if: {
        type: new s.GraphQLNonNull(l.GraphQLBoolean),
        description: "Skipped when true."
      }
    }
  });
  Te.GraphQLSkipDirective = m;
  const p = "No longer supported";
  Te.DEFAULT_DEPRECATION_REASON = p;
  const b = new u({
    name: "deprecated",
    description: "Marks an element of a GraphQL schema as no longer supported.",
    locations: [
      r.DirectiveLocation.FIELD_DEFINITION,
      r.DirectiveLocation.ARGUMENT_DEFINITION,
      r.DirectiveLocation.INPUT_FIELD_DEFINITION,
      r.DirectiveLocation.ENUM_VALUE
    ],
    args: {
      reason: {
        type: l.GraphQLString,
        description: "Explains why this element was deprecated, usually also including a suggestion for how to access supported similar data. Formatted using the Markdown syntax, as specified by [CommonMark](https://commonmark.org/).",
        defaultValue: p
      }
    }
  });
  Te.GraphQLDeprecatedDirective = b;
  const T = new u({
    name: "specifiedBy",
    description: "Exposes a URL that specifies the behavior of this scalar.",
    locations: [r.DirectiveLocation.SCALAR],
    args: {
      url: {
        type: new s.GraphQLNonNull(l.GraphQLString),
        description: "The URL that specifies the behavior of this scalar."
      }
    }
  });
  Te.GraphQLSpecifiedByDirective = T;
  const y = new u({
    name: "oneOf",
    description: "Indicates exactly one field must be supplied and this field must not be `null`.",
    locations: [r.DirectiveLocation.INPUT_OBJECT],
    args: {}
  });
  Te.GraphQLOneOfDirective = y;
  const h = Object.freeze([
    c,
    m,
    b,
    T,
    y
  ]);
  Te.specifiedDirectives = h;
  function I(S) {
    return h.some(({ name: E }) => E === S.name);
  }
  return Te;
}
var le = {}, bt = {}, Et = {}, ua;
function oi() {
  if (ua) return Et;
  ua = 1, Object.defineProperty(Et, "__esModule", {
    value: !0
  }), Et.isIterableObject = e;
  function e(n) {
    return typeof n == "object" && typeof n?.[Symbol.iterator] == "function";
  }
  return Et;
}
var ca;
function wr() {
  if (ca) return bt;
  ca = 1, Object.defineProperty(bt, "__esModule", {
    value: !0
  }), bt.astFromValue = s;
  var e = /* @__PURE__ */ de(), n = /* @__PURE__ */ Le(), a = /* @__PURE__ */ oi(), i = /* @__PURE__ */ ze(), t = /* @__PURE__ */ se(), r = /* @__PURE__ */ oe(), o = /* @__PURE__ */ Xe();
  function s(d, f) {
    if ((0, r.isNonNullType)(f)) {
      const u = s(d, f.ofType);
      return u?.kind === t.Kind.NULL ? null : u;
    }
    if (d === null)
      return {
        kind: t.Kind.NULL
      };
    if (d === void 0)
      return null;
    if ((0, r.isListType)(f)) {
      const u = f.ofType;
      if ((0, a.isIterableObject)(d)) {
        const c = [];
        for (const m of d) {
          const p = s(m, u);
          p != null && c.push(p);
        }
        return {
          kind: t.Kind.LIST,
          values: c
        };
      }
      return s(d, u);
    }
    if ((0, r.isInputObjectType)(f)) {
      if (!(0, i.isObjectLike)(d))
        return null;
      const u = [];
      for (const c of Object.values(f.getFields())) {
        const m = s(d[c.name], c.type);
        m && u.push({
          kind: t.Kind.OBJECT_FIELD,
          name: {
            kind: t.Kind.NAME,
            value: c.name
          },
          value: m
        });
      }
      return {
        kind: t.Kind.OBJECT,
        fields: u
      };
    }
    if ((0, r.isLeafType)(f)) {
      const u = f.serialize(d);
      if (u == null)
        return null;
      if (typeof u == "boolean")
        return {
          kind: t.Kind.BOOLEAN,
          value: u
        };
      if (typeof u == "number" && Number.isFinite(u)) {
        const c = String(u);
        return l.test(c) ? {
          kind: t.Kind.INT,
          value: c
        } : {
          kind: t.Kind.FLOAT,
          value: c
        };
      }
      if (typeof u == "string")
        return (0, r.isEnumType)(f) ? {
          kind: t.Kind.ENUM,
          value: u
        } : f === o.GraphQLID && l.test(u) ? {
          kind: t.Kind.INT,
          value: u
        } : {
          kind: t.Kind.STRING,
          value: u
        };
      throw new TypeError(
        `Cannot convert value to AST: ${(0, e.inspect)(u)}.`
      );
    }
    (0, n.invariant)(
      !1,
      "Unexpected input type: " + (0, e.inspect)(f)
    );
  }
  const l = /^-?(?:0|[1-9][0-9]*)$/;
  return bt;
}
var la;
function Ge() {
  if (la) return le;
  la = 1, Object.defineProperty(le, "__esModule", {
    value: !0
  }), le.introspectionTypes = le.__TypeKind = le.__Type = le.__Schema = le.__InputValue = le.__Field = le.__EnumValue = le.__DirectiveLocation = le.__Directive = le.TypeNameMetaFieldDef = le.TypeMetaFieldDef = le.TypeKind = le.SchemaMetaFieldDef = void 0, le.isIntrospectionType = S;
  var e = /* @__PURE__ */ de(), n = /* @__PURE__ */ Le(), a = /* @__PURE__ */ Jn(), i = /* @__PURE__ */ Fe(), t = /* @__PURE__ */ wr(), r = /* @__PURE__ */ oe(), o = /* @__PURE__ */ Xe();
  const s = new r.GraphQLObjectType({
    name: "__Schema",
    description: "A GraphQL Schema defines the capabilities of a GraphQL server. It exposes all available types and directives on the server, as well as the entry points for query, mutation, and subscription operations.",
    fields: () => ({
      description: {
        type: o.GraphQLString,
        resolve: (E) => E.description
      },
      types: {
        description: "A list of all types supported by this server.",
        type: new r.GraphQLNonNull(
          new r.GraphQLList(new r.GraphQLNonNull(f))
        ),
        resolve(E) {
          return Object.values(E.getTypeMap());
        }
      },
      queryType: {
        description: "The type that query operations will be rooted at.",
        type: new r.GraphQLNonNull(f),
        resolve: (E) => E.getQueryType()
      },
      mutationType: {
        description: "If this server supports mutation, the type that mutation operations will be rooted at.",
        type: f,
        resolve: (E) => E.getMutationType()
      },
      subscriptionType: {
        description: "If this server support subscription, the type that subscription operations will be rooted at.",
        type: f,
        resolve: (E) => E.getSubscriptionType()
      },
      directives: {
        description: "A list of all directives supported by this server.",
        type: new r.GraphQLNonNull(
          new r.GraphQLList(
            new r.GraphQLNonNull(l)
          )
        ),
        resolve: (E) => E.getDirectives()
      }
    })
  });
  le.__Schema = s;
  const l = new r.GraphQLObjectType({
    name: "__Directive",
    description: `A Directive provides a way to describe alternate runtime execution and type validation behavior in a GraphQL document.

In some cases, you need to provide options to alter GraphQL's execution behavior in ways field arguments will not suffice, such as conditionally including or skipping a field. Directives provide this by describing additional information to the executor.`,
    fields: () => ({
      name: {
        type: new r.GraphQLNonNull(o.GraphQLString),
        resolve: (E) => E.name
      },
      description: {
        type: o.GraphQLString,
        resolve: (E) => E.description
      },
      isRepeatable: {
        type: new r.GraphQLNonNull(o.GraphQLBoolean),
        resolve: (E) => E.isRepeatable
      },
      locations: {
        type: new r.GraphQLNonNull(
          new r.GraphQLList(
            new r.GraphQLNonNull(d)
          )
        ),
        resolve: (E) => E.locations
      },
      args: {
        type: new r.GraphQLNonNull(
          new r.GraphQLList(
            new r.GraphQLNonNull(c)
          )
        ),
        args: {
          includeDeprecated: {
            type: o.GraphQLBoolean,
            defaultValue: !1
          }
        },
        resolve(E, { includeDeprecated: k }) {
          return k ? E.args : E.args.filter((M) => M.deprecationReason == null);
        }
      }
    })
  });
  le.__Directive = l;
  const d = new r.GraphQLEnumType({
    name: "__DirectiveLocation",
    description: "A Directive can be adjacent to many parts of the GraphQL language, a __DirectiveLocation describes one such possible adjacencies.",
    values: {
      QUERY: {
        value: a.DirectiveLocation.QUERY,
        description: "Location adjacent to a query operation."
      },
      MUTATION: {
        value: a.DirectiveLocation.MUTATION,
        description: "Location adjacent to a mutation operation."
      },
      SUBSCRIPTION: {
        value: a.DirectiveLocation.SUBSCRIPTION,
        description: "Location adjacent to a subscription operation."
      },
      FIELD: {
        value: a.DirectiveLocation.FIELD,
        description: "Location adjacent to a field."
      },
      FRAGMENT_DEFINITION: {
        value: a.DirectiveLocation.FRAGMENT_DEFINITION,
        description: "Location adjacent to a fragment definition."
      },
      FRAGMENT_SPREAD: {
        value: a.DirectiveLocation.FRAGMENT_SPREAD,
        description: "Location adjacent to a fragment spread."
      },
      INLINE_FRAGMENT: {
        value: a.DirectiveLocation.INLINE_FRAGMENT,
        description: "Location adjacent to an inline fragment."
      },
      VARIABLE_DEFINITION: {
        value: a.DirectiveLocation.VARIABLE_DEFINITION,
        description: "Location adjacent to a variable definition."
      },
      SCHEMA: {
        value: a.DirectiveLocation.SCHEMA,
        description: "Location adjacent to a schema definition."
      },
      SCALAR: {
        value: a.DirectiveLocation.SCALAR,
        description: "Location adjacent to a scalar definition."
      },
      OBJECT: {
        value: a.DirectiveLocation.OBJECT,
        description: "Location adjacent to an object type definition."
      },
      FIELD_DEFINITION: {
        value: a.DirectiveLocation.FIELD_DEFINITION,
        description: "Location adjacent to a field definition."
      },
      ARGUMENT_DEFINITION: {
        value: a.DirectiveLocation.ARGUMENT_DEFINITION,
        description: "Location adjacent to an argument definition."
      },
      INTERFACE: {
        value: a.DirectiveLocation.INTERFACE,
        description: "Location adjacent to an interface definition."
      },
      UNION: {
        value: a.DirectiveLocation.UNION,
        description: "Location adjacent to a union definition."
      },
      ENUM: {
        value: a.DirectiveLocation.ENUM,
        description: "Location adjacent to an enum definition."
      },
      ENUM_VALUE: {
        value: a.DirectiveLocation.ENUM_VALUE,
        description: "Location adjacent to an enum value definition."
      },
      INPUT_OBJECT: {
        value: a.DirectiveLocation.INPUT_OBJECT,
        description: "Location adjacent to an input object type definition."
      },
      INPUT_FIELD_DEFINITION: {
        value: a.DirectiveLocation.INPUT_FIELD_DEFINITION,
        description: "Location adjacent to an input object field definition."
      }
    }
  });
  le.__DirectiveLocation = d;
  const f = new r.GraphQLObjectType({
    name: "__Type",
    description: "The fundamental unit of any GraphQL Schema is the type. There are many kinds of types in GraphQL as represented by the `__TypeKind` enum.\n\nDepending on the kind of a type, certain fields describe information about that type. Scalar types provide no information beyond a name, description and optional `specifiedByURL`, while Enum types provide their values. Object and Interface types provide the fields they describe. Abstract types, Union and Interface, provide the Object types possible at runtime. List and NonNull types compose other types.",
    fields: () => ({
      kind: {
        type: new r.GraphQLNonNull(b),
        resolve(E) {
          if ((0, r.isScalarType)(E))
            return p.SCALAR;
          if ((0, r.isObjectType)(E))
            return p.OBJECT;
          if ((0, r.isInterfaceType)(E))
            return p.INTERFACE;
          if ((0, r.isUnionType)(E))
            return p.UNION;
          if ((0, r.isEnumType)(E))
            return p.ENUM;
          if ((0, r.isInputObjectType)(E))
            return p.INPUT_OBJECT;
          if ((0, r.isListType)(E))
            return p.LIST;
          if ((0, r.isNonNullType)(E))
            return p.NON_NULL;
          (0, n.invariant)(
            !1,
            `Unexpected type: "${(0, e.inspect)(E)}".`
          );
        }
      },
      name: {
        type: o.GraphQLString,
        resolve: (E) => "name" in E ? E.name : void 0
      },
      description: {
        type: o.GraphQLString,
        resolve: (E) => (
          /* c8 ignore next */
          "description" in E ? E.description : void 0
        )
      },
      specifiedByURL: {
        type: o.GraphQLString,
        resolve: (E) => "specifiedByURL" in E ? E.specifiedByURL : void 0
      },
      fields: {
        type: new r.GraphQLList(
          new r.GraphQLNonNull(u)
        ),
        args: {
          includeDeprecated: {
            type: o.GraphQLBoolean,
            defaultValue: !1
          }
        },
        resolve(E, { includeDeprecated: k }) {
          if ((0, r.isObjectType)(E) || (0, r.isInterfaceType)(E)) {
            const M = Object.values(E.getFields());
            return k ? M : M.filter((C) => C.deprecationReason == null);
          }
        }
      },
      interfaces: {
        type: new r.GraphQLList(new r.GraphQLNonNull(f)),
        resolve(E) {
          if ((0, r.isObjectType)(E) || (0, r.isInterfaceType)(E))
            return E.getInterfaces();
        }
      },
      possibleTypes: {
        type: new r.GraphQLList(new r.GraphQLNonNull(f)),
        resolve(E, k, M, { schema: C }) {
          if ((0, r.isAbstractType)(E))
            return C.getPossibleTypes(E);
        }
      },
      enumValues: {
        type: new r.GraphQLList(
          new r.GraphQLNonNull(m)
        ),
        args: {
          includeDeprecated: {
            type: o.GraphQLBoolean,
            defaultValue: !1
          }
        },
        resolve(E, { includeDeprecated: k }) {
          if ((0, r.isEnumType)(E)) {
            const M = E.getValues();
            return k ? M : M.filter((C) => C.deprecationReason == null);
          }
        }
      },
      inputFields: {
        type: new r.GraphQLList(
          new r.GraphQLNonNull(c)
        ),
        args: {
          includeDeprecated: {
            type: o.GraphQLBoolean,
            defaultValue: !1
          }
        },
        resolve(E, { includeDeprecated: k }) {
          if ((0, r.isInputObjectType)(E)) {
            const M = Object.values(E.getFields());
            return k ? M : M.filter((C) => C.deprecationReason == null);
          }
        }
      },
      ofType: {
        type: f,
        resolve: (E) => "ofType" in E ? E.ofType : void 0
      },
      isOneOf: {
        type: o.GraphQLBoolean,
        resolve: (E) => {
          if ((0, r.isInputObjectType)(E))
            return E.isOneOf;
        }
      }
    })
  });
  le.__Type = f;
  const u = new r.GraphQLObjectType({
    name: "__Field",
    description: "Object and Interface types are described by a list of Fields, each of which has a name, potentially a list of arguments, and a return type.",
    fields: () => ({
      name: {
        type: new r.GraphQLNonNull(o.GraphQLString),
        resolve: (E) => E.name
      },
      description: {
        type: o.GraphQLString,
        resolve: (E) => E.description
      },
      args: {
        type: new r.GraphQLNonNull(
          new r.GraphQLList(
            new r.GraphQLNonNull(c)
          )
        ),
        args: {
          includeDeprecated: {
            type: o.GraphQLBoolean,
            defaultValue: !1
          }
        },
        resolve(E, { includeDeprecated: k }) {
          return k ? E.args : E.args.filter((M) => M.deprecationReason == null);
        }
      },
      type: {
        type: new r.GraphQLNonNull(f),
        resolve: (E) => E.type
      },
      isDeprecated: {
        type: new r.GraphQLNonNull(o.GraphQLBoolean),
        resolve: (E) => E.deprecationReason != null
      },
      deprecationReason: {
        type: o.GraphQLString,
        resolve: (E) => E.deprecationReason
      }
    })
  });
  le.__Field = u;
  const c = new r.GraphQLObjectType({
    name: "__InputValue",
    description: "Arguments provided to Fields or Directives and the input fields of an InputObject are represented as Input Values which describe their type and optionally a default value.",
    fields: () => ({
      name: {
        type: new r.GraphQLNonNull(o.GraphQLString),
        resolve: (E) => E.name
      },
      description: {
        type: o.GraphQLString,
        resolve: (E) => E.description
      },
      type: {
        type: new r.GraphQLNonNull(f),
        resolve: (E) => E.type
      },
      defaultValue: {
        type: o.GraphQLString,
        description: "A GraphQL-formatted string representing the default value for this input value.",
        resolve(E) {
          const { type: k, defaultValue: M } = E, C = (0, t.astFromValue)(M, k);
          return C ? (0, i.print)(C) : null;
        }
      },
      isDeprecated: {
        type: new r.GraphQLNonNull(o.GraphQLBoolean),
        resolve: (E) => E.deprecationReason != null
      },
      deprecationReason: {
        type: o.GraphQLString,
        resolve: (E) => E.deprecationReason
      }
    })
  });
  le.__InputValue = c;
  const m = new r.GraphQLObjectType({
    name: "__EnumValue",
    description: "One possible value for a given Enum. Enum values are unique values, not a placeholder for a string or numeric value. However an Enum value is returned in a JSON response as a string.",
    fields: () => ({
      name: {
        type: new r.GraphQLNonNull(o.GraphQLString),
        resolve: (E) => E.name
      },
      description: {
        type: o.GraphQLString,
        resolve: (E) => E.description
      },
      isDeprecated: {
        type: new r.GraphQLNonNull(o.GraphQLBoolean),
        resolve: (E) => E.deprecationReason != null
      },
      deprecationReason: {
        type: o.GraphQLString,
        resolve: (E) => E.deprecationReason
      }
    })
  });
  le.__EnumValue = m;
  var p;
  le.TypeKind = p, (function(E) {
    E.SCALAR = "SCALAR", E.OBJECT = "OBJECT", E.INTERFACE = "INTERFACE", E.UNION = "UNION", E.ENUM = "ENUM", E.INPUT_OBJECT = "INPUT_OBJECT", E.LIST = "LIST", E.NON_NULL = "NON_NULL";
  })(p || (le.TypeKind = p = {}));
  const b = new r.GraphQLEnumType({
    name: "__TypeKind",
    description: "An enum describing what kind of type a given `__Type` is.",
    values: {
      SCALAR: {
        value: p.SCALAR,
        description: "Indicates this type is a scalar."
      },
      OBJECT: {
        value: p.OBJECT,
        description: "Indicates this type is an object. `fields` and `interfaces` are valid fields."
      },
      INTERFACE: {
        value: p.INTERFACE,
        description: "Indicates this type is an interface. `fields`, `interfaces`, and `possibleTypes` are valid fields."
      },
      UNION: {
        value: p.UNION,
        description: "Indicates this type is a union. `possibleTypes` is a valid field."
      },
      ENUM: {
        value: p.ENUM,
        description: "Indicates this type is an enum. `enumValues` is a valid field."
      },
      INPUT_OBJECT: {
        value: p.INPUT_OBJECT,
        description: "Indicates this type is an input object. `inputFields` is a valid field."
      },
      LIST: {
        value: p.LIST,
        description: "Indicates this type is a list. `ofType` is a valid field."
      },
      NON_NULL: {
        value: p.NON_NULL,
        description: "Indicates this type is a non-null. `ofType` is a valid field."
      }
    }
  });
  le.__TypeKind = b;
  const T = {
    name: "__schema",
    type: new r.GraphQLNonNull(s),
    description: "Access the current type schema of this server.",
    args: [],
    resolve: (E, k, M, { schema: C }) => C,
    deprecationReason: void 0,
    extensions: /* @__PURE__ */ Object.create(null),
    astNode: void 0
  };
  le.SchemaMetaFieldDef = T;
  const y = {
    name: "__type",
    type: f,
    description: "Request the type information of a single type.",
    args: [
      {
        name: "name",
        description: void 0,
        type: new r.GraphQLNonNull(o.GraphQLString),
        defaultValue: void 0,
        deprecationReason: void 0,
        extensions: /* @__PURE__ */ Object.create(null),
        astNode: void 0
      }
    ],
    resolve: (E, { name: k }, M, { schema: C }) => C.getType(k),
    deprecationReason: void 0,
    extensions: /* @__PURE__ */ Object.create(null),
    astNode: void 0
  };
  le.TypeMetaFieldDef = y;
  const h = {
    name: "__typename",
    type: new r.GraphQLNonNull(o.GraphQLString),
    description: "The name of the current Object type at runtime.",
    args: [],
    resolve: (E, k, M, { parentType: C }) => C.name,
    deprecationReason: void 0,
    extensions: /* @__PURE__ */ Object.create(null),
    astNode: void 0
  };
  le.TypeNameMetaFieldDef = h;
  const I = Object.freeze([
    s,
    l,
    d,
    f,
    u,
    c,
    m,
    b
  ]);
  le.introspectionTypes = I;
  function S(E) {
    return I.some(({ name: k }) => E.name === k);
  }
  return le;
}
var an = {}, pa;
function In() {
  if (pa) return an;
  pa = 1, Object.defineProperty(an, "__esModule", {
    value: !0
  }), an.GraphQLSchema = void 0, an.assertSchema = f, an.isSchema = d;
  var e = /* @__PURE__ */ De(), n = /* @__PURE__ */ de(), a = /* @__PURE__ */ Ar(), i = /* @__PURE__ */ ze(), t = /* @__PURE__ */ si(), r = /* @__PURE__ */ Qe(), o = /* @__PURE__ */ oe(), s = /* @__PURE__ */ Pe(), l = /* @__PURE__ */ Ge();
  function d(m) {
    return (0, a.instanceOf)(m, u);
  }
  function f(m) {
    if (!d(m))
      throw new Error(
        `Expected ${(0, n.inspect)(m)} to be a GraphQL schema.`
      );
    return m;
  }
  class u {
    // Used as a cache for validateSchema().
    constructor(p) {
      var b, T;
      this.__validationErrors = p.assumeValid === !0 ? [] : void 0, (0, i.isObjectLike)(p) || (0, e.devAssert)(!1, "Must provide configuration object."), !p.types || Array.isArray(p.types) || (0, e.devAssert)(
        !1,
        `"types" must be Array if provided but got: ${(0, n.inspect)(
          p.types
        )}.`
      ), !p.directives || Array.isArray(p.directives) || (0, e.devAssert)(
        !1,
        `"directives" must be Array if provided but got: ${(0, n.inspect)(p.directives)}.`
      ), this.description = p.description, this.extensions = (0, t.toObjMap)(p.extensions), this.astNode = p.astNode, this.extensionASTNodes = (b = p.extensionASTNodes) !== null && b !== void 0 ? b : [], this._queryType = p.query, this._mutationType = p.mutation, this._subscriptionType = p.subscription, this._directives = (T = p.directives) !== null && T !== void 0 ? T : s.specifiedDirectives;
      const y = new Set(p.types);
      if (p.types != null)
        for (const h of p.types)
          y.delete(h), c(h, y);
      this._queryType != null && c(this._queryType, y), this._mutationType != null && c(this._mutationType, y), this._subscriptionType != null && c(this._subscriptionType, y);
      for (const h of this._directives)
        if ((0, s.isDirective)(h))
          for (const I of h.args)
            c(I.type, y);
      c(l.__Schema, y), this._typeMap = /* @__PURE__ */ Object.create(null), this._subTypeMap = /* @__PURE__ */ Object.create(null), this._implementationsMap = /* @__PURE__ */ Object.create(null);
      for (const h of y) {
        if (h == null)
          continue;
        const I = h.name;
        if (I || (0, e.devAssert)(
          !1,
          "One of the provided types for building the Schema is missing a name."
        ), this._typeMap[I] !== void 0)
          throw new Error(
            `Schema must contain uniquely named types but contains multiple types named "${I}".`
          );
        if (this._typeMap[I] = h, (0, o.isInterfaceType)(h)) {
          for (const S of h.getInterfaces())
            if ((0, o.isInterfaceType)(S)) {
              let E = this._implementationsMap[S.name];
              E === void 0 && (E = this._implementationsMap[S.name] = {
                objects: [],
                interfaces: []
              }), E.interfaces.push(h);
            }
        } else if ((0, o.isObjectType)(h)) {
          for (const S of h.getInterfaces())
            if ((0, o.isInterfaceType)(S)) {
              let E = this._implementationsMap[S.name];
              E === void 0 && (E = this._implementationsMap[S.name] = {
                objects: [],
                interfaces: []
              }), E.objects.push(h);
            }
        }
      }
    }
    get [Symbol.toStringTag]() {
      return "GraphQLSchema";
    }
    getQueryType() {
      return this._queryType;
    }
    getMutationType() {
      return this._mutationType;
    }
    getSubscriptionType() {
      return this._subscriptionType;
    }
    getRootType(p) {
      switch (p) {
        case r.OperationTypeNode.QUERY:
          return this.getQueryType();
        case r.OperationTypeNode.MUTATION:
          return this.getMutationType();
        case r.OperationTypeNode.SUBSCRIPTION:
          return this.getSubscriptionType();
      }
    }
    getTypeMap() {
      return this._typeMap;
    }
    getType(p) {
      return this.getTypeMap()[p];
    }
    getPossibleTypes(p) {
      return (0, o.isUnionType)(p) ? p.getTypes() : this.getImplementations(p).objects;
    }
    getImplementations(p) {
      const b = this._implementationsMap[p.name];
      return b ?? {
        objects: [],
        interfaces: []
      };
    }
    isSubType(p, b) {
      let T = this._subTypeMap[p.name];
      if (T === void 0) {
        if (T = /* @__PURE__ */ Object.create(null), (0, o.isUnionType)(p))
          for (const y of p.getTypes())
            T[y.name] = !0;
        else {
          const y = this.getImplementations(p);
          for (const h of y.objects)
            T[h.name] = !0;
          for (const h of y.interfaces)
            T[h.name] = !0;
        }
        this._subTypeMap[p.name] = T;
      }
      return T[b.name] !== void 0;
    }
    getDirectives() {
      return this._directives;
    }
    getDirective(p) {
      return this.getDirectives().find((b) => b.name === p);
    }
    toConfig() {
      return {
        description: this.description,
        query: this.getQueryType(),
        mutation: this.getMutationType(),
        subscription: this.getSubscriptionType(),
        types: Object.values(this.getTypeMap()),
        directives: this.getDirectives(),
        extensions: this.extensions,
        astNode: this.astNode,
        extensionASTNodes: this.extensionASTNodes,
        assumeValid: this.__validationErrors !== void 0
      };
    }
  }
  an.GraphQLSchema = u;
  function c(m, p) {
    const b = (0, o.getNamedType)(m);
    if (!p.has(b)) {
      if (p.add(b), (0, o.isUnionType)(b))
        for (const T of b.getTypes())
          c(T, p);
      else if ((0, o.isObjectType)(b) || (0, o.isInterfaceType)(b)) {
        for (const T of b.getInterfaces())
          c(T, p);
        for (const T of Object.values(b.getFields())) {
          c(T.type, p);
          for (const y of T.args)
            c(y.type, p);
        }
      } else if ((0, o.isInputObjectType)(b))
        for (const T of Object.values(b.getFields()))
          c(T.type, p);
    }
    return p;
  }
  return an;
}
var da;
function Vr() {
  if (da) return Pn;
  da = 1, Object.defineProperty(Pn, "__esModule", {
    value: !0
  }), Pn.assertValidSchema = d, Pn.validateSchema = l;
  var e = /* @__PURE__ */ de(), n = /* @__PURE__ */ ne(), a = /* @__PURE__ */ Qe(), i = /* @__PURE__ */ Fr(), t = /* @__PURE__ */ oe(), r = /* @__PURE__ */ Pe(), o = /* @__PURE__ */ Ge(), s = /* @__PURE__ */ In();
  function l(O) {
    if ((0, s.assertSchema)(O), O.__validationErrors)
      return O.__validationErrors;
    const v = new f(O);
    u(v), m(v), b(v);
    const g = v.getErrors();
    return O.__validationErrors = g, g;
  }
  function d(O) {
    const v = l(O);
    if (v.length !== 0)
      throw new Error(v.map((g) => g.message).join(`

`));
  }
  class f {
    constructor(v) {
      this._errors = [], this.schema = v;
    }
    reportError(v, g) {
      const L = Array.isArray(g) ? g.filter(Boolean) : g;
      this._errors.push(
        new n.GraphQLError(v, {
          nodes: L
        })
      );
    }
    getErrors() {
      return this._errors;
    }
  }
  function u(O) {
    const v = O.schema, g = v.getQueryType();
    if (!g)
      O.reportError("Query root type must be provided.", v.astNode);
    else if (!(0, t.isObjectType)(g)) {
      var L;
      O.reportError(
        `Query root type must be Object type, it cannot be ${(0, e.inspect)(g)}.`,
        (L = c(
          v,
          a.OperationTypeNode.QUERY
        )) !== null && L !== void 0 ? L : g.astNode
      );
    }
    const R = v.getMutationType();
    if (R && !(0, t.isObjectType)(R)) {
      var j;
      O.reportError(
        `Mutation root type must be Object type if provided, it cannot be ${(0, e.inspect)(R)}.`,
        (j = c(
          v,
          a.OperationTypeNode.MUTATION
        )) !== null && j !== void 0 ? j : R.astNode
      );
    }
    const V = v.getSubscriptionType();
    if (V && !(0, t.isObjectType)(V)) {
      var U;
      O.reportError(
        `Subscription root type must be Object type if provided, it cannot be ${(0, e.inspect)(V)}.`,
        (U = c(
          v,
          a.OperationTypeNode.SUBSCRIPTION
        )) !== null && U !== void 0 ? U : V.astNode
      );
    }
  }
  function c(O, v) {
    var g;
    return (g = [O.astNode, ...O.extensionASTNodes].flatMap(
      // FIXME: https://github.com/graphql/graphql-js/issues/2203
      (L) => {
        var R;
        return (
          /* c8 ignore next */
          (R = L?.operationTypes) !== null && R !== void 0 ? R : []
        );
      }
    ).find((L) => L.operation === v)) === null || g === void 0 ? void 0 : g.type;
  }
  function m(O) {
    for (const g of O.schema.getDirectives()) {
      if (!(0, r.isDirective)(g)) {
        O.reportError(
          `Expected directive but got: ${(0, e.inspect)(g)}.`,
          g?.astNode
        );
        continue;
      }
      p(O, g), g.locations.length === 0 && O.reportError(
        `Directive @${g.name} must include 1 or more locations.`,
        g.astNode
      );
      for (const L of g.args)
        if (p(O, L), (0, t.isInputType)(L.type) || O.reportError(
          `The type of @${g.name}(${L.name}:) must be Input Type but got: ${(0, e.inspect)(L.type)}.`,
          L.astNode
        ), (0, t.isRequiredArgument)(L) && L.deprecationReason != null) {
          var v;
          O.reportError(
            `Required argument @${g.name}(${L.name}:) cannot be deprecated.`,
            [
              D(L.astNode),
              (v = L.astNode) === null || v === void 0 ? void 0 : v.type
            ]
          );
        }
    }
  }
  function p(O, v) {
    v.name.startsWith("__") && O.reportError(
      `Name "${v.name}" must not begin with "__", which is reserved by GraphQL introspection.`,
      v.astNode
    );
  }
  function b(O) {
    const v = C(O), g = O.schema.getTypeMap();
    for (const L of Object.values(g)) {
      if (!(0, t.isNamedType)(L)) {
        O.reportError(
          `Expected GraphQL named type but got: ${(0, e.inspect)(L)}.`,
          L.astNode
        );
        continue;
      }
      (0, o.isIntrospectionType)(L) || p(O, L), (0, t.isObjectType)(L) || (0, t.isInterfaceType)(L) ? (T(O, L), y(O, L)) : (0, t.isUnionType)(L) ? S(O, L) : (0, t.isEnumType)(L) ? E(O, L) : (0, t.isInputObjectType)(L) && (k(O, L), v(L));
    }
  }
  function T(O, v) {
    const g = Object.values(v.getFields());
    g.length === 0 && O.reportError(`Type ${v.name} must define one or more fields.`, [
      v.astNode,
      ...v.extensionASTNodes
    ]);
    for (const V of g) {
      if (p(O, V), !(0, t.isOutputType)(V.type)) {
        var L;
        O.reportError(
          `The type of ${v.name}.${V.name} must be Output Type but got: ${(0, e.inspect)(V.type)}.`,
          (L = V.astNode) === null || L === void 0 ? void 0 : L.type
        );
      }
      for (const U of V.args) {
        const W = U.name;
        if (p(O, U), !(0, t.isInputType)(U.type)) {
          var R;
          O.reportError(
            `The type of ${v.name}.${V.name}(${W}:) must be Input Type but got: ${(0, e.inspect)(U.type)}.`,
            (R = U.astNode) === null || R === void 0 ? void 0 : R.type
          );
        }
        if ((0, t.isRequiredArgument)(U) && U.deprecationReason != null) {
          var j;
          O.reportError(
            `Required argument ${v.name}.${V.name}(${W}:) cannot be deprecated.`,
            [
              D(U.astNode),
              (j = U.astNode) === null || j === void 0 ? void 0 : j.type
            ]
          );
        }
      }
    }
  }
  function y(O, v) {
    const g = /* @__PURE__ */ Object.create(null);
    for (const L of v.getInterfaces()) {
      if (!(0, t.isInterfaceType)(L)) {
        O.reportError(
          `Type ${(0, e.inspect)(
            v
          )} must only implement Interface types, it cannot implement ${(0, e.inspect)(L)}.`,
          _(v, L)
        );
        continue;
      }
      if (v === L) {
        O.reportError(
          `Type ${v.name} cannot implement itself because it would create a circular reference.`,
          _(v, L)
        );
        continue;
      }
      if (g[L.name]) {
        O.reportError(
          `Type ${v.name} can only implement ${L.name} once.`,
          _(v, L)
        );
        continue;
      }
      g[L.name] = !0, I(O, v, L), h(O, v, L);
    }
  }
  function h(O, v, g) {
    const L = v.getFields();
    for (const W of Object.values(g.getFields())) {
      const P = W.name, K = L[P];
      if (!K) {
        O.reportError(
          `Interface field ${g.name}.${P} expected but ${v.name} does not provide it.`,
          [W.astNode, v.astNode, ...v.extensionASTNodes]
        );
        continue;
      }
      if (!(0, i.isTypeSubTypeOf)(
        O.schema,
        K.type,
        W.type
      )) {
        var R, j;
        O.reportError(
          `Interface field ${g.name}.${P} expects type ${(0, e.inspect)(W.type)} but ${v.name}.${P} is type ${(0, e.inspect)(K.type)}.`,
          [
            (R = W.astNode) === null || R === void 0 ? void 0 : R.type,
            (j = K.astNode) === null || j === void 0 ? void 0 : j.type
          ]
        );
      }
      for (const te of W.args) {
        const pe = te.name, G = K.args.find(($) => $.name === pe);
        if (!G) {
          O.reportError(
            `Interface field argument ${g.name}.${P}(${pe}:) expected but ${v.name}.${P} does not provide it.`,
            [te.astNode, K.astNode]
          );
          continue;
        }
        if (!(0, i.isEqualType)(te.type, G.type)) {
          var V, U;
          O.reportError(
            `Interface field argument ${g.name}.${P}(${pe}:) expects type ${(0, e.inspect)(te.type)} but ${v.name}.${P}(${pe}:) is type ${(0, e.inspect)(G.type)}.`,
            [
              (V = te.astNode) === null || V === void 0 ? void 0 : V.type,
              (U = G.astNode) === null || U === void 0 ? void 0 : U.type
            ]
          );
        }
      }
      for (const te of K.args) {
        const pe = te.name;
        !W.args.find(($) => $.name === pe) && (0, t.isRequiredArgument)(te) && O.reportError(
          `Object field ${v.name}.${P} includes required argument ${pe} that is missing from the Interface field ${g.name}.${P}.`,
          [te.astNode, W.astNode]
        );
      }
    }
  }
  function I(O, v, g) {
    const L = v.getInterfaces();
    for (const R of g.getInterfaces())
      L.includes(R) || O.reportError(
        R === v ? `Type ${v.name} cannot implement ${g.name} because it would create a circular reference.` : `Type ${v.name} must implement ${R.name} because it is implemented by ${g.name}.`,
        [
          ..._(g, R),
          ..._(v, g)
        ]
      );
  }
  function S(O, v) {
    const g = v.getTypes();
    g.length === 0 && O.reportError(
      `Union type ${v.name} must define one or more member types.`,
      [v.astNode, ...v.extensionASTNodes]
    );
    const L = /* @__PURE__ */ Object.create(null);
    for (const R of g) {
      if (L[R.name]) {
        O.reportError(
          `Union type ${v.name} can only include type ${R.name} once.`,
          N(v, R.name)
        );
        continue;
      }
      L[R.name] = !0, (0, t.isObjectType)(R) || O.reportError(
        `Union type ${v.name} can only include Object types, it cannot include ${(0, e.inspect)(R)}.`,
        N(v, String(R))
      );
    }
  }
  function E(O, v) {
    const g = v.getValues();
    g.length === 0 && O.reportError(
      `Enum type ${v.name} must define one or more values.`,
      [v.astNode, ...v.extensionASTNodes]
    );
    for (const L of g)
      p(O, L);
  }
  function k(O, v) {
    const g = Object.values(v.getFields());
    g.length === 0 && O.reportError(
      `Input Object type ${v.name} must define one or more fields.`,
      [v.astNode, ...v.extensionASTNodes]
    );
    for (const j of g) {
      if (p(O, j), !(0, t.isInputType)(j.type)) {
        var L;
        O.reportError(
          `The type of ${v.name}.${j.name} must be Input Type but got: ${(0, e.inspect)(j.type)}.`,
          (L = j.astNode) === null || L === void 0 ? void 0 : L.type
        );
      }
      if ((0, t.isRequiredInputField)(j) && j.deprecationReason != null) {
        var R;
        O.reportError(
          `Required input field ${v.name}.${j.name} cannot be deprecated.`,
          [
            D(j.astNode),
            (R = j.astNode) === null || R === void 0 ? void 0 : R.type
          ]
        );
      }
      v.isOneOf && M(v, j, O);
    }
  }
  function M(O, v, g) {
    if ((0, t.isNonNullType)(v.type)) {
      var L;
      g.reportError(
        `OneOf input field ${O.name}.${v.name} must be nullable.`,
        (L = v.astNode) === null || L === void 0 ? void 0 : L.type
      );
    }
    v.defaultValue !== void 0 && g.reportError(
      `OneOf input field ${O.name}.${v.name} cannot have a default value.`,
      v.astNode
    );
  }
  function C(O) {
    const v = /* @__PURE__ */ Object.create(null), g = [], L = /* @__PURE__ */ Object.create(null);
    return R;
    function R(j) {
      if (v[j.name])
        return;
      v[j.name] = !0, L[j.name] = g.length;
      const V = Object.values(j.getFields());
      for (const U of V)
        if ((0, t.isNonNullType)(U.type) && (0, t.isInputObjectType)(U.type.ofType)) {
          const W = U.type.ofType, P = L[W.name];
          if (g.push(U), P === void 0)
            R(W);
          else {
            const K = g.slice(P), te = K.map((pe) => pe.name).join(".");
            O.reportError(
              `Cannot reference Input Object "${W.name}" within itself through a series of non-null fields: "${te}".`,
              K.map((pe) => pe.astNode)
            );
          }
          g.pop();
        }
      L[j.name] = void 0;
    }
  }
  function _(O, v) {
    const { astNode: g, extensionASTNodes: L } = O;
    return (g != null ? [g, ...L] : L).flatMap((j) => {
      var V;
      return (
        /* c8 ignore next */
        (V = j.interfaces) !== null && V !== void 0 ? V : []
      );
    }).filter((j) => j.name.value === v.name);
  }
  function N(O, v) {
    const { astNode: g, extensionASTNodes: L } = O;
    return (g != null ? [g, ...L] : L).flatMap((j) => {
      var V;
      return (
        /* c8 ignore next */
        (V = j.types) !== null && V !== void 0 ? V : []
      );
    }).filter((j) => j.name.value === v);
  }
  function D(O) {
    var v;
    return O == null || (v = O.directives) === null || v === void 0 ? void 0 : v.find(
      (g) => g.name.value === r.GraphQLDeprecatedDirective.name
    );
  }
  return Pn;
}
var sn = {}, Tn = {}, gt = {}, fa;
function He() {
  if (fa) return gt;
  fa = 1, Object.defineProperty(gt, "__esModule", {
    value: !0
  }), gt.typeFromAST = a;
  var e = /* @__PURE__ */ se(), n = /* @__PURE__ */ oe();
  function a(i, t) {
    switch (t.kind) {
      case e.Kind.LIST_TYPE: {
        const r = a(i, t.type);
        return r && new n.GraphQLList(r);
      }
      case e.Kind.NON_NULL_TYPE: {
        const r = a(i, t.type);
        return r && new n.GraphQLNonNull(r);
      }
      case e.Kind.NAMED_TYPE:
        return i.getType(t.name.value);
    }
  }
  return gt;
}
var ma;
function ui() {
  if (ma) return Tn;
  ma = 1, Object.defineProperty(Tn, "__esModule", {
    value: !0
  }), Tn.TypeInfo = void 0, Tn.visitWithTypeInfo = l;
  var e = /* @__PURE__ */ Qe(), n = /* @__PURE__ */ se(), a = /* @__PURE__ */ _n(), i = /* @__PURE__ */ oe(), t = /* @__PURE__ */ Ge(), r = /* @__PURE__ */ He();
  let o = class {
    constructor(f, u, c) {
      this._schema = f, this._typeStack = [], this._parentTypeStack = [], this._inputTypeStack = [], this._fieldDefStack = [], this._defaultValueStack = [], this._directive = null, this._argument = null, this._enumValue = null, this._getFieldDef = c ?? s, u && ((0, i.isInputType)(u) && this._inputTypeStack.push(u), (0, i.isCompositeType)(u) && this._parentTypeStack.push(u), (0, i.isOutputType)(u) && this._typeStack.push(u));
    }
    get [Symbol.toStringTag]() {
      return "TypeInfo";
    }
    getType() {
      if (this._typeStack.length > 0)
        return this._typeStack[this._typeStack.length - 1];
    }
    getParentType() {
      if (this._parentTypeStack.length > 0)
        return this._parentTypeStack[this._parentTypeStack.length - 1];
    }
    getInputType() {
      if (this._inputTypeStack.length > 0)
        return this._inputTypeStack[this._inputTypeStack.length - 1];
    }
    getParentInputType() {
      if (this._inputTypeStack.length > 1)
        return this._inputTypeStack[this._inputTypeStack.length - 2];
    }
    getFieldDef() {
      if (this._fieldDefStack.length > 0)
        return this._fieldDefStack[this._fieldDefStack.length - 1];
    }
    getDefaultValue() {
      if (this._defaultValueStack.length > 0)
        return this._defaultValueStack[this._defaultValueStack.length - 1];
    }
    getDirective() {
      return this._directive;
    }
    getArgument() {
      return this._argument;
    }
    getEnumValue() {
      return this._enumValue;
    }
    enter(f) {
      const u = this._schema;
      switch (f.kind) {
        case n.Kind.SELECTION_SET: {
          const m = (0, i.getNamedType)(this.getType());
          this._parentTypeStack.push(
            (0, i.isCompositeType)(m) ? m : void 0
          );
          break;
        }
        case n.Kind.FIELD: {
          const m = this.getParentType();
          let p, b;
          m && (p = this._getFieldDef(u, m, f), p && (b = p.type)), this._fieldDefStack.push(p), this._typeStack.push(
            (0, i.isOutputType)(b) ? b : void 0
          );
          break;
        }
        case n.Kind.DIRECTIVE:
          this._directive = u.getDirective(f.name.value);
          break;
        case n.Kind.OPERATION_DEFINITION: {
          const m = u.getRootType(f.operation);
          this._typeStack.push(
            (0, i.isObjectType)(m) ? m : void 0
          );
          break;
        }
        case n.Kind.INLINE_FRAGMENT:
        case n.Kind.FRAGMENT_DEFINITION: {
          const m = f.typeCondition, p = m ? (0, r.typeFromAST)(u, m) : (0, i.getNamedType)(this.getType());
          this._typeStack.push(
            (0, i.isOutputType)(p) ? p : void 0
          );
          break;
        }
        case n.Kind.VARIABLE_DEFINITION: {
          const m = (0, r.typeFromAST)(u, f.type);
          this._inputTypeStack.push(
            (0, i.isInputType)(m) ? m : void 0
          );
          break;
        }
        case n.Kind.ARGUMENT: {
          var c;
          let m, p;
          const b = (c = this.getDirective()) !== null && c !== void 0 ? c : this.getFieldDef();
          b && (m = b.args.find(
            (T) => T.name === f.name.value
          ), m && (p = m.type)), this._argument = m, this._defaultValueStack.push(m ? m.defaultValue : void 0), this._inputTypeStack.push(
            (0, i.isInputType)(p) ? p : void 0
          );
          break;
        }
        case n.Kind.LIST: {
          const m = (0, i.getNullableType)(this.getInputType()), p = (0, i.isListType)(m) ? m.ofType : m;
          this._defaultValueStack.push(void 0), this._inputTypeStack.push(
            (0, i.isInputType)(p) ? p : void 0
          );
          break;
        }
        case n.Kind.OBJECT_FIELD: {
          const m = (0, i.getNamedType)(this.getInputType());
          let p, b;
          (0, i.isInputObjectType)(m) && (b = m.getFields()[f.name.value], b && (p = b.type)), this._defaultValueStack.push(
            b ? b.defaultValue : void 0
          ), this._inputTypeStack.push(
            (0, i.isInputType)(p) ? p : void 0
          );
          break;
        }
        case n.Kind.ENUM: {
          const m = (0, i.getNamedType)(this.getInputType());
          let p;
          (0, i.isEnumType)(m) && (p = m.getValue(f.value)), this._enumValue = p;
          break;
        }
      }
    }
    leave(f) {
      switch (f.kind) {
        case n.Kind.SELECTION_SET:
          this._parentTypeStack.pop();
          break;
        case n.Kind.FIELD:
          this._fieldDefStack.pop(), this._typeStack.pop();
          break;
        case n.Kind.DIRECTIVE:
          this._directive = null;
          break;
        case n.Kind.OPERATION_DEFINITION:
        case n.Kind.INLINE_FRAGMENT:
        case n.Kind.FRAGMENT_DEFINITION:
          this._typeStack.pop();
          break;
        case n.Kind.VARIABLE_DEFINITION:
          this._inputTypeStack.pop();
          break;
        case n.Kind.ARGUMENT:
          this._argument = null, this._defaultValueStack.pop(), this._inputTypeStack.pop();
          break;
        case n.Kind.LIST:
        case n.Kind.OBJECT_FIELD:
          this._defaultValueStack.pop(), this._inputTypeStack.pop();
          break;
        case n.Kind.ENUM:
          this._enumValue = null;
          break;
      }
    }
  };
  Tn.TypeInfo = o;
  function s(d, f, u) {
    const c = u.name.value;
    if (c === t.SchemaMetaFieldDef.name && d.getQueryType() === f)
      return t.SchemaMetaFieldDef;
    if (c === t.TypeMetaFieldDef.name && d.getQueryType() === f)
      return t.TypeMetaFieldDef;
    if (c === t.TypeNameMetaFieldDef.name && (0, i.isCompositeType)(f))
      return t.TypeNameMetaFieldDef;
    if ((0, i.isObjectType)(f) || (0, i.isInterfaceType)(f))
      return f.getFields()[c];
  }
  function l(d, f) {
    return {
      enter(...u) {
        const c = u[0];
        d.enter(c);
        const m = (0, a.getEnterLeaveForKind)(f, c.kind).enter;
        if (m) {
          const p = m.apply(f, u);
          return p !== void 0 && (d.leave(c), (0, e.isNode)(p) && d.enter(p)), p;
        }
      },
      leave(...u) {
        const c = u[0], m = (0, a.getEnterLeaveForKind)(f, c.kind).leave;
        let p;
        return m && (p = m.apply(f, u)), d.leave(c), p;
      }
    };
  }
  return Tn;
}
var xe = {}, Nt = {}, Re = {}, ya;
function Sn() {
  if (ya) return Re;
  ya = 1, Object.defineProperty(Re, "__esModule", {
    value: !0
  }), Re.isConstValueNode = r, Re.isDefinitionNode = n, Re.isExecutableDefinitionNode = a, Re.isSchemaCoordinateNode = u, Re.isSelectionNode = i, Re.isTypeDefinitionNode = l, Re.isTypeExtensionNode = f, Re.isTypeNode = o, Re.isTypeSystemDefinitionNode = s, Re.isTypeSystemExtensionNode = d, Re.isValueNode = t;
  var e = /* @__PURE__ */ se();
  function n(c) {
    return a(c) || s(c) || d(c);
  }
  function a(c) {
    return c.kind === e.Kind.OPERATION_DEFINITION || c.kind === e.Kind.FRAGMENT_DEFINITION;
  }
  function i(c) {
    return c.kind === e.Kind.FIELD || c.kind === e.Kind.FRAGMENT_SPREAD || c.kind === e.Kind.INLINE_FRAGMENT;
  }
  function t(c) {
    return c.kind === e.Kind.VARIABLE || c.kind === e.Kind.INT || c.kind === e.Kind.FLOAT || c.kind === e.Kind.STRING || c.kind === e.Kind.BOOLEAN || c.kind === e.Kind.NULL || c.kind === e.Kind.ENUM || c.kind === e.Kind.LIST || c.kind === e.Kind.OBJECT;
  }
  function r(c) {
    return t(c) && (c.kind === e.Kind.LIST ? c.values.some(r) : c.kind === e.Kind.OBJECT ? c.fields.some((m) => r(m.value)) : c.kind !== e.Kind.VARIABLE);
  }
  function o(c) {
    return c.kind === e.Kind.NAMED_TYPE || c.kind === e.Kind.LIST_TYPE || c.kind === e.Kind.NON_NULL_TYPE;
  }
  function s(c) {
    return c.kind === e.Kind.SCHEMA_DEFINITION || l(c) || c.kind === e.Kind.DIRECTIVE_DEFINITION;
  }
  function l(c) {
    return c.kind === e.Kind.SCALAR_TYPE_DEFINITION || c.kind === e.Kind.OBJECT_TYPE_DEFINITION || c.kind === e.Kind.INTERFACE_TYPE_DEFINITION || c.kind === e.Kind.UNION_TYPE_DEFINITION || c.kind === e.Kind.ENUM_TYPE_DEFINITION || c.kind === e.Kind.INPUT_OBJECT_TYPE_DEFINITION;
  }
  function d(c) {
    return c.kind === e.Kind.SCHEMA_EXTENSION || f(c);
  }
  function f(c) {
    return c.kind === e.Kind.SCALAR_TYPE_EXTENSION || c.kind === e.Kind.OBJECT_TYPE_EXTENSION || c.kind === e.Kind.INTERFACE_TYPE_EXTENSION || c.kind === e.Kind.UNION_TYPE_EXTENSION || c.kind === e.Kind.ENUM_TYPE_EXTENSION || c.kind === e.Kind.INPUT_OBJECT_TYPE_EXTENSION;
  }
  function u(c) {
    return c.kind === e.Kind.TYPE_COORDINATE || c.kind === e.Kind.MEMBER_COORDINATE || c.kind === e.Kind.ARGUMENT_COORDINATE || c.kind === e.Kind.DIRECTIVE_COORDINATE || c.kind === e.Kind.DIRECTIVE_ARGUMENT_COORDINATE;
  }
  return Re;
}
var ha;
function Ws() {
  if (ha) return Nt;
  ha = 1, Object.defineProperty(Nt, "__esModule", {
    value: !0
  }), Nt.ExecutableDefinitionsRule = i;
  var e = /* @__PURE__ */ ne(), n = /* @__PURE__ */ se(), a = /* @__PURE__ */ Sn();
  function i(t) {
    return {
      Document(r) {
        for (const o of r.definitions)
          if (!(0, a.isExecutableDefinitionNode)(o)) {
            const s = o.kind === n.Kind.SCHEMA_DEFINITION || o.kind === n.Kind.SCHEMA_EXTENSION ? "schema" : '"' + o.name.value + '"';
            t.reportError(
              new e.GraphQLError(
                `The ${s} definition is not executable.`,
                {
                  nodes: o
                }
              )
            );
          }
        return !1;
      }
    };
  }
  return Nt;
}
var Ot = {}, va;
function Zs() {
  if (va) return Ot;
  va = 1, Object.defineProperty(Ot, "__esModule", {
    value: !0
  }), Ot.FieldsOnCorrectTypeRule = r;
  var e = /* @__PURE__ */ on(), n = /* @__PURE__ */ Pr(), a = /* @__PURE__ */ cn(), i = /* @__PURE__ */ ne(), t = /* @__PURE__ */ oe();
  function r(l) {
    return {
      Field(d) {
        const f = l.getParentType();
        if (f && !l.getFieldDef()) {
          const c = l.getSchema(), m = d.name.value;
          let p = (0, e.didYouMean)(
            "to use an inline fragment on",
            o(c, f, m)
          );
          p === "" && (p = (0, e.didYouMean)(
            s(f, m)
          )), l.reportError(
            new i.GraphQLError(
              `Cannot query field "${m}" on type "${f.name}".` + p,
              {
                nodes: d
              }
            )
          );
        }
      }
    };
  }
  function o(l, d, f) {
    if (!(0, t.isAbstractType)(d))
      return [];
    const u = /* @__PURE__ */ new Set(), c = /* @__PURE__ */ Object.create(null);
    for (const p of l.getPossibleTypes(d))
      if (p.getFields()[f]) {
        u.add(p), c[p.name] = 1;
        for (const b of p.getInterfaces()) {
          var m;
          b.getFields()[f] && (u.add(b), c[b.name] = ((m = c[b.name]) !== null && m !== void 0 ? m : 0) + 1);
        }
      }
    return [...u].sort((p, b) => {
      const T = c[b.name] - c[p.name];
      return T !== 0 ? T : (0, t.isInterfaceType)(p) && l.isSubType(p, b) ? -1 : (0, t.isInterfaceType)(b) && l.isSubType(b, p) ? 1 : (0, n.naturalCompare)(p.name, b.name);
    }).map((p) => p.name);
  }
  function s(l, d) {
    if ((0, t.isObjectType)(l) || (0, t.isInterfaceType)(l)) {
      const f = Object.keys(l.getFields());
      return (0, a.suggestionList)(d, f);
    }
    return [];
  }
  return Ot;
}
var _t = {}, Ta;
function eo() {
  if (Ta) return _t;
  Ta = 1, Object.defineProperty(_t, "__esModule", {
    value: !0
  }), _t.FragmentsOnCompositeTypesRule = t;
  var e = /* @__PURE__ */ ne(), n = /* @__PURE__ */ Fe(), a = /* @__PURE__ */ oe(), i = /* @__PURE__ */ He();
  function t(r) {
    return {
      InlineFragment(o) {
        const s = o.typeCondition;
        if (s) {
          const l = (0, i.typeFromAST)(
            r.getSchema(),
            s
          );
          if (l && !(0, a.isCompositeType)(l)) {
            const d = (0, n.print)(s);
            r.reportError(
              new e.GraphQLError(
                `Fragment cannot condition on non composite type "${d}".`,
                {
                  nodes: s
                }
              )
            );
          }
        }
      },
      FragmentDefinition(o) {
        const s = (0, i.typeFromAST)(
          r.getSchema(),
          o.typeCondition
        );
        if (s && !(0, a.isCompositeType)(s)) {
          const l = (0, n.print)(o.typeCondition);
          r.reportError(
            new e.GraphQLError(
              `Fragment "${o.name.value}" cannot condition on non composite type "${l}".`,
              {
                nodes: o.typeCondition
              }
            )
          );
        }
      }
    };
  }
  return _t;
}
var Fn = {}, ba;
function no() {
  if (ba) return Fn;
  ba = 1, Object.defineProperty(Fn, "__esModule", {
    value: !0
  }), Fn.KnownArgumentNamesOnDirectivesRule = o, Fn.KnownArgumentNamesRule = r;
  var e = /* @__PURE__ */ on(), n = /* @__PURE__ */ cn(), a = /* @__PURE__ */ ne(), i = /* @__PURE__ */ se(), t = /* @__PURE__ */ Pe();
  function r(s) {
    return {
      // eslint-disable-next-line new-cap
      ...o(s),
      Argument(l) {
        const d = s.getArgument(), f = s.getFieldDef(), u = s.getParentType();
        if (!d && f && u) {
          const c = l.name.value, m = f.args.map((b) => b.name), p = (0, n.suggestionList)(
            c,
            m
          );
          s.reportError(
            new a.GraphQLError(
              `Unknown argument "${c}" on field "${u.name}.${f.name}".` + (0, e.didYouMean)(p),
              {
                nodes: l
              }
            )
          );
        }
      }
    };
  }
  function o(s) {
    const l = /* @__PURE__ */ Object.create(null), d = s.getSchema(), f = d ? d.getDirectives() : t.specifiedDirectives;
    for (const m of f)
      l[m.name] = m.args.map((p) => p.name);
    const u = s.getDocument().definitions;
    for (const m of u)
      if (m.kind === i.Kind.DIRECTIVE_DEFINITION) {
        var c;
        const p = (c = m.arguments) !== null && c !== void 0 ? c : [];
        l[m.name.value] = p.map((b) => b.name.value);
      }
    return {
      Directive(m) {
        const p = m.name.value, b = l[p];
        if (m.arguments && b)
          for (const T of m.arguments) {
            const y = T.name.value;
            if (!b.includes(y)) {
              const h = (0, n.suggestionList)(
                y,
                b
              );
              s.reportError(
                new a.GraphQLError(
                  `Unknown argument "${y}" on directive "@${p}".` + (0, e.didYouMean)(h),
                  {
                    nodes: T
                  }
                )
              );
            }
          }
        return !1;
      }
    };
  }
  return Fn;
}
var It = {}, Ea;
function to() {
  if (Ea) return It;
  Ea = 1, Object.defineProperty(It, "__esModule", {
    value: !0
  }), It.KnownDirectivesRule = s;
  var e = /* @__PURE__ */ de(), n = /* @__PURE__ */ Le(), a = /* @__PURE__ */ ne(), i = /* @__PURE__ */ Qe(), t = /* @__PURE__ */ Jn(), r = /* @__PURE__ */ se(), o = /* @__PURE__ */ Pe();
  function s(f) {
    const u = /* @__PURE__ */ Object.create(null), c = f.getSchema(), m = c ? c.getDirectives() : o.specifiedDirectives;
    for (const b of m)
      u[b.name] = b.locations;
    const p = f.getDocument().definitions;
    for (const b of p)
      b.kind === r.Kind.DIRECTIVE_DEFINITION && (u[b.name.value] = b.locations.map((T) => T.value));
    return {
      Directive(b, T, y, h, I) {
        const S = b.name.value, E = u[S];
        if (!E) {
          f.reportError(
            new a.GraphQLError(`Unknown directive "@${S}".`, {
              nodes: b
            })
          );
          return;
        }
        const k = l(I);
        k && !E.includes(k) && f.reportError(
          new a.GraphQLError(
            `Directive "@${S}" may not be used on ${k}.`,
            {
              nodes: b
            }
          )
        );
      }
    };
  }
  function l(f) {
    const u = f[f.length - 1];
    switch ("kind" in u || (0, n.invariant)(!1), u.kind) {
      case r.Kind.OPERATION_DEFINITION:
        return d(u.operation);
      case r.Kind.FIELD:
        return t.DirectiveLocation.FIELD;
      case r.Kind.FRAGMENT_SPREAD:
        return t.DirectiveLocation.FRAGMENT_SPREAD;
      case r.Kind.INLINE_FRAGMENT:
        return t.DirectiveLocation.INLINE_FRAGMENT;
      case r.Kind.FRAGMENT_DEFINITION:
        return t.DirectiveLocation.FRAGMENT_DEFINITION;
      case r.Kind.VARIABLE_DEFINITION:
        return t.DirectiveLocation.VARIABLE_DEFINITION;
      case r.Kind.SCHEMA_DEFINITION:
      case r.Kind.SCHEMA_EXTENSION:
        return t.DirectiveLocation.SCHEMA;
      case r.Kind.SCALAR_TYPE_DEFINITION:
      case r.Kind.SCALAR_TYPE_EXTENSION:
        return t.DirectiveLocation.SCALAR;
      case r.Kind.OBJECT_TYPE_DEFINITION:
      case r.Kind.OBJECT_TYPE_EXTENSION:
        return t.DirectiveLocation.OBJECT;
      case r.Kind.FIELD_DEFINITION:
        return t.DirectiveLocation.FIELD_DEFINITION;
      case r.Kind.INTERFACE_TYPE_DEFINITION:
      case r.Kind.INTERFACE_TYPE_EXTENSION:
        return t.DirectiveLocation.INTERFACE;
      case r.Kind.UNION_TYPE_DEFINITION:
      case r.Kind.UNION_TYPE_EXTENSION:
        return t.DirectiveLocation.UNION;
      case r.Kind.ENUM_TYPE_DEFINITION:
      case r.Kind.ENUM_TYPE_EXTENSION:
        return t.DirectiveLocation.ENUM;
      case r.Kind.ENUM_VALUE_DEFINITION:
        return t.DirectiveLocation.ENUM_VALUE;
      case r.Kind.INPUT_OBJECT_TYPE_DEFINITION:
      case r.Kind.INPUT_OBJECT_TYPE_EXTENSION:
        return t.DirectiveLocation.INPUT_OBJECT;
      case r.Kind.INPUT_VALUE_DEFINITION: {
        const c = f[f.length - 3];
        return "kind" in c || (0, n.invariant)(!1), c.kind === r.Kind.INPUT_OBJECT_TYPE_DEFINITION ? t.DirectiveLocation.INPUT_FIELD_DEFINITION : t.DirectiveLocation.ARGUMENT_DEFINITION;
      }
      // Not reachable, all possible types have been considered.
      /* c8 ignore next */
      default:
        (0, n.invariant)(
          !1,
          "Unexpected kind: " + (0, e.inspect)(u.kind)
        );
    }
  }
  function d(f) {
    switch (f) {
      case i.OperationTypeNode.QUERY:
        return t.DirectiveLocation.QUERY;
      case i.OperationTypeNode.MUTATION:
        return t.DirectiveLocation.MUTATION;
      case i.OperationTypeNode.SUBSCRIPTION:
        return t.DirectiveLocation.SUBSCRIPTION;
    }
  }
  return It;
}
var St = {}, ga;
function ro() {
  if (ga) return St;
  ga = 1, Object.defineProperty(St, "__esModule", {
    value: !0
  }), St.KnownFragmentNamesRule = n;
  var e = /* @__PURE__ */ ne();
  function n(a) {
    return {
      FragmentSpread(i) {
        const t = i.name.value;
        a.getFragment(t) || a.reportError(
          new e.GraphQLError(
            `Unknown fragment "${t}".`,
            {
              nodes: i.name
            }
          )
        );
      }
    };
  }
  return St;
}
var Lt = {}, Na;
function io() {
  if (Na) return Lt;
  Na = 1, Object.defineProperty(Lt, "__esModule", {
    value: !0
  }), Lt.KnownTypeNamesRule = o;
  var e = /* @__PURE__ */ on(), n = /* @__PURE__ */ cn(), a = /* @__PURE__ */ ne(), i = /* @__PURE__ */ Sn(), t = /* @__PURE__ */ Ge(), r = /* @__PURE__ */ Xe();
  function o(d) {
    const f = d.getSchema(), u = f ? f.getTypeMap() : /* @__PURE__ */ Object.create(null), c = /* @__PURE__ */ Object.create(null);
    for (const p of d.getDocument().definitions)
      (0, i.isTypeDefinitionNode)(p) && (c[p.name.value] = !0);
    const m = [
      ...Object.keys(u),
      ...Object.keys(c)
    ];
    return {
      NamedType(p, b, T, y, h) {
        const I = p.name.value;
        if (!u[I] && !c[I]) {
          var S;
          const E = (S = h[2]) !== null && S !== void 0 ? S : T, k = E != null && l(E);
          if (k && s.includes(I))
            return;
          const M = (0, n.suggestionList)(
            I,
            k ? s.concat(m) : m
          );
          d.reportError(
            new a.GraphQLError(
              `Unknown type "${I}".` + (0, e.didYouMean)(M),
              {
                nodes: p
              }
            )
          );
        }
      }
    };
  }
  const s = [
    ...r.specifiedScalarTypes,
    ...t.introspectionTypes
  ].map((d) => d.name);
  function l(d) {
    return "kind" in d && ((0, i.isTypeSystemDefinitionNode)(d) || (0, i.isTypeSystemExtensionNode)(d));
  }
  return Lt;
}
var Rt = {}, Oa;
function ao() {
  if (Oa) return Rt;
  Oa = 1, Object.defineProperty(Rt, "__esModule", {
    value: !0
  }), Rt.LoneAnonymousOperationRule = a;
  var e = /* @__PURE__ */ ne(), n = /* @__PURE__ */ se();
  function a(i) {
    let t = 0;
    return {
      Document(r) {
        t = r.definitions.filter(
          (o) => o.kind === n.Kind.OPERATION_DEFINITION
        ).length;
      },
      OperationDefinition(r) {
        !r.name && t > 1 && i.reportError(
          new e.GraphQLError(
            "This anonymous operation must be the only defined operation.",
            {
              nodes: r
            }
          )
        );
      }
    };
  }
  return Rt;
}
var Dt = {}, _a;
function so() {
  if (_a) return Dt;
  _a = 1, Object.defineProperty(Dt, "__esModule", {
    value: !0
  }), Dt.LoneSchemaDefinitionRule = n;
  var e = /* @__PURE__ */ ne();
  function n(a) {
    var i, t, r;
    const o = a.getSchema(), s = (i = (t = (r = o?.astNode) !== null && r !== void 0 ? r : o?.getQueryType()) !== null && t !== void 0 ? t : o?.getMutationType()) !== null && i !== void 0 ? i : o?.getSubscriptionType();
    let l = 0;
    return {
      SchemaDefinition(d) {
        if (s) {
          a.reportError(
            new e.GraphQLError(
              "Cannot define a new schema within a schema extension.",
              {
                nodes: d
              }
            )
          );
          return;
        }
        l > 0 && a.reportError(
          new e.GraphQLError(
            "Must provide only one schema definition.",
            {
              nodes: d
            }
          )
        ), ++l;
      }
    };
  }
  return Dt;
}
var At = {}, Ia;
function oo() {
  if (Ia) return At;
  Ia = 1, Object.defineProperty(At, "__esModule", {
    value: !0
  }), At.MaxIntrospectionDepthRule = i;
  var e = /* @__PURE__ */ ne(), n = /* @__PURE__ */ se();
  const a = 3;
  function i(t) {
    function r(o, s = /* @__PURE__ */ Object.create(null), l = 0) {
      if (o.kind === n.Kind.FRAGMENT_SPREAD) {
        const d = o.name.value;
        if (s[d] === !0)
          return !1;
        const f = t.getFragment(d);
        if (!f)
          return !1;
        try {
          return s[d] = !0, r(f, s, l);
        } finally {
          s[d] = void 0;
        }
      }
      if (o.kind === n.Kind.FIELD && // check all introspection lists
      (o.name.value === "fields" || o.name.value === "interfaces" || o.name.value === "possibleTypes" || o.name.value === "inputFields") && (l++, l >= a))
        return !0;
      if ("selectionSet" in o && o.selectionSet) {
        for (const d of o.selectionSet.selections)
          if (r(d, s, l))
            return !0;
      }
      return !1;
    }
    return {
      Field(o) {
        if ((o.name.value === "__schema" || o.name.value === "__type") && r(o))
          return t.reportError(
            new e.GraphQLError(
              "Maximum introspection depth exceeded",
              {
                nodes: [o]
              }
            )
          ), !1;
      }
    };
  }
  return At;
}
var jt = {}, Sa;
function uo() {
  if (Sa) return jt;
  Sa = 1, Object.defineProperty(jt, "__esModule", {
    value: !0
  }), jt.NoFragmentCyclesRule = n;
  var e = /* @__PURE__ */ ne();
  function n(a) {
    const i = /* @__PURE__ */ Object.create(null), t = [], r = /* @__PURE__ */ Object.create(null);
    return {
      OperationDefinition: () => !1,
      FragmentDefinition(s) {
        return o(s), !1;
      }
    };
    function o(s) {
      if (i[s.name.value])
        return;
      const l = s.name.value;
      i[l] = !0;
      const d = a.getFragmentSpreads(s.selectionSet);
      if (d.length !== 0) {
        r[l] = t.length;
        for (const f of d) {
          const u = f.name.value, c = r[u];
          if (t.push(f), c === void 0) {
            const m = a.getFragment(u);
            m && o(m);
          } else {
            const m = t.slice(c), p = m.slice(0, -1).map((b) => '"' + b.name.value + '"').join(", ");
            a.reportError(
              new e.GraphQLError(
                `Cannot spread fragment "${u}" within itself` + (p !== "" ? ` via ${p}.` : "."),
                {
                  nodes: m
                }
              )
            );
          }
          t.pop();
        }
        r[l] = void 0;
      }
    }
  }
  return jt;
}
var Pt = {}, La;
function co() {
  if (La) return Pt;
  La = 1, Object.defineProperty(Pt, "__esModule", {
    value: !0
  }), Pt.NoUndefinedVariablesRule = n;
  var e = /* @__PURE__ */ ne();
  function n(a) {
    let i = /* @__PURE__ */ Object.create(null);
    return {
      OperationDefinition: {
        enter() {
          i = /* @__PURE__ */ Object.create(null);
        },
        leave(t) {
          const r = a.getRecursiveVariableUsages(t);
          for (const { node: o } of r) {
            const s = o.name.value;
            i[s] !== !0 && a.reportError(
              new e.GraphQLError(
                t.name ? `Variable "$${s}" is not defined by operation "${t.name.value}".` : `Variable "$${s}" is not defined.`,
                {
                  nodes: [o, t]
                }
              )
            );
          }
        }
      },
      VariableDefinition(t) {
        i[t.variable.name.value] = !0;
      }
    };
  }
  return Pt;
}
var kt = {}, Ra;
function lo() {
  if (Ra) return kt;
  Ra = 1, Object.defineProperty(kt, "__esModule", {
    value: !0
  }), kt.NoUnusedFragmentsRule = n;
  var e = /* @__PURE__ */ ne();
  function n(a) {
    const i = [], t = [];
    return {
      OperationDefinition(r) {
        return i.push(r), !1;
      },
      FragmentDefinition(r) {
        return t.push(r), !1;
      },
      Document: {
        leave() {
          const r = /* @__PURE__ */ Object.create(null);
          for (const o of i)
            for (const s of a.getRecursivelyReferencedFragments(
              o
            ))
              r[s.name.value] = !0;
          for (const o of t) {
            const s = o.name.value;
            r[s] !== !0 && a.reportError(
              new e.GraphQLError(
                `Fragment "${s}" is never used.`,
                {
                  nodes: o
                }
              )
            );
          }
        }
      }
    };
  }
  return kt;
}
var Ft = {}, Da;
function po() {
  if (Da) return Ft;
  Da = 1, Object.defineProperty(Ft, "__esModule", {
    value: !0
  }), Ft.NoUnusedVariablesRule = n;
  var e = /* @__PURE__ */ ne();
  function n(a) {
    let i = [];
    return {
      OperationDefinition: {
        enter() {
          i = [];
        },
        leave(t) {
          const r = /* @__PURE__ */ Object.create(null), o = a.getRecursiveVariableUsages(t);
          for (const { node: s } of o)
            r[s.name.value] = !0;
          for (const s of i) {
            const l = s.variable.name.value;
            r[l] !== !0 && a.reportError(
              new e.GraphQLError(
                t.name ? `Variable "$${l}" is never used in operation "${t.name.value}".` : `Variable "$${l}" is never used.`,
                {
                  nodes: s
                }
              )
            );
          }
        }
      },
      VariableDefinition(t) {
        i.push(t);
      }
    };
  }
  return Ft;
}
var wt = {}, Vt = {}, Aa;
function fo() {
  if (Aa) return Vt;
  Aa = 1, Object.defineProperty(Vt, "__esModule", {
    value: !0
  }), Vt.sortValueNode = a;
  var e = /* @__PURE__ */ Pr(), n = /* @__PURE__ */ se();
  function a(t) {
    switch (t.kind) {
      case n.Kind.OBJECT:
        return { ...t, fields: i(t.fields) };
      case n.Kind.LIST:
        return { ...t, values: t.values.map(a) };
      case n.Kind.INT:
      case n.Kind.FLOAT:
      case n.Kind.STRING:
      case n.Kind.BOOLEAN:
      case n.Kind.NULL:
      case n.Kind.ENUM:
      case n.Kind.VARIABLE:
        return t;
    }
  }
  function i(t) {
    return t.map((r) => ({
      ...r,
      value: a(r.value)
    })).sort(
      (r, o) => (0, e.naturalCompare)(r.name.value, o.name.value)
    );
  }
  return Vt;
}
var ja;
function mo() {
  if (ja) return wt;
  ja = 1, Object.defineProperty(wt, "__esModule", {
    value: !0
  }), wt.OverlappingFieldsCanBeMergedRule = l;
  var e = /* @__PURE__ */ de(), n = /* @__PURE__ */ ne(), a = /* @__PURE__ */ se(), i = /* @__PURE__ */ Fe(), t = /* @__PURE__ */ oe(), r = /* @__PURE__ */ fo(), o = /* @__PURE__ */ He();
  function s(_) {
    return Array.isArray(_) ? _.map(
      ([N, D]) => `subfields "${N}" conflict because ` + s(D)
    ).join(" and ") : _;
  }
  function l(_) {
    const N = new M(), D = new C(), O = /* @__PURE__ */ new Map();
    return {
      SelectionSet(v) {
        const g = d(
          _,
          O,
          N,
          D,
          _.getParentType(),
          v
        );
        for (const [[L, R], j, V] of g) {
          const U = s(R);
          _.reportError(
            new n.GraphQLError(
              `Fields "${L}" conflict because ${U}. Use different aliases on the fields to fetch both if this was intentional.`,
              {
                nodes: j.concat(V)
              }
            )
          );
        }
      }
    };
  }
  function d(_, N, D, O, v, g) {
    const L = [], [R, j] = I(
      _,
      N,
      v,
      g
    );
    if (m(
      _,
      L,
      N,
      D,
      O,
      R
    ), j.length !== 0)
      for (let V = 0; V < j.length; V++) {
        f(
          _,
          L,
          N,
          D,
          O,
          !1,
          R,
          j[V]
        );
        for (let U = V + 1; U < j.length; U++)
          u(
            _,
            L,
            N,
            D,
            O,
            !1,
            j[V],
            j[U]
          );
      }
    return L;
  }
  function f(_, N, D, O, v, g, L, R) {
    if (O.has(
      L,
      R,
      g
    ))
      return;
    O.add(
      L,
      R,
      g
    );
    const j = _.getFragment(R);
    if (!j)
      return;
    const [V, U] = S(
      _,
      D,
      j
    );
    if (L !== V) {
      p(
        _,
        N,
        D,
        O,
        v,
        g,
        L,
        V
      );
      for (const W of U)
        f(
          _,
          N,
          D,
          O,
          v,
          g,
          L,
          W
        );
    }
  }
  function u(_, N, D, O, v, g, L, R) {
    if (L === R || v.has(
      L,
      R,
      g
    ))
      return;
    v.add(L, R, g);
    const j = _.getFragment(L), V = _.getFragment(R);
    if (!j || !V)
      return;
    const [U, W] = S(
      _,
      D,
      j
    ), [P, K] = S(
      _,
      D,
      V
    );
    p(
      _,
      N,
      D,
      O,
      v,
      g,
      U,
      P
    );
    for (const te of K)
      u(
        _,
        N,
        D,
        O,
        v,
        g,
        L,
        te
      );
    for (const te of W)
      u(
        _,
        N,
        D,
        O,
        v,
        g,
        te,
        R
      );
  }
  function c(_, N, D, O, v, g, L, R, j) {
    const V = [], [U, W] = I(
      _,
      N,
      g,
      L
    ), [P, K] = I(
      _,
      N,
      R,
      j
    );
    p(
      _,
      V,
      N,
      D,
      O,
      v,
      U,
      P
    );
    for (const te of K)
      f(
        _,
        V,
        N,
        D,
        O,
        v,
        U,
        te
      );
    for (const te of W)
      f(
        _,
        V,
        N,
        D,
        O,
        v,
        P,
        te
      );
    for (const te of W)
      for (const pe of K)
        u(
          _,
          V,
          N,
          D,
          O,
          v,
          te,
          pe
        );
    return V;
  }
  function m(_, N, D, O, v, g) {
    for (const [L, R] of Object.entries(g))
      if (R.length > 1)
        for (let j = 0; j < R.length; j++)
          for (let V = j + 1; V < R.length; V++) {
            const U = b(
              _,
              D,
              O,
              v,
              !1,
              // within one collection is never mutually exclusive
              L,
              R[j],
              R[V]
            );
            U && N.push(U);
          }
  }
  function p(_, N, D, O, v, g, L, R) {
    for (const [j, V] of Object.entries(L)) {
      const U = R[j];
      if (U)
        for (const W of V)
          for (const P of U) {
            const K = b(
              _,
              D,
              O,
              v,
              g,
              j,
              W,
              P
            );
            K && N.push(K);
          }
    }
  }
  function b(_, N, D, O, v, g, L, R) {
    const [j, V, U] = L, [W, P, K] = R, te = v || j !== W && (0, t.isObjectType)(j) && (0, t.isObjectType)(W);
    if (!te) {
      const Y = V.name.value, Z = P.name.value;
      if (Y !== Z)
        return [
          [g, `"${Y}" and "${Z}" are different fields`],
          [V],
          [P]
        ];
      if (!T(V, P))
        return [
          [g, "they have differing arguments"],
          [V],
          [P]
        ];
    }
    const pe = U?.type, G = K?.type;
    if (pe && G && h(pe, G))
      return [
        [
          g,
          `they return conflicting types "${(0, e.inspect)(
            pe
          )}" and "${(0, e.inspect)(G)}"`
        ],
        [V],
        [P]
      ];
    const $ = V.selectionSet, x = P.selectionSet;
    if ($ && x) {
      const Y = c(
        _,
        N,
        D,
        O,
        te,
        (0, t.getNamedType)(pe),
        $,
        (0, t.getNamedType)(G),
        x
      );
      return k(Y, g, V, P);
    }
  }
  function T(_, N) {
    const D = _.arguments, O = N.arguments;
    if (D === void 0 || D.length === 0)
      return O === void 0 || O.length === 0;
    if (O === void 0 || O.length === 0 || D.length !== O.length)
      return !1;
    const v = new Map(O.map(({ name: g, value: L }) => [g.value, L]));
    return D.every((g) => {
      const L = g.value, R = v.get(g.name.value);
      return R === void 0 ? !1 : y(L) === y(R);
    });
  }
  function y(_) {
    return (0, i.print)((0, r.sortValueNode)(_));
  }
  function h(_, N) {
    return (0, t.isListType)(_) ? (0, t.isListType)(N) ? h(_.ofType, N.ofType) : !0 : (0, t.isListType)(N) ? !0 : (0, t.isNonNullType)(_) ? (0, t.isNonNullType)(N) ? h(_.ofType, N.ofType) : !0 : (0, t.isNonNullType)(N) ? !0 : (0, t.isLeafType)(_) || (0, t.isLeafType)(N) ? _ !== N : !1;
  }
  function I(_, N, D, O) {
    const v = N.get(O);
    if (v)
      return v;
    const g = /* @__PURE__ */ Object.create(null), L = /* @__PURE__ */ Object.create(null);
    E(
      _,
      D,
      O,
      g,
      L
    );
    const R = [g, Object.keys(L)];
    return N.set(O, R), R;
  }
  function S(_, N, D) {
    const O = N.get(D.selectionSet);
    if (O)
      return O;
    const v = (0, o.typeFromAST)(
      _.getSchema(),
      D.typeCondition
    );
    return I(
      _,
      N,
      v,
      D.selectionSet
    );
  }
  function E(_, N, D, O, v) {
    for (const g of D.selections)
      switch (g.kind) {
        case a.Kind.FIELD: {
          const L = g.name.value;
          let R;
          ((0, t.isObjectType)(N) || (0, t.isInterfaceType)(N)) && (R = N.getFields()[L]);
          const j = g.alias ? g.alias.value : L;
          O[j] || (O[j] = []), O[j].push([N, g, R]);
          break;
        }
        case a.Kind.FRAGMENT_SPREAD:
          v[g.name.value] = !0;
          break;
        case a.Kind.INLINE_FRAGMENT: {
          const L = g.typeCondition, R = L ? (0, o.typeFromAST)(_.getSchema(), L) : N;
          E(
            _,
            R,
            g.selectionSet,
            O,
            v
          );
          break;
        }
      }
  }
  function k(_, N, D, O) {
    if (_.length > 0)
      return [
        [N, _.map(([v]) => v)],
        [D, ..._.map(([, v]) => v).flat()],
        [O, ..._.map(([, , v]) => v).flat()]
      ];
  }
  class M {
    constructor() {
      this._data = /* @__PURE__ */ new Map();
    }
    has(N, D, O) {
      var v;
      const g = (v = this._data.get(N)) === null || v === void 0 ? void 0 : v.get(D);
      return g === void 0 ? !1 : O ? !0 : O === g;
    }
    add(N, D, O) {
      const v = this._data.get(N);
      v === void 0 ? this._data.set(N, /* @__PURE__ */ new Map([[D, O]])) : v.set(D, O);
    }
  }
  class C {
    constructor() {
      this._orderedPairSet = new M();
    }
    has(N, D, O) {
      return N < D ? this._orderedPairSet.has(N, D, O) : this._orderedPairSet.has(D, N, O);
    }
    add(N, D, O) {
      N < D ? this._orderedPairSet.add(N, D, O) : this._orderedPairSet.add(D, N, O);
    }
  }
  return wt;
}
var Ct = {}, Pa;
function yo() {
  if (Pa) return Ct;
  Pa = 1, Object.defineProperty(Ct, "__esModule", {
    value: !0
  }), Ct.PossibleFragmentSpreadsRule = r;
  var e = /* @__PURE__ */ de(), n = /* @__PURE__ */ ne(), a = /* @__PURE__ */ oe(), i = /* @__PURE__ */ Fr(), t = /* @__PURE__ */ He();
  function r(s) {
    return {
      InlineFragment(l) {
        const d = s.getType(), f = s.getParentType();
        if ((0, a.isCompositeType)(d) && (0, a.isCompositeType)(f) && !(0, i.doTypesOverlap)(
          s.getSchema(),
          d,
          f
        )) {
          const u = (0, e.inspect)(f), c = (0, e.inspect)(d);
          s.reportError(
            new n.GraphQLError(
              `Fragment cannot be spread here as objects of type "${u}" can never be of type "${c}".`,
              {
                nodes: l
              }
            )
          );
        }
      },
      FragmentSpread(l) {
        const d = l.name.value, f = o(s, d), u = s.getParentType();
        if (f && u && !(0, i.doTypesOverlap)(
          s.getSchema(),
          f,
          u
        )) {
          const c = (0, e.inspect)(u), m = (0, e.inspect)(f);
          s.reportError(
            new n.GraphQLError(
              `Fragment "${d}" cannot be spread here as objects of type "${c}" can never be of type "${m}".`,
              {
                nodes: l
              }
            )
          );
        }
      }
    };
  }
  function o(s, l) {
    const d = s.getFragment(l);
    if (d) {
      const f = (0, t.typeFromAST)(
        s.getSchema(),
        d.typeCondition
      );
      if ((0, a.isCompositeType)(f))
        return f;
    }
  }
  return Ct;
}
var Gt = {}, ka;
function ho() {
  if (ka) return Gt;
  ka = 1, Object.defineProperty(Gt, "__esModule", {
    value: !0
  }), Gt.PossibleTypeExtensionsRule = l;
  var e = /* @__PURE__ */ on(), n = /* @__PURE__ */ de(), a = /* @__PURE__ */ Le(), i = /* @__PURE__ */ cn(), t = /* @__PURE__ */ ne(), r = /* @__PURE__ */ se(), o = /* @__PURE__ */ Sn(), s = /* @__PURE__ */ oe();
  function l(c) {
    const m = c.getSchema(), p = /* @__PURE__ */ Object.create(null);
    for (const T of c.getDocument().definitions)
      (0, o.isTypeDefinitionNode)(T) && (p[T.name.value] = T);
    return {
      ScalarTypeExtension: b,
      ObjectTypeExtension: b,
      InterfaceTypeExtension: b,
      UnionTypeExtension: b,
      EnumTypeExtension: b,
      InputObjectTypeExtension: b
    };
    function b(T) {
      const y = T.name.value, h = p[y], I = m?.getType(y);
      let S;
      if (h ? S = d[h.kind] : I && (S = f(I)), S) {
        if (S !== T.kind) {
          const E = u(T.kind);
          c.reportError(
            new t.GraphQLError(
              `Cannot extend non-${E} type "${y}".`,
              {
                nodes: h ? [h, T] : T
              }
            )
          );
        }
      } else {
        const E = Object.keys({
          ...p,
          ...m?.getTypeMap()
        }), k = (0, i.suggestionList)(
          y,
          E
        );
        c.reportError(
          new t.GraphQLError(
            `Cannot extend type "${y}" because it is not defined.` + (0, e.didYouMean)(k),
            {
              nodes: T.name
            }
          )
        );
      }
    }
  }
  const d = {
    [r.Kind.SCALAR_TYPE_DEFINITION]: r.Kind.SCALAR_TYPE_EXTENSION,
    [r.Kind.OBJECT_TYPE_DEFINITION]: r.Kind.OBJECT_TYPE_EXTENSION,
    [r.Kind.INTERFACE_TYPE_DEFINITION]: r.Kind.INTERFACE_TYPE_EXTENSION,
    [r.Kind.UNION_TYPE_DEFINITION]: r.Kind.UNION_TYPE_EXTENSION,
    [r.Kind.ENUM_TYPE_DEFINITION]: r.Kind.ENUM_TYPE_EXTENSION,
    [r.Kind.INPUT_OBJECT_TYPE_DEFINITION]: r.Kind.INPUT_OBJECT_TYPE_EXTENSION
  };
  function f(c) {
    if ((0, s.isScalarType)(c))
      return r.Kind.SCALAR_TYPE_EXTENSION;
    if ((0, s.isObjectType)(c))
      return r.Kind.OBJECT_TYPE_EXTENSION;
    if ((0, s.isInterfaceType)(c))
      return r.Kind.INTERFACE_TYPE_EXTENSION;
    if ((0, s.isUnionType)(c))
      return r.Kind.UNION_TYPE_EXTENSION;
    if ((0, s.isEnumType)(c))
      return r.Kind.ENUM_TYPE_EXTENSION;
    if ((0, s.isInputObjectType)(c))
      return r.Kind.INPUT_OBJECT_TYPE_EXTENSION;
    (0, a.invariant)(
      !1,
      "Unexpected type: " + (0, n.inspect)(c)
    );
  }
  function u(c) {
    switch (c) {
      case r.Kind.SCALAR_TYPE_EXTENSION:
        return "scalar";
      case r.Kind.OBJECT_TYPE_EXTENSION:
        return "object";
      case r.Kind.INTERFACE_TYPE_EXTENSION:
        return "interface";
      case r.Kind.UNION_TYPE_EXTENSION:
        return "union";
      case r.Kind.ENUM_TYPE_EXTENSION:
        return "enum";
      case r.Kind.INPUT_OBJECT_TYPE_EXTENSION:
        return "input object";
      // Not reachable. All possible types have been considered
      /* c8 ignore next */
      default:
        (0, a.invariant)(
          !1,
          "Unexpected kind: " + (0, n.inspect)(c)
        );
    }
  }
  return Gt;
}
var wn = {}, Fa;
function vo() {
  if (Fa) return wn;
  Fa = 1, Object.defineProperty(wn, "__esModule", {
    value: !0
  }), wn.ProvidedRequiredArgumentsOnDirectivesRule = l, wn.ProvidedRequiredArgumentsRule = s;
  var e = /* @__PURE__ */ de(), n = /* @__PURE__ */ un(), a = /* @__PURE__ */ ne(), i = /* @__PURE__ */ se(), t = /* @__PURE__ */ Fe(), r = /* @__PURE__ */ oe(), o = /* @__PURE__ */ Pe();
  function s(f) {
    return {
      // eslint-disable-next-line new-cap
      ...l(f),
      Field: {
        // Validate on leave to allow for deeper errors to appear first.
        leave(u) {
          var c;
          const m = f.getFieldDef();
          if (!m)
            return !1;
          const p = new Set(
            // FIXME: https://github.com/graphql/graphql-js/issues/2203
            /* c8 ignore next */
            (c = u.arguments) === null || c === void 0 ? void 0 : c.map((b) => b.name.value)
          );
          for (const b of m.args)
            if (!p.has(b.name) && (0, r.isRequiredArgument)(b)) {
              const T = (0, e.inspect)(b.type);
              f.reportError(
                new a.GraphQLError(
                  `Field "${m.name}" argument "${b.name}" of type "${T}" is required, but it was not provided.`,
                  {
                    nodes: u
                  }
                )
              );
            }
        }
      }
    };
  }
  function l(f) {
    var u;
    const c = /* @__PURE__ */ Object.create(null), m = f.getSchema(), p = (u = m?.getDirectives()) !== null && u !== void 0 ? u : o.specifiedDirectives;
    for (const y of p)
      c[y.name] = (0, n.keyMap)(
        y.args.filter(r.isRequiredArgument),
        (h) => h.name
      );
    const b = f.getDocument().definitions;
    for (const y of b)
      if (y.kind === i.Kind.DIRECTIVE_DEFINITION) {
        var T;
        const h = (T = y.arguments) !== null && T !== void 0 ? T : [];
        c[y.name.value] = (0, n.keyMap)(
          h.filter(d),
          (I) => I.name.value
        );
      }
    return {
      Directive: {
        // Validate on leave to allow for deeper errors to appear first.
        leave(y) {
          const h = y.name.value, I = c[h];
          if (I) {
            var S;
            const E = (S = y.arguments) !== null && S !== void 0 ? S : [], k = new Set(E.map((M) => M.name.value));
            for (const [M, C] of Object.entries(I))
              if (!k.has(M)) {
                const _ = (0, r.isType)(C.type) ? (0, e.inspect)(C.type) : (0, t.print)(C.type);
                f.reportError(
                  new a.GraphQLError(
                    `Directive "@${h}" argument "${M}" of type "${_}" is required, but it was not provided.`,
                    {
                      nodes: y
                    }
                  )
                );
              }
          }
        }
      }
    };
  }
  function d(f) {
    return f.type.kind === i.Kind.NON_NULL_TYPE && f.defaultValue == null;
  }
  return wn;
}
var Mt = {}, wa;
function To() {
  if (wa) return Mt;
  wa = 1, Object.defineProperty(Mt, "__esModule", {
    value: !0
  }), Mt.ScalarLeafsRule = i;
  var e = /* @__PURE__ */ de(), n = /* @__PURE__ */ ne(), a = /* @__PURE__ */ oe();
  function i(t) {
    return {
      Field(r) {
        const o = t.getType(), s = r.selectionSet;
        if (o)
          if ((0, a.isLeafType)((0, a.getNamedType)(o))) {
            if (s) {
              const l = r.name.value, d = (0, e.inspect)(o);
              t.reportError(
                new n.GraphQLError(
                  `Field "${l}" must not have a selection since type "${d}" has no subfields.`,
                  {
                    nodes: s
                  }
                )
              );
            }
          } else if (s) {
            if (s.selections.length === 0) {
              const l = r.name.value, d = (0, e.inspect)(o);
              t.reportError(
                new n.GraphQLError(
                  `Field "${l}" of type "${d}" must have at least one field selected.`,
                  {
                    nodes: r
                  }
                )
              );
            }
          } else {
            const l = r.name.value, d = (0, e.inspect)(o);
            t.reportError(
              new n.GraphQLError(
                `Field "${l}" of type "${d}" must have a selection of subfields. Did you mean "${l} { ... }"?`,
                {
                  nodes: r
                }
              )
            );
          }
      }
    };
  }
  return Mt;
}
var $t = {}, Vn = {}, bn = {}, Ut = {}, Va;
function bo() {
  if (Va) return Ut;
  Va = 1, Object.defineProperty(Ut, "__esModule", {
    value: !0
  }), Ut.printPathArray = e;
  function e(n) {
    return n.map(
      (a) => typeof a == "number" ? "[" + a.toString() + "]" : "." + a
    ).join("");
  }
  return Ut;
}
var Qt = {}, Cn = {}, Ca;
function Cr() {
  if (Ca) return Cn;
  Ca = 1, Object.defineProperty(Cn, "__esModule", {
    value: !0
  }), Cn.addPath = e, Cn.pathToArray = n;
  function e(a, i, t) {
    return {
      prev: a,
      key: i,
      typename: t
    };
  }
  function n(a) {
    const i = [];
    let t = a;
    for (; t; )
      i.push(t.key), t = t.prev;
    return i.reverse();
  }
  return Cn;
}
var Ga;
function Eo() {
  if (Ga) return Qt;
  Ga = 1, Object.defineProperty(Qt, "__esModule", {
    value: !0
  }), Qt.coerceInputValue = f;
  var e = /* @__PURE__ */ on(), n = /* @__PURE__ */ de(), a = /* @__PURE__ */ Le(), i = /* @__PURE__ */ oi(), t = /* @__PURE__ */ ze(), r = /* @__PURE__ */ Cr(), o = /* @__PURE__ */ bo(), s = /* @__PURE__ */ cn(), l = /* @__PURE__ */ ne(), d = /* @__PURE__ */ oe();
  function f(m, p, b = u) {
    return c(m, p, b, void 0);
  }
  function u(m, p, b) {
    let T = "Invalid value " + (0, n.inspect)(p);
    throw m.length > 0 && (T += ` at "value${(0, o.printPathArray)(m)}"`), b.message = T + ": " + b.message, b;
  }
  function c(m, p, b, T) {
    if ((0, d.isNonNullType)(p)) {
      if (m != null)
        return c(m, p.ofType, b, T);
      b(
        (0, r.pathToArray)(T),
        m,
        new l.GraphQLError(
          `Expected non-nullable type "${(0, n.inspect)(
            p
          )}" not to be null.`
        )
      );
      return;
    }
    if (m == null)
      return null;
    if ((0, d.isListType)(p)) {
      const y = p.ofType;
      return (0, i.isIterableObject)(m) ? Array.from(m, (h, I) => {
        const S = (0, r.addPath)(T, I, void 0);
        return c(h, y, b, S);
      }) : [c(m, y, b, T)];
    }
    if ((0, d.isInputObjectType)(p)) {
      if (!(0, t.isObjectLike)(m) || Array.isArray(m)) {
        b(
          (0, r.pathToArray)(T),
          m,
          new l.GraphQLError(
            `Expected type "${p.name}" to be an object.`
          )
        );
        return;
      }
      const y = {}, h = p.getFields();
      for (const I of Object.values(h)) {
        const S = m[I.name];
        if (S === void 0) {
          if (I.defaultValue !== void 0)
            y[I.name] = I.defaultValue;
          else if ((0, d.isNonNullType)(I.type)) {
            const E = (0, n.inspect)(I.type);
            b(
              (0, r.pathToArray)(T),
              m,
              new l.GraphQLError(
                `Field "${I.name}" of required type "${E}" was not provided.`
              )
            );
          }
          continue;
        }
        y[I.name] = c(
          S,
          I.type,
          b,
          (0, r.addPath)(T, I.name, p.name)
        );
      }
      for (const I of Object.keys(m))
        if (!h[I]) {
          const S = (0, s.suggestionList)(
            I,
            Object.keys(p.getFields())
          );
          b(
            (0, r.pathToArray)(T),
            m,
            new l.GraphQLError(
              `Field "${I}" is not defined by type "${p.name}".` + (0, e.didYouMean)(S)
            )
          );
        }
      if (p.isOneOf) {
        const I = Object.keys(y);
        I.length !== 1 && b(
          (0, r.pathToArray)(T),
          m,
          new l.GraphQLError(
            `Exactly one key must be specified for OneOf type "${p.name}".`
          )
        );
        const S = I[0], E = y[S];
        E === null && b(
          (0, r.pathToArray)(T).concat(S),
          E,
          new l.GraphQLError(`Field "${S}" must be non-null.`)
        );
      }
      return y;
    }
    if ((0, d.isLeafType)(p)) {
      let y;
      try {
        y = p.parseValue(m);
      } catch (h) {
        h instanceof l.GraphQLError ? b((0, r.pathToArray)(T), m, h) : b(
          (0, r.pathToArray)(T),
          m,
          new l.GraphQLError(
            `Expected type "${p.name}". ` + h.message,
            {
              originalError: h
            }
          )
        );
        return;
      }
      return y === void 0 && b(
        (0, r.pathToArray)(T),
        m,
        new l.GraphQLError(`Expected type "${p.name}".`)
      ), y;
    }
    (0, a.invariant)(
      !1,
      "Unexpected input type: " + (0, n.inspect)(p)
    );
  }
  return Qt;
}
var qt = {}, Ma;
function Gr() {
  if (Ma) return qt;
  Ma = 1, Object.defineProperty(qt, "__esModule", {
    value: !0
  }), qt.valueFromAST = r;
  var e = /* @__PURE__ */ de(), n = /* @__PURE__ */ Le(), a = /* @__PURE__ */ un(), i = /* @__PURE__ */ se(), t = /* @__PURE__ */ oe();
  function r(s, l, d) {
    if (s) {
      if (s.kind === i.Kind.VARIABLE) {
        const f = s.name.value;
        if (d == null || d[f] === void 0)
          return;
        const u = d[f];
        return u === null && (0, t.isNonNullType)(l) ? void 0 : u;
      }
      if ((0, t.isNonNullType)(l))
        return s.kind === i.Kind.NULL ? void 0 : r(s, l.ofType, d);
      if (s.kind === i.Kind.NULL)
        return null;
      if ((0, t.isListType)(l)) {
        const f = l.ofType;
        if (s.kind === i.Kind.LIST) {
          const c = [];
          for (const m of s.values)
            if (o(m, d)) {
              if ((0, t.isNonNullType)(f))
                return;
              c.push(null);
            } else {
              const p = r(m, f, d);
              if (p === void 0)
                return;
              c.push(p);
            }
          return c;
        }
        const u = r(s, f, d);
        return u === void 0 ? void 0 : [u];
      }
      if ((0, t.isInputObjectType)(l)) {
        if (s.kind !== i.Kind.OBJECT)
          return;
        const f = /* @__PURE__ */ Object.create(null), u = (0, a.keyMap)(
          s.fields,
          (c) => c.name.value
        );
        for (const c of Object.values(l.getFields())) {
          const m = u[c.name];
          if (!m || o(m.value, d)) {
            if (c.defaultValue !== void 0)
              f[c.name] = c.defaultValue;
            else if ((0, t.isNonNullType)(c.type))
              return;
            continue;
          }
          const p = r(m.value, c.type, d);
          if (p === void 0)
            return;
          f[c.name] = p;
        }
        if (l.isOneOf) {
          const c = Object.keys(f);
          if (c.length !== 1 || f[c[0]] === null)
            return;
        }
        return f;
      }
      if ((0, t.isLeafType)(l)) {
        let f;
        try {
          f = l.parseLiteral(s, d);
        } catch {
          return;
        }
        return f === void 0 ? void 0 : f;
      }
      (0, n.invariant)(
        !1,
        "Unexpected input type: " + (0, e.inspect)(l)
      );
    }
  }
  function o(s, l) {
    return s.kind === i.Kind.VARIABLE && (l == null || l[s.name.value] === void 0);
  }
  return qt;
}
var $a;
function Xn() {
  if ($a) return bn;
  $a = 1, Object.defineProperty(bn, "__esModule", {
    value: !0
  }), bn.getArgumentValues = c, bn.getDirectiveValues = m, bn.getVariableValues = f;
  var e = /* @__PURE__ */ de(), n = /* @__PURE__ */ un(), a = /* @__PURE__ */ bo(), i = /* @__PURE__ */ ne(), t = /* @__PURE__ */ se(), r = /* @__PURE__ */ Fe(), o = /* @__PURE__ */ oe(), s = /* @__PURE__ */ Eo(), l = /* @__PURE__ */ He(), d = /* @__PURE__ */ Gr();
  function f(b, T, y, h) {
    const I = [], S = h?.maxErrors;
    try {
      const E = u(
        b,
        T,
        y,
        (k) => {
          if (S != null && I.length >= S)
            throw new i.GraphQLError(
              "Too many errors processing variables, error limit reached. Execution aborted."
            );
          I.push(k);
        }
      );
      if (I.length === 0)
        return {
          coerced: E
        };
    } catch (E) {
      I.push(E);
    }
    return {
      errors: I
    };
  }
  function u(b, T, y, h) {
    const I = {};
    for (const S of T) {
      const E = S.variable.name.value, k = (0, l.typeFromAST)(b, S.type);
      if (!(0, o.isInputType)(k)) {
        const C = (0, r.print)(S.type);
        h(
          new i.GraphQLError(
            `Variable "$${E}" expected value of type "${C}" which cannot be used as an input type.`,
            {
              nodes: S.type
            }
          )
        );
        continue;
      }
      if (!p(y, E)) {
        if (S.defaultValue)
          I[E] = (0, d.valueFromAST)(
            S.defaultValue,
            k
          );
        else if ((0, o.isNonNullType)(k)) {
          const C = (0, e.inspect)(k);
          h(
            new i.GraphQLError(
              `Variable "$${E}" of required type "${C}" was not provided.`,
              {
                nodes: S
              }
            )
          );
        }
        continue;
      }
      const M = y[E];
      if (M === null && (0, o.isNonNullType)(k)) {
        const C = (0, e.inspect)(k);
        h(
          new i.GraphQLError(
            `Variable "$${E}" of non-null type "${C}" must not be null.`,
            {
              nodes: S
            }
          )
        );
        continue;
      }
      I[E] = (0, s.coerceInputValue)(
        M,
        k,
        (C, _, N) => {
          let D = `Variable "$${E}" got invalid value ` + (0, e.inspect)(_);
          C.length > 0 && (D += ` at "${E}${(0, a.printPathArray)(
            C
          )}"`), h(
            new i.GraphQLError(D + "; " + N.message, {
              nodes: S,
              originalError: N
            })
          );
        }
      );
    }
    return I;
  }
  function c(b, T, y) {
    var h;
    const I = {}, S = (h = T.arguments) !== null && h !== void 0 ? h : [], E = (0, n.keyMap)(
      S,
      (k) => k.name.value
    );
    for (const k of b.args) {
      const M = k.name, C = k.type, _ = E[M];
      if (!_) {
        if (k.defaultValue !== void 0)
          I[M] = k.defaultValue;
        else if ((0, o.isNonNullType)(C))
          throw new i.GraphQLError(
            `Argument "${M}" of required type "${(0, e.inspect)(
              C
            )}" was not provided.`,
            {
              nodes: T
            }
          );
        continue;
      }
      const N = _.value;
      let D = N.kind === t.Kind.NULL;
      if (N.kind === t.Kind.VARIABLE) {
        const v = N.name.value;
        if (y == null || !p(y, v)) {
          if (k.defaultValue !== void 0)
            I[M] = k.defaultValue;
          else if ((0, o.isNonNullType)(C))
            throw new i.GraphQLError(
              `Argument "${M}" of required type "${(0, e.inspect)(
                C
              )}" was provided the variable "$${v}" which was not provided a runtime value.`,
              {
                nodes: N
              }
            );
          continue;
        }
        D = y[v] == null;
      }
      if (D && (0, o.isNonNullType)(C))
        throw new i.GraphQLError(
          `Argument "${M}" of non-null type "${(0, e.inspect)(
            C
          )}" must not be null.`,
          {
            nodes: N
          }
        );
      const O = (0, d.valueFromAST)(
        N,
        C,
        y
      );
      if (O === void 0)
        throw new i.GraphQLError(
          `Argument "${M}" has invalid value ${(0, r.print)(
            N
          )}.`,
          {
            nodes: N
          }
        );
      I[M] = O;
    }
    return I;
  }
  function m(b, T, y) {
    var h;
    const I = (h = T.directives) === null || h === void 0 ? void 0 : h.find(
      (S) => S.name.value === b.name
    );
    if (I)
      return c(b, I, y);
  }
  function p(b, T) {
    return Object.prototype.hasOwnProperty.call(b, T);
  }
  return bn;
}
var Ua;
function ci() {
  if (Ua) return Vn;
  Ua = 1, Object.defineProperty(Vn, "__esModule", {
    value: !0
  }), Vn.collectFields = r, Vn.collectSubfields = o;
  var e = /* @__PURE__ */ se(), n = /* @__PURE__ */ oe(), a = /* @__PURE__ */ Pe(), i = /* @__PURE__ */ He(), t = /* @__PURE__ */ Xn();
  function r(u, c, m, p, b) {
    const T = /* @__PURE__ */ new Map();
    return s(
      u,
      c,
      m,
      p,
      b,
      T,
      /* @__PURE__ */ new Set()
    ), T;
  }
  function o(u, c, m, p, b) {
    const T = /* @__PURE__ */ new Map(), y = /* @__PURE__ */ new Set();
    for (const h of b)
      h.selectionSet && s(
        u,
        c,
        m,
        p,
        h.selectionSet,
        T,
        y
      );
    return T;
  }
  function s(u, c, m, p, b, T, y) {
    for (const h of b.selections)
      switch (h.kind) {
        case e.Kind.FIELD: {
          if (!l(m, h))
            continue;
          const I = f(h), S = T.get(I);
          S !== void 0 ? S.push(h) : T.set(I, [h]);
          break;
        }
        case e.Kind.INLINE_FRAGMENT: {
          if (!l(m, h) || !d(u, h, p))
            continue;
          s(
            u,
            c,
            m,
            p,
            h.selectionSet,
            T,
            y
          );
          break;
        }
        case e.Kind.FRAGMENT_SPREAD: {
          const I = h.name.value;
          if (y.has(I) || !l(m, h))
            continue;
          y.add(I);
          const S = c[I];
          if (!S || !d(u, S, p))
            continue;
          s(
            u,
            c,
            m,
            p,
            S.selectionSet,
            T,
            y
          );
          break;
        }
      }
  }
  function l(u, c) {
    const m = (0, t.getDirectiveValues)(
      a.GraphQLSkipDirective,
      c,
      u
    );
    if (m?.if === !0)
      return !1;
    const p = (0, t.getDirectiveValues)(
      a.GraphQLIncludeDirective,
      c,
      u
    );
    return p?.if !== !1;
  }
  function d(u, c, m) {
    const p = c.typeCondition;
    if (!p)
      return !0;
    const b = (0, i.typeFromAST)(
      u,
      p
    );
    return b === m ? !0 : (0, n.isAbstractType)(b) ? u.isSubType(b, m) : !1;
  }
  function f(u) {
    return u.alias ? u.alias.value : u.name.value;
  }
  return Vn;
}
var Qa;
function go() {
  if (Qa) return $t;
  Qa = 1, Object.defineProperty($t, "__esModule", {
    value: !0
  }), $t.SingleFieldSubscriptionsRule = i;
  var e = /* @__PURE__ */ ne(), n = /* @__PURE__ */ se(), a = /* @__PURE__ */ ci();
  function i(t) {
    return {
      OperationDefinition(r) {
        if (r.operation === "subscription") {
          const o = t.getSchema(), s = o.getSubscriptionType();
          if (s) {
            const l = r.name ? r.name.value : null, d = /* @__PURE__ */ Object.create(null), f = t.getDocument(), u = /* @__PURE__ */ Object.create(null);
            for (const m of f.definitions)
              m.kind === n.Kind.FRAGMENT_DEFINITION && (u[m.name.value] = m);
            const c = (0, a.collectFields)(
              o,
              u,
              d,
              s,
              r.selectionSet
            );
            if (c.size > 1) {
              const b = [...c.values()].slice(1).flat();
              t.reportError(
                new e.GraphQLError(
                  l != null ? `Subscription "${l}" must select only one top level field.` : "Anonymous Subscription must select only one top level field.",
                  {
                    nodes: b
                  }
                )
              );
            }
            for (const m of c.values())
              m[0].name.value.startsWith("__") && t.reportError(
                new e.GraphQLError(
                  l != null ? `Subscription "${l}" must not select an introspection top level field.` : "Anonymous Subscription must not select an introspection top level field.",
                  {
                    nodes: m
                  }
                )
              );
          }
        }
      }
    };
  }
  return $t;
}
var Kt = {}, Bt = {}, qa;
function li() {
  if (qa) return Bt;
  qa = 1, Object.defineProperty(Bt, "__esModule", {
    value: !0
  }), Bt.groupBy = e;
  function e(n, a) {
    const i = /* @__PURE__ */ new Map();
    for (const t of n) {
      const r = a(t), o = i.get(r);
      o === void 0 ? i.set(r, [t]) : o.push(t);
    }
    return i;
  }
  return Bt;
}
var Ka;
function No() {
  if (Ka) return Kt;
  Ka = 1, Object.defineProperty(Kt, "__esModule", {
    value: !0
  }), Kt.UniqueArgumentDefinitionNamesRule = a;
  var e = /* @__PURE__ */ li(), n = /* @__PURE__ */ ne();
  function a(i) {
    return {
      DirectiveDefinition(o) {
        var s;
        const l = (s = o.arguments) !== null && s !== void 0 ? s : [];
        return r(`@${o.name.value}`, l);
      },
      InterfaceTypeDefinition: t,
      InterfaceTypeExtension: t,
      ObjectTypeDefinition: t,
      ObjectTypeExtension: t
    };
    function t(o) {
      var s;
      const l = o.name.value, d = (s = o.fields) !== null && s !== void 0 ? s : [];
      for (const u of d) {
        var f;
        const c = u.name.value, m = (f = u.arguments) !== null && f !== void 0 ? f : [];
        r(`${l}.${c}`, m);
      }
      return !1;
    }
    function r(o, s) {
      const l = (0, e.groupBy)(
        s,
        (d) => d.name.value
      );
      for (const [d, f] of l)
        f.length > 1 && i.reportError(
          new n.GraphQLError(
            `Argument "${o}(${d}:)" can only be defined once.`,
            {
              nodes: f.map((u) => u.name)
            }
          )
        );
      return !1;
    }
  }
  return Kt;
}
var xt = {}, Ba;
function Oo() {
  if (Ba) return xt;
  Ba = 1, Object.defineProperty(xt, "__esModule", {
    value: !0
  }), xt.UniqueArgumentNamesRule = a;
  var e = /* @__PURE__ */ li(), n = /* @__PURE__ */ ne();
  function a(i) {
    return {
      Field: t,
      Directive: t
    };
    function t(r) {
      var o;
      const s = (o = r.arguments) !== null && o !== void 0 ? o : [], l = (0, e.groupBy)(
        s,
        (d) => d.name.value
      );
      for (const [d, f] of l)
        f.length > 1 && i.reportError(
          new n.GraphQLError(
            `There can be only one argument named "${d}".`,
            {
              nodes: f.map((u) => u.name)
            }
          )
        );
    }
  }
  return xt;
}
var Yt = {}, xa;
function _o() {
  if (xa) return Yt;
  xa = 1, Object.defineProperty(Yt, "__esModule", {
    value: !0
  }), Yt.UniqueDirectiveNamesRule = n;
  var e = /* @__PURE__ */ ne();
  function n(a) {
    const i = /* @__PURE__ */ Object.create(null), t = a.getSchema();
    return {
      DirectiveDefinition(r) {
        const o = r.name.value;
        if (t != null && t.getDirective(o)) {
          a.reportError(
            new e.GraphQLError(
              `Directive "@${o}" already exists in the schema. It cannot be redefined.`,
              {
                nodes: r.name
              }
            )
          );
          return;
        }
        return i[o] ? a.reportError(
          new e.GraphQLError(
            `There can be only one directive named "@${o}".`,
            {
              nodes: [i[o], r.name]
            }
          )
        ) : i[o] = r.name, !1;
      }
    };
  }
  return Yt;
}
var Jt = {}, Ya;
function Io() {
  if (Ya) return Jt;
  Ya = 1, Object.defineProperty(Jt, "__esModule", {
    value: !0
  }), Jt.UniqueDirectivesPerLocationRule = t;
  var e = /* @__PURE__ */ ne(), n = /* @__PURE__ */ se(), a = /* @__PURE__ */ Sn(), i = /* @__PURE__ */ Pe();
  function t(r) {
    const o = /* @__PURE__ */ Object.create(null), s = r.getSchema(), l = s ? s.getDirectives() : i.specifiedDirectives;
    for (const c of l)
      o[c.name] = !c.isRepeatable;
    const d = r.getDocument().definitions;
    for (const c of d)
      c.kind === n.Kind.DIRECTIVE_DEFINITION && (o[c.name.value] = !c.repeatable);
    const f = /* @__PURE__ */ Object.create(null), u = /* @__PURE__ */ Object.create(null);
    return {
      // Many different AST nodes may contain directives. Rather than listing
      // them all, just listen for entering any node, and check to see if it
      // defines any directives.
      enter(c) {
        if (!("directives" in c) || !c.directives)
          return;
        let m;
        if (c.kind === n.Kind.SCHEMA_DEFINITION || c.kind === n.Kind.SCHEMA_EXTENSION)
          m = f;
        else if ((0, a.isTypeDefinitionNode)(c) || (0, a.isTypeExtensionNode)(c)) {
          const p = c.name.value;
          m = u[p], m === void 0 && (u[p] = m = /* @__PURE__ */ Object.create(null));
        } else
          m = /* @__PURE__ */ Object.create(null);
        for (const p of c.directives) {
          const b = p.name.value;
          o[b] && (m[b] ? r.reportError(
            new e.GraphQLError(
              `The directive "@${b}" can only be used once at this location.`,
              {
                nodes: [m[b], p]
              }
            )
          ) : m[b] = p);
        }
      }
    };
  }
  return Jt;
}
var zt = {}, Ja;
function So() {
  if (Ja) return zt;
  Ja = 1, Object.defineProperty(zt, "__esModule", {
    value: !0
  }), zt.UniqueEnumValueNamesRule = a;
  var e = /* @__PURE__ */ ne(), n = /* @__PURE__ */ oe();
  function a(i) {
    const t = i.getSchema(), r = t ? t.getTypeMap() : /* @__PURE__ */ Object.create(null), o = /* @__PURE__ */ Object.create(null);
    return {
      EnumTypeDefinition: s,
      EnumTypeExtension: s
    };
    function s(l) {
      var d;
      const f = l.name.value;
      o[f] || (o[f] = /* @__PURE__ */ Object.create(null));
      const u = (d = l.values) !== null && d !== void 0 ? d : [], c = o[f];
      for (const m of u) {
        const p = m.name.value, b = r[f];
        (0, n.isEnumType)(b) && b.getValue(p) ? i.reportError(
          new e.GraphQLError(
            `Enum value "${f}.${p}" already exists in the schema. It cannot also be defined in this type extension.`,
            {
              nodes: m.name
            }
          )
        ) : c[p] ? i.reportError(
          new e.GraphQLError(
            `Enum value "${f}.${p}" can only be defined once.`,
            {
              nodes: [c[p], m.name]
            }
          )
        ) : c[p] = m.name;
      }
      return !1;
    }
  }
  return zt;
}
var Xt = {}, za;
function Lo() {
  if (za) return Xt;
  za = 1, Object.defineProperty(Xt, "__esModule", {
    value: !0
  }), Xt.UniqueFieldDefinitionNamesRule = a;
  var e = /* @__PURE__ */ ne(), n = /* @__PURE__ */ oe();
  function a(t) {
    const r = t.getSchema(), o = r ? r.getTypeMap() : /* @__PURE__ */ Object.create(null), s = /* @__PURE__ */ Object.create(null);
    return {
      InputObjectTypeDefinition: l,
      InputObjectTypeExtension: l,
      InterfaceTypeDefinition: l,
      InterfaceTypeExtension: l,
      ObjectTypeDefinition: l,
      ObjectTypeExtension: l
    };
    function l(d) {
      var f;
      const u = d.name.value;
      s[u] || (s[u] = /* @__PURE__ */ Object.create(null));
      const c = (f = d.fields) !== null && f !== void 0 ? f : [], m = s[u];
      for (const p of c) {
        const b = p.name.value;
        i(o[u], b) ? t.reportError(
          new e.GraphQLError(
            `Field "${u}.${b}" already exists in the schema. It cannot also be defined in this type extension.`,
            {
              nodes: p.name
            }
          )
        ) : m[b] ? t.reportError(
          new e.GraphQLError(
            `Field "${u}.${b}" can only be defined once.`,
            {
              nodes: [m[b], p.name]
            }
          )
        ) : m[b] = p.name;
      }
      return !1;
    }
  }
  function i(t, r) {
    return (0, n.isObjectType)(t) || (0, n.isInterfaceType)(t) || (0, n.isInputObjectType)(t) ? t.getFields()[r] != null : !1;
  }
  return Xt;
}
var Ht = {}, Xa;
function Ro() {
  if (Xa) return Ht;
  Xa = 1, Object.defineProperty(Ht, "__esModule", {
    value: !0
  }), Ht.UniqueFragmentNamesRule = n;
  var e = /* @__PURE__ */ ne();
  function n(a) {
    const i = /* @__PURE__ */ Object.create(null);
    return {
      OperationDefinition: () => !1,
      FragmentDefinition(t) {
        const r = t.name.value;
        return i[r] ? a.reportError(
          new e.GraphQLError(
            `There can be only one fragment named "${r}".`,
            {
              nodes: [i[r], t.name]
            }
          )
        ) : i[r] = t.name, !1;
      }
    };
  }
  return Ht;
}
var Wt = {}, Ha;
function Do() {
  if (Ha) return Wt;
  Ha = 1, Object.defineProperty(Wt, "__esModule", {
    value: !0
  }), Wt.UniqueInputFieldNamesRule = a;
  var e = /* @__PURE__ */ Le(), n = /* @__PURE__ */ ne();
  function a(i) {
    const t = [];
    let r = /* @__PURE__ */ Object.create(null);
    return {
      ObjectValue: {
        enter() {
          t.push(r), r = /* @__PURE__ */ Object.create(null);
        },
        leave() {
          const o = t.pop();
          o || (0, e.invariant)(!1), r = o;
        }
      },
      ObjectField(o) {
        const s = o.name.value;
        r[s] ? i.reportError(
          new n.GraphQLError(
            `There can be only one input field named "${s}".`,
            {
              nodes: [r[s], o.name]
            }
          )
        ) : r[s] = o.name;
      }
    };
  }
  return Wt;
}
var Zt = {}, Wa;
function Ao() {
  if (Wa) return Zt;
  Wa = 1, Object.defineProperty(Zt, "__esModule", {
    value: !0
  }), Zt.UniqueOperationNamesRule = n;
  var e = /* @__PURE__ */ ne();
  function n(a) {
    const i = /* @__PURE__ */ Object.create(null);
    return {
      OperationDefinition(t) {
        const r = t.name;
        return r && (i[r.value] ? a.reportError(
          new e.GraphQLError(
            `There can be only one operation named "${r.value}".`,
            {
              nodes: [
                i[r.value],
                r
              ]
            }
          )
        ) : i[r.value] = r), !1;
      },
      FragmentDefinition: () => !1
    };
  }
  return Zt;
}
var er = {}, Za;
function jo() {
  if (Za) return er;
  Za = 1, Object.defineProperty(er, "__esModule", {
    value: !0
  }), er.UniqueOperationTypesRule = n;
  var e = /* @__PURE__ */ ne();
  function n(a) {
    const i = a.getSchema(), t = /* @__PURE__ */ Object.create(null), r = i ? {
      query: i.getQueryType(),
      mutation: i.getMutationType(),
      subscription: i.getSubscriptionType()
    } : {};
    return {
      SchemaDefinition: o,
      SchemaExtension: o
    };
    function o(s) {
      var l;
      const d = (l = s.operationTypes) !== null && l !== void 0 ? l : [];
      for (const f of d) {
        const u = f.operation, c = t[u];
        r[u] ? a.reportError(
          new e.GraphQLError(
            `Type for ${u} already defined in the schema. It cannot be redefined.`,
            {
              nodes: f
            }
          )
        ) : c ? a.reportError(
          new e.GraphQLError(
            `There can be only one ${u} type in schema.`,
            {
              nodes: [c, f]
            }
          )
        ) : t[u] = f;
      }
      return !1;
    }
  }
  return er;
}
var nr = {}, es;
function Po() {
  if (es) return nr;
  es = 1, Object.defineProperty(nr, "__esModule", {
    value: !0
  }), nr.UniqueTypeNamesRule = n;
  var e = /* @__PURE__ */ ne();
  function n(a) {
    const i = /* @__PURE__ */ Object.create(null), t = a.getSchema();
    return {
      ScalarTypeDefinition: r,
      ObjectTypeDefinition: r,
      InterfaceTypeDefinition: r,
      UnionTypeDefinition: r,
      EnumTypeDefinition: r,
      InputObjectTypeDefinition: r
    };
    function r(o) {
      const s = o.name.value;
      if (t != null && t.getType(s)) {
        a.reportError(
          new e.GraphQLError(
            `Type "${s}" already exists in the schema. It cannot also be defined in this type definition.`,
            {
              nodes: o.name
            }
          )
        );
        return;
      }
      return i[s] ? a.reportError(
        new e.GraphQLError(
          `There can be only one type named "${s}".`,
          {
            nodes: [i[s], o.name]
          }
        )
      ) : i[s] = o.name, !1;
    }
  }
  return nr;
}
var tr = {}, ns;
function ko() {
  if (ns) return tr;
  ns = 1, Object.defineProperty(tr, "__esModule", {
    value: !0
  }), tr.UniqueVariableNamesRule = a;
  var e = /* @__PURE__ */ li(), n = /* @__PURE__ */ ne();
  function a(i) {
    return {
      OperationDefinition(t) {
        var r;
        const o = (r = t.variableDefinitions) !== null && r !== void 0 ? r : [], s = (0, e.groupBy)(
          o,
          (l) => l.variable.name.value
        );
        for (const [l, d] of s)
          d.length > 1 && i.reportError(
            new n.GraphQLError(
              `There can be only one variable named "$${l}".`,
              {
                nodes: d.map((f) => f.variable.name)
              }
            )
          );
      }
    };
  }
  return tr;
}
var rr = {}, ts;
function Fo() {
  if (ts) return rr;
  ts = 1, Object.defineProperty(rr, "__esModule", {
    value: !0
  }), rr.ValuesOfCorrectTypeRule = l;
  var e = /* @__PURE__ */ on(), n = /* @__PURE__ */ de(), a = /* @__PURE__ */ un(), i = /* @__PURE__ */ cn(), t = /* @__PURE__ */ ne(), r = /* @__PURE__ */ se(), o = /* @__PURE__ */ Fe(), s = /* @__PURE__ */ oe();
  function l(u) {
    let c = {};
    return {
      OperationDefinition: {
        enter() {
          c = {};
        }
      },
      VariableDefinition(m) {
        c[m.variable.name.value] = m;
      },
      ListValue(m) {
        const p = (0, s.getNullableType)(
          u.getParentInputType()
        );
        if (!(0, s.isListType)(p))
          return d(u, m), !1;
      },
      ObjectValue(m) {
        const p = (0, s.getNamedType)(u.getInputType());
        if (!(0, s.isInputObjectType)(p))
          return d(u, m), !1;
        const b = (0, a.keyMap)(
          m.fields,
          (T) => T.name.value
        );
        for (const T of Object.values(p.getFields()))
          if (!b[T.name] && (0, s.isRequiredInputField)(T)) {
            const h = (0, n.inspect)(T.type);
            u.reportError(
              new t.GraphQLError(
                `Field "${p.name}.${T.name}" of required type "${h}" was not provided.`,
                {
                  nodes: m
                }
              )
            );
          }
        p.isOneOf && f(u, m, p, b);
      },
      ObjectField(m) {
        const p = (0, s.getNamedType)(
          u.getParentInputType()
        );
        if (!u.getInputType() && (0, s.isInputObjectType)(p)) {
          const T = (0, i.suggestionList)(
            m.name.value,
            Object.keys(p.getFields())
          );
          u.reportError(
            new t.GraphQLError(
              `Field "${m.name.value}" is not defined by type "${p.name}".` + (0, e.didYouMean)(T),
              {
                nodes: m
              }
            )
          );
        }
      },
      NullValue(m) {
        const p = u.getInputType();
        (0, s.isNonNullType)(p) && u.reportError(
          new t.GraphQLError(
            `Expected value of type "${(0, n.inspect)(
              p
            )}", found ${(0, o.print)(m)}.`,
            {
              nodes: m
            }
          )
        );
      },
      EnumValue: (m) => d(u, m),
      IntValue: (m) => d(u, m),
      FloatValue: (m) => d(u, m),
      StringValue: (m) => d(u, m),
      BooleanValue: (m) => d(u, m)
    };
  }
  function d(u, c) {
    const m = u.getInputType();
    if (!m)
      return;
    const p = (0, s.getNamedType)(m);
    if (!(0, s.isLeafType)(p)) {
      const b = (0, n.inspect)(m);
      u.reportError(
        new t.GraphQLError(
          `Expected value of type "${b}", found ${(0, o.print)(
            c
          )}.`,
          {
            nodes: c
          }
        )
      );
      return;
    }
    try {
      if (p.parseLiteral(
        c,
        void 0
        /* variables */
      ) === void 0) {
        const T = (0, n.inspect)(m);
        u.reportError(
          new t.GraphQLError(
            `Expected value of type "${T}", found ${(0, o.print)(
              c
            )}.`,
            {
              nodes: c
            }
          )
        );
      }
    } catch (b) {
      const T = (0, n.inspect)(m);
      b instanceof t.GraphQLError ? u.reportError(b) : u.reportError(
        new t.GraphQLError(
          `Expected value of type "${T}", found ${(0, o.print)(
            c
          )}; ` + b.message,
          {
            nodes: c,
            originalError: b
          }
        )
      );
    }
  }
  function f(u, c, m, p) {
    var b;
    const T = Object.keys(p);
    if (T.length !== 1) {
      u.reportError(
        new t.GraphQLError(
          `OneOf Input Object "${m.name}" must specify exactly one key.`,
          {
            nodes: [c]
          }
        )
      );
      return;
    }
    const h = (b = p[T[0]]) === null || b === void 0 ? void 0 : b.value;
    (!h || h.kind === r.Kind.NULL) && u.reportError(
      new t.GraphQLError(
        `Field "${m.name}.${T[0]}" must be non-null.`,
        {
          nodes: [c]
        }
      )
    );
  }
  return rr;
}
var ir = {}, rs;
function wo() {
  if (rs) return ir;
  rs = 1, Object.defineProperty(ir, "__esModule", {
    value: !0
  }), ir.VariablesAreInputTypesRule = t;
  var e = /* @__PURE__ */ ne(), n = /* @__PURE__ */ Fe(), a = /* @__PURE__ */ oe(), i = /* @__PURE__ */ He();
  function t(r) {
    return {
      VariableDefinition(o) {
        const s = (0, i.typeFromAST)(
          r.getSchema(),
          o.type
        );
        if (s !== void 0 && !(0, a.isInputType)(s)) {
          const l = o.variable.name.value, d = (0, n.print)(o.type);
          r.reportError(
            new e.GraphQLError(
              `Variable "$${l}" cannot be non-input type "${d}".`,
              {
                nodes: o.type
              }
            )
          );
        }
      }
    };
  }
  return ir;
}
var ar = {}, is;
function Vo() {
  if (is) return ar;
  is = 1, Object.defineProperty(ar, "__esModule", {
    value: !0
  }), ar.VariablesInAllowedPositionRule = o;
  var e = /* @__PURE__ */ de(), n = /* @__PURE__ */ ne(), a = /* @__PURE__ */ se(), i = /* @__PURE__ */ oe(), t = /* @__PURE__ */ Fr(), r = /* @__PURE__ */ He();
  function o(l) {
    let d = /* @__PURE__ */ Object.create(null);
    return {
      OperationDefinition: {
        enter() {
          d = /* @__PURE__ */ Object.create(null);
        },
        leave(f) {
          const u = l.getRecursiveVariableUsages(f);
          for (const { node: c, type: m, defaultValue: p, parentType: b } of u) {
            const T = c.name.value, y = d[T];
            if (y && m) {
              const h = l.getSchema(), I = (0, r.typeFromAST)(h, y.type);
              if (I && !s(
                h,
                I,
                y.defaultValue,
                m,
                p
              )) {
                const S = (0, e.inspect)(I), E = (0, e.inspect)(m);
                l.reportError(
                  new n.GraphQLError(
                    `Variable "$${T}" of type "${S}" used in position expecting type "${E}".`,
                    {
                      nodes: [y, c]
                    }
                  )
                );
              }
              (0, i.isInputObjectType)(b) && b.isOneOf && (0, i.isNullableType)(I) && l.reportError(
                new n.GraphQLError(
                  `Variable "$${T}" is of type "${I}" but must be non-nullable to be used for OneOf Input Object "${b}".`,
                  {
                    nodes: [y, c]
                  }
                )
              );
            }
          }
        }
      },
      VariableDefinition(f) {
        d[f.variable.name.value] = f;
      }
    };
  }
  function s(l, d, f, u, c) {
    if ((0, i.isNonNullType)(u) && !(0, i.isNonNullType)(d)) {
      if (!(f != null && f.kind !== a.Kind.NULL) && !(c !== void 0))
        return !1;
      const b = u.ofType;
      return (0, t.isTypeSubTypeOf)(
        l,
        d,
        b
      );
    }
    return (0, t.isTypeSubTypeOf)(l, d, u);
  }
  return ar;
}
var as;
function Co() {
  if (as) return xe;
  as = 1, Object.defineProperty(xe, "__esModule", {
    value: !0
  }), xe.specifiedSDLRules = xe.specifiedRules = xe.recommendedRules = void 0;
  var e = /* @__PURE__ */ Ws(), n = /* @__PURE__ */ Zs(), a = /* @__PURE__ */ eo(), i = /* @__PURE__ */ no(), t = /* @__PURE__ */ to(), r = /* @__PURE__ */ ro(), o = /* @__PURE__ */ io(), s = /* @__PURE__ */ ao(), l = /* @__PURE__ */ so(), d = /* @__PURE__ */ oo(), f = /* @__PURE__ */ uo(), u = /* @__PURE__ */ co(), c = /* @__PURE__ */ lo(), m = /* @__PURE__ */ po(), p = /* @__PURE__ */ mo(), b = /* @__PURE__ */ yo(), T = /* @__PURE__ */ ho(), y = /* @__PURE__ */ vo(), h = /* @__PURE__ */ To(), I = /* @__PURE__ */ go(), S = /* @__PURE__ */ No(), E = /* @__PURE__ */ Oo(), k = /* @__PURE__ */ _o(), M = /* @__PURE__ */ Io(), C = /* @__PURE__ */ So(), _ = /* @__PURE__ */ Lo(), N = /* @__PURE__ */ Ro(), D = /* @__PURE__ */ Do(), O = /* @__PURE__ */ Ao(), v = /* @__PURE__ */ jo(), g = /* @__PURE__ */ Po(), L = /* @__PURE__ */ ko(), R = /* @__PURE__ */ Fo(), j = /* @__PURE__ */ wo(), V = /* @__PURE__ */ Vo();
  const U = Object.freeze([
    d.MaxIntrospectionDepthRule
  ]);
  xe.recommendedRules = U;
  const W = Object.freeze([
    e.ExecutableDefinitionsRule,
    O.UniqueOperationNamesRule,
    s.LoneAnonymousOperationRule,
    I.SingleFieldSubscriptionsRule,
    o.KnownTypeNamesRule,
    a.FragmentsOnCompositeTypesRule,
    j.VariablesAreInputTypesRule,
    h.ScalarLeafsRule,
    n.FieldsOnCorrectTypeRule,
    N.UniqueFragmentNamesRule,
    r.KnownFragmentNamesRule,
    c.NoUnusedFragmentsRule,
    b.PossibleFragmentSpreadsRule,
    f.NoFragmentCyclesRule,
    L.UniqueVariableNamesRule,
    u.NoUndefinedVariablesRule,
    m.NoUnusedVariablesRule,
    t.KnownDirectivesRule,
    M.UniqueDirectivesPerLocationRule,
    i.KnownArgumentNamesRule,
    E.UniqueArgumentNamesRule,
    R.ValuesOfCorrectTypeRule,
    y.ProvidedRequiredArgumentsRule,
    V.VariablesInAllowedPositionRule,
    p.OverlappingFieldsCanBeMergedRule,
    D.UniqueInputFieldNamesRule,
    ...U
  ]);
  xe.specifiedRules = W;
  const P = Object.freeze([
    l.LoneSchemaDefinitionRule,
    v.UniqueOperationTypesRule,
    g.UniqueTypeNamesRule,
    C.UniqueEnumValueNamesRule,
    _.UniqueFieldDefinitionNamesRule,
    S.UniqueArgumentDefinitionNamesRule,
    k.UniqueDirectiveNamesRule,
    o.KnownTypeNamesRule,
    t.KnownDirectivesRule,
    M.UniqueDirectivesPerLocationRule,
    T.PossibleTypeExtensionsRule,
    i.KnownArgumentNamesOnDirectivesRule,
    E.UniqueArgumentNamesRule,
    D.UniqueInputFieldNamesRule,
    y.ProvidedRequiredArgumentsOnDirectivesRule
  ]);
  return xe.specifiedSDLRules = P, xe;
}
var Ye = {}, ss;
function Go() {
  if (ss) return Ye;
  ss = 1, Object.defineProperty(Ye, "__esModule", {
    value: !0
  }), Ye.ValidationContext = Ye.SDLValidationContext = Ye.ASTValidationContext = void 0;
  var e = /* @__PURE__ */ se(), n = /* @__PURE__ */ _n(), a = /* @__PURE__ */ ui();
  class i {
    constructor(s, l) {
      this._ast = s, this._fragments = void 0, this._fragmentSpreads = /* @__PURE__ */ new Map(), this._recursivelyReferencedFragments = /* @__PURE__ */ new Map(), this._onError = l;
    }
    get [Symbol.toStringTag]() {
      return "ASTValidationContext";
    }
    reportError(s) {
      this._onError(s);
    }
    getDocument() {
      return this._ast;
    }
    getFragment(s) {
      let l;
      if (this._fragments)
        l = this._fragments;
      else {
        l = /* @__PURE__ */ Object.create(null);
        for (const d of this.getDocument().definitions)
          d.kind === e.Kind.FRAGMENT_DEFINITION && (l[d.name.value] = d);
        this._fragments = l;
      }
      return l[s];
    }
    getFragmentSpreads(s) {
      let l = this._fragmentSpreads.get(s);
      if (!l) {
        l = [];
        const d = [s];
        let f;
        for (; f = d.pop(); )
          for (const u of f.selections)
            u.kind === e.Kind.FRAGMENT_SPREAD ? l.push(u) : u.selectionSet && d.push(u.selectionSet);
        this._fragmentSpreads.set(s, l);
      }
      return l;
    }
    getRecursivelyReferencedFragments(s) {
      let l = this._recursivelyReferencedFragments.get(s);
      if (!l) {
        l = [];
        const d = /* @__PURE__ */ Object.create(null), f = [s.selectionSet];
        let u;
        for (; u = f.pop(); )
          for (const c of this.getFragmentSpreads(u)) {
            const m = c.name.value;
            if (d[m] !== !0) {
              d[m] = !0;
              const p = this.getFragment(m);
              p && (l.push(p), f.push(p.selectionSet));
            }
          }
        this._recursivelyReferencedFragments.set(s, l);
      }
      return l;
    }
  }
  Ye.ASTValidationContext = i;
  class t extends i {
    constructor(s, l, d) {
      super(s, d), this._schema = l;
    }
    get [Symbol.toStringTag]() {
      return "SDLValidationContext";
    }
    getSchema() {
      return this._schema;
    }
  }
  Ye.SDLValidationContext = t;
  let r = class extends i {
    constructor(s, l, d, f) {
      super(l, f), this._schema = s, this._typeInfo = d, this._variableUsages = /* @__PURE__ */ new Map(), this._recursiveVariableUsages = /* @__PURE__ */ new Map();
    }
    get [Symbol.toStringTag]() {
      return "ValidationContext";
    }
    getSchema() {
      return this._schema;
    }
    getVariableUsages(s) {
      let l = this._variableUsages.get(s);
      if (!l) {
        const d = [], f = new a.TypeInfo(this._schema);
        (0, n.visit)(
          s,
          (0, a.visitWithTypeInfo)(f, {
            VariableDefinition: () => !1,
            Variable(u) {
              d.push({
                node: u,
                type: f.getInputType(),
                defaultValue: f.getDefaultValue(),
                parentType: f.getParentInputType()
              });
            }
          })
        ), l = d, this._variableUsages.set(s, l);
      }
      return l;
    }
    getRecursiveVariableUsages(s) {
      let l = this._recursiveVariableUsages.get(s);
      if (!l) {
        l = this.getVariableUsages(s);
        for (const d of this.getRecursivelyReferencedFragments(s))
          l = l.concat(this.getVariableUsages(d));
        this._recursiveVariableUsages.set(s, l);
      }
      return l;
    }
    getType() {
      return this._typeInfo.getType();
    }
    getParentType() {
      return this._typeInfo.getParentType();
    }
    getInputType() {
      return this._typeInfo.getInputType();
    }
    getParentInputType() {
      return this._typeInfo.getParentInputType();
    }
    getFieldDef() {
      return this._typeInfo.getFieldDef();
    }
    getDirective() {
      return this._typeInfo.getDirective();
    }
    getArgument() {
      return this._typeInfo.getArgument();
    }
    getEnumValue() {
      return this._typeInfo.getEnumValue();
    }
  };
  return Ye.ValidationContext = r, Ye;
}
var os;
function Mr() {
  if (os) return sn;
  os = 1, Object.defineProperty(sn, "__esModule", {
    value: !0
  }), sn.assertValidSDL = d, sn.assertValidSDLExtension = f, sn.validate = s, sn.validateSDL = l;
  var e = /* @__PURE__ */ De(), n = /* @__PURE__ */ ne(), a = /* @__PURE__ */ _n(), i = /* @__PURE__ */ Vr(), t = /* @__PURE__ */ ui(), r = /* @__PURE__ */ Co(), o = /* @__PURE__ */ Go();
  function s(u, c, m = r.specifiedRules, p, b = new t.TypeInfo(u)) {
    var T;
    const y = (T = p?.maxErrors) !== null && T !== void 0 ? T : 100;
    c || (0, e.devAssert)(!1, "Must provide document."), (0, i.assertValidSchema)(u);
    const h = Object.freeze({}), I = [], S = new o.ValidationContext(
      u,
      c,
      b,
      (k) => {
        if (I.length >= y)
          throw I.push(
            new n.GraphQLError(
              "Too many validation errors, error limit reached. Validation aborted."
            )
          ), h;
        I.push(k);
      }
    ), E = (0, a.visitInParallel)(
      m.map((k) => k(S))
    );
    try {
      (0, a.visit)(
        c,
        (0, t.visitWithTypeInfo)(b, E)
      );
    } catch (k) {
      if (k !== h)
        throw k;
    }
    return I;
  }
  function l(u, c, m = r.specifiedSDLRules) {
    const p = [], b = new o.SDLValidationContext(
      u,
      c,
      (y) => {
        p.push(y);
      }
    ), T = m.map((y) => y(b));
    return (0, a.visit)(u, (0, a.visitInParallel)(T)), p;
  }
  function d(u) {
    const c = l(u);
    if (c.length !== 0)
      throw new Error(c.map((m) => m.message).join(`

`));
  }
  function f(u, c) {
    const m = l(u, c);
    if (m.length !== 0)
      throw new Error(m.map((p) => p.message).join(`

`));
  }
  return sn;
}
var je = {}, sr = {}, us;
function Pu() {
  if (us) return sr;
  us = 1, Object.defineProperty(sr, "__esModule", {
    value: !0
  }), sr.memoize3 = e;
  function e(n) {
    let a;
    return function(t, r, o) {
      a === void 0 && (a = /* @__PURE__ */ new WeakMap());
      let s = a.get(t);
      s === void 0 && (s = /* @__PURE__ */ new WeakMap(), a.set(t, s));
      let l = s.get(r);
      l === void 0 && (l = /* @__PURE__ */ new WeakMap(), s.set(r, l));
      let d = l.get(o);
      return d === void 0 && (d = n(t, r, o), l.set(o, d)), d;
    };
  }
  return sr;
}
var or = {}, cs;
function ku() {
  if (cs) return or;
  cs = 1, Object.defineProperty(or, "__esModule", {
    value: !0
  }), or.promiseForObject = e;
  function e(n) {
    return Promise.all(Object.values(n)).then((a) => {
      const i = /* @__PURE__ */ Object.create(null);
      for (const [t, r] of Object.keys(n).entries())
        i[r] = a[t];
      return i;
    });
  }
  return or;
}
var ur = {}, ls;
function Fu() {
  if (ls) return ur;
  ls = 1, Object.defineProperty(ur, "__esModule", {
    value: !0
  }), ur.promiseReduce = n;
  var e = /* @__PURE__ */ ii();
  function n(a, i, t) {
    let r = t;
    for (const o of a)
      r = (0, e.isPromise)(r) ? r.then((s) => i(s, o)) : i(r, o);
    return r;
  }
  return ur;
}
var ps;
function $r() {
  if (ps) return je;
  ps = 1, Object.defineProperty(je, "__esModule", {
    value: !0
  }), je.assertValidExecutionArguments = M, je.buildExecutionContext = C, je.buildResolveInfo = v, je.defaultTypeResolver = je.defaultFieldResolver = void 0, je.execute = S, je.executeSync = E, je.getFieldDef = pe;
  var e = /* @__PURE__ */ De(), n = /* @__PURE__ */ de(), a = /* @__PURE__ */ Le(), i = /* @__PURE__ */ oi(), t = /* @__PURE__ */ ze(), r = /* @__PURE__ */ ii(), o = /* @__PURE__ */ Pu(), s = /* @__PURE__ */ Cr(), l = /* @__PURE__ */ ku(), d = /* @__PURE__ */ Fu(), f = /* @__PURE__ */ ne(), u = /* @__PURE__ */ ri(), c = /* @__PURE__ */ Qe(), m = /* @__PURE__ */ se(), p = /* @__PURE__ */ oe(), b = /* @__PURE__ */ Ge(), T = /* @__PURE__ */ Vr(), y = /* @__PURE__ */ ci(), h = /* @__PURE__ */ Xn();
  const I = (0, o.memoize3)(
    (G, $, x) => (0, y.collectSubfields)(
      G.schema,
      G.fragments,
      G.variableValues,
      $,
      x
    )
  );
  function S(G) {
    arguments.length < 2 || (0, e.devAssert)(
      !1,
      "graphql@16 dropped long-deprecated support for positional arguments, please pass an object instead."
    );
    const { schema: $, document: x, variableValues: Y, rootValue: Z } = G;
    M($, x, Y);
    const B = C(G);
    if (!("schema" in B))
      return {
        errors: B
      };
    try {
      const { operation: ee } = B, ie = _(B, ee, Z);
      return (0, r.isPromise)(ie) ? ie.then(
        (ue) => k(ue, B.errors),
        (ue) => (B.errors.push(ue), k(null, B.errors))
      ) : k(ie, B.errors);
    } catch (ee) {
      return B.errors.push(ee), k(null, B.errors);
    }
  }
  function E(G) {
    const $ = S(G);
    if ((0, r.isPromise)($))
      throw new Error("GraphQL execution failed to complete synchronously.");
    return $;
  }
  function k(G, $) {
    return $.length === 0 ? {
      data: G
    } : {
      errors: $,
      data: G
    };
  }
  function M(G, $, x) {
    $ || (0, e.devAssert)(!1, "Must provide document."), (0, T.assertValidSchema)(G), x == null || (0, t.isObjectLike)(x) || (0, e.devAssert)(
      !1,
      "Variables must be provided as an Object where each property is a variable value. Perhaps look to see if an unparsed JSON string was provided."
    );
  }
  function C(G) {
    var $, x, Y;
    const {
      schema: Z,
      document: B,
      rootValue: ee,
      contextValue: ie,
      variableValues: ue,
      operationName: ce,
      fieldResolver: he,
      typeResolver: Oe,
      subscribeFieldResolver: ge,
      options: ve
    } = G;
    let _e;
    const ke = /* @__PURE__ */ Object.create(null);
    for (const w of B.definitions)
      switch (w.kind) {
        case m.Kind.OPERATION_DEFINITION:
          if (ce == null) {
            if (_e !== void 0)
              return [
                new f.GraphQLError(
                  "Must provide operation name if query contains multiple operations."
                )
              ];
            _e = w;
          } else (($ = w.name) === null || $ === void 0 ? void 0 : $.value) === ce && (_e = w);
          break;
        case m.Kind.FRAGMENT_DEFINITION:
          ke[w.name.value] = w;
          break;
      }
    if (!_e)
      return ce != null ? [
        new f.GraphQLError(
          `Unknown operation named "${ce}".`
        )
      ] : [new f.GraphQLError("Must provide an operation.")];
    const nn = (x = _e.variableDefinitions) !== null && x !== void 0 ? x : [], We = (0, h.getVariableValues)(
      Z,
      nn,
      ue ?? {},
      {
        maxErrors: (Y = ve?.maxCoercionErrors) !== null && Y !== void 0 ? Y : 50
      }
    );
    return We.errors ? We.errors : {
      schema: Z,
      fragments: ke,
      rootValue: ee,
      contextValue: ie,
      operation: _e,
      variableValues: We.coerced,
      fieldResolver: he ?? te,
      typeResolver: Oe ?? K,
      subscribeFieldResolver: ge ?? te,
      errors: []
    };
  }
  function _(G, $, x) {
    const Y = G.schema.getRootType($.operation);
    if (Y == null)
      throw new f.GraphQLError(
        `Schema is not configured to execute ${$.operation} operation.`,
        {
          nodes: $
        }
      );
    const Z = (0, y.collectFields)(
      G.schema,
      G.fragments,
      G.variableValues,
      Y,
      $.selectionSet
    ), B = void 0;
    switch ($.operation) {
      case c.OperationTypeNode.QUERY:
        return D(G, Y, x, B, Z);
      case c.OperationTypeNode.MUTATION:
        return N(
          G,
          Y,
          x,
          B,
          Z
        );
      case c.OperationTypeNode.SUBSCRIPTION:
        return D(G, Y, x, B, Z);
    }
  }
  function N(G, $, x, Y, Z) {
    return (0, d.promiseReduce)(
      Z.entries(),
      (B, [ee, ie]) => {
        const ue = (0, s.addPath)(Y, ee, $.name), ce = O(
          G,
          $,
          x,
          ie,
          ue
        );
        return ce === void 0 ? B : (0, r.isPromise)(ce) ? ce.then((he) => (B[ee] = he, B)) : (B[ee] = ce, B);
      },
      /* @__PURE__ */ Object.create(null)
    );
  }
  function D(G, $, x, Y, Z) {
    const B = /* @__PURE__ */ Object.create(null);
    let ee = !1;
    try {
      for (const [ie, ue] of Z.entries()) {
        const ce = (0, s.addPath)(Y, ie, $.name), he = O(
          G,
          $,
          x,
          ue,
          ce
        );
        he !== void 0 && (B[ie] = he, (0, r.isPromise)(he) && (ee = !0));
      }
    } catch (ie) {
      if (ee)
        return (0, l.promiseForObject)(B).finally(() => {
          throw ie;
        });
      throw ie;
    }
    return ee ? (0, l.promiseForObject)(B) : B;
  }
  function O(G, $, x, Y, Z) {
    var B;
    const ee = pe(G.schema, $, Y[0]);
    if (!ee)
      return;
    const ie = ee.type, ue = (B = ee.resolve) !== null && B !== void 0 ? B : G.fieldResolver, ce = v(
      G,
      ee,
      Y,
      $,
      Z
    );
    try {
      const he = (0, h.getArgumentValues)(
        ee,
        Y[0],
        G.variableValues
      ), Oe = G.contextValue, ge = ue(x, he, Oe, ce);
      let ve;
      return (0, r.isPromise)(ge) ? ve = ge.then(
        (_e) => L(G, ie, Y, ce, Z, _e)
      ) : ve = L(
        G,
        ie,
        Y,
        ce,
        Z,
        ge
      ), (0, r.isPromise)(ve) ? ve.then(void 0, (_e) => {
        const ke = (0, u.locatedError)(
          _e,
          Y,
          (0, s.pathToArray)(Z)
        );
        return g(ke, ie, G);
      }) : ve;
    } catch (he) {
      const Oe = (0, u.locatedError)(
        he,
        Y,
        (0, s.pathToArray)(Z)
      );
      return g(Oe, ie, G);
    }
  }
  function v(G, $, x, Y, Z) {
    return {
      fieldName: $.name,
      fieldNodes: x,
      returnType: $.type,
      parentType: Y,
      path: Z,
      schema: G.schema,
      fragments: G.fragments,
      rootValue: G.rootValue,
      operation: G.operation,
      variableValues: G.variableValues
    };
  }
  function g(G, $, x) {
    if ((0, p.isNonNullType)($))
      throw G;
    return x.errors.push(G), null;
  }
  function L(G, $, x, Y, Z, B) {
    if (B instanceof Error)
      throw B;
    if ((0, p.isNonNullType)($)) {
      const ee = L(
        G,
        $.ofType,
        x,
        Y,
        Z,
        B
      );
      if (ee === null)
        throw new Error(
          `Cannot return null for non-nullable field ${Y.parentType.name}.${Y.fieldName}.`
        );
      return ee;
    }
    if (B == null)
      return null;
    if ((0, p.isListType)($))
      return R(
        G,
        $,
        x,
        Y,
        Z,
        B
      );
    if ((0, p.isLeafType)($))
      return j($, B);
    if ((0, p.isAbstractType)($))
      return V(
        G,
        $,
        x,
        Y,
        Z,
        B
      );
    if ((0, p.isObjectType)($))
      return W(
        G,
        $,
        x,
        Y,
        Z,
        B
      );
    (0, a.invariant)(
      !1,
      "Cannot complete value of unexpected output type: " + (0, n.inspect)($)
    );
  }
  function R(G, $, x, Y, Z, B) {
    if (!(0, i.isIterableObject)(B))
      throw new f.GraphQLError(
        `Expected Iterable, but did not find one for field "${Y.parentType.name}.${Y.fieldName}".`
      );
    const ee = $.ofType;
    let ie = !1;
    const ue = Array.from(B, (ce, he) => {
      const Oe = (0, s.addPath)(Z, he, void 0);
      try {
        let ge;
        return (0, r.isPromise)(ce) ? ge = ce.then(
          (ve) => L(
            G,
            ee,
            x,
            Y,
            Oe,
            ve
          )
        ) : ge = L(
          G,
          ee,
          x,
          Y,
          Oe,
          ce
        ), (0, r.isPromise)(ge) ? (ie = !0, ge.then(void 0, (ve) => {
          const _e = (0, u.locatedError)(
            ve,
            x,
            (0, s.pathToArray)(Oe)
          );
          return g(_e, ee, G);
        })) : ge;
      } catch (ge) {
        const ve = (0, u.locatedError)(
          ge,
          x,
          (0, s.pathToArray)(Oe)
        );
        return g(ve, ee, G);
      }
    });
    return ie ? Promise.all(ue) : ue;
  }
  function j(G, $) {
    const x = G.serialize($);
    if (x == null)
      throw new Error(
        `Expected \`${(0, n.inspect)(G)}.serialize(${(0, n.inspect)($)})\` to return non-nullable value, returned: ${(0, n.inspect)(
          x
        )}`
      );
    return x;
  }
  function V(G, $, x, Y, Z, B) {
    var ee;
    const ie = (ee = $.resolveType) !== null && ee !== void 0 ? ee : G.typeResolver, ue = G.contextValue, ce = ie(B, ue, Y, $);
    return (0, r.isPromise)(ce) ? ce.then(
      (he) => W(
        G,
        U(
          he,
          G,
          $,
          x,
          Y,
          B
        ),
        x,
        Y,
        Z,
        B
      )
    ) : W(
      G,
      U(
        ce,
        G,
        $,
        x,
        Y,
        B
      ),
      x,
      Y,
      Z,
      B
    );
  }
  function U(G, $, x, Y, Z, B) {
    if (G == null)
      throw new f.GraphQLError(
        `Abstract type "${x.name}" must resolve to an Object type at runtime for field "${Z.parentType.name}.${Z.fieldName}". Either the "${x.name}" type should provide a "resolveType" function or each possible type should provide an "isTypeOf" function.`,
        Y
      );
    if ((0, p.isObjectType)(G))
      throw new f.GraphQLError(
        "Support for returning GraphQLObjectType from resolveType was removed in graphql-js@16.0.0 please return type name instead."
      );
    if (typeof G != "string")
      throw new f.GraphQLError(
        `Abstract type "${x.name}" must resolve to an Object type at runtime for field "${Z.parentType.name}.${Z.fieldName}" with value ${(0, n.inspect)(B)}, received "${(0, n.inspect)(G)}".`
      );
    const ee = $.schema.getType(G);
    if (ee == null)
      throw new f.GraphQLError(
        `Abstract type "${x.name}" was resolved to a type "${G}" that does not exist inside the schema.`,
        {
          nodes: Y
        }
      );
    if (!(0, p.isObjectType)(ee))
      throw new f.GraphQLError(
        `Abstract type "${x.name}" was resolved to a non-object type "${G}".`,
        {
          nodes: Y
        }
      );
    if (!$.schema.isSubType(x, ee))
      throw new f.GraphQLError(
        `Runtime Object type "${ee.name}" is not a possible type for "${x.name}".`,
        {
          nodes: Y
        }
      );
    return ee;
  }
  function W(G, $, x, Y, Z, B) {
    const ee = I(G, $, x);
    if ($.isTypeOf) {
      const ie = $.isTypeOf(B, G.contextValue, Y);
      if ((0, r.isPromise)(ie))
        return ie.then((ue) => {
          if (!ue)
            throw P($, B, x);
          return D(
            G,
            $,
            B,
            Z,
            ee
          );
        });
      if (!ie)
        throw P($, B, x);
    }
    return D(G, $, B, Z, ee);
  }
  function P(G, $, x) {
    return new f.GraphQLError(
      `Expected value of type "${G.name}" but got: ${(0, n.inspect)($)}.`,
      {
        nodes: x
      }
    );
  }
  const K = function(G, $, x, Y) {
    if ((0, t.isObjectLike)(G) && typeof G.__typename == "string")
      return G.__typename;
    const Z = x.schema.getPossibleTypes(Y), B = [];
    for (let ee = 0; ee < Z.length; ee++) {
      const ie = Z[ee];
      if (ie.isTypeOf) {
        const ue = ie.isTypeOf(G, $, x);
        if ((0, r.isPromise)(ue))
          B[ee] = ue;
        else if (ue)
          return B.length && Promise.allSettled(B).catch(() => {
          }), ie.name;
      }
    }
    if (B.length)
      return Promise.all(B).then((ee) => {
        for (let ie = 0; ie < ee.length; ie++)
          if (ee[ie])
            return Z[ie].name;
      });
  };
  je.defaultTypeResolver = K;
  const te = function(G, $, x, Y) {
    if ((0, t.isObjectLike)(G) || typeof G == "function") {
      const Z = G[Y.fieldName];
      return typeof Z == "function" ? G[Y.fieldName]($, x, Y) : Z;
    }
  };
  je.defaultFieldResolver = te;
  function pe(G, $, x) {
    const Y = x.name.value;
    return Y === b.SchemaMetaFieldDef.name && G.getQueryType() === $ ? b.SchemaMetaFieldDef : Y === b.TypeMetaFieldDef.name && G.getQueryType() === $ ? b.TypeMetaFieldDef : Y === b.TypeNameMetaFieldDef.name ? b.TypeNameMetaFieldDef : $.getFields()[Y];
  }
  return je;
}
var ds;
function wu() {
  if (ds) return Dn;
  ds = 1, Object.defineProperty(Dn, "__esModule", {
    value: !0
  }), Dn.graphql = o, Dn.graphqlSync = s;
  var e = /* @__PURE__ */ De(), n = /* @__PURE__ */ ii(), a = /* @__PURE__ */ On(), i = /* @__PURE__ */ Vr(), t = /* @__PURE__ */ Mr(), r = /* @__PURE__ */ $r();
  function o(d) {
    return new Promise((f) => f(l(d)));
  }
  function s(d) {
    const f = l(d);
    if ((0, n.isPromise)(f))
      throw new Error("GraphQL execution failed to complete synchronously.");
    return f;
  }
  function l(d) {
    arguments.length < 2 || (0, e.devAssert)(
      !1,
      "graphql@16 dropped long-deprecated support for positional arguments, please pass an object instead."
    );
    const {
      schema: f,
      source: u,
      rootValue: c,
      contextValue: m,
      variableValues: p,
      operationName: b,
      fieldResolver: T,
      typeResolver: y
    } = d, h = (0, i.validateSchema)(f);
    if (h.length > 0)
      return {
        errors: h
      };
    let I;
    try {
      I = (0, a.parse)(u);
    } catch (E) {
      return {
        errors: [E]
      };
    }
    const S = (0, t.validate)(f, I);
    return S.length > 0 ? {
      errors: S
    } : (0, r.execute)({
      schema: f,
      document: I,
      rootValue: c,
      contextValue: m,
      variableValues: p,
      operationName: b,
      fieldResolver: T,
      typeResolver: y
    });
  }
  return Dn;
}
var Kr = {}, fs;
function Vu() {
  return fs || (fs = 1, (function(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), Object.defineProperty(e, "DEFAULT_DEPRECATION_REASON", {
      enumerable: !0,
      get: function() {
        return i.DEFAULT_DEPRECATION_REASON;
      }
    }), Object.defineProperty(e, "GRAPHQL_MAX_INT", {
      enumerable: !0,
      get: function() {
        return t.GRAPHQL_MAX_INT;
      }
    }), Object.defineProperty(e, "GRAPHQL_MIN_INT", {
      enumerable: !0,
      get: function() {
        return t.GRAPHQL_MIN_INT;
      }
    }), Object.defineProperty(e, "GraphQLBoolean", {
      enumerable: !0,
      get: function() {
        return t.GraphQLBoolean;
      }
    }), Object.defineProperty(e, "GraphQLDeprecatedDirective", {
      enumerable: !0,
      get: function() {
        return i.GraphQLDeprecatedDirective;
      }
    }), Object.defineProperty(e, "GraphQLDirective", {
      enumerable: !0,
      get: function() {
        return i.GraphQLDirective;
      }
    }), Object.defineProperty(e, "GraphQLEnumType", {
      enumerable: !0,
      get: function() {
        return a.GraphQLEnumType;
      }
    }), Object.defineProperty(e, "GraphQLFloat", {
      enumerable: !0,
      get: function() {
        return t.GraphQLFloat;
      }
    }), Object.defineProperty(e, "GraphQLID", {
      enumerable: !0,
      get: function() {
        return t.GraphQLID;
      }
    }), Object.defineProperty(e, "GraphQLIncludeDirective", {
      enumerable: !0,
      get: function() {
        return i.GraphQLIncludeDirective;
      }
    }), Object.defineProperty(e, "GraphQLInputObjectType", {
      enumerable: !0,
      get: function() {
        return a.GraphQLInputObjectType;
      }
    }), Object.defineProperty(e, "GraphQLInt", {
      enumerable: !0,
      get: function() {
        return t.GraphQLInt;
      }
    }), Object.defineProperty(e, "GraphQLInterfaceType", {
      enumerable: !0,
      get: function() {
        return a.GraphQLInterfaceType;
      }
    }), Object.defineProperty(e, "GraphQLList", {
      enumerable: !0,
      get: function() {
        return a.GraphQLList;
      }
    }), Object.defineProperty(e, "GraphQLNonNull", {
      enumerable: !0,
      get: function() {
        return a.GraphQLNonNull;
      }
    }), Object.defineProperty(e, "GraphQLObjectType", {
      enumerable: !0,
      get: function() {
        return a.GraphQLObjectType;
      }
    }), Object.defineProperty(e, "GraphQLOneOfDirective", {
      enumerable: !0,
      get: function() {
        return i.GraphQLOneOfDirective;
      }
    }), Object.defineProperty(e, "GraphQLScalarType", {
      enumerable: !0,
      get: function() {
        return a.GraphQLScalarType;
      }
    }), Object.defineProperty(e, "GraphQLSchema", {
      enumerable: !0,
      get: function() {
        return n.GraphQLSchema;
      }
    }), Object.defineProperty(e, "GraphQLSkipDirective", {
      enumerable: !0,
      get: function() {
        return i.GraphQLSkipDirective;
      }
    }), Object.defineProperty(e, "GraphQLSpecifiedByDirective", {
      enumerable: !0,
      get: function() {
        return i.GraphQLSpecifiedByDirective;
      }
    }), Object.defineProperty(e, "GraphQLString", {
      enumerable: !0,
      get: function() {
        return t.GraphQLString;
      }
    }), Object.defineProperty(e, "GraphQLUnionType", {
      enumerable: !0,
      get: function() {
        return a.GraphQLUnionType;
      }
    }), Object.defineProperty(e, "SchemaMetaFieldDef", {
      enumerable: !0,
      get: function() {
        return r.SchemaMetaFieldDef;
      }
    }), Object.defineProperty(e, "TypeKind", {
      enumerable: !0,
      get: function() {
        return r.TypeKind;
      }
    }), Object.defineProperty(e, "TypeMetaFieldDef", {
      enumerable: !0,
      get: function() {
        return r.TypeMetaFieldDef;
      }
    }), Object.defineProperty(e, "TypeNameMetaFieldDef", {
      enumerable: !0,
      get: function() {
        return r.TypeNameMetaFieldDef;
      }
    }), Object.defineProperty(e, "__Directive", {
      enumerable: !0,
      get: function() {
        return r.__Directive;
      }
    }), Object.defineProperty(e, "__DirectiveLocation", {
      enumerable: !0,
      get: function() {
        return r.__DirectiveLocation;
      }
    }), Object.defineProperty(e, "__EnumValue", {
      enumerable: !0,
      get: function() {
        return r.__EnumValue;
      }
    }), Object.defineProperty(e, "__Field", {
      enumerable: !0,
      get: function() {
        return r.__Field;
      }
    }), Object.defineProperty(e, "__InputValue", {
      enumerable: !0,
      get: function() {
        return r.__InputValue;
      }
    }), Object.defineProperty(e, "__Schema", {
      enumerable: !0,
      get: function() {
        return r.__Schema;
      }
    }), Object.defineProperty(e, "__Type", {
      enumerable: !0,
      get: function() {
        return r.__Type;
      }
    }), Object.defineProperty(e, "__TypeKind", {
      enumerable: !0,
      get: function() {
        return r.__TypeKind;
      }
    }), Object.defineProperty(e, "assertAbstractType", {
      enumerable: !0,
      get: function() {
        return a.assertAbstractType;
      }
    }), Object.defineProperty(e, "assertCompositeType", {
      enumerable: !0,
      get: function() {
        return a.assertCompositeType;
      }
    }), Object.defineProperty(e, "assertDirective", {
      enumerable: !0,
      get: function() {
        return i.assertDirective;
      }
    }), Object.defineProperty(e, "assertEnumType", {
      enumerable: !0,
      get: function() {
        return a.assertEnumType;
      }
    }), Object.defineProperty(e, "assertEnumValueName", {
      enumerable: !0,
      get: function() {
        return s.assertEnumValueName;
      }
    }), Object.defineProperty(e, "assertInputObjectType", {
      enumerable: !0,
      get: function() {
        return a.assertInputObjectType;
      }
    }), Object.defineProperty(e, "assertInputType", {
      enumerable: !0,
      get: function() {
        return a.assertInputType;
      }
    }), Object.defineProperty(e, "assertInterfaceType", {
      enumerable: !0,
      get: function() {
        return a.assertInterfaceType;
      }
    }), Object.defineProperty(e, "assertLeafType", {
      enumerable: !0,
      get: function() {
        return a.assertLeafType;
      }
    }), Object.defineProperty(e, "assertListType", {
      enumerable: !0,
      get: function() {
        return a.assertListType;
      }
    }), Object.defineProperty(e, "assertName", {
      enumerable: !0,
      get: function() {
        return s.assertName;
      }
    }), Object.defineProperty(e, "assertNamedType", {
      enumerable: !0,
      get: function() {
        return a.assertNamedType;
      }
    }), Object.defineProperty(e, "assertNonNullType", {
      enumerable: !0,
      get: function() {
        return a.assertNonNullType;
      }
    }), Object.defineProperty(e, "assertNullableType", {
      enumerable: !0,
      get: function() {
        return a.assertNullableType;
      }
    }), Object.defineProperty(e, "assertObjectType", {
      enumerable: !0,
      get: function() {
        return a.assertObjectType;
      }
    }), Object.defineProperty(e, "assertOutputType", {
      enumerable: !0,
      get: function() {
        return a.assertOutputType;
      }
    }), Object.defineProperty(e, "assertScalarType", {
      enumerable: !0,
      get: function() {
        return a.assertScalarType;
      }
    }), Object.defineProperty(e, "assertSchema", {
      enumerable: !0,
      get: function() {
        return n.assertSchema;
      }
    }), Object.defineProperty(e, "assertType", {
      enumerable: !0,
      get: function() {
        return a.assertType;
      }
    }), Object.defineProperty(e, "assertUnionType", {
      enumerable: !0,
      get: function() {
        return a.assertUnionType;
      }
    }), Object.defineProperty(e, "assertValidSchema", {
      enumerable: !0,
      get: function() {
        return o.assertValidSchema;
      }
    }), Object.defineProperty(e, "assertWrappingType", {
      enumerable: !0,
      get: function() {
        return a.assertWrappingType;
      }
    }), Object.defineProperty(e, "getNamedType", {
      enumerable: !0,
      get: function() {
        return a.getNamedType;
      }
    }), Object.defineProperty(e, "getNullableType", {
      enumerable: !0,
      get: function() {
        return a.getNullableType;
      }
    }), Object.defineProperty(e, "introspectionTypes", {
      enumerable: !0,
      get: function() {
        return r.introspectionTypes;
      }
    }), Object.defineProperty(e, "isAbstractType", {
      enumerable: !0,
      get: function() {
        return a.isAbstractType;
      }
    }), Object.defineProperty(e, "isCompositeType", {
      enumerable: !0,
      get: function() {
        return a.isCompositeType;
      }
    }), Object.defineProperty(e, "isDirective", {
      enumerable: !0,
      get: function() {
        return i.isDirective;
      }
    }), Object.defineProperty(e, "isEnumType", {
      enumerable: !0,
      get: function() {
        return a.isEnumType;
      }
    }), Object.defineProperty(e, "isInputObjectType", {
      enumerable: !0,
      get: function() {
        return a.isInputObjectType;
      }
    }), Object.defineProperty(e, "isInputType", {
      enumerable: !0,
      get: function() {
        return a.isInputType;
      }
    }), Object.defineProperty(e, "isInterfaceType", {
      enumerable: !0,
      get: function() {
        return a.isInterfaceType;
      }
    }), Object.defineProperty(e, "isIntrospectionType", {
      enumerable: !0,
      get: function() {
        return r.isIntrospectionType;
      }
    }), Object.defineProperty(e, "isLeafType", {
      enumerable: !0,
      get: function() {
        return a.isLeafType;
      }
    }), Object.defineProperty(e, "isListType", {
      enumerable: !0,
      get: function() {
        return a.isListType;
      }
    }), Object.defineProperty(e, "isNamedType", {
      enumerable: !0,
      get: function() {
        return a.isNamedType;
      }
    }), Object.defineProperty(e, "isNonNullType", {
      enumerable: !0,
      get: function() {
        return a.isNonNullType;
      }
    }), Object.defineProperty(e, "isNullableType", {
      enumerable: !0,
      get: function() {
        return a.isNullableType;
      }
    }), Object.defineProperty(e, "isObjectType", {
      enumerable: !0,
      get: function() {
        return a.isObjectType;
      }
    }), Object.defineProperty(e, "isOutputType", {
      enumerable: !0,
      get: function() {
        return a.isOutputType;
      }
    }), Object.defineProperty(e, "isRequiredArgument", {
      enumerable: !0,
      get: function() {
        return a.isRequiredArgument;
      }
    }), Object.defineProperty(e, "isRequiredInputField", {
      enumerable: !0,
      get: function() {
        return a.isRequiredInputField;
      }
    }), Object.defineProperty(e, "isScalarType", {
      enumerable: !0,
      get: function() {
        return a.isScalarType;
      }
    }), Object.defineProperty(e, "isSchema", {
      enumerable: !0,
      get: function() {
        return n.isSchema;
      }
    }), Object.defineProperty(e, "isSpecifiedDirective", {
      enumerable: !0,
      get: function() {
        return i.isSpecifiedDirective;
      }
    }), Object.defineProperty(e, "isSpecifiedScalarType", {
      enumerable: !0,
      get: function() {
        return t.isSpecifiedScalarType;
      }
    }), Object.defineProperty(e, "isType", {
      enumerable: !0,
      get: function() {
        return a.isType;
      }
    }), Object.defineProperty(e, "isUnionType", {
      enumerable: !0,
      get: function() {
        return a.isUnionType;
      }
    }), Object.defineProperty(e, "isWrappingType", {
      enumerable: !0,
      get: function() {
        return a.isWrappingType;
      }
    }), Object.defineProperty(e, "resolveObjMapThunk", {
      enumerable: !0,
      get: function() {
        return a.resolveObjMapThunk;
      }
    }), Object.defineProperty(e, "resolveReadonlyArrayThunk", {
      enumerable: !0,
      get: function() {
        return a.resolveReadonlyArrayThunk;
      }
    }), Object.defineProperty(e, "specifiedDirectives", {
      enumerable: !0,
      get: function() {
        return i.specifiedDirectives;
      }
    }), Object.defineProperty(e, "specifiedScalarTypes", {
      enumerable: !0,
      get: function() {
        return t.specifiedScalarTypes;
      }
    }), Object.defineProperty(e, "validateSchema", {
      enumerable: !0,
      get: function() {
        return o.validateSchema;
      }
    });
    var n = /* @__PURE__ */ In(), a = /* @__PURE__ */ oe(), i = /* @__PURE__ */ Pe(), t = /* @__PURE__ */ Xe(), r = /* @__PURE__ */ Ge(), o = /* @__PURE__ */ Vr(), s = /* @__PURE__ */ kr();
  })(Kr)), Kr;
}
var Br = {}, ms;
function Cu() {
  return ms || (ms = 1, (function(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), Object.defineProperty(e, "BREAK", {
      enumerable: !0,
      get: function() {
        return d.BREAK;
      }
    }), Object.defineProperty(e, "DirectiveLocation", {
      enumerable: !0,
      get: function() {
        return c.DirectiveLocation;
      }
    }), Object.defineProperty(e, "Kind", {
      enumerable: !0,
      get: function() {
        return t.Kind;
      }
    }), Object.defineProperty(e, "Lexer", {
      enumerable: !0,
      get: function() {
        return o.Lexer;
      }
    }), Object.defineProperty(e, "Location", {
      enumerable: !0,
      get: function() {
        return f.Location;
      }
    }), Object.defineProperty(e, "OperationTypeNode", {
      enumerable: !0,
      get: function() {
        return f.OperationTypeNode;
      }
    }), Object.defineProperty(e, "Source", {
      enumerable: !0,
      get: function() {
        return n.Source;
      }
    }), Object.defineProperty(e, "Token", {
      enumerable: !0,
      get: function() {
        return f.Token;
      }
    }), Object.defineProperty(e, "TokenKind", {
      enumerable: !0,
      get: function() {
        return r.TokenKind;
      }
    }), Object.defineProperty(e, "getEnterLeaveForKind", {
      enumerable: !0,
      get: function() {
        return d.getEnterLeaveForKind;
      }
    }), Object.defineProperty(e, "getLocation", {
      enumerable: !0,
      get: function() {
        return a.getLocation;
      }
    }), Object.defineProperty(e, "getVisitFn", {
      enumerable: !0,
      get: function() {
        return d.getVisitFn;
      }
    }), Object.defineProperty(e, "isConstValueNode", {
      enumerable: !0,
      get: function() {
        return u.isConstValueNode;
      }
    }), Object.defineProperty(e, "isDefinitionNode", {
      enumerable: !0,
      get: function() {
        return u.isDefinitionNode;
      }
    }), Object.defineProperty(e, "isExecutableDefinitionNode", {
      enumerable: !0,
      get: function() {
        return u.isExecutableDefinitionNode;
      }
    }), Object.defineProperty(e, "isSchemaCoordinateNode", {
      enumerable: !0,
      get: function() {
        return u.isSchemaCoordinateNode;
      }
    }), Object.defineProperty(e, "isSelectionNode", {
      enumerable: !0,
      get: function() {
        return u.isSelectionNode;
      }
    }), Object.defineProperty(e, "isTypeDefinitionNode", {
      enumerable: !0,
      get: function() {
        return u.isTypeDefinitionNode;
      }
    }), Object.defineProperty(e, "isTypeExtensionNode", {
      enumerable: !0,
      get: function() {
        return u.isTypeExtensionNode;
      }
    }), Object.defineProperty(e, "isTypeNode", {
      enumerable: !0,
      get: function() {
        return u.isTypeNode;
      }
    }), Object.defineProperty(e, "isTypeSystemDefinitionNode", {
      enumerable: !0,
      get: function() {
        return u.isTypeSystemDefinitionNode;
      }
    }), Object.defineProperty(e, "isTypeSystemExtensionNode", {
      enumerable: !0,
      get: function() {
        return u.isTypeSystemExtensionNode;
      }
    }), Object.defineProperty(e, "isValueNode", {
      enumerable: !0,
      get: function() {
        return u.isValueNode;
      }
    }), Object.defineProperty(e, "parse", {
      enumerable: !0,
      get: function() {
        return s.parse;
      }
    }), Object.defineProperty(e, "parseConstValue", {
      enumerable: !0,
      get: function() {
        return s.parseConstValue;
      }
    }), Object.defineProperty(e, "parseSchemaCoordinate", {
      enumerable: !0,
      get: function() {
        return s.parseSchemaCoordinate;
      }
    }), Object.defineProperty(e, "parseType", {
      enumerable: !0,
      get: function() {
        return s.parseType;
      }
    }), Object.defineProperty(e, "parseValue", {
      enumerable: !0,
      get: function() {
        return s.parseValue;
      }
    }), Object.defineProperty(e, "print", {
      enumerable: !0,
      get: function() {
        return l.print;
      }
    }), Object.defineProperty(e, "printLocation", {
      enumerable: !0,
      get: function() {
        return i.printLocation;
      }
    }), Object.defineProperty(e, "printSourceLocation", {
      enumerable: !0,
      get: function() {
        return i.printSourceLocation;
      }
    }), Object.defineProperty(e, "visit", {
      enumerable: !0,
      get: function() {
        return d.visit;
      }
    }), Object.defineProperty(e, "visitInParallel", {
      enumerable: !0,
      get: function() {
        return d.visitInParallel;
      }
    });
    var n = /* @__PURE__ */ ai(), a = /* @__PURE__ */ ti(), i = /* @__PURE__ */ Js(), t = /* @__PURE__ */ se(), r = /* @__PURE__ */ zn(), o = /* @__PURE__ */ Dr(), s = /* @__PURE__ */ On(), l = /* @__PURE__ */ Fe(), d = /* @__PURE__ */ _n(), f = /* @__PURE__ */ Qe(), u = /* @__PURE__ */ Sn(), c = /* @__PURE__ */ Jn();
  })(Br)), Br;
}
var xr = {}, Gn = {}, cr = {}, ys;
function Gu() {
  if (ys) return cr;
  ys = 1, Object.defineProperty(cr, "__esModule", {
    value: !0
  }), cr.isAsyncIterable = e;
  function e(n) {
    return typeof n?.[Symbol.asyncIterator] == "function";
  }
  return cr;
}
var lr = {}, hs;
function Mu() {
  if (hs) return lr;
  hs = 1, Object.defineProperty(lr, "__esModule", {
    value: !0
  }), lr.mapAsyncIterator = e;
  function e(n, a) {
    const i = n[Symbol.asyncIterator]();
    async function t(r) {
      if (r.done)
        return r;
      try {
        return {
          value: await a(r.value),
          done: !1
        };
      } catch (o) {
        if (typeof i.return == "function")
          try {
            await i.return();
          } catch {
          }
        throw o;
      }
    }
    return {
      async next() {
        return t(await i.next());
      },
      async return() {
        return typeof i.return == "function" ? t(await i.return()) : {
          value: void 0,
          done: !0
        };
      },
      async throw(r) {
        if (typeof i.throw == "function")
          return t(await i.throw(r));
        throw r;
      },
      [Symbol.asyncIterator]() {
        return this;
      }
    };
  }
  return lr;
}
var vs;
function $u() {
  if (vs) return Gn;
  vs = 1, Object.defineProperty(Gn, "__esModule", {
    value: !0
  }), Gn.createSourceEventStream = c, Gn.subscribe = f;
  var e = /* @__PURE__ */ De(), n = /* @__PURE__ */ de(), a = /* @__PURE__ */ Gu(), i = /* @__PURE__ */ Cr(), t = /* @__PURE__ */ ne(), r = /* @__PURE__ */ ri(), o = /* @__PURE__ */ ci(), s = /* @__PURE__ */ $r(), l = /* @__PURE__ */ Mu(), d = /* @__PURE__ */ Xn();
  async function f(p) {
    arguments.length < 2 || (0, e.devAssert)(
      !1,
      "graphql@16 dropped long-deprecated support for positional arguments, please pass an object instead."
    );
    const b = await c(p);
    if (!(0, a.isAsyncIterable)(b))
      return b;
    const T = (y) => (0, s.execute)({ ...p, rootValue: y });
    return (0, l.mapAsyncIterator)(
      b,
      T
    );
  }
  function u(p) {
    const b = p[0];
    return b && "document" in b ? b : {
      schema: b,
      // FIXME: when underlying TS bug fixed, see https://github.com/microsoft/TypeScript/issues/31613
      document: p[1],
      rootValue: p[2],
      contextValue: p[3],
      variableValues: p[4],
      operationName: p[5],
      subscribeFieldResolver: p[6]
    };
  }
  async function c(...p) {
    const b = u(p), { schema: T, document: y, variableValues: h } = b;
    (0, s.assertValidExecutionArguments)(T, y, h);
    const I = (0, s.buildExecutionContext)(b);
    if (!("schema" in I))
      return {
        errors: I
      };
    try {
      const S = await m(I);
      if (!(0, a.isAsyncIterable)(S))
        throw new Error(
          `Subscription field must return Async Iterable. Received: ${(0, n.inspect)(S)}.`
        );
      return S;
    } catch (S) {
      if (S instanceof t.GraphQLError)
        return {
          errors: [S]
        };
      throw S;
    }
  }
  async function m(p) {
    const { schema: b, fragments: T, operation: y, variableValues: h, rootValue: I } = p, S = b.getSubscriptionType();
    if (S == null)
      throw new t.GraphQLError(
        "Schema is not configured to execute subscription operation.",
        {
          nodes: y
        }
      );
    const E = (0, o.collectFields)(
      b,
      T,
      h,
      S,
      y.selectionSet
    ), [k, M] = [...E.entries()][0], C = (0, s.getFieldDef)(b, S, M[0]);
    if (!C) {
      const O = M[0].name.value;
      throw new t.GraphQLError(
        `The subscription field "${O}" is not defined.`,
        {
          nodes: M
        }
      );
    }
    const _ = (0, i.addPath)(void 0, k, S.name), N = (0, s.buildResolveInfo)(
      p,
      C,
      M,
      S,
      _
    );
    try {
      var D;
      const O = (0, d.getArgumentValues)(
        C,
        M[0],
        h
      ), v = p.contextValue, L = await ((D = C.subscribe) !== null && D !== void 0 ? D : p.subscribeFieldResolver)(I, O, v, N);
      if (L instanceof Error)
        throw L;
      return L;
    } catch (O) {
      throw (0, r.locatedError)(
        O,
        M,
        (0, i.pathToArray)(_)
      );
    }
  }
  return Gn;
}
var Ts;
function Uu() {
  return Ts || (Ts = 1, (function(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), Object.defineProperty(e, "createSourceEventStream", {
      enumerable: !0,
      get: function() {
        return i.createSourceEventStream;
      }
    }), Object.defineProperty(e, "defaultFieldResolver", {
      enumerable: !0,
      get: function() {
        return a.defaultFieldResolver;
      }
    }), Object.defineProperty(e, "defaultTypeResolver", {
      enumerable: !0,
      get: function() {
        return a.defaultTypeResolver;
      }
    }), Object.defineProperty(e, "execute", {
      enumerable: !0,
      get: function() {
        return a.execute;
      }
    }), Object.defineProperty(e, "executeSync", {
      enumerable: !0,
      get: function() {
        return a.executeSync;
      }
    }), Object.defineProperty(e, "getArgumentValues", {
      enumerable: !0,
      get: function() {
        return t.getArgumentValues;
      }
    }), Object.defineProperty(e, "getDirectiveValues", {
      enumerable: !0,
      get: function() {
        return t.getDirectiveValues;
      }
    }), Object.defineProperty(e, "getVariableValues", {
      enumerable: !0,
      get: function() {
        return t.getVariableValues;
      }
    }), Object.defineProperty(e, "responsePathAsArray", {
      enumerable: !0,
      get: function() {
        return n.pathToArray;
      }
    }), Object.defineProperty(e, "subscribe", {
      enumerable: !0,
      get: function() {
        return i.subscribe;
      }
    });
    var n = /* @__PURE__ */ Cr(), a = /* @__PURE__ */ $r(), i = /* @__PURE__ */ $u(), t = /* @__PURE__ */ Xn();
  })(xr)), xr;
}
var Yr = {}, pr = {}, bs;
function Qu() {
  if (bs) return pr;
  bs = 1, Object.defineProperty(pr, "__esModule", {
    value: !0
  }), pr.NoDeprecatedCustomRule = i;
  var e = /* @__PURE__ */ Le(), n = /* @__PURE__ */ ne(), a = /* @__PURE__ */ oe();
  function i(t) {
    return {
      Field(r) {
        const o = t.getFieldDef(), s = o?.deprecationReason;
        if (o && s != null) {
          const l = t.getParentType();
          l != null || (0, e.invariant)(!1), t.reportError(
            new n.GraphQLError(
              `The field ${l.name}.${o.name} is deprecated. ${s}`,
              {
                nodes: r
              }
            )
          );
        }
      },
      Argument(r) {
        const o = t.getArgument(), s = o?.deprecationReason;
        if (o && s != null) {
          const l = t.getDirective();
          if (l != null)
            t.reportError(
              new n.GraphQLError(
                `Directive "@${l.name}" argument "${o.name}" is deprecated. ${s}`,
                {
                  nodes: r
                }
              )
            );
          else {
            const d = t.getParentType(), f = t.getFieldDef();
            d != null && f != null || (0, e.invariant)(!1), t.reportError(
              new n.GraphQLError(
                `Field "${d.name}.${f.name}" argument "${o.name}" is deprecated. ${s}`,
                {
                  nodes: r
                }
              )
            );
          }
        }
      },
      ObjectField(r) {
        const o = (0, a.getNamedType)(
          t.getParentInputType()
        );
        if ((0, a.isInputObjectType)(o)) {
          const s = o.getFields()[r.name.value], l = s?.deprecationReason;
          l != null && t.reportError(
            new n.GraphQLError(
              `The input field ${o.name}.${s.name} is deprecated. ${l}`,
              {
                nodes: r
              }
            )
          );
        }
      },
      EnumValue(r) {
        const o = t.getEnumValue(), s = o?.deprecationReason;
        if (o && s != null) {
          const l = (0, a.getNamedType)(
            t.getInputType()
          );
          l != null || (0, e.invariant)(!1), t.reportError(
            new n.GraphQLError(
              `The enum value "${l.name}.${o.name}" is deprecated. ${s}`,
              {
                nodes: r
              }
            )
          );
        }
      }
    };
  }
  return pr;
}
var dr = {}, Es;
function qu() {
  if (Es) return dr;
  Es = 1, Object.defineProperty(dr, "__esModule", {
    value: !0
  }), dr.NoSchemaIntrospectionCustomRule = i;
  var e = /* @__PURE__ */ ne(), n = /* @__PURE__ */ oe(), a = /* @__PURE__ */ Ge();
  function i(t) {
    return {
      Field(r) {
        const o = (0, n.getNamedType)(t.getType());
        o && (0, a.isIntrospectionType)(o) && t.reportError(
          new e.GraphQLError(
            `GraphQL introspection has been disabled, but the requested query contained the field "${r.name.value}".`,
            {
              nodes: r
            }
          )
        );
      }
    };
  }
  return dr;
}
var gs;
function Ku() {
  return gs || (gs = 1, (function(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), Object.defineProperty(e, "ExecutableDefinitionsRule", {
      enumerable: !0,
      get: function() {
        return t.ExecutableDefinitionsRule;
      }
    }), Object.defineProperty(e, "FieldsOnCorrectTypeRule", {
      enumerable: !0,
      get: function() {
        return r.FieldsOnCorrectTypeRule;
      }
    }), Object.defineProperty(e, "FragmentsOnCompositeTypesRule", {
      enumerable: !0,
      get: function() {
        return o.FragmentsOnCompositeTypesRule;
      }
    }), Object.defineProperty(e, "KnownArgumentNamesRule", {
      enumerable: !0,
      get: function() {
        return s.KnownArgumentNamesRule;
      }
    }), Object.defineProperty(e, "KnownDirectivesRule", {
      enumerable: !0,
      get: function() {
        return l.KnownDirectivesRule;
      }
    }), Object.defineProperty(e, "KnownFragmentNamesRule", {
      enumerable: !0,
      get: function() {
        return d.KnownFragmentNamesRule;
      }
    }), Object.defineProperty(e, "KnownTypeNamesRule", {
      enumerable: !0,
      get: function() {
        return f.KnownTypeNamesRule;
      }
    }), Object.defineProperty(e, "LoneAnonymousOperationRule", {
      enumerable: !0,
      get: function() {
        return u.LoneAnonymousOperationRule;
      }
    }), Object.defineProperty(e, "LoneSchemaDefinitionRule", {
      enumerable: !0,
      get: function() {
        return L.LoneSchemaDefinitionRule;
      }
    }), Object.defineProperty(e, "MaxIntrospectionDepthRule", {
      enumerable: !0,
      get: function() {
        return g.MaxIntrospectionDepthRule;
      }
    }), Object.defineProperty(e, "NoDeprecatedCustomRule", {
      enumerable: !0,
      get: function() {
        return te.NoDeprecatedCustomRule;
      }
    }), Object.defineProperty(e, "NoFragmentCyclesRule", {
      enumerable: !0,
      get: function() {
        return c.NoFragmentCyclesRule;
      }
    }), Object.defineProperty(e, "NoSchemaIntrospectionCustomRule", {
      enumerable: !0,
      get: function() {
        return pe.NoSchemaIntrospectionCustomRule;
      }
    }), Object.defineProperty(e, "NoUndefinedVariablesRule", {
      enumerable: !0,
      get: function() {
        return m.NoUndefinedVariablesRule;
      }
    }), Object.defineProperty(e, "NoUnusedFragmentsRule", {
      enumerable: !0,
      get: function() {
        return p.NoUnusedFragmentsRule;
      }
    }), Object.defineProperty(e, "NoUnusedVariablesRule", {
      enumerable: !0,
      get: function() {
        return b.NoUnusedVariablesRule;
      }
    }), Object.defineProperty(e, "OverlappingFieldsCanBeMergedRule", {
      enumerable: !0,
      get: function() {
        return T.OverlappingFieldsCanBeMergedRule;
      }
    }), Object.defineProperty(e, "PossibleFragmentSpreadsRule", {
      enumerable: !0,
      get: function() {
        return y.PossibleFragmentSpreadsRule;
      }
    }), Object.defineProperty(e, "PossibleTypeExtensionsRule", {
      enumerable: !0,
      get: function() {
        return K.PossibleTypeExtensionsRule;
      }
    }), Object.defineProperty(e, "ProvidedRequiredArgumentsRule", {
      enumerable: !0,
      get: function() {
        return h.ProvidedRequiredArgumentsRule;
      }
    }), Object.defineProperty(e, "ScalarLeafsRule", {
      enumerable: !0,
      get: function() {
        return I.ScalarLeafsRule;
      }
    }), Object.defineProperty(e, "SingleFieldSubscriptionsRule", {
      enumerable: !0,
      get: function() {
        return S.SingleFieldSubscriptionsRule;
      }
    }), Object.defineProperty(e, "UniqueArgumentDefinitionNamesRule", {
      enumerable: !0,
      get: function() {
        return W.UniqueArgumentDefinitionNamesRule;
      }
    }), Object.defineProperty(e, "UniqueArgumentNamesRule", {
      enumerable: !0,
      get: function() {
        return E.UniqueArgumentNamesRule;
      }
    }), Object.defineProperty(e, "UniqueDirectiveNamesRule", {
      enumerable: !0,
      get: function() {
        return P.UniqueDirectiveNamesRule;
      }
    }), Object.defineProperty(e, "UniqueDirectivesPerLocationRule", {
      enumerable: !0,
      get: function() {
        return k.UniqueDirectivesPerLocationRule;
      }
    }), Object.defineProperty(e, "UniqueEnumValueNamesRule", {
      enumerable: !0,
      get: function() {
        return V.UniqueEnumValueNamesRule;
      }
    }), Object.defineProperty(e, "UniqueFieldDefinitionNamesRule", {
      enumerable: !0,
      get: function() {
        return U.UniqueFieldDefinitionNamesRule;
      }
    }), Object.defineProperty(e, "UniqueFragmentNamesRule", {
      enumerable: !0,
      get: function() {
        return M.UniqueFragmentNamesRule;
      }
    }), Object.defineProperty(e, "UniqueInputFieldNamesRule", {
      enumerable: !0,
      get: function() {
        return C.UniqueInputFieldNamesRule;
      }
    }), Object.defineProperty(e, "UniqueOperationNamesRule", {
      enumerable: !0,
      get: function() {
        return _.UniqueOperationNamesRule;
      }
    }), Object.defineProperty(e, "UniqueOperationTypesRule", {
      enumerable: !0,
      get: function() {
        return R.UniqueOperationTypesRule;
      }
    }), Object.defineProperty(e, "UniqueTypeNamesRule", {
      enumerable: !0,
      get: function() {
        return j.UniqueTypeNamesRule;
      }
    }), Object.defineProperty(e, "UniqueVariableNamesRule", {
      enumerable: !0,
      get: function() {
        return N.UniqueVariableNamesRule;
      }
    }), Object.defineProperty(e, "ValidationContext", {
      enumerable: !0,
      get: function() {
        return a.ValidationContext;
      }
    }), Object.defineProperty(e, "ValuesOfCorrectTypeRule", {
      enumerable: !0,
      get: function() {
        return D.ValuesOfCorrectTypeRule;
      }
    }), Object.defineProperty(e, "VariablesAreInputTypesRule", {
      enumerable: !0,
      get: function() {
        return O.VariablesAreInputTypesRule;
      }
    }), Object.defineProperty(e, "VariablesInAllowedPositionRule", {
      enumerable: !0,
      get: function() {
        return v.VariablesInAllowedPositionRule;
      }
    }), Object.defineProperty(e, "recommendedRules", {
      enumerable: !0,
      get: function() {
        return i.recommendedRules;
      }
    }), Object.defineProperty(e, "specifiedRules", {
      enumerable: !0,
      get: function() {
        return i.specifiedRules;
      }
    }), Object.defineProperty(e, "validate", {
      enumerable: !0,
      get: function() {
        return n.validate;
      }
    });
    var n = /* @__PURE__ */ Mr(), a = /* @__PURE__ */ Go(), i = /* @__PURE__ */ Co(), t = /* @__PURE__ */ Ws(), r = /* @__PURE__ */ Zs(), o = /* @__PURE__ */ eo(), s = /* @__PURE__ */ no(), l = /* @__PURE__ */ to(), d = /* @__PURE__ */ ro(), f = /* @__PURE__ */ io(), u = /* @__PURE__ */ ao(), c = /* @__PURE__ */ uo(), m = /* @__PURE__ */ co(), p = /* @__PURE__ */ lo(), b = /* @__PURE__ */ po(), T = /* @__PURE__ */ mo(), y = /* @__PURE__ */ yo(), h = /* @__PURE__ */ vo(), I = /* @__PURE__ */ To(), S = /* @__PURE__ */ go(), E = /* @__PURE__ */ Oo(), k = /* @__PURE__ */ Io(), M = /* @__PURE__ */ Ro(), C = /* @__PURE__ */ Do(), _ = /* @__PURE__ */ Ao(), N = /* @__PURE__ */ ko(), D = /* @__PURE__ */ Fo(), O = /* @__PURE__ */ wo(), v = /* @__PURE__ */ Vo(), g = /* @__PURE__ */ oo(), L = /* @__PURE__ */ so(), R = /* @__PURE__ */ jo(), j = /* @__PURE__ */ Po(), V = /* @__PURE__ */ So(), U = /* @__PURE__ */ Lo(), W = /* @__PURE__ */ No(), P = /* @__PURE__ */ _o(), K = /* @__PURE__ */ ho(), te = /* @__PURE__ */ Qu(), pe = /* @__PURE__ */ qu();
  })(Yr)), Yr;
}
var Jr = {}, fr = {}, Ns;
function Mo() {
  if (Ns) return fr;
  Ns = 1, Object.defineProperty(fr, "__esModule", {
    value: !0
  }), fr.getIntrospectionQuery = e;
  function e(n) {
    const a = {
      descriptions: !0,
      specifiedByUrl: !1,
      directiveIsRepeatable: !1,
      schemaDescription: !1,
      inputValueDeprecation: !1,
      oneOf: !1,
      ...n
    }, i = a.descriptions ? "description" : "", t = a.specifiedByUrl ? "specifiedByURL" : "", r = a.directiveIsRepeatable ? "isRepeatable" : "", o = a.schemaDescription ? i : "";
    function s(d) {
      return a.inputValueDeprecation ? d : "";
    }
    const l = a.oneOf ? "isOneOf" : "";
    return `
    query IntrospectionQuery {
      __schema {
        ${o}
        queryType { name kind }
        mutationType { name kind }
        subscriptionType { name kind }
        types {
          ...FullType
        }
        directives {
          name
          ${i}
          ${r}
          locations
          args${s("(includeDeprecated: true)")} {
            ...InputValue
          }
        }
      }
    }

    fragment FullType on __Type {
      kind
      name
      ${i}
      ${t}
      ${l}
      fields(includeDeprecated: true) {
        name
        ${i}
        args${s("(includeDeprecated: true)")} {
          ...InputValue
        }
        type {
          ...TypeRef
        }
        isDeprecated
        deprecationReason
      }
      inputFields${s("(includeDeprecated: true)")} {
        ...InputValue
      }
      interfaces {
        ...TypeRef
      }
      enumValues(includeDeprecated: true) {
        name
        ${i}
        isDeprecated
        deprecationReason
      }
      possibleTypes {
        ...TypeRef
      }
    }

    fragment InputValue on __InputValue {
      name
      ${i}
      type { ...TypeRef }
      defaultValue
      ${s("isDeprecated")}
      ${s("deprecationReason")}
    }

    fragment TypeRef on __Type {
      kind
      name
      ofType {
        kind
        name
        ofType {
          kind
          name
          ofType {
            kind
            name
            ofType {
              kind
              name
              ofType {
                kind
                name
                ofType {
                  kind
                  name
                  ofType {
                    kind
                    name
                    ofType {
                      kind
                      name
                      ofType {
                        kind
                        name
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  `;
  }
  return fr;
}
var mr = {}, Os;
function Bu() {
  if (Os) return mr;
  Os = 1, Object.defineProperty(mr, "__esModule", {
    value: !0
  }), mr.getOperationAST = n;
  var e = /* @__PURE__ */ se();
  function n(a, i) {
    let t = null;
    for (const o of a.definitions)
      if (o.kind === e.Kind.OPERATION_DEFINITION) {
        var r;
        if (i == null) {
          if (t)
            return null;
          t = o;
        } else if (((r = o.name) === null || r === void 0 ? void 0 : r.value) === i)
          return o;
      }
    return t;
  }
  return mr;
}
var yr = {}, _s;
function xu() {
  if (_s) return yr;
  _s = 1, Object.defineProperty(yr, "__esModule", {
    value: !0
  }), yr.getOperationRootType = n;
  var e = /* @__PURE__ */ ne();
  function n(a, i) {
    if (i.operation === "query") {
      const t = a.getQueryType();
      if (!t)
        throw new e.GraphQLError(
          "Schema does not define the required query root type.",
          {
            nodes: i
          }
        );
      return t;
    }
    if (i.operation === "mutation") {
      const t = a.getMutationType();
      if (!t)
        throw new e.GraphQLError(
          "Schema is not configured for mutations.",
          {
            nodes: i
          }
        );
      return t;
    }
    if (i.operation === "subscription") {
      const t = a.getSubscriptionType();
      if (!t)
        throw new e.GraphQLError(
          "Schema is not configured for subscriptions.",
          {
            nodes: i
          }
        );
      return t;
    }
    throw new e.GraphQLError(
      "Can only have query, mutation and subscription operations.",
      {
        nodes: i
      }
    );
  }
  return yr;
}
var hr = {}, Is;
function Yu() {
  if (Is) return hr;
  Is = 1, Object.defineProperty(hr, "__esModule", {
    value: !0
  }), hr.introspectionFromSchema = t;
  var e = /* @__PURE__ */ Le(), n = /* @__PURE__ */ On(), a = /* @__PURE__ */ $r(), i = /* @__PURE__ */ Mo();
  function t(r, o) {
    const s = {
      specifiedByUrl: !0,
      directiveIsRepeatable: !0,
      schemaDescription: !0,
      inputValueDeprecation: !0,
      oneOf: !0,
      ...o
    }, l = (0, n.parse)(
      (0, i.getIntrospectionQuery)(s)
    ), d = (0, a.executeSync)({
      schema: r,
      document: l
    });
    return !d.errors && d.data || (0, e.invariant)(!1), d.data;
  }
  return hr;
}
var vr = {}, Ss;
function Ju() {
  if (Ss) return vr;
  Ss = 1, Object.defineProperty(vr, "__esModule", {
    value: !0
  }), vr.buildClientSchema = u;
  var e = /* @__PURE__ */ De(), n = /* @__PURE__ */ de(), a = /* @__PURE__ */ ze(), i = /* @__PURE__ */ jr(), t = /* @__PURE__ */ On(), r = /* @__PURE__ */ oe(), o = /* @__PURE__ */ Pe(), s = /* @__PURE__ */ Ge(), l = /* @__PURE__ */ Xe(), d = /* @__PURE__ */ In(), f = /* @__PURE__ */ Gr();
  function u(c, m) {
    (0, a.isObjectLike)(c) && (0, a.isObjectLike)(c.__schema) || (0, e.devAssert)(
      !1,
      `Invalid or incomplete introspection result. Ensure that you are passing "data" property of introspection response and no "errors" was returned alongside: ${(0, n.inspect)(c)}.`
    );
    const p = c.__schema, b = (0, i.keyValMap)(
      p.types,
      (P) => P.name,
      (P) => C(P)
    );
    for (const P of [
      ...l.specifiedScalarTypes,
      ...s.introspectionTypes
    ])
      b[P.name] && (b[P.name] = P);
    const T = p.queryType ? k(p.queryType) : null, y = p.mutationType ? k(p.mutationType) : null, h = p.subscriptionType ? k(p.subscriptionType) : null, I = p.directives ? p.directives.map(W) : [];
    return new d.GraphQLSchema({
      description: p.description,
      query: T,
      mutation: y,
      subscription: h,
      types: Object.values(b),
      directives: I,
      assumeValid: m?.assumeValid
    });
    function S(P) {
      if (P.kind === s.TypeKind.LIST) {
        const K = P.ofType;
        if (!K)
          throw new Error("Decorated type deeper than introspection query.");
        return new r.GraphQLList(S(K));
      }
      if (P.kind === s.TypeKind.NON_NULL) {
        const K = P.ofType;
        if (!K)
          throw new Error("Decorated type deeper than introspection query.");
        const te = S(K);
        return new r.GraphQLNonNull(
          (0, r.assertNullableType)(te)
        );
      }
      return E(P);
    }
    function E(P) {
      const K = P.name;
      if (!K)
        throw new Error(
          `Unknown type reference: ${(0, n.inspect)(P)}.`
        );
      const te = b[K];
      if (!te)
        throw new Error(
          `Invalid or incomplete schema, unknown type: ${K}. Ensure that a full introspection query is used in order to build a client schema.`
        );
      return te;
    }
    function k(P) {
      return (0, r.assertObjectType)(E(P));
    }
    function M(P) {
      return (0, r.assertInterfaceType)(E(P));
    }
    function C(P) {
      if (P != null && P.name != null && P.kind != null)
        switch (P.kind) {
          case s.TypeKind.SCALAR:
            return _(P);
          case s.TypeKind.OBJECT:
            return D(P);
          case s.TypeKind.INTERFACE:
            return O(P);
          case s.TypeKind.UNION:
            return v(P);
          case s.TypeKind.ENUM:
            return g(P);
          case s.TypeKind.INPUT_OBJECT:
            return L(P);
        }
      const K = (0, n.inspect)(P);
      throw new Error(
        `Invalid or incomplete introspection result. Ensure that a full introspection query is used in order to build a client schema: ${K}.`
      );
    }
    function _(P) {
      return new r.GraphQLScalarType({
        name: P.name,
        description: P.description,
        specifiedByURL: P.specifiedByURL
      });
    }
    function N(P) {
      if (P.interfaces === null && P.kind === s.TypeKind.INTERFACE)
        return [];
      if (!P.interfaces) {
        const K = (0, n.inspect)(
          P
        );
        throw new Error(
          `Introspection result missing interfaces: ${K}.`
        );
      }
      return P.interfaces.map(M);
    }
    function D(P) {
      return new r.GraphQLObjectType({
        name: P.name,
        description: P.description,
        interfaces: () => N(P),
        fields: () => R(P)
      });
    }
    function O(P) {
      return new r.GraphQLInterfaceType({
        name: P.name,
        description: P.description,
        interfaces: () => N(P),
        fields: () => R(P)
      });
    }
    function v(P) {
      if (!P.possibleTypes) {
        const K = (0, n.inspect)(P);
        throw new Error(
          `Introspection result missing possibleTypes: ${K}.`
        );
      }
      return new r.GraphQLUnionType({
        name: P.name,
        description: P.description,
        types: () => P.possibleTypes.map(k)
      });
    }
    function g(P) {
      if (!P.enumValues) {
        const K = (0, n.inspect)(P);
        throw new Error(
          `Introspection result missing enumValues: ${K}.`
        );
      }
      return new r.GraphQLEnumType({
        name: P.name,
        description: P.description,
        values: (0, i.keyValMap)(
          P.enumValues,
          (K) => K.name,
          (K) => ({
            description: K.description,
            deprecationReason: K.deprecationReason
          })
        )
      });
    }
    function L(P) {
      if (!P.inputFields) {
        const K = (0, n.inspect)(
          P
        );
        throw new Error(
          `Introspection result missing inputFields: ${K}.`
        );
      }
      return new r.GraphQLInputObjectType({
        name: P.name,
        description: P.description,
        fields: () => V(P.inputFields),
        isOneOf: P.isOneOf
      });
    }
    function R(P) {
      if (!P.fields)
        throw new Error(
          `Introspection result missing fields: ${(0, n.inspect)(
            P
          )}.`
        );
      return (0, i.keyValMap)(
        P.fields,
        (K) => K.name,
        j
      );
    }
    function j(P) {
      const K = S(P.type);
      if (!(0, r.isOutputType)(K)) {
        const te = (0, n.inspect)(K);
        throw new Error(
          `Introspection must provide output type for fields, but received: ${te}.`
        );
      }
      if (!P.args) {
        const te = (0, n.inspect)(P);
        throw new Error(
          `Introspection result missing field args: ${te}.`
        );
      }
      return {
        description: P.description,
        deprecationReason: P.deprecationReason,
        type: K,
        args: V(P.args)
      };
    }
    function V(P) {
      return (0, i.keyValMap)(
        P,
        (K) => K.name,
        U
      );
    }
    function U(P) {
      const K = S(P.type);
      if (!(0, r.isInputType)(K)) {
        const pe = (0, n.inspect)(K);
        throw new Error(
          `Introspection must provide input type for arguments, but received: ${pe}.`
        );
      }
      const te = P.defaultValue != null ? (0, f.valueFromAST)(
        (0, t.parseValue)(P.defaultValue),
        K
      ) : void 0;
      return {
        description: P.description,
        type: K,
        defaultValue: te,
        deprecationReason: P.deprecationReason
      };
    }
    function W(P) {
      if (!P.args) {
        const K = (0, n.inspect)(
          P
        );
        throw new Error(
          `Introspection result missing directive args: ${K}.`
        );
      }
      if (!P.locations) {
        const K = (0, n.inspect)(
          P
        );
        throw new Error(
          `Introspection result missing directive locations: ${K}.`
        );
      }
      return new o.GraphQLDirective({
        name: P.name,
        description: P.description,
        isRepeatable: P.isRepeatable,
        locations: P.locations.slice(),
        args: V(P.args)
      });
    }
  }
  return vr;
}
var Mn = {}, $n = {}, Ls;
function $o() {
  if (Ls) return $n;
  Ls = 1, Object.defineProperty($n, "__esModule", {
    value: !0
  }), $n.extendSchema = b, $n.extendSchemaImpl = T;
  var e = /* @__PURE__ */ De(), n = /* @__PURE__ */ de(), a = /* @__PURE__ */ Le(), i = /* @__PURE__ */ un(), t = /* @__PURE__ */ Xs(), r = /* @__PURE__ */ se(), o = /* @__PURE__ */ Sn(), s = /* @__PURE__ */ oe(), l = /* @__PURE__ */ Pe(), d = /* @__PURE__ */ Ge(), f = /* @__PURE__ */ Xe(), u = /* @__PURE__ */ In(), c = /* @__PURE__ */ Mr(), m = /* @__PURE__ */ Xn(), p = /* @__PURE__ */ Gr();
  function b(E, k, M) {
    (0, u.assertSchema)(E), k != null && k.kind === r.Kind.DOCUMENT || (0, e.devAssert)(!1, "Must provide valid Document AST."), M?.assumeValid !== !0 && M?.assumeValidSDL !== !0 && (0, c.assertValidSDLExtension)(k, E);
    const C = E.toConfig(), _ = T(C, k, M);
    return C === _ ? E : new u.GraphQLSchema(_);
  }
  function T(E, k, M) {
    var C, _, N, D;
    const O = [], v = /* @__PURE__ */ Object.create(null), g = [];
    let L;
    const R = [];
    for (const w of k.definitions)
      if (w.kind === r.Kind.SCHEMA_DEFINITION)
        L = w;
      else if (w.kind === r.Kind.SCHEMA_EXTENSION)
        R.push(w);
      else if ((0, o.isTypeDefinitionNode)(w))
        O.push(w);
      else if ((0, o.isTypeExtensionNode)(w)) {
        const z = w.name.value, q = v[z];
        v[z] = q ? q.concat([w]) : [w];
      } else w.kind === r.Kind.DIRECTIVE_DEFINITION && g.push(w);
    if (Object.keys(v).length === 0 && O.length === 0 && g.length === 0 && R.length === 0 && L == null)
      return E;
    const j = /* @__PURE__ */ Object.create(null);
    for (const w of E.types)
      j[w.name] = te(w);
    for (const w of O) {
      var V;
      const z = w.name.value;
      j[z] = (V = y[z]) !== null && V !== void 0 ? V : We(w);
    }
    const U = {
      // Get the extended root operation types.
      query: E.query && P(E.query),
      mutation: E.mutation && P(E.mutation),
      subscription: E.subscription && P(E.subscription),
      // Then, incorporate schema definition and all schema extensions.
      ...L && ie([L]),
      ...ie(R)
    };
    return {
      description: (C = L) === null || C === void 0 || (_ = C.description) === null || _ === void 0 ? void 0 : _.value,
      ...U,
      types: Object.values(j),
      directives: [
        ...E.directives.map(K),
        ...g.map(he)
      ],
      extensions: /* @__PURE__ */ Object.create(null),
      astNode: (N = L) !== null && N !== void 0 ? N : E.astNode,
      extensionASTNodes: E.extensionASTNodes.concat(R),
      assumeValid: (D = M?.assumeValid) !== null && D !== void 0 ? D : !1
    };
    function W(w) {
      return (0, s.isListType)(w) ? new s.GraphQLList(W(w.ofType)) : (0, s.isNonNullType)(w) ? new s.GraphQLNonNull(W(w.ofType)) : P(w);
    }
    function P(w) {
      return j[w.name];
    }
    function K(w) {
      const z = w.toConfig();
      return new l.GraphQLDirective({
        ...z,
        args: (0, t.mapValue)(z.args, ee)
      });
    }
    function te(w) {
      if ((0, d.isIntrospectionType)(w) || (0, f.isSpecifiedScalarType)(w))
        return w;
      if ((0, s.isScalarType)(w))
        return $(w);
      if ((0, s.isObjectType)(w))
        return x(w);
      if ((0, s.isInterfaceType)(w))
        return Y(w);
      if ((0, s.isUnionType)(w))
        return Z(w);
      if ((0, s.isEnumType)(w))
        return G(w);
      if ((0, s.isInputObjectType)(w))
        return pe(w);
      (0, a.invariant)(
        !1,
        "Unexpected type: " + (0, n.inspect)(w)
      );
    }
    function pe(w) {
      var z;
      const q = w.toConfig(), X = (z = v[q.name]) !== null && z !== void 0 ? z : [];
      return new s.GraphQLInputObjectType({
        ...q,
        fields: () => ({
          ...(0, t.mapValue)(q.fields, (fe) => ({
            ...fe,
            type: W(fe.type)
          })),
          ...ve(X)
        }),
        extensionASTNodes: q.extensionASTNodes.concat(X)
      });
    }
    function G(w) {
      var z;
      const q = w.toConfig(), X = (z = v[w.name]) !== null && z !== void 0 ? z : [];
      return new s.GraphQLEnumType({
        ...q,
        values: { ...q.values, ..._e(X) },
        extensionASTNodes: q.extensionASTNodes.concat(X)
      });
    }
    function $(w) {
      var z;
      const q = w.toConfig(), X = (z = v[q.name]) !== null && z !== void 0 ? z : [];
      let fe = q.specifiedByURL;
      for (const me of X) {
        var be;
        fe = (be = I(me)) !== null && be !== void 0 ? be : fe;
      }
      return new s.GraphQLScalarType({
        ...q,
        specifiedByURL: fe,
        extensionASTNodes: q.extensionASTNodes.concat(X)
      });
    }
    function x(w) {
      var z;
      const q = w.toConfig(), X = (z = v[q.name]) !== null && z !== void 0 ? z : [];
      return new s.GraphQLObjectType({
        ...q,
        interfaces: () => [
          ...w.getInterfaces().map(P),
          ...ke(X)
        ],
        fields: () => ({
          ...(0, t.mapValue)(q.fields, B),
          ...Oe(X)
        }),
        extensionASTNodes: q.extensionASTNodes.concat(X)
      });
    }
    function Y(w) {
      var z;
      const q = w.toConfig(), X = (z = v[q.name]) !== null && z !== void 0 ? z : [];
      return new s.GraphQLInterfaceType({
        ...q,
        interfaces: () => [
          ...w.getInterfaces().map(P),
          ...ke(X)
        ],
        fields: () => ({
          ...(0, t.mapValue)(q.fields, B),
          ...Oe(X)
        }),
        extensionASTNodes: q.extensionASTNodes.concat(X)
      });
    }
    function Z(w) {
      var z;
      const q = w.toConfig(), X = (z = v[q.name]) !== null && z !== void 0 ? z : [];
      return new s.GraphQLUnionType({
        ...q,
        types: () => [
          ...w.getTypes().map(P),
          ...nn(X)
        ],
        extensionASTNodes: q.extensionASTNodes.concat(X)
      });
    }
    function B(w) {
      return {
        ...w,
        type: W(w.type),
        args: w.args && (0, t.mapValue)(w.args, ee)
      };
    }
    function ee(w) {
      return { ...w, type: W(w.type) };
    }
    function ie(w) {
      const z = {};
      for (const X of w) {
        var q;
        const fe = (
          /* c8 ignore next */
          (q = X.operationTypes) !== null && q !== void 0 ? q : []
        );
        for (const be of fe)
          z[be.operation] = ue(be.type);
      }
      return z;
    }
    function ue(w) {
      var z;
      const q = w.name.value, X = (z = y[q]) !== null && z !== void 0 ? z : j[q];
      if (X === void 0)
        throw new Error(`Unknown type: "${q}".`);
      return X;
    }
    function ce(w) {
      return w.kind === r.Kind.LIST_TYPE ? new s.GraphQLList(ce(w.type)) : w.kind === r.Kind.NON_NULL_TYPE ? new s.GraphQLNonNull(ce(w.type)) : ue(w);
    }
    function he(w) {
      var z;
      return new l.GraphQLDirective({
        name: w.name.value,
        description: (z = w.description) === null || z === void 0 ? void 0 : z.value,
        // @ts-expect-error
        locations: w.locations.map(({ value: q }) => q),
        isRepeatable: w.repeatable,
        args: ge(w.arguments),
        astNode: w
      });
    }
    function Oe(w) {
      const z = /* @__PURE__ */ Object.create(null);
      for (const fe of w) {
        var q;
        const be = (
          /* c8 ignore next */
          (q = fe.fields) !== null && q !== void 0 ? q : []
        );
        for (const me of be) {
          var X;
          z[me.name.value] = {
            // Note: While this could make assertions to get the correctly typed
            // value, that would throw immediately while type system validation
            // with validateSchema() will produce more actionable results.
            type: ce(me.type),
            description: (X = me.description) === null || X === void 0 ? void 0 : X.value,
            args: ge(me.arguments),
            deprecationReason: h(me),
            astNode: me
          };
        }
      }
      return z;
    }
    function ge(w) {
      const z = (
        /* c8 ignore next */
        w ?? []
      ), q = /* @__PURE__ */ Object.create(null);
      for (const fe of z) {
        var X;
        const be = ce(fe.type);
        q[fe.name.value] = {
          type: be,
          description: (X = fe.description) === null || X === void 0 ? void 0 : X.value,
          defaultValue: (0, p.valueFromAST)(fe.defaultValue, be),
          deprecationReason: h(fe),
          astNode: fe
        };
      }
      return q;
    }
    function ve(w) {
      const z = /* @__PURE__ */ Object.create(null);
      for (const fe of w) {
        var q;
        const be = (
          /* c8 ignore next */
          (q = fe.fields) !== null && q !== void 0 ? q : []
        );
        for (const me of be) {
          var X;
          const qe = ce(me.type);
          z[me.name.value] = {
            type: qe,
            description: (X = me.description) === null || X === void 0 ? void 0 : X.value,
            defaultValue: (0, p.valueFromAST)(
              me.defaultValue,
              qe
            ),
            deprecationReason: h(me),
            astNode: me
          };
        }
      }
      return z;
    }
    function _e(w) {
      const z = /* @__PURE__ */ Object.create(null);
      for (const fe of w) {
        var q;
        const be = (
          /* c8 ignore next */
          (q = fe.values) !== null && q !== void 0 ? q : []
        );
        for (const me of be) {
          var X;
          z[me.name.value] = {
            description: (X = me.description) === null || X === void 0 ? void 0 : X.value,
            deprecationReason: h(me),
            astNode: me
          };
        }
      }
      return z;
    }
    function ke(w) {
      return w.flatMap(
        // FIXME: https://github.com/graphql/graphql-js/issues/2203
        (z) => {
          var q, X;
          return (
            /* c8 ignore next */
            (q = (X = z.interfaces) === null || X === void 0 ? void 0 : X.map(ue)) !== null && q !== void 0 ? q : []
          );
        }
      );
    }
    function nn(w) {
      return w.flatMap(
        // FIXME: https://github.com/graphql/graphql-js/issues/2203
        (z) => {
          var q, X;
          return (
            /* c8 ignore next */
            (q = (X = z.types) === null || X === void 0 ? void 0 : X.map(ue)) !== null && q !== void 0 ? q : []
          );
        }
      );
    }
    function We(w) {
      var z;
      const q = w.name.value, X = (z = v[q]) !== null && z !== void 0 ? z : [];
      switch (w.kind) {
        case r.Kind.OBJECT_TYPE_DEFINITION: {
          var fe;
          const Ie = [w, ...X];
          return new s.GraphQLObjectType({
            name: q,
            description: (fe = w.description) === null || fe === void 0 ? void 0 : fe.value,
            interfaces: () => ke(Ie),
            fields: () => Oe(Ie),
            astNode: w,
            extensionASTNodes: X
          });
        }
        case r.Kind.INTERFACE_TYPE_DEFINITION: {
          var be;
          const Ie = [w, ...X];
          return new s.GraphQLInterfaceType({
            name: q,
            description: (be = w.description) === null || be === void 0 ? void 0 : be.value,
            interfaces: () => ke(Ie),
            fields: () => Oe(Ie),
            astNode: w,
            extensionASTNodes: X
          });
        }
        case r.Kind.ENUM_TYPE_DEFINITION: {
          var me;
          const Ie = [w, ...X];
          return new s.GraphQLEnumType({
            name: q,
            description: (me = w.description) === null || me === void 0 ? void 0 : me.value,
            values: _e(Ie),
            astNode: w,
            extensionASTNodes: X
          });
        }
        case r.Kind.UNION_TYPE_DEFINITION: {
          var qe;
          const Ie = [w, ...X];
          return new s.GraphQLUnionType({
            name: q,
            description: (qe = w.description) === null || qe === void 0 ? void 0 : qe.value,
            types: () => nn(Ie),
            astNode: w,
            extensionASTNodes: X
          });
        }
        case r.Kind.SCALAR_TYPE_DEFINITION: {
          var Ln;
          return new s.GraphQLScalarType({
            name: q,
            description: (Ln = w.description) === null || Ln === void 0 ? void 0 : Ln.value,
            specifiedByURL: I(w),
            astNode: w,
            extensionASTNodes: X
          });
        }
        case r.Kind.INPUT_OBJECT_TYPE_DEFINITION: {
          var ln;
          const Ie = [w, ...X];
          return new s.GraphQLInputObjectType({
            name: q,
            description: (ln = w.description) === null || ln === void 0 ? void 0 : ln.value,
            fields: () => ve(Ie),
            astNode: w,
            extensionASTNodes: X,
            isOneOf: S(w)
          });
        }
      }
    }
  }
  const y = (0, i.keyMap)(
    [...f.specifiedScalarTypes, ...d.introspectionTypes],
    (E) => E.name
  );
  function h(E) {
    const k = (0, m.getDirectiveValues)(
      l.GraphQLDeprecatedDirective,
      E
    );
    return k?.reason;
  }
  function I(E) {
    const k = (0, m.getDirectiveValues)(
      l.GraphQLSpecifiedByDirective,
      E
    );
    return k?.url;
  }
  function S(E) {
    return !!(0, m.getDirectiveValues)(l.GraphQLOneOfDirective, E);
  }
  return $n;
}
var Rs;
function zu() {
  if (Rs) return Mn;
  Rs = 1, Object.defineProperty(Mn, "__esModule", {
    value: !0
  }), Mn.buildASTSchema = s, Mn.buildSchema = l;
  var e = /* @__PURE__ */ De(), n = /* @__PURE__ */ se(), a = /* @__PURE__ */ On(), i = /* @__PURE__ */ Pe(), t = /* @__PURE__ */ In(), r = /* @__PURE__ */ Mr(), o = /* @__PURE__ */ $o();
  function s(d, f) {
    d != null && d.kind === n.Kind.DOCUMENT || (0, e.devAssert)(!1, "Must provide valid Document AST."), f?.assumeValid !== !0 && f?.assumeValidSDL !== !0 && (0, r.assertValidSDL)(d);
    const u = {
      description: void 0,
      types: [],
      directives: [],
      extensions: /* @__PURE__ */ Object.create(null),
      extensionASTNodes: [],
      assumeValid: !1
    }, c = (0, o.extendSchemaImpl)(
      u,
      d,
      f
    );
    if (c.astNode == null)
      for (const p of c.types)
        switch (p.name) {
          // Note: While this could make early assertions to get the correctly
          // typed values below, that would throw immediately while type system
          // validation with validateSchema() will produce more actionable results.
          case "Query":
            c.query = p;
            break;
          case "Mutation":
            c.mutation = p;
            break;
          case "Subscription":
            c.subscription = p;
            break;
        }
    const m = [
      ...c.directives,
      // If specified directives were not explicitly declared, add them.
      ...i.specifiedDirectives.filter(
        (p) => c.directives.every(
          (b) => b.name !== p.name
        )
      )
    ];
    return new t.GraphQLSchema({ ...c, directives: m });
  }
  function l(d, f) {
    const u = (0, a.parse)(d, {
      noLocation: f?.noLocation,
      allowLegacyFragmentVariables: f?.allowLegacyFragmentVariables
    });
    return s(u, {
      assumeValidSDL: f?.assumeValidSDL,
      assumeValid: f?.assumeValid
    });
  }
  return Mn;
}
var Tr = {}, Ds;
function Xu() {
  if (Ds) return Tr;
  Ds = 1, Object.defineProperty(Tr, "__esModule", {
    value: !0
  }), Tr.lexicographicSortSchema = l;
  var e = /* @__PURE__ */ de(), n = /* @__PURE__ */ Le(), a = /* @__PURE__ */ jr(), i = /* @__PURE__ */ Pr(), t = /* @__PURE__ */ oe(), r = /* @__PURE__ */ Pe(), o = /* @__PURE__ */ Ge(), s = /* @__PURE__ */ In();
  function l(c) {
    const m = c.toConfig(), p = (0, a.keyValMap)(
      f(m.types),
      (C) => C.name,
      M
    );
    return new s.GraphQLSchema({
      ...m,
      types: Object.values(p),
      directives: f(m.directives).map(h),
      query: y(m.query),
      mutation: y(m.mutation),
      subscription: y(m.subscription)
    });
    function b(C) {
      return (0, t.isListType)(C) ? new t.GraphQLList(b(C.ofType)) : (0, t.isNonNullType)(C) ? new t.GraphQLNonNull(b(C.ofType)) : T(C);
    }
    function T(C) {
      return p[C.name];
    }
    function y(C) {
      return C && T(C);
    }
    function h(C) {
      const _ = C.toConfig();
      return new r.GraphQLDirective({
        ..._,
        locations: u(_.locations, (N) => N),
        args: I(_.args)
      });
    }
    function I(C) {
      return d(C, (_) => ({ ..._, type: b(_.type) }));
    }
    function S(C) {
      return d(C, (_) => ({
        ..._,
        type: b(_.type),
        args: _.args && I(_.args)
      }));
    }
    function E(C) {
      return d(C, (_) => ({
        ..._,
        type: b(_.type)
      }));
    }
    function k(C) {
      return f(C).map(T);
    }
    function M(C) {
      if ((0, t.isScalarType)(C) || (0, o.isIntrospectionType)(C))
        return C;
      if ((0, t.isObjectType)(C)) {
        const _ = C.toConfig();
        return new t.GraphQLObjectType({
          ..._,
          interfaces: () => k(_.interfaces),
          fields: () => S(_.fields)
        });
      }
      if ((0, t.isInterfaceType)(C)) {
        const _ = C.toConfig();
        return new t.GraphQLInterfaceType({
          ..._,
          interfaces: () => k(_.interfaces),
          fields: () => S(_.fields)
        });
      }
      if ((0, t.isUnionType)(C)) {
        const _ = C.toConfig();
        return new t.GraphQLUnionType({
          ..._,
          types: () => k(_.types)
        });
      }
      if ((0, t.isEnumType)(C)) {
        const _ = C.toConfig();
        return new t.GraphQLEnumType({
          ..._,
          values: d(_.values, (N) => N)
        });
      }
      if ((0, t.isInputObjectType)(C)) {
        const _ = C.toConfig();
        return new t.GraphQLInputObjectType({
          ..._,
          fields: () => E(_.fields)
        });
      }
      (0, n.invariant)(
        !1,
        "Unexpected type: " + (0, e.inspect)(C)
      );
    }
  }
  function d(c, m) {
    const p = /* @__PURE__ */ Object.create(null);
    for (const b of Object.keys(c).sort(i.naturalCompare))
      p[b] = m(c[b]);
    return p;
  }
  function f(c) {
    return u(c, (m) => m.name);
  }
  function u(c, m) {
    return c.slice().sort((p, b) => {
      const T = m(p), y = m(b);
      return (0, i.naturalCompare)(T, y);
    });
  }
  return Tr;
}
var En = {}, As;
function Hu() {
  if (As) return En;
  As = 1, Object.defineProperty(En, "__esModule", {
    value: !0
  }), En.printIntrospectionSchema = u, En.printSchema = f, En.printType = T;
  var e = /* @__PURE__ */ de(), n = /* @__PURE__ */ Le(), a = /* @__PURE__ */ Rr(), i = /* @__PURE__ */ se(), t = /* @__PURE__ */ Fe(), r = /* @__PURE__ */ oe(), o = /* @__PURE__ */ Pe(), s = /* @__PURE__ */ Ge(), l = /* @__PURE__ */ Xe(), d = /* @__PURE__ */ wr();
  function f(R) {
    return m(
      R,
      (j) => !(0, o.isSpecifiedDirective)(j),
      c
    );
  }
  function u(R) {
    return m(
      R,
      o.isSpecifiedDirective,
      s.isIntrospectionType
    );
  }
  function c(R) {
    return !(0, l.isSpecifiedScalarType)(R) && !(0, s.isIntrospectionType)(R);
  }
  function m(R, j, V) {
    const U = R.getDirectives().filter(j), W = Object.values(R.getTypeMap()).filter(V);
    return [
      p(R),
      ...U.map((P) => O(P)),
      ...W.map((P) => T(P))
    ].filter(Boolean).join(`

`);
  }
  function p(R) {
    if (R.description == null && b(R))
      return;
    const j = [], V = R.getQueryType();
    V && j.push(`  query: ${V.name}`);
    const U = R.getMutationType();
    U && j.push(`  mutation: ${U.name}`);
    const W = R.getSubscriptionType();
    return W && j.push(`  subscription: ${W.name}`), L(R) + `schema {
${j.join(`
`)}
}`;
  }
  function b(R) {
    const j = R.getQueryType();
    if (j && j.name !== "Query")
      return !1;
    const V = R.getMutationType();
    if (V && V.name !== "Mutation")
      return !1;
    const U = R.getSubscriptionType();
    return !(U && U.name !== "Subscription");
  }
  function T(R) {
    if ((0, r.isScalarType)(R))
      return y(R);
    if ((0, r.isObjectType)(R))
      return I(R);
    if ((0, r.isInterfaceType)(R))
      return S(R);
    if ((0, r.isUnionType)(R))
      return E(R);
    if ((0, r.isEnumType)(R))
      return k(R);
    if ((0, r.isInputObjectType)(R))
      return M(R);
    (0, n.invariant)(
      !1,
      "Unexpected type: " + (0, e.inspect)(R)
    );
  }
  function y(R) {
    return L(R) + `scalar ${R.name}` + g(R);
  }
  function h(R) {
    const j = R.getInterfaces();
    return j.length ? " implements " + j.map((V) => V.name).join(" & ") : "";
  }
  function I(R) {
    return L(R) + `type ${R.name}` + h(R) + C(R);
  }
  function S(R) {
    return L(R) + `interface ${R.name}` + h(R) + C(R);
  }
  function E(R) {
    const j = R.getTypes(), V = j.length ? " = " + j.join(" | ") : "";
    return L(R) + "union " + R.name + V;
  }
  function k(R) {
    const j = R.getValues().map(
      (V, U) => L(V, "  ", !U) + "  " + V.name + v(V.deprecationReason)
    );
    return L(R) + `enum ${R.name}` + _(j);
  }
  function M(R) {
    const j = Object.values(R.getFields()).map(
      (V, U) => L(V, "  ", !U) + "  " + D(V)
    );
    return L(R) + `input ${R.name}` + (R.isOneOf ? " @oneOf" : "") + _(j);
  }
  function C(R) {
    const j = Object.values(R.getFields()).map(
      (V, U) => L(V, "  ", !U) + "  " + V.name + N(V.args, "  ") + ": " + String(V.type) + v(V.deprecationReason)
    );
    return _(j);
  }
  function _(R) {
    return R.length !== 0 ? ` {
` + R.join(`
`) + `
}` : "";
  }
  function N(R, j = "") {
    return R.length === 0 ? "" : R.every((V) => !V.description) ? "(" + R.map(D).join(", ") + ")" : `(
` + R.map(
      (V, U) => L(V, "  " + j, !U) + "  " + j + D(V)
    ).join(`
`) + `
` + j + ")";
  }
  function D(R) {
    const j = (0, d.astFromValue)(
      R.defaultValue,
      R.type
    );
    let V = R.name + ": " + String(R.type);
    return j && (V += ` = ${(0, t.print)(j)}`), V + v(R.deprecationReason);
  }
  function O(R) {
    return L(R) + "directive @" + R.name + N(R.args) + (R.isRepeatable ? " repeatable" : "") + " on " + R.locations.join(" | ");
  }
  function v(R) {
    return R == null ? "" : R !== o.DEFAULT_DEPRECATION_REASON ? ` @deprecated(reason: ${(0, t.print)({
      kind: i.Kind.STRING,
      value: R
    })})` : " @deprecated";
  }
  function g(R) {
    return R.specifiedByURL == null ? "" : ` @specifiedBy(url: ${(0, t.print)({
      kind: i.Kind.STRING,
      value: R.specifiedByURL
    })})`;
  }
  function L(R, j = "", V = !0) {
    const { description: U } = R;
    if (U == null)
      return "";
    const W = (0, t.print)({
      kind: i.Kind.STRING,
      value: U,
      block: (0, a.isPrintableAsBlockString)(U)
    });
    return (j && !V ? `
` + j : j) + W.replace(/\n/g, `
` + j) + `
`;
  }
  return En;
}
var br = {}, js;
function Wu() {
  if (js) return br;
  js = 1, Object.defineProperty(br, "__esModule", {
    value: !0
  }), br.concatAST = n;
  var e = /* @__PURE__ */ se();
  function n(a) {
    const i = [];
    for (const t of a)
      i.push(...t.definitions);
    return {
      kind: e.Kind.DOCUMENT,
      definitions: i
    };
  }
  return br;
}
var Er = {}, Ps;
function Zu() {
  if (Ps) return Er;
  Ps = 1, Object.defineProperty(Er, "__esModule", {
    value: !0
  }), Er.separateOperations = a;
  var e = /* @__PURE__ */ se(), n = /* @__PURE__ */ _n();
  function a(r) {
    const o = [], s = /* @__PURE__ */ Object.create(null);
    for (const d of r.definitions)
      switch (d.kind) {
        case e.Kind.OPERATION_DEFINITION:
          o.push(d);
          break;
        case e.Kind.FRAGMENT_DEFINITION:
          s[d.name.value] = t(
            d.selectionSet
          );
          break;
      }
    const l = /* @__PURE__ */ Object.create(null);
    for (const d of o) {
      const f = /* @__PURE__ */ new Set();
      for (const c of t(d.selectionSet))
        i(f, s, c);
      const u = d.name ? d.name.value : "";
      l[u] = {
        kind: e.Kind.DOCUMENT,
        definitions: r.definitions.filter(
          (c) => c === d || c.kind === e.Kind.FRAGMENT_DEFINITION && f.has(c.name.value)
        )
      };
    }
    return l;
  }
  function i(r, o, s) {
    if (!r.has(s)) {
      r.add(s);
      const l = o[s];
      if (l !== void 0)
        for (const d of l)
          i(r, o, d);
    }
  }
  function t(r) {
    const o = [];
    return (0, n.visit)(r, {
      FragmentSpread(s) {
        o.push(s.name.value);
      }
    }), o;
  }
  return Er;
}
var gr = {}, ks;
function ec() {
  if (ks) return gr;
  ks = 1, Object.defineProperty(gr, "__esModule", {
    value: !0
  }), gr.stripIgnoredCharacters = t;
  var e = /* @__PURE__ */ Rr(), n = /* @__PURE__ */ Dr(), a = /* @__PURE__ */ ai(), i = /* @__PURE__ */ zn();
  function t(r) {
    const o = (0, a.isSource)(r) ? r : new a.Source(r), s = o.body, l = new n.Lexer(o);
    let d = "", f = !1;
    for (; l.advance().kind !== i.TokenKind.EOF; ) {
      const u = l.token, c = u.kind, m = !(0, n.isPunctuatorTokenKind)(
        u.kind
      );
      f && (m || u.kind === i.TokenKind.SPREAD) && (d += " ");
      const p = s.slice(u.start, u.end);
      c === i.TokenKind.BLOCK_STRING ? d += (0, e.printBlockString)(u.value, {
        minimize: !0
      }) : d += p, f = m;
    }
    return d;
  }
  return gr;
}
var Un = {}, Fs;
function nc() {
  if (Fs) return Un;
  Fs = 1, Object.defineProperty(Un, "__esModule", {
    value: !0
  }), Un.assertValidName = i, Un.isValidNameError = t;
  var e = /* @__PURE__ */ De(), n = /* @__PURE__ */ ne(), a = /* @__PURE__ */ kr();
  function i(r) {
    const o = t(r);
    if (o)
      throw o;
    return r;
  }
  function t(r) {
    if (typeof r == "string" || (0, e.devAssert)(!1, "Expected name to be a string."), r.startsWith("__"))
      return new n.GraphQLError(
        `Name "${r}" must not begin with "__", which is reserved by GraphQL introspection.`
      );
    try {
      (0, a.assertName)(r);
    } catch (o) {
      return o;
    }
  }
  return Un;
}
var Ve = {}, ws;
function tc() {
  if (ws) return Ve;
  ws = 1, Object.defineProperty(Ve, "__esModule", {
    value: !0
  }), Ve.DangerousChangeType = Ve.BreakingChangeType = void 0, Ve.findBreakingChanges = f, Ve.findDangerousChanges = u;
  var e = /* @__PURE__ */ de(), n = /* @__PURE__ */ Le(), a = /* @__PURE__ */ un(), i = /* @__PURE__ */ Fe(), t = /* @__PURE__ */ oe(), r = /* @__PURE__ */ Xe(), o = /* @__PURE__ */ wr(), s = /* @__PURE__ */ fo(), l;
  Ve.BreakingChangeType = l, (function(N) {
    N.TYPE_REMOVED = "TYPE_REMOVED", N.TYPE_CHANGED_KIND = "TYPE_CHANGED_KIND", N.TYPE_REMOVED_FROM_UNION = "TYPE_REMOVED_FROM_UNION", N.VALUE_REMOVED_FROM_ENUM = "VALUE_REMOVED_FROM_ENUM", N.REQUIRED_INPUT_FIELD_ADDED = "REQUIRED_INPUT_FIELD_ADDED", N.IMPLEMENTED_INTERFACE_REMOVED = "IMPLEMENTED_INTERFACE_REMOVED", N.FIELD_REMOVED = "FIELD_REMOVED", N.FIELD_CHANGED_KIND = "FIELD_CHANGED_KIND", N.REQUIRED_ARG_ADDED = "REQUIRED_ARG_ADDED", N.ARG_REMOVED = "ARG_REMOVED", N.ARG_CHANGED_KIND = "ARG_CHANGED_KIND", N.DIRECTIVE_REMOVED = "DIRECTIVE_REMOVED", N.DIRECTIVE_ARG_REMOVED = "DIRECTIVE_ARG_REMOVED", N.REQUIRED_DIRECTIVE_ARG_ADDED = "REQUIRED_DIRECTIVE_ARG_ADDED", N.DIRECTIVE_REPEATABLE_REMOVED = "DIRECTIVE_REPEATABLE_REMOVED", N.DIRECTIVE_LOCATION_REMOVED = "DIRECTIVE_LOCATION_REMOVED";
  })(
    l || (Ve.BreakingChangeType = l = {})
  );
  var d;
  Ve.DangerousChangeType = d, (function(N) {
    N.VALUE_ADDED_TO_ENUM = "VALUE_ADDED_TO_ENUM", N.TYPE_ADDED_TO_UNION = "TYPE_ADDED_TO_UNION", N.OPTIONAL_INPUT_FIELD_ADDED = "OPTIONAL_INPUT_FIELD_ADDED", N.OPTIONAL_ARG_ADDED = "OPTIONAL_ARG_ADDED", N.IMPLEMENTED_INTERFACE_ADDED = "IMPLEMENTED_INTERFACE_ADDED", N.ARG_DEFAULT_VALUE_CHANGE = "ARG_DEFAULT_VALUE_CHANGE";
  })(
    d || (Ve.DangerousChangeType = d = {})
  );
  function f(N, D) {
    return c(N, D).filter(
      (O) => O.type in l
    );
  }
  function u(N, D) {
    return c(N, D).filter(
      (O) => O.type in d
    );
  }
  function c(N, D) {
    return [
      ...p(N, D),
      ...m(N, D)
    ];
  }
  function m(N, D) {
    const O = [], v = _(
      N.getDirectives(),
      D.getDirectives()
    );
    for (const g of v.removed)
      O.push({
        type: l.DIRECTIVE_REMOVED,
        description: `${g.name} was removed.`
      });
    for (const [g, L] of v.persisted) {
      const R = _(g.args, L.args);
      for (const j of R.added)
        (0, t.isRequiredArgument)(j) && O.push({
          type: l.REQUIRED_DIRECTIVE_ARG_ADDED,
          description: `A required arg ${j.name} on directive ${g.name} was added.`
        });
      for (const j of R.removed)
        O.push({
          type: l.DIRECTIVE_ARG_REMOVED,
          description: `${j.name} was removed from ${g.name}.`
        });
      g.isRepeatable && !L.isRepeatable && O.push({
        type: l.DIRECTIVE_REPEATABLE_REMOVED,
        description: `Repeatable flag was removed from ${g.name}.`
      });
      for (const j of g.locations)
        L.locations.includes(j) || O.push({
          type: l.DIRECTIVE_LOCATION_REMOVED,
          description: `${j} was removed from ${g.name}.`
        });
    }
    return O;
  }
  function p(N, D) {
    const O = [], v = _(
      Object.values(N.getTypeMap()),
      Object.values(D.getTypeMap())
    );
    for (const g of v.removed)
      O.push({
        type: l.TYPE_REMOVED,
        description: (0, r.isSpecifiedScalarType)(g) ? `Standard scalar ${g.name} was removed because it is not referenced anymore.` : `${g.name} was removed.`
      });
    for (const [g, L] of v.persisted)
      (0, t.isEnumType)(g) && (0, t.isEnumType)(L) ? O.push(...y(g, L)) : (0, t.isUnionType)(g) && (0, t.isUnionType)(L) ? O.push(...T(g, L)) : (0, t.isInputObjectType)(g) && (0, t.isInputObjectType)(L) ? O.push(...b(g, L)) : (0, t.isObjectType)(g) && (0, t.isObjectType)(L) ? O.push(
        ...I(g, L),
        ...h(g, L)
      ) : (0, t.isInterfaceType)(g) && (0, t.isInterfaceType)(L) ? O.push(
        ...I(g, L),
        ...h(g, L)
      ) : g.constructor !== L.constructor && O.push({
        type: l.TYPE_CHANGED_KIND,
        description: `${g.name} changed from ${M(g)} to ${M(L)}.`
      });
    return O;
  }
  function b(N, D) {
    const O = [], v = _(
      Object.values(N.getFields()),
      Object.values(D.getFields())
    );
    for (const g of v.added)
      (0, t.isRequiredInputField)(g) ? O.push({
        type: l.REQUIRED_INPUT_FIELD_ADDED,
        description: `A required field ${g.name} on input type ${N.name} was added.`
      }) : O.push({
        type: d.OPTIONAL_INPUT_FIELD_ADDED,
        description: `An optional field ${g.name} on input type ${N.name} was added.`
      });
    for (const g of v.removed)
      O.push({
        type: l.FIELD_REMOVED,
        description: `${N.name}.${g.name} was removed.`
      });
    for (const [g, L] of v.persisted)
      k(
        g.type,
        L.type
      ) || O.push({
        type: l.FIELD_CHANGED_KIND,
        description: `${N.name}.${g.name} changed type from ${String(g.type)} to ${String(L.type)}.`
      });
    return O;
  }
  function T(N, D) {
    const O = [], v = _(N.getTypes(), D.getTypes());
    for (const g of v.added)
      O.push({
        type: d.TYPE_ADDED_TO_UNION,
        description: `${g.name} was added to union type ${N.name}.`
      });
    for (const g of v.removed)
      O.push({
        type: l.TYPE_REMOVED_FROM_UNION,
        description: `${g.name} was removed from union type ${N.name}.`
      });
    return O;
  }
  function y(N, D) {
    const O = [], v = _(N.getValues(), D.getValues());
    for (const g of v.added)
      O.push({
        type: d.VALUE_ADDED_TO_ENUM,
        description: `${g.name} was added to enum type ${N.name}.`
      });
    for (const g of v.removed)
      O.push({
        type: l.VALUE_REMOVED_FROM_ENUM,
        description: `${g.name} was removed from enum type ${N.name}.`
      });
    return O;
  }
  function h(N, D) {
    const O = [], v = _(N.getInterfaces(), D.getInterfaces());
    for (const g of v.added)
      O.push({
        type: d.IMPLEMENTED_INTERFACE_ADDED,
        description: `${g.name} added to interfaces implemented by ${N.name}.`
      });
    for (const g of v.removed)
      O.push({
        type: l.IMPLEMENTED_INTERFACE_REMOVED,
        description: `${N.name} no longer implements interface ${g.name}.`
      });
    return O;
  }
  function I(N, D) {
    const O = [], v = _(
      Object.values(N.getFields()),
      Object.values(D.getFields())
    );
    for (const g of v.removed)
      O.push({
        type: l.FIELD_REMOVED,
        description: `${N.name}.${g.name} was removed.`
      });
    for (const [g, L] of v.persisted)
      O.push(...S(N, g, L)), E(
        g.type,
        L.type
      ) || O.push({
        type: l.FIELD_CHANGED_KIND,
        description: `${N.name}.${g.name} changed type from ${String(g.type)} to ${String(L.type)}.`
      });
    return O;
  }
  function S(N, D, O) {
    const v = [], g = _(D.args, O.args);
    for (const L of g.removed)
      v.push({
        type: l.ARG_REMOVED,
        description: `${N.name}.${D.name} arg ${L.name} was removed.`
      });
    for (const [L, R] of g.persisted)
      if (!k(
        L.type,
        R.type
      ))
        v.push({
          type: l.ARG_CHANGED_KIND,
          description: `${N.name}.${D.name} arg ${L.name} has changed type from ${String(L.type)} to ${String(R.type)}.`
        });
      else if (L.defaultValue !== void 0)
        if (R.defaultValue === void 0)
          v.push({
            type: d.ARG_DEFAULT_VALUE_CHANGE,
            description: `${N.name}.${D.name} arg ${L.name} defaultValue was removed.`
          });
        else {
          const V = C(L.defaultValue, L.type), U = C(R.defaultValue, R.type);
          V !== U && v.push({
            type: d.ARG_DEFAULT_VALUE_CHANGE,
            description: `${N.name}.${D.name} arg ${L.name} has changed defaultValue from ${V} to ${U}.`
          });
        }
    for (const L of g.added)
      (0, t.isRequiredArgument)(L) ? v.push({
        type: l.REQUIRED_ARG_ADDED,
        description: `A required arg ${L.name} on ${N.name}.${D.name} was added.`
      }) : v.push({
        type: d.OPTIONAL_ARG_ADDED,
        description: `An optional arg ${L.name} on ${N.name}.${D.name} was added.`
      });
    return v;
  }
  function E(N, D) {
    return (0, t.isListType)(N) ? (
      // if they're both lists, make sure the underlying types are compatible
      (0, t.isListType)(D) && E(
        N.ofType,
        D.ofType
      ) || // moving from nullable to non-null of the same underlying type is safe
      (0, t.isNonNullType)(D) && E(N, D.ofType)
    ) : (0, t.isNonNullType)(N) ? (0, t.isNonNullType)(D) && E(N.ofType, D.ofType) : (
      // if they're both named types, see if their names are equivalent
      (0, t.isNamedType)(D) && N.name === D.name || // moving from nullable to non-null of the same underlying type is safe
      (0, t.isNonNullType)(D) && E(N, D.ofType)
    );
  }
  function k(N, D) {
    return (0, t.isListType)(N) ? (0, t.isListType)(D) && k(N.ofType, D.ofType) : (0, t.isNonNullType)(N) ? (
      // if they're both non-null, make sure the underlying types are
      // compatible
      (0, t.isNonNullType)(D) && k(
        N.ofType,
        D.ofType
      ) || // moving from non-null to nullable of the same underlying type is safe
      !(0, t.isNonNullType)(D) && k(N.ofType, D)
    ) : (0, t.isNamedType)(D) && N.name === D.name;
  }
  function M(N) {
    if ((0, t.isScalarType)(N))
      return "a Scalar type";
    if ((0, t.isObjectType)(N))
      return "an Object type";
    if ((0, t.isInterfaceType)(N))
      return "an Interface type";
    if ((0, t.isUnionType)(N))
      return "a Union type";
    if ((0, t.isEnumType)(N))
      return "an Enum type";
    if ((0, t.isInputObjectType)(N))
      return "an Input type";
    (0, n.invariant)(
      !1,
      "Unexpected type: " + (0, e.inspect)(N)
    );
  }
  function C(N, D) {
    const O = (0, o.astFromValue)(N, D);
    return O != null || (0, n.invariant)(!1), (0, i.print)((0, s.sortValueNode)(O));
  }
  function _(N, D) {
    const O = [], v = [], g = [], L = (0, a.keyMap)(N, ({ name: j }) => j), R = (0, a.keyMap)(D, ({ name: j }) => j);
    for (const j of N) {
      const V = R[j.name];
      V === void 0 ? v.push(j) : g.push([j, V]);
    }
    for (const j of D)
      L[j.name] === void 0 && O.push(j);
    return {
      added: O,
      persisted: g,
      removed: v
    };
  }
  return Ve;
}
var Qn = {}, Vs;
function rc() {
  if (Vs) return Qn;
  Vs = 1, Object.defineProperty(Qn, "__esModule", {
    value: !0
  }), Qn.resolveASTSchemaCoordinate = f, Qn.resolveSchemaCoordinate = t;
  var e = /* @__PURE__ */ de(), n = /* @__PURE__ */ se(), a = /* @__PURE__ */ On(), i = /* @__PURE__ */ oe();
  function t(u, c) {
    return f(
      u,
      (0, a.parseSchemaCoordinate)(c)
    );
  }
  function r(u, c) {
    const m = c.name.value, p = u.getType(m);
    if (p != null)
      return {
        kind: "NamedType",
        type: p
      };
  }
  function o(u, c) {
    const m = c.name.value, p = u.getType(m);
    if (!p)
      throw new Error(
        `Expected ${(0, e.inspect)(
          m
        )} to be defined as a type in the schema.`
      );
    if (!(0, i.isEnumType)(p) && !(0, i.isInputObjectType)(p) && !(0, i.isObjectType)(p) && !(0, i.isInterfaceType)(p))
      throw new Error(
        `Expected ${(0, e.inspect)(
          m
        )} to be an Enum, Input Object, Object or Interface type.`
      );
    if ((0, i.isEnumType)(p)) {
      const y = c.memberName.value, h = p.getValue(y);
      return h == null ? void 0 : {
        kind: "EnumValue",
        type: p,
        enumValue: h
      };
    }
    if ((0, i.isInputObjectType)(p)) {
      const y = c.memberName.value, h = p.getFields()[y];
      return h == null ? void 0 : {
        kind: "InputField",
        type: p,
        inputField: h
      };
    }
    const b = c.memberName.value, T = p.getFields()[b];
    if (T != null)
      return {
        kind: "Field",
        type: p,
        field: T
      };
  }
  function s(u, c) {
    const m = c.name.value, p = u.getType(m);
    if (p == null)
      throw new Error(
        `Expected ${(0, e.inspect)(
          m
        )} to be defined as a type in the schema.`
      );
    if (!(0, i.isObjectType)(p) && !(0, i.isInterfaceType)(p))
      throw new Error(
        `Expected ${(0, e.inspect)(
          m
        )} to be an object type or interface type.`
      );
    const b = c.fieldName.value, T = p.getFields()[b];
    if (T == null)
      throw new Error(
        `Expected ${(0, e.inspect)(
          b
        )} to exist as a field of type ${(0, e.inspect)(
          m
        )} in the schema.`
      );
    const y = c.argumentName.value, h = T.args.find(
      (I) => I.name === y
    );
    if (h != null)
      return {
        kind: "FieldArgument",
        type: p,
        field: T,
        fieldArgument: h
      };
  }
  function l(u, c) {
    const m = c.name.value, p = u.getDirective(m);
    if (p)
      return {
        kind: "Directive",
        directive: p
      };
  }
  function d(u, c) {
    const m = c.name.value, p = u.getDirective(m);
    if (!p)
      throw new Error(
        `Expected ${(0, e.inspect)(
          m
        )} to be defined as a directive in the schema.`
      );
    const {
      argumentName: { value: b }
    } = c, T = p.args.find(
      (y) => y.name === b
    );
    if (T)
      return {
        kind: "DirectiveArgument",
        directive: p,
        directiveArgument: T
      };
  }
  function f(u, c) {
    switch (c.kind) {
      case n.Kind.TYPE_COORDINATE:
        return r(u, c);
      case n.Kind.MEMBER_COORDINATE:
        return o(u, c);
      case n.Kind.ARGUMENT_COORDINATE:
        return s(u, c);
      case n.Kind.DIRECTIVE_COORDINATE:
        return l(u, c);
      case n.Kind.DIRECTIVE_ARGUMENT_COORDINATE:
        return d(u, c);
    }
  }
  return Qn;
}
var Cs;
function ic() {
  return Cs || (Cs = 1, (function(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), Object.defineProperty(e, "BreakingChangeType", {
      enumerable: !0,
      get: function() {
        return E.BreakingChangeType;
      }
    }), Object.defineProperty(e, "DangerousChangeType", {
      enumerable: !0,
      get: function() {
        return E.DangerousChangeType;
      }
    }), Object.defineProperty(e, "TypeInfo", {
      enumerable: !0,
      get: function() {
        return p.TypeInfo;
      }
    }), Object.defineProperty(e, "assertValidName", {
      enumerable: !0,
      get: function() {
        return S.assertValidName;
      }
    }), Object.defineProperty(e, "astFromValue", {
      enumerable: !0,
      get: function() {
        return m.astFromValue;
      }
    }), Object.defineProperty(e, "buildASTSchema", {
      enumerable: !0,
      get: function() {
        return o.buildASTSchema;
      }
    }), Object.defineProperty(e, "buildClientSchema", {
      enumerable: !0,
      get: function() {
        return r.buildClientSchema;
      }
    }), Object.defineProperty(e, "buildSchema", {
      enumerable: !0,
      get: function() {
        return o.buildSchema;
      }
    }), Object.defineProperty(e, "coerceInputValue", {
      enumerable: !0,
      get: function() {
        return b.coerceInputValue;
      }
    }), Object.defineProperty(e, "concatAST", {
      enumerable: !0,
      get: function() {
        return T.concatAST;
      }
    }), Object.defineProperty(e, "doTypesOverlap", {
      enumerable: !0,
      get: function() {
        return I.doTypesOverlap;
      }
    }), Object.defineProperty(e, "extendSchema", {
      enumerable: !0,
      get: function() {
        return s.extendSchema;
      }
    }), Object.defineProperty(e, "findBreakingChanges", {
      enumerable: !0,
      get: function() {
        return E.findBreakingChanges;
      }
    }), Object.defineProperty(e, "findDangerousChanges", {
      enumerable: !0,
      get: function() {
        return E.findDangerousChanges;
      }
    }), Object.defineProperty(e, "getIntrospectionQuery", {
      enumerable: !0,
      get: function() {
        return n.getIntrospectionQuery;
      }
    }), Object.defineProperty(e, "getOperationAST", {
      enumerable: !0,
      get: function() {
        return a.getOperationAST;
      }
    }), Object.defineProperty(e, "getOperationRootType", {
      enumerable: !0,
      get: function() {
        return i.getOperationRootType;
      }
    }), Object.defineProperty(e, "introspectionFromSchema", {
      enumerable: !0,
      get: function() {
        return t.introspectionFromSchema;
      }
    }), Object.defineProperty(e, "isEqualType", {
      enumerable: !0,
      get: function() {
        return I.isEqualType;
      }
    }), Object.defineProperty(e, "isTypeSubTypeOf", {
      enumerable: !0,
      get: function() {
        return I.isTypeSubTypeOf;
      }
    }), Object.defineProperty(e, "isValidNameError", {
      enumerable: !0,
      get: function() {
        return S.isValidNameError;
      }
    }), Object.defineProperty(e, "lexicographicSortSchema", {
      enumerable: !0,
      get: function() {
        return l.lexicographicSortSchema;
      }
    }), Object.defineProperty(e, "printIntrospectionSchema", {
      enumerable: !0,
      get: function() {
        return d.printIntrospectionSchema;
      }
    }), Object.defineProperty(e, "printSchema", {
      enumerable: !0,
      get: function() {
        return d.printSchema;
      }
    }), Object.defineProperty(e, "printType", {
      enumerable: !0,
      get: function() {
        return d.printType;
      }
    }), Object.defineProperty(e, "resolveASTSchemaCoordinate", {
      enumerable: !0,
      get: function() {
        return k.resolveASTSchemaCoordinate;
      }
    }), Object.defineProperty(e, "resolveSchemaCoordinate", {
      enumerable: !0,
      get: function() {
        return k.resolveSchemaCoordinate;
      }
    }), Object.defineProperty(e, "separateOperations", {
      enumerable: !0,
      get: function() {
        return y.separateOperations;
      }
    }), Object.defineProperty(e, "stripIgnoredCharacters", {
      enumerable: !0,
      get: function() {
        return h.stripIgnoredCharacters;
      }
    }), Object.defineProperty(e, "typeFromAST", {
      enumerable: !0,
      get: function() {
        return f.typeFromAST;
      }
    }), Object.defineProperty(e, "valueFromAST", {
      enumerable: !0,
      get: function() {
        return u.valueFromAST;
      }
    }), Object.defineProperty(e, "valueFromASTUntyped", {
      enumerable: !0,
      get: function() {
        return c.valueFromASTUntyped;
      }
    }), Object.defineProperty(e, "visitWithTypeInfo", {
      enumerable: !0,
      get: function() {
        return p.visitWithTypeInfo;
      }
    });
    var n = /* @__PURE__ */ Mo(), a = /* @__PURE__ */ Bu(), i = /* @__PURE__ */ xu(), t = /* @__PURE__ */ Yu(), r = /* @__PURE__ */ Ju(), o = /* @__PURE__ */ zu(), s = /* @__PURE__ */ $o(), l = /* @__PURE__ */ Xu(), d = /* @__PURE__ */ Hu(), f = /* @__PURE__ */ He(), u = /* @__PURE__ */ Gr(), c = /* @__PURE__ */ Hs(), m = /* @__PURE__ */ wr(), p = /* @__PURE__ */ ui(), b = /* @__PURE__ */ Eo(), T = /* @__PURE__ */ Wu(), y = /* @__PURE__ */ Zu(), h = /* @__PURE__ */ ec(), I = /* @__PURE__ */ Fr(), S = /* @__PURE__ */ nc(), E = /* @__PURE__ */ tc(), k = /* @__PURE__ */ rc();
  })(Jr)), Jr;
}
var Gs;
function ac() {
  return Gs || (Gs = 1, (function(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), Object.defineProperty(e, "BREAK", {
      enumerable: !0,
      get: function() {
        return t.BREAK;
      }
    }), Object.defineProperty(e, "BreakingChangeType", {
      enumerable: !0,
      get: function() {
        return l.BreakingChangeType;
      }
    }), Object.defineProperty(e, "DEFAULT_DEPRECATION_REASON", {
      enumerable: !0,
      get: function() {
        return i.DEFAULT_DEPRECATION_REASON;
      }
    }), Object.defineProperty(e, "DangerousChangeType", {
      enumerable: !0,
      get: function() {
        return l.DangerousChangeType;
      }
    }), Object.defineProperty(e, "DirectiveLocation", {
      enumerable: !0,
      get: function() {
        return t.DirectiveLocation;
      }
    }), Object.defineProperty(e, "ExecutableDefinitionsRule", {
      enumerable: !0,
      get: function() {
        return o.ExecutableDefinitionsRule;
      }
    }), Object.defineProperty(e, "FieldsOnCorrectTypeRule", {
      enumerable: !0,
      get: function() {
        return o.FieldsOnCorrectTypeRule;
      }
    }), Object.defineProperty(e, "FragmentsOnCompositeTypesRule", {
      enumerable: !0,
      get: function() {
        return o.FragmentsOnCompositeTypesRule;
      }
    }), Object.defineProperty(e, "GRAPHQL_MAX_INT", {
      enumerable: !0,
      get: function() {
        return i.GRAPHQL_MAX_INT;
      }
    }), Object.defineProperty(e, "GRAPHQL_MIN_INT", {
      enumerable: !0,
      get: function() {
        return i.GRAPHQL_MIN_INT;
      }
    }), Object.defineProperty(e, "GraphQLBoolean", {
      enumerable: !0,
      get: function() {
        return i.GraphQLBoolean;
      }
    }), Object.defineProperty(e, "GraphQLDeprecatedDirective", {
      enumerable: !0,
      get: function() {
        return i.GraphQLDeprecatedDirective;
      }
    }), Object.defineProperty(e, "GraphQLDirective", {
      enumerable: !0,
      get: function() {
        return i.GraphQLDirective;
      }
    }), Object.defineProperty(e, "GraphQLEnumType", {
      enumerable: !0,
      get: function() {
        return i.GraphQLEnumType;
      }
    }), Object.defineProperty(e, "GraphQLError", {
      enumerable: !0,
      get: function() {
        return s.GraphQLError;
      }
    }), Object.defineProperty(e, "GraphQLFloat", {
      enumerable: !0,
      get: function() {
        return i.GraphQLFloat;
      }
    }), Object.defineProperty(e, "GraphQLID", {
      enumerable: !0,
      get: function() {
        return i.GraphQLID;
      }
    }), Object.defineProperty(e, "GraphQLIncludeDirective", {
      enumerable: !0,
      get: function() {
        return i.GraphQLIncludeDirective;
      }
    }), Object.defineProperty(e, "GraphQLInputObjectType", {
      enumerable: !0,
      get: function() {
        return i.GraphQLInputObjectType;
      }
    }), Object.defineProperty(e, "GraphQLInt", {
      enumerable: !0,
      get: function() {
        return i.GraphQLInt;
      }
    }), Object.defineProperty(e, "GraphQLInterfaceType", {
      enumerable: !0,
      get: function() {
        return i.GraphQLInterfaceType;
      }
    }), Object.defineProperty(e, "GraphQLList", {
      enumerable: !0,
      get: function() {
        return i.GraphQLList;
      }
    }), Object.defineProperty(e, "GraphQLNonNull", {
      enumerable: !0,
      get: function() {
        return i.GraphQLNonNull;
      }
    }), Object.defineProperty(e, "GraphQLObjectType", {
      enumerable: !0,
      get: function() {
        return i.GraphQLObjectType;
      }
    }), Object.defineProperty(e, "GraphQLOneOfDirective", {
      enumerable: !0,
      get: function() {
        return i.GraphQLOneOfDirective;
      }
    }), Object.defineProperty(e, "GraphQLScalarType", {
      enumerable: !0,
      get: function() {
        return i.GraphQLScalarType;
      }
    }), Object.defineProperty(e, "GraphQLSchema", {
      enumerable: !0,
      get: function() {
        return i.GraphQLSchema;
      }
    }), Object.defineProperty(e, "GraphQLSkipDirective", {
      enumerable: !0,
      get: function() {
        return i.GraphQLSkipDirective;
      }
    }), Object.defineProperty(e, "GraphQLSpecifiedByDirective", {
      enumerable: !0,
      get: function() {
        return i.GraphQLSpecifiedByDirective;
      }
    }), Object.defineProperty(e, "GraphQLString", {
      enumerable: !0,
      get: function() {
        return i.GraphQLString;
      }
    }), Object.defineProperty(e, "GraphQLUnionType", {
      enumerable: !0,
      get: function() {
        return i.GraphQLUnionType;
      }
    }), Object.defineProperty(e, "Kind", {
      enumerable: !0,
      get: function() {
        return t.Kind;
      }
    }), Object.defineProperty(e, "KnownArgumentNamesRule", {
      enumerable: !0,
      get: function() {
        return o.KnownArgumentNamesRule;
      }
    }), Object.defineProperty(e, "KnownDirectivesRule", {
      enumerable: !0,
      get: function() {
        return o.KnownDirectivesRule;
      }
    }), Object.defineProperty(e, "KnownFragmentNamesRule", {
      enumerable: !0,
      get: function() {
        return o.KnownFragmentNamesRule;
      }
    }), Object.defineProperty(e, "KnownTypeNamesRule", {
      enumerable: !0,
      get: function() {
        return o.KnownTypeNamesRule;
      }
    }), Object.defineProperty(e, "Lexer", {
      enumerable: !0,
      get: function() {
        return t.Lexer;
      }
    }), Object.defineProperty(e, "Location", {
      enumerable: !0,
      get: function() {
        return t.Location;
      }
    }), Object.defineProperty(e, "LoneAnonymousOperationRule", {
      enumerable: !0,
      get: function() {
        return o.LoneAnonymousOperationRule;
      }
    }), Object.defineProperty(e, "LoneSchemaDefinitionRule", {
      enumerable: !0,
      get: function() {
        return o.LoneSchemaDefinitionRule;
      }
    }), Object.defineProperty(e, "MaxIntrospectionDepthRule", {
      enumerable: !0,
      get: function() {
        return o.MaxIntrospectionDepthRule;
      }
    }), Object.defineProperty(e, "NoDeprecatedCustomRule", {
      enumerable: !0,
      get: function() {
        return o.NoDeprecatedCustomRule;
      }
    }), Object.defineProperty(e, "NoFragmentCyclesRule", {
      enumerable: !0,
      get: function() {
        return o.NoFragmentCyclesRule;
      }
    }), Object.defineProperty(e, "NoSchemaIntrospectionCustomRule", {
      enumerable: !0,
      get: function() {
        return o.NoSchemaIntrospectionCustomRule;
      }
    }), Object.defineProperty(e, "NoUndefinedVariablesRule", {
      enumerable: !0,
      get: function() {
        return o.NoUndefinedVariablesRule;
      }
    }), Object.defineProperty(e, "NoUnusedFragmentsRule", {
      enumerable: !0,
      get: function() {
        return o.NoUnusedFragmentsRule;
      }
    }), Object.defineProperty(e, "NoUnusedVariablesRule", {
      enumerable: !0,
      get: function() {
        return o.NoUnusedVariablesRule;
      }
    }), Object.defineProperty(e, "OperationTypeNode", {
      enumerable: !0,
      get: function() {
        return t.OperationTypeNode;
      }
    }), Object.defineProperty(e, "OverlappingFieldsCanBeMergedRule", {
      enumerable: !0,
      get: function() {
        return o.OverlappingFieldsCanBeMergedRule;
      }
    }), Object.defineProperty(e, "PossibleFragmentSpreadsRule", {
      enumerable: !0,
      get: function() {
        return o.PossibleFragmentSpreadsRule;
      }
    }), Object.defineProperty(e, "PossibleTypeExtensionsRule", {
      enumerable: !0,
      get: function() {
        return o.PossibleTypeExtensionsRule;
      }
    }), Object.defineProperty(e, "ProvidedRequiredArgumentsRule", {
      enumerable: !0,
      get: function() {
        return o.ProvidedRequiredArgumentsRule;
      }
    }), Object.defineProperty(e, "ScalarLeafsRule", {
      enumerable: !0,
      get: function() {
        return o.ScalarLeafsRule;
      }
    }), Object.defineProperty(e, "SchemaMetaFieldDef", {
      enumerable: !0,
      get: function() {
        return i.SchemaMetaFieldDef;
      }
    }), Object.defineProperty(e, "SingleFieldSubscriptionsRule", {
      enumerable: !0,
      get: function() {
        return o.SingleFieldSubscriptionsRule;
      }
    }), Object.defineProperty(e, "Source", {
      enumerable: !0,
      get: function() {
        return t.Source;
      }
    }), Object.defineProperty(e, "Token", {
      enumerable: !0,
      get: function() {
        return t.Token;
      }
    }), Object.defineProperty(e, "TokenKind", {
      enumerable: !0,
      get: function() {
        return t.TokenKind;
      }
    }), Object.defineProperty(e, "TypeInfo", {
      enumerable: !0,
      get: function() {
        return l.TypeInfo;
      }
    }), Object.defineProperty(e, "TypeKind", {
      enumerable: !0,
      get: function() {
        return i.TypeKind;
      }
    }), Object.defineProperty(e, "TypeMetaFieldDef", {
      enumerable: !0,
      get: function() {
        return i.TypeMetaFieldDef;
      }
    }), Object.defineProperty(e, "TypeNameMetaFieldDef", {
      enumerable: !0,
      get: function() {
        return i.TypeNameMetaFieldDef;
      }
    }), Object.defineProperty(e, "UniqueArgumentDefinitionNamesRule", {
      enumerable: !0,
      get: function() {
        return o.UniqueArgumentDefinitionNamesRule;
      }
    }), Object.defineProperty(e, "UniqueArgumentNamesRule", {
      enumerable: !0,
      get: function() {
        return o.UniqueArgumentNamesRule;
      }
    }), Object.defineProperty(e, "UniqueDirectiveNamesRule", {
      enumerable: !0,
      get: function() {
        return o.UniqueDirectiveNamesRule;
      }
    }), Object.defineProperty(e, "UniqueDirectivesPerLocationRule", {
      enumerable: !0,
      get: function() {
        return o.UniqueDirectivesPerLocationRule;
      }
    }), Object.defineProperty(e, "UniqueEnumValueNamesRule", {
      enumerable: !0,
      get: function() {
        return o.UniqueEnumValueNamesRule;
      }
    }), Object.defineProperty(e, "UniqueFieldDefinitionNamesRule", {
      enumerable: !0,
      get: function() {
        return o.UniqueFieldDefinitionNamesRule;
      }
    }), Object.defineProperty(e, "UniqueFragmentNamesRule", {
      enumerable: !0,
      get: function() {
        return o.UniqueFragmentNamesRule;
      }
    }), Object.defineProperty(e, "UniqueInputFieldNamesRule", {
      enumerable: !0,
      get: function() {
        return o.UniqueInputFieldNamesRule;
      }
    }), Object.defineProperty(e, "UniqueOperationNamesRule", {
      enumerable: !0,
      get: function() {
        return o.UniqueOperationNamesRule;
      }
    }), Object.defineProperty(e, "UniqueOperationTypesRule", {
      enumerable: !0,
      get: function() {
        return o.UniqueOperationTypesRule;
      }
    }), Object.defineProperty(e, "UniqueTypeNamesRule", {
      enumerable: !0,
      get: function() {
        return o.UniqueTypeNamesRule;
      }
    }), Object.defineProperty(e, "UniqueVariableNamesRule", {
      enumerable: !0,
      get: function() {
        return o.UniqueVariableNamesRule;
      }
    }), Object.defineProperty(e, "ValidationContext", {
      enumerable: !0,
      get: function() {
        return o.ValidationContext;
      }
    }), Object.defineProperty(e, "ValuesOfCorrectTypeRule", {
      enumerable: !0,
      get: function() {
        return o.ValuesOfCorrectTypeRule;
      }
    }), Object.defineProperty(e, "VariablesAreInputTypesRule", {
      enumerable: !0,
      get: function() {
        return o.VariablesAreInputTypesRule;
      }
    }), Object.defineProperty(e, "VariablesInAllowedPositionRule", {
      enumerable: !0,
      get: function() {
        return o.VariablesInAllowedPositionRule;
      }
    }), Object.defineProperty(e, "__Directive", {
      enumerable: !0,
      get: function() {
        return i.__Directive;
      }
    }), Object.defineProperty(e, "__DirectiveLocation", {
      enumerable: !0,
      get: function() {
        return i.__DirectiveLocation;
      }
    }), Object.defineProperty(e, "__EnumValue", {
      enumerable: !0,
      get: function() {
        return i.__EnumValue;
      }
    }), Object.defineProperty(e, "__Field", {
      enumerable: !0,
      get: function() {
        return i.__Field;
      }
    }), Object.defineProperty(e, "__InputValue", {
      enumerable: !0,
      get: function() {
        return i.__InputValue;
      }
    }), Object.defineProperty(e, "__Schema", {
      enumerable: !0,
      get: function() {
        return i.__Schema;
      }
    }), Object.defineProperty(e, "__Type", {
      enumerable: !0,
      get: function() {
        return i.__Type;
      }
    }), Object.defineProperty(e, "__TypeKind", {
      enumerable: !0,
      get: function() {
        return i.__TypeKind;
      }
    }), Object.defineProperty(e, "assertAbstractType", {
      enumerable: !0,
      get: function() {
        return i.assertAbstractType;
      }
    }), Object.defineProperty(e, "assertCompositeType", {
      enumerable: !0,
      get: function() {
        return i.assertCompositeType;
      }
    }), Object.defineProperty(e, "assertDirective", {
      enumerable: !0,
      get: function() {
        return i.assertDirective;
      }
    }), Object.defineProperty(e, "assertEnumType", {
      enumerable: !0,
      get: function() {
        return i.assertEnumType;
      }
    }), Object.defineProperty(e, "assertEnumValueName", {
      enumerable: !0,
      get: function() {
        return i.assertEnumValueName;
      }
    }), Object.defineProperty(e, "assertInputObjectType", {
      enumerable: !0,
      get: function() {
        return i.assertInputObjectType;
      }
    }), Object.defineProperty(e, "assertInputType", {
      enumerable: !0,
      get: function() {
        return i.assertInputType;
      }
    }), Object.defineProperty(e, "assertInterfaceType", {
      enumerable: !0,
      get: function() {
        return i.assertInterfaceType;
      }
    }), Object.defineProperty(e, "assertLeafType", {
      enumerable: !0,
      get: function() {
        return i.assertLeafType;
      }
    }), Object.defineProperty(e, "assertListType", {
      enumerable: !0,
      get: function() {
        return i.assertListType;
      }
    }), Object.defineProperty(e, "assertName", {
      enumerable: !0,
      get: function() {
        return i.assertName;
      }
    }), Object.defineProperty(e, "assertNamedType", {
      enumerable: !0,
      get: function() {
        return i.assertNamedType;
      }
    }), Object.defineProperty(e, "assertNonNullType", {
      enumerable: !0,
      get: function() {
        return i.assertNonNullType;
      }
    }), Object.defineProperty(e, "assertNullableType", {
      enumerable: !0,
      get: function() {
        return i.assertNullableType;
      }
    }), Object.defineProperty(e, "assertObjectType", {
      enumerable: !0,
      get: function() {
        return i.assertObjectType;
      }
    }), Object.defineProperty(e, "assertOutputType", {
      enumerable: !0,
      get: function() {
        return i.assertOutputType;
      }
    }), Object.defineProperty(e, "assertScalarType", {
      enumerable: !0,
      get: function() {
        return i.assertScalarType;
      }
    }), Object.defineProperty(e, "assertSchema", {
      enumerable: !0,
      get: function() {
        return i.assertSchema;
      }
    }), Object.defineProperty(e, "assertType", {
      enumerable: !0,
      get: function() {
        return i.assertType;
      }
    }), Object.defineProperty(e, "assertUnionType", {
      enumerable: !0,
      get: function() {
        return i.assertUnionType;
      }
    }), Object.defineProperty(e, "assertValidName", {
      enumerable: !0,
      get: function() {
        return l.assertValidName;
      }
    }), Object.defineProperty(e, "assertValidSchema", {
      enumerable: !0,
      get: function() {
        return i.assertValidSchema;
      }
    }), Object.defineProperty(e, "assertWrappingType", {
      enumerable: !0,
      get: function() {
        return i.assertWrappingType;
      }
    }), Object.defineProperty(e, "astFromValue", {
      enumerable: !0,
      get: function() {
        return l.astFromValue;
      }
    }), Object.defineProperty(e, "buildASTSchema", {
      enumerable: !0,
      get: function() {
        return l.buildASTSchema;
      }
    }), Object.defineProperty(e, "buildClientSchema", {
      enumerable: !0,
      get: function() {
        return l.buildClientSchema;
      }
    }), Object.defineProperty(e, "buildSchema", {
      enumerable: !0,
      get: function() {
        return l.buildSchema;
      }
    }), Object.defineProperty(e, "coerceInputValue", {
      enumerable: !0,
      get: function() {
        return l.coerceInputValue;
      }
    }), Object.defineProperty(e, "concatAST", {
      enumerable: !0,
      get: function() {
        return l.concatAST;
      }
    }), Object.defineProperty(e, "createSourceEventStream", {
      enumerable: !0,
      get: function() {
        return r.createSourceEventStream;
      }
    }), Object.defineProperty(e, "defaultFieldResolver", {
      enumerable: !0,
      get: function() {
        return r.defaultFieldResolver;
      }
    }), Object.defineProperty(e, "defaultTypeResolver", {
      enumerable: !0,
      get: function() {
        return r.defaultTypeResolver;
      }
    }), Object.defineProperty(e, "doTypesOverlap", {
      enumerable: !0,
      get: function() {
        return l.doTypesOverlap;
      }
    }), Object.defineProperty(e, "execute", {
      enumerable: !0,
      get: function() {
        return r.execute;
      }
    }), Object.defineProperty(e, "executeSync", {
      enumerable: !0,
      get: function() {
        return r.executeSync;
      }
    }), Object.defineProperty(e, "extendSchema", {
      enumerable: !0,
      get: function() {
        return l.extendSchema;
      }
    }), Object.defineProperty(e, "findBreakingChanges", {
      enumerable: !0,
      get: function() {
        return l.findBreakingChanges;
      }
    }), Object.defineProperty(e, "findDangerousChanges", {
      enumerable: !0,
      get: function() {
        return l.findDangerousChanges;
      }
    }), Object.defineProperty(e, "formatError", {
      enumerable: !0,
      get: function() {
        return s.formatError;
      }
    }), Object.defineProperty(e, "getArgumentValues", {
      enumerable: !0,
      get: function() {
        return r.getArgumentValues;
      }
    }), Object.defineProperty(e, "getDirectiveValues", {
      enumerable: !0,
      get: function() {
        return r.getDirectiveValues;
      }
    }), Object.defineProperty(e, "getEnterLeaveForKind", {
      enumerable: !0,
      get: function() {
        return t.getEnterLeaveForKind;
      }
    }), Object.defineProperty(e, "getIntrospectionQuery", {
      enumerable: !0,
      get: function() {
        return l.getIntrospectionQuery;
      }
    }), Object.defineProperty(e, "getLocation", {
      enumerable: !0,
      get: function() {
        return t.getLocation;
      }
    }), Object.defineProperty(e, "getNamedType", {
      enumerable: !0,
      get: function() {
        return i.getNamedType;
      }
    }), Object.defineProperty(e, "getNullableType", {
      enumerable: !0,
      get: function() {
        return i.getNullableType;
      }
    }), Object.defineProperty(e, "getOperationAST", {
      enumerable: !0,
      get: function() {
        return l.getOperationAST;
      }
    }), Object.defineProperty(e, "getOperationRootType", {
      enumerable: !0,
      get: function() {
        return l.getOperationRootType;
      }
    }), Object.defineProperty(e, "getVariableValues", {
      enumerable: !0,
      get: function() {
        return r.getVariableValues;
      }
    }), Object.defineProperty(e, "getVisitFn", {
      enumerable: !0,
      get: function() {
        return t.getVisitFn;
      }
    }), Object.defineProperty(e, "graphql", {
      enumerable: !0,
      get: function() {
        return a.graphql;
      }
    }), Object.defineProperty(e, "graphqlSync", {
      enumerable: !0,
      get: function() {
        return a.graphqlSync;
      }
    }), Object.defineProperty(e, "introspectionFromSchema", {
      enumerable: !0,
      get: function() {
        return l.introspectionFromSchema;
      }
    }), Object.defineProperty(e, "introspectionTypes", {
      enumerable: !0,
      get: function() {
        return i.introspectionTypes;
      }
    }), Object.defineProperty(e, "isAbstractType", {
      enumerable: !0,
      get: function() {
        return i.isAbstractType;
      }
    }), Object.defineProperty(e, "isCompositeType", {
      enumerable: !0,
      get: function() {
        return i.isCompositeType;
      }
    }), Object.defineProperty(e, "isConstValueNode", {
      enumerable: !0,
      get: function() {
        return t.isConstValueNode;
      }
    }), Object.defineProperty(e, "isDefinitionNode", {
      enumerable: !0,
      get: function() {
        return t.isDefinitionNode;
      }
    }), Object.defineProperty(e, "isDirective", {
      enumerable: !0,
      get: function() {
        return i.isDirective;
      }
    }), Object.defineProperty(e, "isEnumType", {
      enumerable: !0,
      get: function() {
        return i.isEnumType;
      }
    }), Object.defineProperty(e, "isEqualType", {
      enumerable: !0,
      get: function() {
        return l.isEqualType;
      }
    }), Object.defineProperty(e, "isExecutableDefinitionNode", {
      enumerable: !0,
      get: function() {
        return t.isExecutableDefinitionNode;
      }
    }), Object.defineProperty(e, "isInputObjectType", {
      enumerable: !0,
      get: function() {
        return i.isInputObjectType;
      }
    }), Object.defineProperty(e, "isInputType", {
      enumerable: !0,
      get: function() {
        return i.isInputType;
      }
    }), Object.defineProperty(e, "isInterfaceType", {
      enumerable: !0,
      get: function() {
        return i.isInterfaceType;
      }
    }), Object.defineProperty(e, "isIntrospectionType", {
      enumerable: !0,
      get: function() {
        return i.isIntrospectionType;
      }
    }), Object.defineProperty(e, "isLeafType", {
      enumerable: !0,
      get: function() {
        return i.isLeafType;
      }
    }), Object.defineProperty(e, "isListType", {
      enumerable: !0,
      get: function() {
        return i.isListType;
      }
    }), Object.defineProperty(e, "isNamedType", {
      enumerable: !0,
      get: function() {
        return i.isNamedType;
      }
    }), Object.defineProperty(e, "isNonNullType", {
      enumerable: !0,
      get: function() {
        return i.isNonNullType;
      }
    }), Object.defineProperty(e, "isNullableType", {
      enumerable: !0,
      get: function() {
        return i.isNullableType;
      }
    }), Object.defineProperty(e, "isObjectType", {
      enumerable: !0,
      get: function() {
        return i.isObjectType;
      }
    }), Object.defineProperty(e, "isOutputType", {
      enumerable: !0,
      get: function() {
        return i.isOutputType;
      }
    }), Object.defineProperty(e, "isRequiredArgument", {
      enumerable: !0,
      get: function() {
        return i.isRequiredArgument;
      }
    }), Object.defineProperty(e, "isRequiredInputField", {
      enumerable: !0,
      get: function() {
        return i.isRequiredInputField;
      }
    }), Object.defineProperty(e, "isScalarType", {
      enumerable: !0,
      get: function() {
        return i.isScalarType;
      }
    }), Object.defineProperty(e, "isSchema", {
      enumerable: !0,
      get: function() {
        return i.isSchema;
      }
    }), Object.defineProperty(e, "isSchemaCoordinateNode", {
      enumerable: !0,
      get: function() {
        return t.isSchemaCoordinateNode;
      }
    }), Object.defineProperty(e, "isSelectionNode", {
      enumerable: !0,
      get: function() {
        return t.isSelectionNode;
      }
    }), Object.defineProperty(e, "isSpecifiedDirective", {
      enumerable: !0,
      get: function() {
        return i.isSpecifiedDirective;
      }
    }), Object.defineProperty(e, "isSpecifiedScalarType", {
      enumerable: !0,
      get: function() {
        return i.isSpecifiedScalarType;
      }
    }), Object.defineProperty(e, "isType", {
      enumerable: !0,
      get: function() {
        return i.isType;
      }
    }), Object.defineProperty(e, "isTypeDefinitionNode", {
      enumerable: !0,
      get: function() {
        return t.isTypeDefinitionNode;
      }
    }), Object.defineProperty(e, "isTypeExtensionNode", {
      enumerable: !0,
      get: function() {
        return t.isTypeExtensionNode;
      }
    }), Object.defineProperty(e, "isTypeNode", {
      enumerable: !0,
      get: function() {
        return t.isTypeNode;
      }
    }), Object.defineProperty(e, "isTypeSubTypeOf", {
      enumerable: !0,
      get: function() {
        return l.isTypeSubTypeOf;
      }
    }), Object.defineProperty(e, "isTypeSystemDefinitionNode", {
      enumerable: !0,
      get: function() {
        return t.isTypeSystemDefinitionNode;
      }
    }), Object.defineProperty(e, "isTypeSystemExtensionNode", {
      enumerable: !0,
      get: function() {
        return t.isTypeSystemExtensionNode;
      }
    }), Object.defineProperty(e, "isUnionType", {
      enumerable: !0,
      get: function() {
        return i.isUnionType;
      }
    }), Object.defineProperty(e, "isValidNameError", {
      enumerable: !0,
      get: function() {
        return l.isValidNameError;
      }
    }), Object.defineProperty(e, "isValueNode", {
      enumerable: !0,
      get: function() {
        return t.isValueNode;
      }
    }), Object.defineProperty(e, "isWrappingType", {
      enumerable: !0,
      get: function() {
        return i.isWrappingType;
      }
    }), Object.defineProperty(e, "lexicographicSortSchema", {
      enumerable: !0,
      get: function() {
        return l.lexicographicSortSchema;
      }
    }), Object.defineProperty(e, "locatedError", {
      enumerable: !0,
      get: function() {
        return s.locatedError;
      }
    }), Object.defineProperty(e, "parse", {
      enumerable: !0,
      get: function() {
        return t.parse;
      }
    }), Object.defineProperty(e, "parseConstValue", {
      enumerable: !0,
      get: function() {
        return t.parseConstValue;
      }
    }), Object.defineProperty(e, "parseSchemaCoordinate", {
      enumerable: !0,
      get: function() {
        return t.parseSchemaCoordinate;
      }
    }), Object.defineProperty(e, "parseType", {
      enumerable: !0,
      get: function() {
        return t.parseType;
      }
    }), Object.defineProperty(e, "parseValue", {
      enumerable: !0,
      get: function() {
        return t.parseValue;
      }
    }), Object.defineProperty(e, "print", {
      enumerable: !0,
      get: function() {
        return t.print;
      }
    }), Object.defineProperty(e, "printError", {
      enumerable: !0,
      get: function() {
        return s.printError;
      }
    }), Object.defineProperty(e, "printIntrospectionSchema", {
      enumerable: !0,
      get: function() {
        return l.printIntrospectionSchema;
      }
    }), Object.defineProperty(e, "printLocation", {
      enumerable: !0,
      get: function() {
        return t.printLocation;
      }
    }), Object.defineProperty(e, "printSchema", {
      enumerable: !0,
      get: function() {
        return l.printSchema;
      }
    }), Object.defineProperty(e, "printSourceLocation", {
      enumerable: !0,
      get: function() {
        return t.printSourceLocation;
      }
    }), Object.defineProperty(e, "printType", {
      enumerable: !0,
      get: function() {
        return l.printType;
      }
    }), Object.defineProperty(e, "recommendedRules", {
      enumerable: !0,
      get: function() {
        return o.recommendedRules;
      }
    }), Object.defineProperty(e, "resolveASTSchemaCoordinate", {
      enumerable: !0,
      get: function() {
        return l.resolveASTSchemaCoordinate;
      }
    }), Object.defineProperty(e, "resolveObjMapThunk", {
      enumerable: !0,
      get: function() {
        return i.resolveObjMapThunk;
      }
    }), Object.defineProperty(e, "resolveReadonlyArrayThunk", {
      enumerable: !0,
      get: function() {
        return i.resolveReadonlyArrayThunk;
      }
    }), Object.defineProperty(e, "resolveSchemaCoordinate", {
      enumerable: !0,
      get: function() {
        return l.resolveSchemaCoordinate;
      }
    }), Object.defineProperty(e, "responsePathAsArray", {
      enumerable: !0,
      get: function() {
        return r.responsePathAsArray;
      }
    }), Object.defineProperty(e, "separateOperations", {
      enumerable: !0,
      get: function() {
        return l.separateOperations;
      }
    }), Object.defineProperty(e, "specifiedDirectives", {
      enumerable: !0,
      get: function() {
        return i.specifiedDirectives;
      }
    }), Object.defineProperty(e, "specifiedRules", {
      enumerable: !0,
      get: function() {
        return o.specifiedRules;
      }
    }), Object.defineProperty(e, "specifiedScalarTypes", {
      enumerable: !0,
      get: function() {
        return i.specifiedScalarTypes;
      }
    }), Object.defineProperty(e, "stripIgnoredCharacters", {
      enumerable: !0,
      get: function() {
        return l.stripIgnoredCharacters;
      }
    }), Object.defineProperty(e, "subscribe", {
      enumerable: !0,
      get: function() {
        return r.subscribe;
      }
    }), Object.defineProperty(e, "syntaxError", {
      enumerable: !0,
      get: function() {
        return s.syntaxError;
      }
    }), Object.defineProperty(e, "typeFromAST", {
      enumerable: !0,
      get: function() {
        return l.typeFromAST;
      }
    }), Object.defineProperty(e, "validate", {
      enumerable: !0,
      get: function() {
        return o.validate;
      }
    }), Object.defineProperty(e, "validateSchema", {
      enumerable: !0,
      get: function() {
        return i.validateSchema;
      }
    }), Object.defineProperty(e, "valueFromAST", {
      enumerable: !0,
      get: function() {
        return l.valueFromAST;
      }
    }), Object.defineProperty(e, "valueFromASTUntyped", {
      enumerable: !0,
      get: function() {
        return l.valueFromASTUntyped;
      }
    }), Object.defineProperty(e, "version", {
      enumerable: !0,
      get: function() {
        return n.version;
      }
    }), Object.defineProperty(e, "versionInfo", {
      enumerable: !0,
      get: function() {
        return n.versionInfo;
      }
    }), Object.defineProperty(e, "visit", {
      enumerable: !0,
      get: function() {
        return t.visit;
      }
    }), Object.defineProperty(e, "visitInParallel", {
      enumerable: !0,
      get: function() {
        return t.visitInParallel;
      }
    }), Object.defineProperty(e, "visitWithTypeInfo", {
      enumerable: !0,
      get: function() {
        return l.visitWithTypeInfo;
      }
    });
    var n = /* @__PURE__ */ Ru(), a = /* @__PURE__ */ wu(), i = /* @__PURE__ */ Vu(), t = /* @__PURE__ */ Cu(), r = /* @__PURE__ */ Uu(), o = /* @__PURE__ */ Ku(), s = /* @__PURE__ */ Lu(), l = /* @__PURE__ */ ic();
  })(qr)), qr;
}
var sc = /* @__PURE__ */ ac();
const oc = "$[Circular Reference]", uc = "$ref:", cc = /* @__PURE__ */ new Set([
  "properties",
  "items",
  "additionalProperties",
  "allOf",
  "anyOf",
  "oneOf"
]), Uo = (e, n = /* @__PURE__ */ new WeakSet(), a = /* @__PURE__ */ new WeakMap(), i = [], t = /* @__PURE__ */ new Set()) => {
  if (e === null || typeof e != "object") return e;
  const r = e.__$ref;
  if (n.has(e) || typeof r == "string" && t.has(r)) {
    if (typeof r == "string") return uc + r;
    const d = i.find((f) => !cc.has(f)) || i[0];
    return [oc, d].filter(Boolean).join(":");
  }
  if (a.has(e)) return a.get(e);
  n.add(e), typeof r == "string" && t.add(r);
  const s = (d, f) => Uo(
    d,
    n,
    a,
    [...i, f],
    t
  ), l = Array.isArray(e) ? e.map((d, f) => s(d, f.toString())) : Object.fromEntries(
    Object.entries(e).map(([d, f]) => [d, s(f, d)])
  );
  return a.set(e, l), n.delete(e), typeof r == "string" && t.delete(r), l;
}, Oc = new sc.GraphQLScalarType({
  ...Ei,
  name: "JSONSchema",
  description: "OpenAPI schema scalar type that handles circular references",
  serialize: (e) => Ei.serialize(Uo(e))
});
export {
  yc as A,
  Ms as B,
  oc as C,
  Wo as D,
  eu as E,
  tu as F,
  ei as G,
  Zo as H,
  $s as I,
  hu as J,
  ye as K,
  uu as L,
  pc as M,
  Hr as N,
  Eu as O,
  gu as P,
  _u as Q,
  Lu as R,
  uc as S,
  Ei as T,
  Ec as U,
  Oc as V,
  Nn as a,
  Us as b,
  Bn as c,
  Ir as d,
  yu as e,
  Ue as f,
  Tu as g,
  bu as h,
  mc as i,
  Wr as j,
  dc as k,
  Yn as l,
  vu as m,
  mu as n,
  Ou as o,
  Or as p,
  Kn as q,
  xn as r,
  vc as s,
  $e as t,
  du as u,
  Tc as v,
  hc as w,
  fu as x,
  bc as y,
  fc as z
};
//# sourceMappingURL=circular-BvNS-yVz.js.map
