import { j as e } from "./jsx-runtime-BzflLqGi.js";
import { TrashIcon as ge, CircleSlashIcon as H, CheckIcon as je, XIcon as ve, PencilLineIcon as Ce, RefreshCwIcon as we, KeyRoundIcon as ke } from "lucide-react";
import { Z as M, i as I } from "./invariant-B_t_F2s_.js";
import * as F from "react";
import { createContext as V, useRef as D, useLayoutEffect as Ee, useEffect as le, useId as _, useContext as B, useInsertionEffect as Ie, useMemo as Q, useCallback as be, Children as Ke, isValidElement as De, useState as b } from "react";
import { D as Pe, a as ne, E as Ae } from "./Zudoku-BPvTuMy8.js";
import { Button as $ } from "./ui/Button.js";
import "./ZudokuReactContext-DGJAP1sN.js";
import "./index-DAWHN3cH.js";
import { u as ce, b as Re } from "./hook-BqOwTUgE.js";
import { F as Se, g as Ne, j as Oe, h as Te, d as qe, I as Me, a as $e, b as Fe, k as ze, c as Le } from "./Frame-DKlOmSkU.js";
import { A as P, a as A, b as de } from "./Mermaid-CJQJeZ9Q.js";
import { S as He, a as Qe, b as Ve, c as _e, d as Be, e as Ye, f as ie, g as Ze } from "./Secret-9xKh4cip.js";
import { e as Y, f as R, D as Z, g as G, a as J, b as U, c as W, d as ue } from "./Dialog-hlvmmQ_c.js";
import { e as fe } from "./useQuery-DSKGiCQr.js";
import { u as q } from "./useMutation-CgOLW9Kh.js";
import { a as Ge } from "./index.esm-BYObtETB.js";
import { u as Je } from "./chunk-EPOLDU6W-CLHrVxOG.js";
import { A as Ue } from "./ActionButton-Da3UAOFM.js";
import { a as X } from "./ZudokuContext-Mfno-z8f.js";
import { Input as We } from "./ui/Input.js";
import { u as Xe } from "./useSuspenseQuery-DbPM3Wv6.js";
import { c as ee } from "./cn-5-Gd1Dss.js";
import { B as E } from "./Button-qpSb3K7a.js";
import { I as et } from "./Input-Cx-GeKoF.js";
function tt({ error: t }) {
  const i = t instanceof Error ? t.message : "Something went wrong", s = process.env.NODE_ENV === "development", n = t instanceof M ? t.developerHint : void 0, r = t instanceof M ? t.title : "Something went wrong", o = t instanceof Error ? t.stack : void 0, a = t instanceof Error ? t.cause : void 0, c = a instanceof Error ? String(a.stack) : o;
  return /* @__PURE__ */ e.jsxs(e.Fragment, { children: [
    /* @__PURE__ */ e.jsxs(P, { variant: "destructive", children: [
      /* @__PURE__ */ e.jsx(A, { children: r }),
      /* @__PURE__ */ e.jsx(de, { children: i })
    ] }),
    s && n && /* @__PURE__ */ e.jsx(Pe, { className: "mb-4", children: n }),
    s && c && /* @__PURE__ */ e.jsx(
      He,
      {
        className: "max-h-[400px] [&>pre]:p-4",
        language: "js",
        code: c
      }
    )
  ] });
}
const st = ({
  service: t,
  onOpenChange: i
}) => {
  const s = X(), n = fe(), r = Je(), o = Ge({
    defaultValues: {
      expiresOn: "30"
    }
  }), a = ce(), c = q({
    mutationFn: ({ description: l, expiresOn: p }) => {
      if (!t.createKey)
        throw new Error("createKey not implemented");
      const u = p !== "never" ? nt(Number(p)) : void 0;
      return t.createKey({
        apiKey: {
          description: l || "Secret Key",
          expiresOn: u
        },
        context: s,
        auth: a
      });
    },
    onSuccess: async () => {
      await n.invalidateQueries({ queryKey: ["api-keys"] }), await r("/settings/api-keys/");
    }
  });
  return t.createKey ? /* @__PURE__ */ e.jsxs(
    "form",
    {
      onSubmit: o.handleSubmit(
        (l) => c.mutate(
          { ...l },
          {
            onSuccess: () => i(!1)
          }
        )
      ),
      children: [
        c.error && /* @__PURE__ */ e.jsxs(P, { variant: "destructive", className: "mb-4", children: [
          /* @__PURE__ */ e.jsx(A, { children: "Error" }),
          /* @__PURE__ */ e.jsx(de, { children: c.error.message })
        ] }),
        /* @__PURE__ */ e.jsxs("div", { className: "flex gap-2 flex-col text-sm font-medium", children: [
          "Name",
          /* @__PURE__ */ e.jsx(We, { ...o.register("description") }),
          "Expiration",
          /* @__PURE__ */ e.jsxs(
            Qe,
            {
              onValueChange: (l) => o.setValue("expiresOn", l),
              defaultValue: o.getValues("expiresOn"),
              children: [
                /* @__PURE__ */ e.jsx(Ve, { children: /* @__PURE__ */ e.jsx(_e, {}) }),
                /* @__PURE__ */ e.jsx(Be, { children: /* @__PURE__ */ e.jsxs(Ye, { children: [
                  [7, 30, 60, 90].map((l) => /* @__PURE__ */ e.jsxs(ie, { value: String(l), children: [
                    l,
                    " days"
                  ] }, l)),
                  /* @__PURE__ */ e.jsx(ie, { value: "never", children: "Never" })
                ] }) })
              ]
            }
          ),
          /* @__PURE__ */ e.jsxs(Y, { children: [
            /* @__PURE__ */ e.jsx(R, { asChild: !0, children: /* @__PURE__ */ e.jsx($, { variant: "outline", children: "Cancel" }) }),
            /* @__PURE__ */ e.jsx(Ue, { isPending: c.isPending, children: "Generate Key" })
          ] })
        ] })
      ]
    }
  ) : null;
}, nt = (t) => {
  const i = /* @__PURE__ */ new Date();
  return i.setDate(i.getDate() + t), i.toISOString();
}, pe = ({
  service: t,
  isOpen: i,
  onOpenChange: s,
  trigger: n,
  buttonVariant: r = "outline"
}) => {
  const o = /* @__PURE__ */ e.jsx($, { variant: r, children: "Create API Key" });
  return /* @__PURE__ */ e.jsxs(Z, { open: i, onOpenChange: s, children: [
    /* @__PURE__ */ e.jsx(G, { asChild: !0, children: n ?? o }),
    /* @__PURE__ */ e.jsxs(J, { children: [
      /* @__PURE__ */ e.jsx(U, { children: /* @__PURE__ */ e.jsx(W, { children: "Create API Key" }) }),
      /* @__PURE__ */ e.jsx(st, { service: t, onOpenChange: s })
    ] })
  ] });
}, it = V({});
function he(t) {
  const i = D(null);
  return i.current === null && (i.current = t()), i.current;
}
const rt = typeof window < "u", at = rt ? Ee : le, me = /* @__PURE__ */ V(null);
function ot(t) {
  return typeof t == "object" && t !== null;
}
function re(t) {
  return ot(t) && "offsetHeight" in t;
}
const lt = V({
  transformPagePoint: (t) => t,
  isStatic: !1,
  reducedMotion: "never"
});
function ae(t, i) {
  if (typeof t == "function")
    return t(i);
  t != null && (t.current = i);
}
function ct(...t) {
  return (i) => {
    let s = !1;
    const n = t.map((r) => {
      const o = ae(r, i);
      return !s && typeof o == "function" && (s = !0), o;
    });
    if (s)
      return () => {
        for (let r = 0; r < n.length; r++) {
          const o = n[r];
          typeof o == "function" ? o() : ae(t[r], null);
        }
      };
  };
}
function dt(...t) {
  return F.useCallback(ct(...t), t);
}
class ut extends F.Component {
  getSnapshotBeforeUpdate(i) {
    const s = this.props.childRef.current;
    if (s && i.isPresent && !this.props.isPresent) {
      const n = s.offsetParent, r = re(n) && n.offsetWidth || 0, o = re(n) && n.offsetHeight || 0, a = this.props.sizeRef.current;
      a.height = s.offsetHeight || 0, a.width = s.offsetWidth || 0, a.top = s.offsetTop, a.left = s.offsetLeft, a.right = r - a.width - a.left, a.bottom = o - a.height - a.top;
    }
    return null;
  }
  /**
   * Required with getSnapshotBeforeUpdate to stop React complaining.
   */
  componentDidUpdate() {
  }
  render() {
    return this.props.children;
  }
}
function ft({ children: t, isPresent: i, anchorX: s, anchorY: n, root: r }) {
  const o = _(), a = D(null), c = D({
    width: 0,
    height: 0,
    top: 0,
    left: 0,
    right: 0,
    bottom: 0
  }), { nonce: l } = B(lt), p = t.props?.ref ?? t?.ref, u = dt(a, p);
  return Ie(() => {
    const { width: C, height: f, top: j, left: v, right: d, bottom: h } = c.current;
    if (i || !a.current || !C || !f)
      return;
    const y = s === "left" ? `left: ${v}` : `right: ${d}`, w = n === "bottom" ? `bottom: ${h}` : `top: ${j}`;
    a.current.dataset.motionPopId = o;
    const m = document.createElement("style");
    l && (m.nonce = l);
    const g = r ?? document.head;
    return g.appendChild(m), m.sheet && m.sheet.insertRule(`
          [data-motion-pop-id="${o}"] {
            position: absolute !important;
            width: ${C}px !important;
            height: ${f}px !important;
            ${y}px !important;
            ${w}px !important;
          }
        `), () => {
      g.contains(m) && g.removeChild(m);
    };
  }, [i]), e.jsx(ut, { isPresent: i, childRef: a, sizeRef: c, children: F.cloneElement(t, { ref: u }) });
}
const pt = ({ children: t, initial: i, isPresent: s, onExitComplete: n, custom: r, presenceAffectsLayout: o, mode: a, anchorX: c, anchorY: l, root: p }) => {
  const u = he(ht), C = _();
  let f = !0, j = Q(() => (f = !1, {
    id: C,
    initial: i,
    isPresent: s,
    custom: r,
    onExitComplete: (v) => {
      u.set(v, !0);
      for (const d of u.values())
        if (!d)
          return;
      n && n();
    },
    register: (v) => (u.set(v, !1), () => u.delete(v))
  }), [s, u, n]);
  return o && f && (j = { ...j }), Q(() => {
    u.forEach((v, d) => u.set(d, !1));
  }, [s]), F.useEffect(() => {
    !s && !u.size && n && n();
  }, [s]), a === "popLayout" && (t = e.jsx(ft, { isPresent: s, anchorX: c, anchorY: l, root: p, children: t })), e.jsx(me.Provider, { value: j, children: t });
};
function ht() {
  return /* @__PURE__ */ new Map();
}
function mt(t = !0) {
  const i = B(me);
  if (i === null)
    return [!0, null];
  const { isPresent: s, onExitComplete: n, register: r } = i, o = _();
  le(() => {
    if (t)
      return r(o);
  }, [t]);
  const a = be(() => t && n && n(o), [o, n, t]);
  return !s && n ? [!1, a] : [!0];
}
const S = (t) => t.key || "";
function oe(t) {
  const i = [];
  return Ke.forEach(t, (s) => {
    De(s) && i.push(s);
  }), i;
}
const xt = ({ children: t, custom: i, initial: s = !0, onExitComplete: n, presenceAffectsLayout: r = !0, mode: o = "sync", propagate: a = !1, anchorX: c = "left", anchorY: l = "top", root: p }) => {
  const [u, C] = mt(a), f = Q(() => oe(t), [t]), j = a && !u ? [] : f.map(S), v = D(!0), d = D(f), h = he(() => /* @__PURE__ */ new Map()), y = D(/* @__PURE__ */ new Set()), [w, m] = b(f), [g, te] = b(f);
  at(() => {
    v.current = !1, d.current = f;
    for (let k = 0; k < g.length; k++) {
      const x = S(g[k]);
      j.includes(x) ? (h.delete(x), y.current.delete(x)) : h.get(x) !== !0 && h.set(x, !1);
    }
  }, [g, j.length, j.join("-")]);
  const z = [];
  if (f !== w) {
    let k = [...f];
    for (let x = 0; x < g.length; x++) {
      const K = g[x], L = S(K);
      j.includes(L) || (k.splice(x, 0, K), z.push(K));
    }
    return o === "wait" && z.length && (k = z), te(oe(k)), m(f), null;
  }
  process.env.NODE_ENV !== "production" && o === "wait" && g.length > 1 && console.warn(`You're attempting to animate multiple children within AnimatePresence, but its mode is set to "wait". This will lead to odd visual behaviour.`);
  const { forceRender: xe } = B(it);
  return e.jsx(e.Fragment, { children: g.map((k) => {
    const x = S(k), K = a && !u ? !1 : f === g || j.includes(x), L = () => {
      if (y.current.has(x))
        return;
      if (y.current.add(x), h.has(x))
        h.set(x, !0);
      else
        return;
      let se = !0;
      h.forEach((ye) => {
        ye || (se = !1);
      }), se && (xe?.(), te(d.current), a && C?.(), n && n());
    };
    return e.jsx(pt, { isPresent: K, initial: !v.current || s ? void 0 : !1, custom: i, presenceAffectsLayout: r, mode: o, root: p, onExitComplete: K ? void 0 : L, anchorX: c, anchorY: l, children: k }, x);
  }) });
}, yt = ({
  apiKey: t,
  onDeleteKey: i,
  className: s
}) => {
  const [n, r] = b(!1), { key: o, createdOn: a, expiresOn: c } = t, l = c && new Date(c) < /* @__PURE__ */ new Date(), p = c ? Math.ceil(
    (new Date(c).getTime() - Date.now()) / (1e3 * 60 * 60 * 24)
  ) : 1 / 0, u = p <= 7 && !l;
  return /* @__PURE__ */ e.jsxs("div", { className: ee("grid col-span-full grid-cols-subgrid p-6", s), children: [
    /* @__PURE__ */ e.jsxs("div", { className: "flex flex-col gap-1", children: [
      /* @__PURE__ */ e.jsx(
        Ze,
        {
          className: "max-w-fit w-full",
          secret: o,
          status: l ? "expired" : u ? "expiring" : "active",
          revealed: n,
          onReveal: r
        }
      ),
      /* @__PURE__ */ e.jsxs("div", { className: "flex gap-1 mt-0.5 text-nowrap", children: [
        a && /* @__PURE__ */ e.jsxs("span", { className: "text-xs text-muted-foreground", children: [
          "Created ",
          gt(a),
          "."
        ] }),
        " ",
        c && u && /* @__PURE__ */ e.jsxs("span", { className: "text-xs text-primary", children: [
          "Expires in ",
          p,
          " ",
          p === 1 ? "day" : "days",
          "."
        ] }),
        c && l && /* @__PURE__ */ e.jsxs("span", { className: "text-xs text-primary", children: [
          "Expired",
          " ",
          p === 0 ? "today." : `${p * -1} days ago.`
        ] })
      ] })
    ] }),
    /* @__PURE__ */ e.jsx("div", { className: "flex justify-end", children: c && i && /* @__PURE__ */ e.jsxs(Z, { children: [
      /* @__PURE__ */ e.jsx(G, { asChild: !0, children: /* @__PURE__ */ e.jsx(E, { variant: "ghost", size: "icon", children: /* @__PURE__ */ e.jsx(ge, { size: 16 }) }) }),
      /* @__PURE__ */ e.jsxs(J, { children: [
        /* @__PURE__ */ e.jsxs(U, { children: [
          /* @__PURE__ */ e.jsx(W, { children: "Delete API Key" }),
          /* @__PURE__ */ e.jsx(ue, { children: "Are you sure you want to delete this API key?" })
        ] }),
        /* @__PURE__ */ e.jsxs(Y, { children: [
          /* @__PURE__ */ e.jsx(R, { asChild: !0, children: /* @__PURE__ */ e.jsx(E, { variant: "outline", children: "Cancel" }) }),
          /* @__PURE__ */ e.jsx(R, { asChild: !0, children: /* @__PURE__ */ e.jsx(
            E,
            {
              onClick: () => {
                i();
              },
              children: "Delete"
            }
          ) })
        ] })
      ] })
    ] }) })
  ] });
}, gt = (t) => {
  const i = /* @__PURE__ */ new Date(), s = new Date(t), n = Math.floor((i.getTime() - s.getTime()) / 1e3), r = new Intl.RelativeTimeFormat("en", { numeric: "auto" });
  return n < 60 ? r.format(-n, "second") : n < 3600 ? r.format(-Math.floor(n / 60), "minute") : n < 86400 ? r.format(-Math.floor(n / 3600), "hour") : n < 2592e3 ? r.format(-Math.floor(n / 86400), "day") : n < 31536e3 ? r.format(-Math.floor(n / 2592e3), "month") : r.format(-Math.floor(n / 31536e3), "year");
}, jt = ({
  consumer: t,
  onUpdate: i,
  onRollKey: s,
  onDeleteKey: n
}) => {
  const [r, o] = b(!1), [a, c] = b(t.label), l = fe(), p = X(), u = q({
    mutationFn: async (d) => {
      if (!s)
        throw new Error("rollKey not implemented");
      return await s?.(d, p);
    },
    onSuccess: () => void l.invalidateQueries({ queryKey: ["api-keys"] })
  }), C = q({
    mutationFn: ({
      consumerId: d,
      keyId: h
    }) => {
      if (!n)
        throw new Error("deleteKey not implemented");
      return n(d, h, p);
    },
    onMutate: async ({ consumerId: d, keyId: h }) => {
      await l.cancelQueries({ queryKey: ["api-keys"] });
      const y = l.getQueryData([
        "api-keys"
      ]);
      return l.setQueryData(["api-keys"], (w) => w && w.map((m) => m.id === d ? {
        ...m,
        apiKeys: m.apiKeys.filter((g) => g.id !== h)
      } : m)), { previousData: y };
    },
    onError: (d, h, y) => {
      y?.previousData && l.setQueryData(["api-keys"], y.previousData);
    },
    onSuccess: () => {
      l.invalidateQueries({ queryKey: ["api-keys"] });
    }
  }), f = q({
    mutationFn: ({
      consumerId: d,
      label: h
    }) => {
      if (!i)
        throw new Error("updateConsumer not implemented");
      return i({ id: d, label: h }, p);
    },
    onMutate: async ({ consumerId: d, label: h }) => {
      await l.cancelQueries({ queryKey: ["api-keys"] });
      const y = l.getQueryData(["api-keys"]);
      return l.setQueryData(["api-keys"], (w) => w && w.map((m) => m.id === d ? {
        ...m,
        label: h
      } : m)), { previousData: y };
    },
    onError: (d, h, y) => {
      y?.previousData && l.setQueryData(["api-keys"], y.previousData);
    },
    onSuccess: () => {
      l.invalidateQueries({ queryKey: ["api-keys"] });
    }
  }), j = () => {
    o(!0), c(t.label);
  }, v = () => {
    a.trim() && f.mutate({
      label: a.trim(),
      consumerId: t.id
    }), o(!1);
  };
  return /* @__PURE__ */ e.jsxs(e.Fragment, { children: [
    u.isError && /* @__PURE__ */ e.jsxs(P, { variant: "destructive", className: "mb-4", children: [
      /* @__PURE__ */ e.jsx(H, { size: 16 }),
      /* @__PURE__ */ e.jsx(A, { children: u.error.message })
    ] }),
    f.isError && /* @__PURE__ */ e.jsxs(P, { variant: "destructive", className: "mb-4", children: [
      /* @__PURE__ */ e.jsx(H, { size: 16 }),
      /* @__PURE__ */ e.jsx(A, { children: f.error.message })
    ] }),
    C.isError && /* @__PURE__ */ e.jsxs(P, { variant: "destructive", className: "mb-4", children: [
      /* @__PURE__ */ e.jsx(H, { size: 16 }),
      /* @__PURE__ */ e.jsx(A, { children: C.error.message })
    ] }),
    /* @__PURE__ */ e.jsxs(
      Se,
      {
        className: "grid grid-cols-subgrid col-span-full items-center mb-4 group",
        children: [
          /* @__PURE__ */ e.jsxs(Ne, { className: "col-span-full flex-row items-start justify-between gap-4", children: [
            /* @__PURE__ */ e.jsxs("div", { className: "flex flex-col gap-1", children: [
              r ? /* @__PURE__ */ e.jsxs("div", { className: "flex items-center gap-2", children: [
                /* @__PURE__ */ e.jsx(
                  et,
                  {
                    maxLength: 32,
                    value: a,
                    onChange: (d) => c(d.target.value),
                    onKeyDown: (d) => {
                      d.key === "Enter" ? v() : d.key === "Escape" && o(!1);
                    },
                    autoFocus: !0
                  }
                ),
                /* @__PURE__ */ e.jsxs("div", { className: "flex items-center", children: [
                  /* @__PURE__ */ e.jsx(
                    E,
                    {
                      size: "icon",
                      variant: "ghost",
                      onClick: v,
                      disabled: !a.trim(),
                      children: /* @__PURE__ */ e.jsx(je, { size: 16 })
                    }
                  ),
                  /* @__PURE__ */ e.jsx(
                    E,
                    {
                      size: "icon",
                      variant: "ghost",
                      onClick: () => o(!1),
                      children: /* @__PURE__ */ e.jsx(ve, { size: 16 })
                    }
                  )
                ] })
              ] }) : /* @__PURE__ */ e.jsx(Oe, { children: t.label }),
              /* @__PURE__ */ e.jsxs(Te, { children: [
                t.createdOn && /* @__PURE__ */ e.jsxs("div", { children: [
                  "Created on ",
                  new Date(t.createdOn).toLocaleDateString()
                ] }),
                t.expiresOn && /* @__PURE__ */ e.jsxs("div", { children: [
                  "Expires on ",
                  new Date(t.expiresOn).toLocaleDateString()
                ] })
              ] })
            ] }),
            /* @__PURE__ */ e.jsxs("div", { className: "flex gap-1", children: [
              i && /* @__PURE__ */ e.jsxs(
                E,
                {
                  variant: "ghost",
                  onClick: j,
                  className: ee(
                    "flex gap-2",
                    r && "opacity-0! pointer-events-none"
                  ),
                  disabled: r,
                  children: [
                    /* @__PURE__ */ e.jsx(Ce, { size: 16 }),
                    /* @__PURE__ */ e.jsx("span", { className: "hidden md:block", children: "Edit label" })
                  ]
                }
              ),
              s && /* @__PURE__ */ e.jsxs(Z, { children: [
                /* @__PURE__ */ e.jsx(G, { asChild: !0, children: /* @__PURE__ */ e.jsxs(
                  E,
                  {
                    title: "Roll this key",
                    variant: "ghost",
                    disabled: u.isPending,
                    className: "flex items-center gap-2",
                    children: [
                      /* @__PURE__ */ e.jsx(
                        we,
                        {
                          size: 16,
                          className: u.isPending ? "animate-spin" : void 0
                        }
                      ),
                      /* @__PURE__ */ e.jsx("span", { className: "hidden md:block", children: "Roll key" })
                    ]
                  }
                ) }),
                /* @__PURE__ */ e.jsxs(J, { children: [
                  /* @__PURE__ */ e.jsxs(U, { children: [
                    /* @__PURE__ */ e.jsx(W, { children: "Roll API Key" }),
                    /* @__PURE__ */ e.jsx(ue, { children: "Are you sure you want to roll this API key?" })
                  ] }),
                  /* @__PURE__ */ e.jsxs(Y, { children: [
                    /* @__PURE__ */ e.jsx(R, { asChild: !0, children: /* @__PURE__ */ e.jsx(E, { variant: "outline", children: "Cancel" }) }),
                    /* @__PURE__ */ e.jsx(R, { asChild: !0, children: /* @__PURE__ */ e.jsx(
                      E,
                      {
                        onClick: () => {
                          u.mutate(t.id);
                        },
                        children: "Roll Key"
                      }
                    ) })
                  ] })
                ] })
              ] })
            ] })
          ] }),
          /* @__PURE__ */ e.jsx(qe, { className: "p-0 grid grid-cols-subgrid col-span-full divide-y divide-border", children: /* @__PURE__ */ e.jsx(xt, { children: t.apiKeys.map((d) => /* @__PURE__ */ e.jsx(
            yt,
            {
              apiKey: d,
              onDeleteKey: () => {
                C.mutate({
                  consumerId: t.id,
                  keyId: d.id
                });
              },
              className: C.variables?.keyId === d.id && C.isPending ? "opacity-10!" : void 0
            },
            d.id
          )) }) })
        ]
      },
      t.id
    )
  ] });
}, vt = ({ service: t }) => {
  const i = X(), { data: s } = Xe({
    queryFn: async () => {
      try {
        return await t.getConsumers(i);
      } catch (o) {
        throw o instanceof M ? o : new M("Cannot get API keys", {
          cause: o,
          title: "Error getting API keys",
          developerHint: "Check the response of the API request for more information."
        });
      }
    },
    queryKey: ["api-keys"],
    retry: !1
  }), [n, r] = b(!1);
  return /* @__PURE__ */ e.jsx("div", { className: "mt-8", children: s.length === 0 ? /* @__PURE__ */ e.jsxs("div", { className: "flex col-span-full flex-col justify-center gap-4 items-center p-8 border rounded-sm bg-muted/30 text-muted-foreground", children: [
    /* @__PURE__ */ e.jsxs("p", { className: "text-center", children: [
      "You have no API keys yet.",
      /* @__PURE__ */ e.jsx("br", {}),
      t.createKey && "Get started and create your first key."
    ] }),
    t.createKey && /* @__PURE__ */ e.jsx(
      pe,
      {
        service: t,
        isOpen: n,
        onOpenChange: r
      }
    )
  ] }) : /* @__PURE__ */ e.jsx("ul", { className: ee("grid grid-cols-[1fr_min-content] col-span-6"), children: s.map((o) => /* @__PURE__ */ e.jsx(
    jt,
    {
      consumer: o,
      onUpdate: t.updateConsumer,
      onRollKey: t.rollKey,
      onDeleteKey: t.deleteKey
    },
    o.id
  )) }) });
}, Ct = ({ service: t }) => {
  const [i, s] = b(!1), n = ce(), { supportsEmailVerification: r, requestEmailVerification: o, refresh: a } = Re();
  return /* @__PURE__ */ e.jsxs("div", { className: "max-w-3xl h-full pt-(--padding-content-top) pb-(--padding-content-bottom)", children: [
    /* @__PURE__ */ e.jsx(ne.Target, { name: "api-keys-list-page" }),
    /* @__PURE__ */ e.jsxs("div", { className: "flex justify-between pb-3", children: [
      /* @__PURE__ */ e.jsx("h1", { className: "font-medium text-2xl", children: "API Keys" }),
      t.createKey && /* @__PURE__ */ e.jsx(
        pe,
        {
          service: t,
          isOpen: i,
          onOpenChange: s
        }
      )
    ] }),
    /* @__PURE__ */ e.jsx("p", { children: "Create, manage, and monitor your API keys" }),
    /* @__PURE__ */ e.jsx(ne.Target, { name: "api-keys-list-page-before-keys" }),
    n.profile?.emailVerified === !1 ? /* @__PURE__ */ e.jsxs(Me, { variant: "outline", className: "mt-4", children: [
      /* @__PURE__ */ e.jsxs($e, { children: [
        /* @__PURE__ */ e.jsx(Fe, { children: "Verified email required" }),
        /* @__PURE__ */ e.jsxs(ze, { children: [
          "You need to verify your email to access API keys.",
          /* @__PURE__ */ e.jsx($, { onClick: a, children: "Refresh" })
        ] })
      ] }),
      r && /* @__PURE__ */ e.jsx(Le, { children: /* @__PURE__ */ e.jsx($, { onClick: () => o(), children: "Request verification" }) })
    ] }) : /* @__PURE__ */ e.jsx(
      Ae,
      {
        fallbackRender: ({ error: c }) => /* @__PURE__ */ e.jsx(tt, { error: c }),
        children: /* @__PURE__ */ e.jsx(vt, { service: t })
      }
    )
  ] });
}, N = "https://api.zuploedge.com/v2/client", wt = async (t) => {
  try {
    return await t.json();
  } catch {
    return;
  }
}, O = async (t) => {
  const i = t.headers.get("content-type");
  if (!t.ok && i?.includes("application/problem+json")) {
    const s = await wt(t);
    if (s.type && s.title)
      throw new Error(s.detail ?? s.title);
  }
}, T = {
  developerHint: "This project is not linked to a Zuplo deployment. Run `zuplo link` to get started with API Keys.",
  title: "Not linked to a Zuplo deployment"
}, kt = ({
  deploymentName: t,
  ...i
}) => ({
  deleteKey: async (s, n, r) => {
    I(t, "Cannot delete API key.", T);
    const o = new Request(
      N + `/${t}/consumers/${s}/keys/${n}`,
      {
        method: "DELETE"
      }
    ), a = await fetch(await r.signRequest(o));
    await O(a), I(a.ok, "Failed to delete API key");
  },
  updateConsumer: async (s, n) => {
    I(
      t,
      "Cannot update API key description.",
      T
    );
    const r = await fetch(
      await n.signRequest(
        new Request(
          `${N}/${t}/consumers/${s.id}`,
          {
            method: "PATCH",
            headers: {
              "Content-Type": "application/json"
            },
            body: JSON.stringify({
              label: s.label
            })
          }
        )
      )
    );
    await O(r), I(r.ok, "Failed to update API key description");
  },
  rollKey: async (s, n) => {
    I(t, "Cannot roll API key.", T);
    const r = await fetch(
      await n.signRequest(
        new Request(
          `${N}/${t}/consumers/${s}/roll-key`,
          {
            method: "POST",
            headers: {
              "Content-Type": "application/json"
            },
            body: JSON.stringify({})
          }
        )
      )
    );
    await O(r), I(r.ok, "Failed to roll API key");
  },
  getConsumers: async (s) => {
    I(t, "Cannot get API keys.", T);
    const n = new Request(
      `${N}/${t}/consumers`
    );
    await s.signRequest(n);
    const r = await fetch(n);
    return await O(r), I(r.ok, "Failed to fetch API keys"), (await r.json()).data.map((a) => ({
      id: a.id,
      createdOn: a.createdOn,
      updatedOn: a.updatedOn,
      expiresOn: a.expiresOn,
      label: a.label || a.subject || "API Key",
      apiKeys: a.apiKeys.data,
      key: a.apiKeys.data.at(0)
    }));
  },
  ...i
}), Zt = (t) => t, Gt = ({
  deploymentName: t,
  isZuplo: i,
  ...s
}) => {
  i && !t && console.warn(
    "This project is not linked to a Zuplo deployment. Run `zuplo link` to get started."
  );
  const n = i ? kt({ deploymentName: t, ...s }) : s;
  if (!n.getConsumers)
    throw new Error("getConsumers is required when using the apiKeyPlugin");
  const r = {
    ...n,
    getConsumers: n.getConsumers
  };
  return {
    getProfileMenuItems: () => [
      {
        label: "API Keys",
        path: "/settings/api-keys",
        category: "middle",
        icon: ke
      }
    ],
    getIdentities: async (o) => {
      try {
        return (await r.getConsumers(o)).map((c) => ({
          authorizeRequest: (l) => (l.headers.set(
            "Authorization",
            `Bearer ${c.apiKeys.at(0)?.key}`
          ), l),
          id: c.id,
          label: c.label
        }));
      } catch {
        return [];
      }
    },
    getRoutes: () => [
      {
        path: "/settings/api-keys",
        element: /* @__PURE__ */ e.jsx(Ct, { service: r })
      }
    ],
    getProtectedRoutes: () => ["/settings/api-keys"]
  };
};
export {
  Gt as apiKeyPlugin,
  Zt as createApiKeyService
};
//# sourceMappingURL=zudoku.plugin-api-keys.js.map
