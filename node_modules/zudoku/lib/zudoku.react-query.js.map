{"version":3,"file":"zudoku.react-query.js","sources":["../../../node_modules/.pnpm/@tanstack+query-core@5.90.12/node_modules/@tanstack/query-core/build/modern/infiniteQueryObserver.js","../../../node_modules/.pnpm/@tanstack+query-core@5.90.12/node_modules/@tanstack/query-core/build/modern/queriesObserver.js","../../../node_modules/.pnpm/@tanstack+query-core@5.90.12/node_modules/@tanstack/query-core/build/modern/streamedQuery.js","../../../node_modules/.pnpm/@tanstack+query-core@5.90.12/node_modules/@tanstack/query-core/build/modern/types.js","../../../node_modules/.pnpm/@tanstack+react-query@5.90.12_react@19.2.4/node_modules/@tanstack/react-query/build/modern/useQueries.js","../../../node_modules/.pnpm/@tanstack+react-query@5.90.12_react@19.2.4/node_modules/@tanstack/react-query/build/modern/useSuspenseInfiniteQuery.js","../../../node_modules/.pnpm/@tanstack+react-query@5.90.12_react@19.2.4/node_modules/@tanstack/react-query/build/modern/useSuspenseQueries.js","../../../node_modules/.pnpm/@tanstack+react-query@5.90.12_react@19.2.4/node_modules/@tanstack/react-query/build/modern/usePrefetchQuery.js","../../../node_modules/.pnpm/@tanstack+react-query@5.90.12_react@19.2.4/node_modules/@tanstack/react-query/build/modern/usePrefetchInfiniteQuery.js","../../../node_modules/.pnpm/@tanstack+react-query@5.90.12_react@19.2.4/node_modules/@tanstack/react-query/build/modern/queryOptions.js","../../../node_modules/.pnpm/@tanstack+react-query@5.90.12_react@19.2.4/node_modules/@tanstack/react-query/build/modern/infiniteQueryOptions.js","../../../node_modules/.pnpm/@tanstack+react-query@5.90.12_react@19.2.4/node_modules/@tanstack/react-query/build/modern/useIsFetching.js","../../../node_modules/.pnpm/@tanstack+react-query@5.90.12_react@19.2.4/node_modules/@tanstack/react-query/build/modern/useMutationState.js","../../../node_modules/.pnpm/@tanstack+react-query@5.90.12_react@19.2.4/node_modules/@tanstack/react-query/build/modern/mutationOptions.js","../../../node_modules/.pnpm/@tanstack+react-query@5.90.12_react@19.2.4/node_modules/@tanstack/react-query/build/modern/useInfiniteQuery.js"],"sourcesContent":["// src/infiniteQueryObserver.ts\nimport { QueryObserver } from \"./queryObserver.js\";\nimport {\n  hasNextPage,\n  hasPreviousPage,\n  infiniteQueryBehavior\n} from \"./infiniteQueryBehavior.js\";\nvar InfiniteQueryObserver = class extends QueryObserver {\n  constructor(client, options) {\n    super(client, options);\n  }\n  bindMethods() {\n    super.bindMethods();\n    this.fetchNextPage = this.fetchNextPage.bind(this);\n    this.fetchPreviousPage = this.fetchPreviousPage.bind(this);\n  }\n  setOptions(options) {\n    super.setOptions({\n      ...options,\n      behavior: infiniteQueryBehavior()\n    });\n  }\n  getOptimisticResult(options) {\n    options.behavior = infiniteQueryBehavior();\n    return super.getOptimisticResult(options);\n  }\n  fetchNextPage(options) {\n    return this.fetch({\n      ...options,\n      meta: {\n        fetchMore: { direction: \"forward\" }\n      }\n    });\n  }\n  fetchPreviousPage(options) {\n    return this.fetch({\n      ...options,\n      meta: {\n        fetchMore: { direction: \"backward\" }\n      }\n    });\n  }\n  createResult(query, options) {\n    const { state } = query;\n    const parentResult = super.createResult(query, options);\n    const { isFetching, isRefetching, isError, isRefetchError } = parentResult;\n    const fetchDirection = state.fetchMeta?.fetchMore?.direction;\n    const isFetchNextPageError = isError && fetchDirection === \"forward\";\n    const isFetchingNextPage = isFetching && fetchDirection === \"forward\";\n    const isFetchPreviousPageError = isError && fetchDirection === \"backward\";\n    const isFetchingPreviousPage = isFetching && fetchDirection === \"backward\";\n    const result = {\n      ...parentResult,\n      fetchNextPage: this.fetchNextPage,\n      fetchPreviousPage: this.fetchPreviousPage,\n      hasNextPage: hasNextPage(options, state.data),\n      hasPreviousPage: hasPreviousPage(options, state.data),\n      isFetchNextPageError,\n      isFetchingNextPage,\n      isFetchPreviousPageError,\n      isFetchingPreviousPage,\n      isRefetchError: isRefetchError && !isFetchNextPageError && !isFetchPreviousPageError,\n      isRefetching: isRefetching && !isFetchingNextPage && !isFetchingPreviousPage\n    };\n    return result;\n  }\n};\nexport {\n  InfiniteQueryObserver\n};\n//# sourceMappingURL=infiniteQueryObserver.js.map","// src/queriesObserver.ts\nimport { notifyManager } from \"./notifyManager.js\";\nimport { QueryObserver } from \"./queryObserver.js\";\nimport { Subscribable } from \"./subscribable.js\";\nimport { replaceEqualDeep, shallowEqualObjects } from \"./utils.js\";\nfunction difference(array1, array2) {\n  const excludeSet = new Set(array2);\n  return array1.filter((x) => !excludeSet.has(x));\n}\nfunction replaceAt(array, index, value) {\n  const copy = array.slice(0);\n  copy[index] = value;\n  return copy;\n}\nvar QueriesObserver = class extends Subscribable {\n  #client;\n  #result;\n  #queries;\n  #options;\n  #observers;\n  #combinedResult;\n  #lastCombine;\n  #lastResult;\n  #observerMatches = [];\n  constructor(client, queries, options) {\n    super();\n    this.#client = client;\n    this.#options = options;\n    this.#queries = [];\n    this.#observers = [];\n    this.#result = [];\n    this.setQueries(queries);\n  }\n  onSubscribe() {\n    if (this.listeners.size === 1) {\n      this.#observers.forEach((observer) => {\n        observer.subscribe((result) => {\n          this.#onUpdate(observer, result);\n        });\n      });\n    }\n  }\n  onUnsubscribe() {\n    if (!this.listeners.size) {\n      this.destroy();\n    }\n  }\n  destroy() {\n    this.listeners = /* @__PURE__ */ new Set();\n    this.#observers.forEach((observer) => {\n      observer.destroy();\n    });\n  }\n  setQueries(queries, options) {\n    this.#queries = queries;\n    this.#options = options;\n    if (process.env.NODE_ENV !== \"production\") {\n      const queryHashes = queries.map(\n        (query) => this.#client.defaultQueryOptions(query).queryHash\n      );\n      if (new Set(queryHashes).size !== queryHashes.length) {\n        console.warn(\n          \"[QueriesObserver]: Duplicate Queries found. This might result in unexpected behavior.\"\n        );\n      }\n    }\n    notifyManager.batch(() => {\n      const prevObservers = this.#observers;\n      const newObserverMatches = this.#findMatchingObservers(this.#queries);\n      this.#observerMatches = newObserverMatches;\n      newObserverMatches.forEach(\n        (match) => match.observer.setOptions(match.defaultedQueryOptions)\n      );\n      const newObservers = newObserverMatches.map((match) => match.observer);\n      const newResult = newObservers.map(\n        (observer) => observer.getCurrentResult()\n      );\n      const hasLengthChange = prevObservers.length !== newObservers.length;\n      const hasIndexChange = newObservers.some(\n        (observer, index) => observer !== prevObservers[index]\n      );\n      const hasStructuralChange = hasLengthChange || hasIndexChange;\n      const hasResultChange = hasStructuralChange ? true : newResult.some((result, index) => {\n        const prev = this.#result[index];\n        return !prev || !shallowEqualObjects(result, prev);\n      });\n      if (!hasStructuralChange && !hasResultChange) return;\n      if (hasStructuralChange) {\n        this.#observers = newObservers;\n      }\n      this.#result = newResult;\n      if (!this.hasListeners()) return;\n      if (hasStructuralChange) {\n        difference(prevObservers, newObservers).forEach((observer) => {\n          observer.destroy();\n        });\n        difference(newObservers, prevObservers).forEach((observer) => {\n          observer.subscribe((result) => {\n            this.#onUpdate(observer, result);\n          });\n        });\n      }\n      this.#notify();\n    });\n  }\n  getCurrentResult() {\n    return this.#result;\n  }\n  getQueries() {\n    return this.#observers.map((observer) => observer.getCurrentQuery());\n  }\n  getObservers() {\n    return this.#observers;\n  }\n  getOptimisticResult(queries, combine) {\n    const matches = this.#findMatchingObservers(queries);\n    const result = matches.map(\n      (match) => match.observer.getOptimisticResult(match.defaultedQueryOptions)\n    );\n    return [\n      result,\n      (r) => {\n        return this.#combineResult(r ?? result, combine);\n      },\n      () => {\n        return this.#trackResult(result, matches);\n      }\n    ];\n  }\n  #trackResult(result, matches) {\n    return matches.map((match, index) => {\n      const observerResult = result[index];\n      return !match.defaultedQueryOptions.notifyOnChangeProps ? match.observer.trackResult(observerResult, (accessedProp) => {\n        matches.forEach((m) => {\n          m.observer.trackProp(accessedProp);\n        });\n      }) : observerResult;\n    });\n  }\n  #combineResult(input, combine) {\n    if (combine) {\n      if (!this.#combinedResult || this.#result !== this.#lastResult || combine !== this.#lastCombine) {\n        this.#lastCombine = combine;\n        this.#lastResult = this.#result;\n        this.#combinedResult = replaceEqualDeep(\n          this.#combinedResult,\n          combine(input)\n        );\n      }\n      return this.#combinedResult;\n    }\n    return input;\n  }\n  #findMatchingObservers(queries) {\n    const prevObserversMap = /* @__PURE__ */ new Map();\n    this.#observers.forEach((observer) => {\n      const key = observer.options.queryHash;\n      if (!key) return;\n      const previousObservers = prevObserversMap.get(key);\n      if (previousObservers) {\n        previousObservers.push(observer);\n      } else {\n        prevObserversMap.set(key, [observer]);\n      }\n    });\n    const observers = [];\n    queries.forEach((options) => {\n      const defaultedOptions = this.#client.defaultQueryOptions(options);\n      const match = prevObserversMap.get(defaultedOptions.queryHash)?.shift();\n      const observer = match ?? new QueryObserver(this.#client, defaultedOptions);\n      observers.push({\n        defaultedQueryOptions: defaultedOptions,\n        observer\n      });\n    });\n    return observers;\n  }\n  #onUpdate(observer, result) {\n    const index = this.#observers.indexOf(observer);\n    if (index !== -1) {\n      this.#result = replaceAt(this.#result, index, result);\n      this.#notify();\n    }\n  }\n  #notify() {\n    if (this.hasListeners()) {\n      const previousResult = this.#combinedResult;\n      const newTracked = this.#trackResult(this.#result, this.#observerMatches);\n      const newResult = this.#combineResult(newTracked, this.#options?.combine);\n      if (previousResult !== newResult) {\n        notifyManager.batch(() => {\n          this.listeners.forEach((listener) => {\n            listener(this.#result);\n          });\n        });\n      }\n    }\n  }\n};\nexport {\n  QueriesObserver\n};\n//# sourceMappingURL=queriesObserver.js.map","// src/streamedQuery.ts\nimport { addToEnd } from \"./utils.js\";\nfunction streamedQuery({\n  streamFn,\n  refetchMode = \"reset\",\n  reducer = (items, chunk) => addToEnd(items, chunk),\n  initialValue = []\n}) {\n  return async (context) => {\n    const query = context.client.getQueryCache().find({ queryKey: context.queryKey, exact: true });\n    const isRefetch = !!query && query.state.data !== void 0;\n    if (isRefetch && refetchMode === \"reset\") {\n      query.setState({\n        status: \"pending\",\n        data: void 0,\n        error: null,\n        fetchStatus: \"fetching\"\n      });\n    }\n    let result = initialValue;\n    const stream = await streamFn(context);\n    for await (const chunk of stream) {\n      if (context.signal.aborted) {\n        break;\n      }\n      if (!isRefetch || refetchMode !== \"replace\") {\n        context.client.setQueryData(\n          context.queryKey,\n          (prev) => reducer(prev === void 0 ? initialValue : prev, chunk)\n        );\n      }\n      result = reducer(result, chunk);\n    }\n    if (isRefetch && refetchMode === \"replace\" && !context.signal.aborted) {\n      context.client.setQueryData(context.queryKey, result);\n    }\n    return context.client.getQueryData(context.queryKey) ?? initialValue;\n  };\n}\nexport {\n  streamedQuery\n};\n//# sourceMappingURL=streamedQuery.js.map","// src/types.ts\nvar dataTagSymbol = Symbol(\"dataTagSymbol\");\nvar dataTagErrorSymbol = Symbol(\"dataTagErrorSymbol\");\nvar unsetMarker = Symbol(\"unsetMarker\");\nexport {\n  dataTagErrorSymbol,\n  dataTagSymbol,\n  unsetMarker\n};\n//# sourceMappingURL=types.js.map","\"use client\";\n\n// src/useQueries.ts\nimport * as React from \"react\";\nimport {\n  QueriesObserver,\n  QueryObserver,\n  noop,\n  notifyManager\n} from \"@tanstack/query-core\";\nimport { useQueryClient } from \"./QueryClientProvider.js\";\nimport { useIsRestoring } from \"./IsRestoringProvider.js\";\nimport { useQueryErrorResetBoundary } from \"./QueryErrorResetBoundary.js\";\nimport {\n  ensurePreventErrorBoundaryRetry,\n  getHasError,\n  useClearResetErrorBoundary\n} from \"./errorBoundaryUtils.js\";\nimport {\n  ensureSuspenseTimers,\n  fetchOptimistic,\n  shouldSuspend,\n  willFetch\n} from \"./suspense.js\";\nfunction useQueries({\n  queries,\n  ...options\n}, queryClient) {\n  const client = useQueryClient(queryClient);\n  const isRestoring = useIsRestoring();\n  const errorResetBoundary = useQueryErrorResetBoundary();\n  const defaultedQueries = React.useMemo(\n    () => queries.map((opts) => {\n      const defaultedOptions = client.defaultQueryOptions(\n        opts\n      );\n      defaultedOptions._optimisticResults = isRestoring ? \"isRestoring\" : \"optimistic\";\n      return defaultedOptions;\n    }),\n    [queries, client, isRestoring]\n  );\n  defaultedQueries.forEach((query) => {\n    ensureSuspenseTimers(query);\n    ensurePreventErrorBoundaryRetry(query, errorResetBoundary);\n  });\n  useClearResetErrorBoundary(errorResetBoundary);\n  const [observer] = React.useState(\n    () => new QueriesObserver(\n      client,\n      defaultedQueries,\n      options\n    )\n  );\n  const [optimisticResult, getCombinedResult, trackResult] = observer.getOptimisticResult(\n    defaultedQueries,\n    options.combine\n  );\n  const shouldSubscribe = !isRestoring && options.subscribed !== false;\n  React.useSyncExternalStore(\n    React.useCallback(\n      (onStoreChange) => shouldSubscribe ? observer.subscribe(notifyManager.batchCalls(onStoreChange)) : noop,\n      [observer, shouldSubscribe]\n    ),\n    () => observer.getCurrentResult(),\n    () => observer.getCurrentResult()\n  );\n  React.useEffect(() => {\n    observer.setQueries(\n      defaultedQueries,\n      options\n    );\n  }, [defaultedQueries, options, observer]);\n  const shouldAtLeastOneSuspend = optimisticResult.some(\n    (result, index) => shouldSuspend(defaultedQueries[index], result)\n  );\n  const suspensePromises = shouldAtLeastOneSuspend ? optimisticResult.flatMap((result, index) => {\n    const opts = defaultedQueries[index];\n    if (opts) {\n      const queryObserver = new QueryObserver(client, opts);\n      if (shouldSuspend(opts, result)) {\n        return fetchOptimistic(opts, queryObserver, errorResetBoundary);\n      } else if (willFetch(result, isRestoring)) {\n        void fetchOptimistic(opts, queryObserver, errorResetBoundary);\n      }\n    }\n    return [];\n  }) : [];\n  if (suspensePromises.length > 0) {\n    throw Promise.all(suspensePromises);\n  }\n  const firstSingleResultWhichShouldThrow = optimisticResult.find(\n    (result, index) => {\n      const query = defaultedQueries[index];\n      return query && getHasError({\n        result,\n        errorResetBoundary,\n        throwOnError: query.throwOnError,\n        query: client.getQueryCache().get(query.queryHash),\n        suspense: query.suspense\n      });\n    }\n  );\n  if (firstSingleResultWhichShouldThrow?.error) {\n    throw firstSingleResultWhichShouldThrow.error;\n  }\n  return getCombinedResult(trackResult());\n}\nexport {\n  useQueries\n};\n//# sourceMappingURL=useQueries.js.map","\"use client\";\n\n// src/useSuspenseInfiniteQuery.ts\nimport { InfiniteQueryObserver, skipToken } from \"@tanstack/query-core\";\nimport { useBaseQuery } from \"./useBaseQuery.js\";\nimport { defaultThrowOnError } from \"./suspense.js\";\nfunction useSuspenseInfiniteQuery(options, queryClient) {\n  if (process.env.NODE_ENV !== \"production\") {\n    if (options.queryFn === skipToken) {\n      console.error(\"skipToken is not allowed for useSuspenseInfiniteQuery\");\n    }\n  }\n  return useBaseQuery(\n    {\n      ...options,\n      enabled: true,\n      suspense: true,\n      throwOnError: defaultThrowOnError\n    },\n    InfiniteQueryObserver,\n    queryClient\n  );\n}\nexport {\n  useSuspenseInfiniteQuery\n};\n//# sourceMappingURL=useSuspenseInfiniteQuery.js.map","\"use client\";\n\n// src/useSuspenseQueries.ts\nimport { skipToken } from \"@tanstack/query-core\";\nimport { useQueries } from \"./useQueries.js\";\nimport { defaultThrowOnError } from \"./suspense.js\";\nfunction useSuspenseQueries(options, queryClient) {\n  return useQueries(\n    {\n      ...options,\n      queries: options.queries.map((query) => {\n        if (process.env.NODE_ENV !== \"production\") {\n          if (query.queryFn === skipToken) {\n            console.error(\"skipToken is not allowed for useSuspenseQueries\");\n          }\n        }\n        return {\n          ...query,\n          suspense: true,\n          throwOnError: defaultThrowOnError,\n          enabled: true,\n          placeholderData: void 0\n        };\n      })\n    },\n    queryClient\n  );\n}\nexport {\n  useSuspenseQueries\n};\n//# sourceMappingURL=useSuspenseQueries.js.map","// src/usePrefetchQuery.tsx\nimport { useQueryClient } from \"./QueryClientProvider.js\";\nfunction usePrefetchQuery(options, queryClient) {\n  const client = useQueryClient(queryClient);\n  if (!client.getQueryState(options.queryKey)) {\n    client.prefetchQuery(options);\n  }\n}\nexport {\n  usePrefetchQuery\n};\n//# sourceMappingURL=usePrefetchQuery.js.map","// src/usePrefetchInfiniteQuery.tsx\nimport { useQueryClient } from \"./QueryClientProvider.js\";\nfunction usePrefetchInfiniteQuery(options, queryClient) {\n  const client = useQueryClient(queryClient);\n  if (!client.getQueryState(options.queryKey)) {\n    client.prefetchInfiniteQuery(options);\n  }\n}\nexport {\n  usePrefetchInfiniteQuery\n};\n//# sourceMappingURL=usePrefetchInfiniteQuery.js.map","// src/queryOptions.ts\nfunction queryOptions(options) {\n  return options;\n}\nexport {\n  queryOptions\n};\n//# sourceMappingURL=queryOptions.js.map","// src/infiniteQueryOptions.ts\nfunction infiniteQueryOptions(options) {\n  return options;\n}\nexport {\n  infiniteQueryOptions\n};\n//# sourceMappingURL=infiniteQueryOptions.js.map","\"use client\";\n\n// src/useIsFetching.ts\nimport * as React from \"react\";\nimport { notifyManager } from \"@tanstack/query-core\";\nimport { useQueryClient } from \"./QueryClientProvider.js\";\nfunction useIsFetching(filters, queryClient) {\n  const client = useQueryClient(queryClient);\n  const queryCache = client.getQueryCache();\n  return React.useSyncExternalStore(\n    React.useCallback(\n      (onStoreChange) => queryCache.subscribe(notifyManager.batchCalls(onStoreChange)),\n      [queryCache]\n    ),\n    () => client.isFetching(filters),\n    () => client.isFetching(filters)\n  );\n}\nexport {\n  useIsFetching\n};\n//# sourceMappingURL=useIsFetching.js.map","\"use client\";\n\n// src/useMutationState.ts\nimport * as React from \"react\";\nimport { notifyManager, replaceEqualDeep } from \"@tanstack/query-core\";\nimport { useQueryClient } from \"./QueryClientProvider.js\";\nfunction useIsMutating(filters, queryClient) {\n  const client = useQueryClient(queryClient);\n  return useMutationState(\n    { filters: { ...filters, status: \"pending\" } },\n    client\n  ).length;\n}\nfunction getResult(mutationCache, options) {\n  return mutationCache.findAll(options.filters).map(\n    (mutation) => options.select ? options.select(mutation) : mutation.state\n  );\n}\nfunction useMutationState(options = {}, queryClient) {\n  const mutationCache = useQueryClient(queryClient).getMutationCache();\n  const optionsRef = React.useRef(options);\n  const result = React.useRef(null);\n  if (result.current === null) {\n    result.current = getResult(mutationCache, options);\n  }\n  React.useEffect(() => {\n    optionsRef.current = options;\n  });\n  return React.useSyncExternalStore(\n    React.useCallback(\n      (onStoreChange) => mutationCache.subscribe(() => {\n        const nextResult = replaceEqualDeep(\n          result.current,\n          getResult(mutationCache, optionsRef.current)\n        );\n        if (result.current !== nextResult) {\n          result.current = nextResult;\n          notifyManager.schedule(onStoreChange);\n        }\n      }),\n      [mutationCache]\n    ),\n    () => result.current,\n    () => result.current\n  );\n}\nexport {\n  useIsMutating,\n  useMutationState\n};\n//# sourceMappingURL=useMutationState.js.map","// src/mutationOptions.ts\nfunction mutationOptions(options) {\n  return options;\n}\nexport {\n  mutationOptions\n};\n//# sourceMappingURL=mutationOptions.js.map","\"use client\";\n\n// src/useInfiniteQuery.ts\nimport { InfiniteQueryObserver } from \"@tanstack/query-core\";\nimport { useBaseQuery } from \"./useBaseQuery.js\";\nfunction useInfiniteQuery(options, queryClient) {\n  return useBaseQuery(\n    options,\n    InfiniteQueryObserver,\n    queryClient\n  );\n}\nexport {\n  useInfiniteQuery\n};\n//# sourceMappingURL=useInfiniteQuery.js.map"],"names":["InfiniteQueryObserver","QueryObserver","client","options","infiniteQueryBehavior","query","state","parentResult","isFetching","isRefetching","isError","isRefetchError","fetchDirection","isFetchNextPageError","isFetchingNextPage","isFetchPreviousPageError","isFetchingPreviousPage","hasNextPage","hasPreviousPage","difference","array1","array2","excludeSet","x","replaceAt","array","index","value","copy","QueriesObserver","Subscribable","#client","#result","#queries","#options","#observers","#combinedResult","#lastCombine","#lastResult","#observerMatches","queries","observer","result","#onUpdate","queryHashes","notifyManager","prevObservers","newObserverMatches","#findMatchingObservers","match","newObservers","newResult","hasLengthChange","hasIndexChange","hasStructuralChange","hasResultChange","prev","shallowEqualObjects","#notify","combine","matches","#combineResult","#trackResult","observerResult","accessedProp","m","input","replaceEqualDeep","prevObserversMap","key","previousObservers","observers","defaultedOptions","previousResult","newTracked","listener","streamedQuery","streamFn","refetchMode","reducer","items","chunk","addToEnd","initialValue","context","isRefetch","stream","dataTagSymbol","dataTagErrorSymbol","unsetMarker","useQueries","queryClient","useQueryClient","isRestoring","useIsRestoring","errorResetBoundary","useQueryErrorResetBoundary","defaultedQueries","React","opts","ensureSuspenseTimers","ensurePreventErrorBoundaryRetry","useClearResetErrorBoundary","optimisticResult","getCombinedResult","trackResult","shouldSubscribe","onStoreChange","noop","suspensePromises","shouldSuspend","queryObserver","fetchOptimistic","willFetch","firstSingleResultWhichShouldThrow","getHasError","useSuspenseInfiniteQuery","skipToken","useBaseQuery","defaultThrowOnError","useSuspenseQueries","usePrefetchQuery","usePrefetchInfiniteQuery","queryOptions","infiniteQueryOptions","useIsFetching","filters","queryCache","useIsMutating","useMutationState","getResult","mutationCache","mutation","optionsRef","nextResult","mutationOptions","useInfiniteQuery"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14]}