import { Q, S as T, n as m, b as D, z as M, l as F, e as b, A as I, B as K, C as B, D as H, E as L, f as A, F as E, G as S, H as _, I as z, s as k, a as q, d as x } from "./useQuery-DSKGiCQr.js";
import { N as ye, J as pe, p as ge, K as be, L as me, M as ve, O as Qe, r as Oe, h as Re, P as Ee, T as Se, k as Pe, m as we, q as Ce, v as Me, y as ke, g as qe, U as xe, u as Ne } from "./useQuery-DSKGiCQr.js";
import { i as P, h as U, a as j } from "./HydrationBoundary-DD-EI0m6.js";
import { H as De, M as Fe, Q as Ie, b as Ke, d as Be, c as He, e as Le, f as Ae } from "./HydrationBoundary-DD-EI0m6.js";
import { M as ze } from "./mutation-DtwNNkmQ.js";
import { M as je, u as Ge } from "./useMutation-CgOLW9Kh.js";
import * as l from "react";
import { u as Ve } from "./useSuspenseQuery-DbPM3Wv6.js";
var N = class extends Q {
  constructor(e, t) {
    super(e, t);
  }
  bindMethods() {
    super.bindMethods(), this.fetchNextPage = this.fetchNextPage.bind(this), this.fetchPreviousPage = this.fetchPreviousPage.bind(this);
  }
  setOptions(e) {
    super.setOptions({
      ...e,
      behavior: P()
    });
  }
  getOptimisticResult(e) {
    return e.behavior = P(), super.getOptimisticResult(e);
  }
  fetchNextPage(e) {
    return this.fetch({
      ...e,
      meta: {
        fetchMore: { direction: "forward" }
      }
    });
  }
  fetchPreviousPage(e) {
    return this.fetch({
      ...e,
      meta: {
        fetchMore: { direction: "backward" }
      }
    });
  }
  createResult(e, t) {
    const { state: s } = e, n = super.createResult(e, t), { isFetching: r, isRefetching: i, isError: u, isRefetchError: o } = n, c = s.fetchMeta?.fetchMore?.direction, y = u && c === "forward", a = r && c === "forward", f = u && c === "backward", g = r && c === "backward";
    return {
      ...n,
      fetchNextPage: this.fetchNextPage,
      fetchPreviousPage: this.fetchPreviousPage,
      hasNextPage: j(t, s.data),
      hasPreviousPage: U(t, s.data),
      isFetchNextPageError: y,
      isFetchingNextPage: a,
      isFetchPreviousPageError: f,
      isFetchingPreviousPage: g,
      isRefetchError: o && !y && !f,
      isRefetching: i && !a && !g
    };
  }
};
function w(e, t) {
  const s = new Set(t);
  return e.filter((n) => !s.has(n));
}
function G(e, t, s) {
  const n = e.slice(0);
  return n[t] = s, n;
}
var J = class extends T {
  #r;
  #e;
  #n;
  #i;
  #t;
  #s;
  #u;
  #a;
  #o = [];
  constructor(e, t, s) {
    super(), this.#r = e, this.#i = s, this.#n = [], this.#t = [], this.#e = [], this.setQueries(t);
  }
  onSubscribe() {
    this.listeners.size === 1 && this.#t.forEach((e) => {
      e.subscribe((t) => {
        this.#f(e, t);
      });
    });
  }
  onUnsubscribe() {
    this.listeners.size || this.destroy();
  }
  destroy() {
    this.listeners = /* @__PURE__ */ new Set(), this.#t.forEach((e) => {
      e.destroy();
    });
  }
  setQueries(e, t) {
    if (this.#n = e, this.#i = t, process.env.NODE_ENV !== "production") {
      const s = e.map(
        (n) => this.#r.defaultQueryOptions(n).queryHash
      );
      new Set(s).size !== s.length && console.warn(
        "[QueriesObserver]: Duplicate Queries found. This might result in unexpected behavior."
      );
    }
    m.batch(() => {
      const s = this.#t, n = this.#l(this.#n);
      this.#o = n, n.forEach(
        (a) => a.observer.setOptions(a.defaultedQueryOptions)
      );
      const r = n.map((a) => a.observer), i = r.map(
        (a) => a.getCurrentResult()
      ), u = s.length !== r.length, o = r.some(
        (a, f) => a !== s[f]
      ), c = u || o, y = c ? !0 : i.some((a, f) => {
        const g = this.#e[f];
        return !g || !D(a, g);
      });
      !c && !y || (c && (this.#t = r), this.#e = i, this.hasListeners() && (c && (w(s, r).forEach((a) => {
        a.destroy();
      }), w(r, s).forEach((a) => {
        a.subscribe((f) => {
          this.#f(a, f);
        });
      })), this.#d()));
    });
  }
  getCurrentResult() {
    return this.#e;
  }
  getQueries() {
    return this.#t.map((e) => e.getCurrentQuery());
  }
  getObservers() {
    return this.#t;
  }
  getOptimisticResult(e, t) {
    const s = this.#l(e), n = s.map(
      (r) => r.observer.getOptimisticResult(r.defaultedQueryOptions)
    );
    return [
      n,
      (r) => this.#h(r ?? n, t),
      () => this.#c(n, s)
    ];
  }
  #c(e, t) {
    return t.map((s, n) => {
      const r = e[n];
      return s.defaultedQueryOptions.notifyOnChangeProps ? r : s.observer.trackResult(r, (i) => {
        t.forEach((u) => {
          u.observer.trackProp(i);
        });
      });
    });
  }
  #h(e, t) {
    return t ? ((!this.#s || this.#e !== this.#a || t !== this.#u) && (this.#u = t, this.#a = this.#e, this.#s = M(
      this.#s,
      t(e)
    )), this.#s) : e;
  }
  #l(e) {
    const t = /* @__PURE__ */ new Map();
    this.#t.forEach((n) => {
      const r = n.options.queryHash;
      if (!r) return;
      const i = t.get(r);
      i ? i.push(n) : t.set(r, [n]);
    });
    const s = [];
    return e.forEach((n) => {
      const r = this.#r.defaultQueryOptions(n), u = t.get(r.queryHash)?.shift() ?? new Q(this.#r, r);
      s.push({
        defaultedQueryOptions: r,
        observer: u
      });
    }), s;
  }
  #f(e, t) {
    const s = this.#t.indexOf(e);
    s !== -1 && (this.#e = G(this.#e, s, t), this.#d());
  }
  #d() {
    if (this.hasListeners()) {
      const e = this.#s, t = this.#c(this.#e, this.#o), s = this.#h(t, this.#i?.combine);
      e !== s && m.batch(() => {
        this.listeners.forEach((n) => {
          n(this.#e);
        });
      });
    }
  }
};
function Z({
  streamFn: e,
  refetchMode: t = "reset",
  reducer: s = (r, i) => F(r, i),
  initialValue: n = []
}) {
  return async (r) => {
    const i = r.client.getQueryCache().find({ queryKey: r.queryKey, exact: !0 }), u = !!i && i.state.data !== void 0;
    u && t === "reset" && i.setState({
      status: "pending",
      data: void 0,
      error: null,
      fetchStatus: "fetching"
    });
    let o = n;
    const c = await e(r);
    for await (const y of c) {
      if (r.signal.aborted)
        break;
      (!u || t !== "replace") && r.client.setQueryData(
        r.queryKey,
        (a) => s(a === void 0 ? n : a, y)
      ), o = s(o, y);
    }
    return u && t === "replace" && !r.signal.aborted && r.client.setQueryData(r.queryKey, o), r.client.getQueryData(r.queryKey) ?? n;
  };
}
var $ = Symbol("dataTagSymbol"), ee = Symbol("dataTagErrorSymbol"), te = Symbol("unsetMarker");
function V({
  queries: e,
  ...t
}, s) {
  const n = b(s), r = I(), i = K(), u = l.useMemo(
    () => e.map((h) => {
      const p = n.defaultQueryOptions(
        h
      );
      return p._optimisticResults = r ? "isRestoring" : "optimistic", p;
    }),
    [e, n, r]
  );
  u.forEach((h) => {
    B(h), H(h, i);
  }), L(i);
  const [o] = l.useState(
    () => new J(
      n,
      u,
      t
    )
  ), [c, y, a] = o.getOptimisticResult(
    u,
    t.combine
  ), f = !r && t.subscribed !== !1;
  l.useSyncExternalStore(
    l.useCallback(
      (h) => f ? o.subscribe(m.batchCalls(h)) : A,
      [o, f]
    ),
    () => o.getCurrentResult(),
    () => o.getCurrentResult()
  ), l.useEffect(() => {
    o.setQueries(
      u,
      t
    );
  }, [u, t, o]);
  const v = c.some(
    (h, p) => E(u[p], h)
  ) ? c.flatMap((h, p) => {
    const d = u[p];
    if (d) {
      const R = new Q(n, d);
      if (E(d, h))
        return S(d, R, i);
      _(h, r) && S(d, R, i);
    }
    return [];
  }) : [];
  if (v.length > 0)
    throw Promise.all(v);
  const O = c.find(
    (h, p) => {
      const d = u[p];
      return d && z({
        result: h,
        errorResetBoundary: i,
        throwOnError: d.throwOnError,
        query: n.getQueryCache().get(d.queryHash),
        suspense: d.suspense
      });
    }
  );
  if (O?.error)
    throw O.error;
  return y(a());
}
function se(e, t) {
  return process.env.NODE_ENV !== "production" && e.queryFn === k && console.error("skipToken is not allowed for useSuspenseInfiniteQuery"), q(
    {
      ...e,
      enabled: !0,
      suspense: !0,
      throwOnError: x
    },
    N,
    t
  );
}
function re(e, t) {
  return V(
    {
      ...e,
      queries: e.queries.map((s) => (process.env.NODE_ENV !== "production" && s.queryFn === k && console.error("skipToken is not allowed for useSuspenseQueries"), {
        ...s,
        suspense: !0,
        throwOnError: x,
        enabled: !0,
        placeholderData: void 0
      }))
    },
    t
  );
}
function ne(e, t) {
  const s = b(t);
  s.getQueryState(e.queryKey) || s.prefetchQuery(e);
}
function ie(e, t) {
  const s = b(t);
  s.getQueryState(e.queryKey) || s.prefetchInfiniteQuery(e);
}
function ue(e) {
  return e;
}
function ae(e) {
  return e;
}
function oe(e, t) {
  const s = b(t), n = s.getQueryCache();
  return l.useSyncExternalStore(
    l.useCallback(
      (r) => n.subscribe(m.batchCalls(r)),
      [n]
    ),
    () => s.isFetching(e),
    () => s.isFetching(e)
  );
}
function ce(e, t) {
  const s = b(t);
  return W(
    { filters: { ...e, status: "pending" } },
    s
  ).length;
}
function C(e, t) {
  return e.findAll(t.filters).map(
    (s) => t.select ? t.select(s) : s.state
  );
}
function W(e = {}, t) {
  const s = b(t).getMutationCache(), n = l.useRef(e), r = l.useRef(null);
  return r.current === null && (r.current = C(s, e)), l.useEffect(() => {
    n.current = e;
  }), l.useSyncExternalStore(
    l.useCallback(
      (i) => s.subscribe(() => {
        const u = M(
          r.current,
          C(s, n.current)
        );
        r.current !== u && (r.current = u, m.schedule(i));
      }),
      [s]
    ),
    () => r.current,
    () => r.current
  );
}
function he(e) {
  return e;
}
function le(e, t) {
  return q(
    e,
    N,
    t
  );
}
export {
  ye as CancelledError,
  De as HydrationBoundary,
  N as InfiniteQueryObserver,
  pe as IsRestoringProvider,
  ze as Mutation,
  Fe as MutationCache,
  je as MutationObserver,
  J as QueriesObserver,
  ge as Query,
  Ie as QueryCache,
  Ke as QueryClient,
  be as QueryClientContext,
  me as QueryClientProvider,
  ve as QueryErrorResetBoundary,
  Q as QueryObserver,
  ee as dataTagErrorSymbol,
  $ as dataTagSymbol,
  Qe as defaultScheduler,
  Be as defaultShouldDehydrateMutation,
  He as defaultShouldDehydrateQuery,
  Le as dehydrate,
  Z as experimental_streamedQuery,
  Oe as focusManager,
  Re as hashKey,
  Ae as hydrate,
  ae as infiniteQueryOptions,
  Ee as isCancelledError,
  Se as isServer,
  Pe as keepPreviousData,
  we as matchMutation,
  Ce as matchQuery,
  he as mutationOptions,
  A as noop,
  m as notifyManager,
  Me as onlineManager,
  ke as partialMatchKey,
  ue as queryOptions,
  M as replaceEqualDeep,
  qe as shouldThrowError,
  k as skipToken,
  xe as timeoutManager,
  te as unsetMarker,
  le as useInfiniteQuery,
  oe as useIsFetching,
  ce as useIsMutating,
  I as useIsRestoring,
  Ge as useMutation,
  W as useMutationState,
  ie as usePrefetchInfiniteQuery,
  ne as usePrefetchQuery,
  V as useQueries,
  Ne as useQuery,
  b as useQueryClient,
  K as useQueryErrorResetBoundary,
  se as useSuspenseInfiniteQuery,
  re as useSuspenseQueries,
  Ve as useSuspenseQuery
};
//# sourceMappingURL=zudoku.react-query.js.map
