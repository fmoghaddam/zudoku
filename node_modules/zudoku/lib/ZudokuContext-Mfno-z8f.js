import { e as m, u as C } from "./useQuery-DSKGiCQr.js";
import { u as P } from "./useSuspenseQuery-DbPM3Wv6.js";
import { useCallback as b, useContext as x, useEffect as A } from "react";
import { a as l, m as h } from "./chunk-EPOLDU6W-CLHrVxOG.js";
import { Z as E, u as k } from "./ZudokuReactContext-DGJAP1sN.js";
import { c as w } from "./index-DI5SPFK9.js";
const N = /^(\w+:\/\/[^/?]+)?([^?]*)(\?.*)?$/, S = (t) => t.filter(
  (e) => e != null && e !== !1 && (typeof e == "string" || typeof e == "number")
).map((e) => `${e}`).filter((e) => e), T = (t) => {
  const e = t.join("/"), [, n = "", a = ""] = e.match(N) ?? [];
  return {
    prefix: n,
    pathname: a.split("/").filter((s) => s !== "")
  };
}, j = (t) => {
  const { prefix: e, pathname: n } = t;
  let a = e;
  return n.length > 0 ? (a ? a += "/" : a = "/", a += n.join("/")) : a || (a = "/"), a;
}, u = (...t) => {
  const e = S(t), n = T(e);
  return j(n);
}, y = Object.freeze({
  API_IDENTITIES: ["api-identities"]
}), q = () => {
  const t = m();
  return { invalidateCache: b(
    (n) => t.invalidateQueries({ queryKey: y[n] }),
    [t]
  ) };
}, F = "no-dehydrate", f = (t, e) => {
  for (const n of t) {
    const a = d(n, e);
    if (a !== void 0) return a;
  }
}, d = (t, e, n = []) => {
  const a = e(t, n);
  if (a !== void 0) return a;
  if (t.type === "category")
    for (const s of t.items) {
      const r = d(s, e, [
        ...n,
        t
      ]);
      if (r !== void 0) return r;
    }
}, M = () => {
  const t = l(), { navigation: e } = I();
  return f(e, (n) => {
    if (n.type === "doc" && u(n.path) === t.pathname)
      return n;
  });
}, O = (t) => {
  const e = l();
  return d(t, (n) => {
    switch (n.type) {
      case "category":
        return n.link && u(n.link.path) === e.pathname ? !0 : void 0;
      case "custom-page":
      case "doc":
        return u(n.path) === e.pathname ? !0 : void 0;
      default:
        return;
    }
  });
}, Q = () => {
  const t = l().pathname, { navigation: e } = I();
  let n, a, s = !1;
  return f(e, (r) => {
    if (r.type === "separator" || r.type === "section" || r.type === "filter")
      return;
    const o = r.type === "doc" ? u(r.path) : r.type === "category" && r.link ? u(r.link.path) : void 0;
    if (o) {
      if (s)
        return a = { label: r.label, id: o }, !0;
      t === o ? s = !0 : n = { label: r.label, id: o };
    }
  }), { prev: n, next: a };
}, U = w(
  "relative flex items-center gap-2 px-(--padding-nav-item) my-0.5 py-1.5 rounded-lg hover:bg-accent tabular-nums",
  {
    variants: {
      isActive: {
        true: "bg-accent font-medium",
        false: "text-foreground/80"
      },
      isMuted: {
        true: "text-foreground/30",
        false: ""
      },
      isPending: {
        true: "bg-accent animate-pulse",
        false: ""
      }
    },
    defaultVariants: {
      isActive: !1
    }
  }
), g = (t, e) => ["separator", "section", "filter"].includes(t.type) || t.label?.toLowerCase().includes(e.toLowerCase()) ? !0 : t.type === "category" ? t.items.some((n) => g(n, e)) : !1, H = (t, e, n) => (a) => a.type === "filter" ? !0 : n?.trim() && !g(a, n) ? !1 : typeof a.display == "function" ? a.display({ context: e, auth: t }) : a.display === "hide" || !a.label ? !1 : a.display === "auth" && t.isAuthenticated || a.display === "anon" && !t.isAuthenticated || !a.display || a.display === "always", v = () => {
  const t = x(E);
  if (!t)
    throw new Error("useZudoku must be used within a ZudokuProvider.");
  return t;
}, Y = () => {
  const { getApiIdentities: t } = v(), { isAuthenticated: e } = k(), { invalidateCache: n } = q();
  return A(() => {
    e || n("API_IDENTITIES");
  }, [e, n]), C({
    queryFn: t,
    queryKey: y.API_IDENTITIES
  });
}, p = (t) => {
  switch (t.type) {
    case "doc":
      return u(t.path);
    case "category":
      return t.link ? u(t.link.path) : void 0;
    case "link":
      return t.to;
    case "custom-page":
      return u(t.path);
    default:
      return;
  }
}, D = (t) => {
  const e = /* @__PURE__ */ new Set(), n = (a) => {
    for (const s of a) {
      const r = p(s)?.split("?").at(0)?.split("#").at(0);
      r && e.add(r), s.type === "category" && n(s.items);
    }
  };
  return n(t), [...e];
}, I = () => {
  const {
    getPluginNavigation: t,
    options: { navigation: e = [] }
  } = v(), n = l(), a = f(e, (o, i) => {
    if (o.type !== "link" && p(o) === n.pathname)
      return i.at(0) ?? o;
  }), { data: s } = P({
    queryFn: () => t(n.pathname),
    queryKey: ["plugin-navigation", n.pathname]
  });
  let r = a;
  if (!a && s.length > 0) {
    const o = D(s);
    r = e.flatMap((i) => {
      const c = p(i);
      return c ? [{ item: i, path: c }] : [];
    }).sort((i, c) => c.path.length - i.path.length).find(({ path: i }) => o.some(
      (c) => h({ path: i, end: !1 }, c) ?? h({ path: c, end: !1 }, i)
    ))?.item;
  }
  return {
    navigation: [
      ...a?.type === "category" ? a.items : [],
      ...s
    ],
    topNavItem: r
  };
};
export {
  y as C,
  F as N,
  v as a,
  M as b,
  Q as c,
  I as d,
  Y as e,
  O as f,
  d as g,
  u as j,
  U as n,
  H as s,
  f as t,
  q as u
};
//# sourceMappingURL=ZudokuContext-Mfno-z8f.js.map
