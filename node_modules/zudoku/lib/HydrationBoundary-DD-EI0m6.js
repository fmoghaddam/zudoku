import { t as U, f as g, i as _, j as z, l as B, S as T, n as c, m as C, o as j, p as x, q as E, r as W, v as S, w as F, x as $, h as H, y as K, s as L, e as V } from "./useQuery-DSKGiCQr.js";
import { M as G } from "./mutation-DtwNNkmQ.js";
import * as b from "react";
function k(e) {
  return e;
}
function J(e) {
  return {
    mutationKey: e.options.mutationKey,
    state: e.state,
    ...e.options.scope && { scope: e.options.scope },
    ...e.meta && { meta: e.meta }
  };
}
function X(e, t, s) {
  const a = () => {
    const r = e.promise?.then(t).catch((i) => s(i) ? (process.env.NODE_ENV !== "production" && console.error(
      `A query that was dehydrated as pending ended up rejecting. [${e.queryHash}]: ${i}; The error will be redacted in production builds`
    ), Promise.reject(new Error("redacted"))) : Promise.reject(i));
    return r?.catch(g), r;
  };
  return {
    dehydratedAt: Date.now(),
    state: {
      ...e.state,
      ...e.state.data !== void 0 && {
        data: t(e.state.data)
      }
    },
    queryKey: e.queryKey,
    queryHash: e.queryHash,
    ...e.state.status === "pending" && {
      promise: a()
    },
    ...e.meta && { meta: e.meta }
  };
}
function Y(e) {
  return e.state.isPaused;
}
function Z(e) {
  return e.state.status === "success";
}
function ee(e) {
  return !0;
}
function ie(e, t = {}) {
  const s = t.shouldDehydrateMutation ?? e.getDefaultOptions().dehydrate?.shouldDehydrateMutation ?? Y, a = e.getMutationCache().getAll().flatMap(
    (n) => s(n) ? [J(n)] : []
  ), r = t.shouldDehydrateQuery ?? e.getDefaultOptions().dehydrate?.shouldDehydrateQuery ?? Z, i = t.shouldRedactErrors ?? e.getDefaultOptions().dehydrate?.shouldRedactErrors ?? ee, h = t.serializeData ?? e.getDefaultOptions().dehydrate?.serializeData ?? k, y = e.getQueryCache().getAll().flatMap(
    (n) => r(n) ? [X(n, h, i)] : []
  );
  return { mutations: a, queries: y };
}
function I(e, t, s) {
  if (typeof t != "object" || t === null)
    return;
  const a = e.getMutationCache(), r = e.getQueryCache(), i = s?.defaultOptions?.deserializeData ?? e.getDefaultOptions().hydrate?.deserializeData ?? k, h = t.mutations || [], y = t.queries || [];
  h.forEach(({ state: n, ...u }) => {
    a.build(
      e,
      {
        ...e.getDefaultOptions().hydrate?.mutations,
        ...s?.defaultOptions?.mutations,
        ...u
      },
      n
    );
  }), y.forEach(
    ({ queryKey: n, state: u, queryHash: m, meta: p, promise: d, dehydratedAt: Q }) => {
      const o = d ? U(d) : void 0, l = u.data === void 0 ? o?.data : u.data, v = l === void 0 ? l : i(l);
      let f = r.get(m);
      const D = f?.state.status === "pending", w = f?.state.fetchStatus === "fetching";
      if (f) {
        const P = o && // We only need this undefined check to handle older dehydration
        // payloads that might not have dehydratedAt
        Q !== void 0 && Q > f.state.dataUpdatedAt;
        if (u.dataUpdatedAt > f.state.dataUpdatedAt || P) {
          const { fetchStatus: q, ...O } = u;
          f.setState({
            ...O,
            data: v
          });
        }
      } else
        f = r.build(
          e,
          {
            ...e.getDefaultOptions().hydrate?.queries,
            ...s?.defaultOptions?.queries,
            queryKey: n,
            queryHash: m,
            meta: p
          },
          // Reset fetch status to idle to avoid
          // query being stuck in fetching state upon hydration
          {
            ...u,
            data: v,
            fetchStatus: "idle",
            status: v !== void 0 ? "success" : u.status
          }
        );
      d && !D && !w && // Only hydrate if dehydration is newer than any existing data,
      // this is always true for new queries
      (Q === void 0 || Q > f.state.dataUpdatedAt) && f.fetch(void 0, {
        // RSC transformed promises are not thenable
        initialPromise: Promise.resolve(d).then(i)
      }).catch(g);
    }
  );
}
function R(e) {
  return {
    onFetch: (t, s) => {
      const a = t.options, r = t.fetchOptions?.meta?.fetchMore?.direction, i = t.state.data?.pages || [], h = t.state.data?.pageParams || [];
      let y = { pages: [], pageParams: [] }, n = 0;
      const u = async () => {
        let m = !1;
        const p = (o) => {
          Object.defineProperty(o, "signal", {
            enumerable: !0,
            get: () => (t.signal.aborted ? m = !0 : t.signal.addEventListener("abort", () => {
              m = !0;
            }), t.signal)
          });
        }, d = _(t.options, t.fetchOptions), Q = async (o, l, v) => {
          if (m)
            return Promise.reject();
          if (l == null && o.pages.length)
            return Promise.resolve(o);
          const D = (() => {
            const O = {
              client: t.client,
              queryKey: t.queryKey,
              pageParam: l,
              direction: v ? "backward" : "forward",
              meta: t.options.meta
            };
            return p(O), O;
          })(), w = await d(D), { maxPages: P } = t.options, q = v ? z : B;
          return {
            pages: q(o.pages, w, P),
            pageParams: q(o.pageParams, l, P)
          };
        };
        if (r && i.length) {
          const o = r === "backward", l = o ? N : A, v = {
            pages: i,
            pageParams: h
          }, f = l(a, v);
          y = await Q(v, f, o);
        } else {
          const o = e ?? i.length;
          do {
            const l = n === 0 ? h[0] ?? a.initialPageParam : A(a, y);
            if (n > 0 && l == null)
              break;
            y = await Q(y, l), n++;
          } while (n < o);
        }
        return y;
      };
      t.options.persister ? t.fetchFn = () => t.options.persister?.(
        u,
        {
          client: t.client,
          queryKey: t.queryKey,
          meta: t.options.meta,
          signal: t.signal
        },
        s
      ) : t.fetchFn = u;
    }
  };
}
function A(e, { pages: t, pageParams: s }) {
  const a = t.length - 1;
  return t.length > 0 ? e.getNextPageParam(
    t[a],
    t,
    s[a],
    s
  ) : void 0;
}
function N(e, { pages: t, pageParams: s }) {
  return t.length > 0 ? e.getPreviousPageParam?.(t[0], t, s[0], s) : void 0;
}
function ne(e, t) {
  return t ? A(e, t) != null : !1;
}
function ue(e, t) {
  return !t || !e.getPreviousPageParam ? !1 : N(e, t) != null;
}
var te = class extends T {
  constructor(e = {}) {
    super(), this.config = e, this.#e = /* @__PURE__ */ new Set(), this.#t = /* @__PURE__ */ new Map(), this.#s = 0;
  }
  #e;
  #t;
  #s;
  build(e, t, s) {
    const a = new G({
      client: e,
      mutationCache: this,
      mutationId: ++this.#s,
      options: e.defaultMutationOptions(t),
      state: s
    });
    return this.add(a), a;
  }
  add(e) {
    this.#e.add(e);
    const t = M(e);
    if (typeof t == "string") {
      const s = this.#t.get(t);
      s ? s.push(e) : this.#t.set(t, [e]);
    }
    this.notify({ type: "added", mutation: e });
  }
  remove(e) {
    if (this.#e.delete(e)) {
      const t = M(e);
      if (typeof t == "string") {
        const s = this.#t.get(t);
        if (s)
          if (s.length > 1) {
            const a = s.indexOf(e);
            a !== -1 && s.splice(a, 1);
          } else s[0] === e && this.#t.delete(t);
      }
    }
    this.notify({ type: "removed", mutation: e });
  }
  canRun(e) {
    const t = M(e);
    if (typeof t == "string") {
      const a = this.#t.get(t)?.find(
        (r) => r.state.status === "pending"
      );
      return !a || a === e;
    } else
      return !0;
  }
  runNext(e) {
    const t = M(e);
    return typeof t == "string" ? this.#t.get(t)?.find((a) => a !== e && a.state.isPaused)?.continue() ?? Promise.resolve() : Promise.resolve();
  }
  clear() {
    c.batch(() => {
      this.#e.forEach((e) => {
        this.notify({ type: "removed", mutation: e });
      }), this.#e.clear(), this.#t.clear();
    });
  }
  getAll() {
    return Array.from(this.#e);
  }
  find(e) {
    const t = { exact: !0, ...e };
    return this.getAll().find(
      (s) => C(t, s)
    );
  }
  findAll(e = {}) {
    return this.getAll().filter((t) => C(e, t));
  }
  notify(e) {
    c.batch(() => {
      this.listeners.forEach((t) => {
        t(e);
      });
    });
  }
  resumePausedMutations() {
    const e = this.getAll().filter((t) => t.state.isPaused);
    return c.batch(
      () => Promise.all(
        e.map((t) => t.continue().catch(g))
      )
    );
  }
};
function M(e) {
  return e.options.scope?.id;
}
var se = class extends T {
  constructor(e = {}) {
    super(), this.config = e, this.#e = /* @__PURE__ */ new Map();
  }
  #e;
  build(e, t, s) {
    const a = t.queryKey, r = t.queryHash ?? j(a, t);
    let i = this.get(r);
    return i || (i = new x({
      client: e,
      queryKey: a,
      queryHash: r,
      options: e.defaultQueryOptions(t),
      state: s,
      defaultOptions: e.getQueryDefaults(a)
    }), this.add(i)), i;
  }
  add(e) {
    this.#e.has(e.queryHash) || (this.#e.set(e.queryHash, e), this.notify({
      type: "added",
      query: e
    }));
  }
  remove(e) {
    const t = this.#e.get(e.queryHash);
    t && (e.destroy(), t === e && this.#e.delete(e.queryHash), this.notify({ type: "removed", query: e }));
  }
  clear() {
    c.batch(() => {
      this.getAll().forEach((e) => {
        this.remove(e);
      });
    });
  }
  get(e) {
    return this.#e.get(e);
  }
  getAll() {
    return [...this.#e.values()];
  }
  find(e) {
    const t = { exact: !0, ...e };
    return this.getAll().find(
      (s) => E(t, s)
    );
  }
  findAll(e = {}) {
    const t = this.getAll();
    return Object.keys(e).length > 0 ? t.filter((s) => E(e, s)) : t;
  }
  notify(e) {
    c.batch(() => {
      this.listeners.forEach((t) => {
        t(e);
      });
    });
  }
  onFocus() {
    c.batch(() => {
      this.getAll().forEach((e) => {
        e.onFocus();
      });
    });
  }
  onOnline() {
    c.batch(() => {
      this.getAll().forEach((e) => {
        e.onOnline();
      });
    });
  }
}, oe = class {
  #e;
  #t;
  #s;
  #r;
  #i;
  #a;
  #n;
  #u;
  constructor(e = {}) {
    this.#e = e.queryCache || new se(), this.#t = e.mutationCache || new te(), this.#s = e.defaultOptions || {}, this.#r = /* @__PURE__ */ new Map(), this.#i = /* @__PURE__ */ new Map(), this.#a = 0;
  }
  mount() {
    this.#a++, this.#a === 1 && (this.#n = W.subscribe(async (e) => {
      e && (await this.resumePausedMutations(), this.#e.onFocus());
    }), this.#u = S.subscribe(async (e) => {
      e && (await this.resumePausedMutations(), this.#e.onOnline());
    }));
  }
  unmount() {
    this.#a--, this.#a === 0 && (this.#n?.(), this.#n = void 0, this.#u?.(), this.#u = void 0);
  }
  isFetching(e) {
    return this.#e.findAll({ ...e, fetchStatus: "fetching" }).length;
  }
  isMutating(e) {
    return this.#t.findAll({ ...e, status: "pending" }).length;
  }
  /**
   * Imperative (non-reactive) way to retrieve data for a QueryKey.
   * Should only be used in callbacks or functions where reading the latest data is necessary, e.g. for optimistic updates.
   *
   * Hint: Do not use this function inside a component, because it won't receive updates.
   * Use `useQuery` to create a `QueryObserver` that subscribes to changes.
   */
  getQueryData(e) {
    const t = this.defaultQueryOptions({ queryKey: e });
    return this.#e.get(t.queryHash)?.state.data;
  }
  ensureQueryData(e) {
    const t = this.defaultQueryOptions(e), s = this.#e.build(this, t), a = s.state.data;
    return a === void 0 ? this.fetchQuery(e) : (e.revalidateIfStale && s.isStaleByTime(F(t.staleTime, s)) && this.prefetchQuery(t), Promise.resolve(a));
  }
  getQueriesData(e) {
    return this.#e.findAll(e).map(({ queryKey: t, state: s }) => {
      const a = s.data;
      return [t, a];
    });
  }
  setQueryData(e, t, s) {
    const a = this.defaultQueryOptions({ queryKey: e }), i = this.#e.get(
      a.queryHash
    )?.state.data, h = $(t, i);
    if (h !== void 0)
      return this.#e.build(this, a).setData(h, { ...s, manual: !0 });
  }
  setQueriesData(e, t, s) {
    return c.batch(
      () => this.#e.findAll(e).map(({ queryKey: a }) => [
        a,
        this.setQueryData(a, t, s)
      ])
    );
  }
  getQueryState(e) {
    const t = this.defaultQueryOptions({ queryKey: e });
    return this.#e.get(
      t.queryHash
    )?.state;
  }
  removeQueries(e) {
    const t = this.#e;
    c.batch(() => {
      t.findAll(e).forEach((s) => {
        t.remove(s);
      });
    });
  }
  resetQueries(e, t) {
    const s = this.#e;
    return c.batch(() => (s.findAll(e).forEach((a) => {
      a.reset();
    }), this.refetchQueries(
      {
        type: "active",
        ...e
      },
      t
    )));
  }
  cancelQueries(e, t = {}) {
    const s = { revert: !0, ...t }, a = c.batch(
      () => this.#e.findAll(e).map((r) => r.cancel(s))
    );
    return Promise.all(a).then(g).catch(g);
  }
  invalidateQueries(e, t = {}) {
    return c.batch(() => (this.#e.findAll(e).forEach((s) => {
      s.invalidate();
    }), e?.refetchType === "none" ? Promise.resolve() : this.refetchQueries(
      {
        ...e,
        type: e?.refetchType ?? e?.type ?? "active"
      },
      t
    )));
  }
  refetchQueries(e, t = {}) {
    const s = {
      ...t,
      cancelRefetch: t.cancelRefetch ?? !0
    }, a = c.batch(
      () => this.#e.findAll(e).filter((r) => !r.isDisabled() && !r.isStatic()).map((r) => {
        let i = r.fetch(void 0, s);
        return s.throwOnError || (i = i.catch(g)), r.state.fetchStatus === "paused" ? Promise.resolve() : i;
      })
    );
    return Promise.all(a).then(g);
  }
  fetchQuery(e) {
    const t = this.defaultQueryOptions(e);
    t.retry === void 0 && (t.retry = !1);
    const s = this.#e.build(this, t);
    return s.isStaleByTime(
      F(t.staleTime, s)
    ) ? s.fetch(t) : Promise.resolve(s.state.data);
  }
  prefetchQuery(e) {
    return this.fetchQuery(e).then(g).catch(g);
  }
  fetchInfiniteQuery(e) {
    return e.behavior = R(e.pages), this.fetchQuery(e);
  }
  prefetchInfiniteQuery(e) {
    return this.fetchInfiniteQuery(e).then(g).catch(g);
  }
  ensureInfiniteQueryData(e) {
    return e.behavior = R(e.pages), this.ensureQueryData(e);
  }
  resumePausedMutations() {
    return S.isOnline() ? this.#t.resumePausedMutations() : Promise.resolve();
  }
  getQueryCache() {
    return this.#e;
  }
  getMutationCache() {
    return this.#t;
  }
  getDefaultOptions() {
    return this.#s;
  }
  setDefaultOptions(e) {
    this.#s = e;
  }
  setQueryDefaults(e, t) {
    this.#r.set(H(e), {
      queryKey: e,
      defaultOptions: t
    });
  }
  getQueryDefaults(e) {
    const t = [...this.#r.values()], s = {};
    return t.forEach((a) => {
      K(e, a.queryKey) && Object.assign(s, a.defaultOptions);
    }), s;
  }
  setMutationDefaults(e, t) {
    this.#i.set(H(e), {
      mutationKey: e,
      defaultOptions: t
    });
  }
  getMutationDefaults(e) {
    const t = [...this.#i.values()], s = {};
    return t.forEach((a) => {
      K(e, a.mutationKey) && Object.assign(s, a.defaultOptions);
    }), s;
  }
  defaultQueryOptions(e) {
    if (e._defaulted)
      return e;
    const t = {
      ...this.#s.queries,
      ...this.getQueryDefaults(e.queryKey),
      ...e,
      _defaulted: !0
    };
    return t.queryHash || (t.queryHash = j(
      t.queryKey,
      t
    )), t.refetchOnReconnect === void 0 && (t.refetchOnReconnect = t.networkMode !== "always"), t.throwOnError === void 0 && (t.throwOnError = !!t.suspense), !t.networkMode && t.persister && (t.networkMode = "offlineFirst"), t.queryFn === L && (t.enabled = !1), t;
  }
  defaultMutationOptions(e) {
    return e?._defaulted ? e : {
      ...this.#s.mutations,
      ...e?.mutationKey && this.getMutationDefaults(e.mutationKey),
      ...e,
      _defaulted: !0
    };
  }
  clear() {
    this.#e.clear(), this.#t.clear();
  }
}, he = ({
  children: e,
  options: t = {},
  state: s,
  queryClient: a
}) => {
  const r = V(a), i = b.useRef(t);
  b.useEffect(() => {
    i.current = t;
  });
  const h = b.useMemo(() => {
    if (s) {
      if (typeof s != "object")
        return;
      const y = r.getQueryCache(), n = s.queries || [], u = [], m = [];
      for (const p of n) {
        const d = y.get(p.queryHash);
        d ? (p.state.dataUpdatedAt > d.state.dataUpdatedAt || p.promise && d.state.status !== "pending" && d.state.fetchStatus !== "fetching" && p.dehydratedAt !== void 0 && p.dehydratedAt > d.state.dataUpdatedAt) && m.push(p) : u.push(p);
      }
      if (u.length > 0 && I(r, { queries: u }, i.current), m.length > 0)
        return m;
    }
  }, [r, s]);
  return b.useEffect(() => {
    h && I(r, { queries: h }, i.current);
  }, [r, h]), e;
};
export {
  he as H,
  te as M,
  se as Q,
  ne as a,
  oe as b,
  Z as c,
  Y as d,
  ie as e,
  I as f,
  ue as h,
  R as i
};
//# sourceMappingURL=HydrationBoundary-DD-EI0m6.js.map
