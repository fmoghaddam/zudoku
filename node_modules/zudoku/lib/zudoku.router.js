import { f as ze, s as Z, g as ve, F as ee, R as $e, S as Ee, h as je, i as qe, E as O, j as Ce, k as J, l as Ve, n as We, o as Xe, p as Je, q as be, t as ne, v as se, w as Q, x as k, y as _e, z as Qe, A as Ge, B as Ke, C as Ye, D as Ze, O as et, G as tt, H as I, I as rt, J as at, r as nt, K as M, M as st, P as oe, Q as ot, T as te, U as P, V as it, W as lt, X as ut } from "./chunk-EPOLDU6W-CLHrVxOG.js";
import { Y as mr, Z as yr, _ as wr, $ as gr, a0 as Rr, a1 as Sr, a2 as vr, L as Er, a3 as Cr, a4 as br, a5 as _r, a6 as xr, N as Ar, a7 as Dr, a8 as Hr, a9 as Tr, aa as kr, ab as Fr, ac as Pr, ad as Ur, ae as Lr, af as Nr, ag as Or, ah as Ir, ai as Br, aj as Mr, ak as zr, al as $r, am as jr, an as qr, ao as Vr, ap as Wr, aq as Xr, ar as Jr, as as Qr, at as Gr, au as Kr, av as Yr, aw as Zr, ax as ea, ay as ta, az as ra, aA as aa, aB as na, aC as sa, aD as oa, aE as ia, aF as la, aG as ua, aH as da, aI as ca, aJ as fa, aK as ha, aL as pa, aM as ma, m as ya, aN as wa, aO as ga, aP as Ra, aQ as Sa, aR as va, aS as Ea, aT as Ca, aU as ba, aV as _a, aW as xa, c as Aa, aX as Da, aY as Ha, aZ as Ta, a_ as ka, a$ as Fa, b0 as Pa, b1 as Ua, a as La, d as Na, b2 as Oa, u as Ia, b3 as Ba, b4 as Ma, b5 as za, b6 as $a, e as ja, b7 as qa, b8 as Va, b9 as Wa, ba as Xa, b as Ja, bb as Qa, bc as Ga } from "./chunk-EPOLDU6W-CLHrVxOG.js";
import * as b from "react";
import _ from "react";
var N = {}, ie;
function dt() {
  if (ie) return N;
  ie = 1, Object.defineProperty(N, "__esModule", { value: !0 }), N.parse = o, N.serialize = u;
  const e = /^[\u0021-\u003A\u003C\u003E-\u007E]+$/, t = /^[\u0021-\u003A\u003C-\u007E]*$/, r = /^([.]?[a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)([.][a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)*$/i, a = /^[\u0020-\u003A\u003D-\u007E]*$/, n = Object.prototype.toString, s = /* @__PURE__ */ (() => {
    const d = function() {
    };
    return d.prototype = /* @__PURE__ */ Object.create(null), d;
  })();
  function o(d, p) {
    const f = new s(), y = d.length;
    if (y < 2)
      return f;
    const m = p?.decode || c;
    let g = 0;
    do {
      const w = d.indexOf("=", g);
      if (w === -1)
        break;
      const R = d.indexOf(";", g), S = R === -1 ? y : R;
      if (w > S) {
        g = d.lastIndexOf(";", w - 1) + 1;
        continue;
      }
      const E = l(d, g, w), H = i(d, w, E), x = d.slice(E, H);
      if (f[x] === void 0) {
        let A = l(d, w + 1, S), U = i(d, S, A);
        const v = m(d.slice(A, U));
        f[x] = v;
      }
      g = S + 1;
    } while (g < y);
    return f;
  }
  function l(d, p, f) {
    do {
      const y = d.charCodeAt(p);
      if (y !== 32 && y !== 9)
        return p;
    } while (++p < f);
    return f;
  }
  function i(d, p, f) {
    for (; p > f; ) {
      const y = d.charCodeAt(--p);
      if (y !== 32 && y !== 9)
        return p + 1;
    }
    return f;
  }
  function u(d, p, f) {
    const y = f?.encode || encodeURIComponent;
    if (!e.test(d))
      throw new TypeError(`argument name is invalid: ${d}`);
    const m = y(p);
    if (!t.test(m))
      throw new TypeError(`argument val is invalid: ${p}`);
    let g = d + "=" + m;
    if (!f)
      return g;
    if (f.maxAge !== void 0) {
      if (!Number.isInteger(f.maxAge))
        throw new TypeError(`option maxAge is invalid: ${f.maxAge}`);
      g += "; Max-Age=" + f.maxAge;
    }
    if (f.domain) {
      if (!r.test(f.domain))
        throw new TypeError(`option domain is invalid: ${f.domain}`);
      g += "; Domain=" + f.domain;
    }
    if (f.path) {
      if (!a.test(f.path))
        throw new TypeError(`option path is invalid: ${f.path}`);
      g += "; Path=" + f.path;
    }
    if (f.expires) {
      if (!h(f.expires) || !Number.isFinite(f.expires.valueOf()))
        throw new TypeError(`option expires is invalid: ${f.expires}`);
      g += "; Expires=" + f.expires.toUTCString();
    }
    if (f.httpOnly && (g += "; HttpOnly"), f.secure && (g += "; Secure"), f.partitioned && (g += "; Partitioned"), f.priority)
      switch (typeof f.priority == "string" ? f.priority.toLowerCase() : void 0) {
        case "low":
          g += "; Priority=Low";
          break;
        case "medium":
          g += "; Priority=Medium";
          break;
        case "high":
          g += "; Priority=High";
          break;
        default:
          throw new TypeError(`option priority is invalid: ${f.priority}`);
      }
    if (f.sameSite)
      switch (typeof f.sameSite == "string" ? f.sameSite.toLowerCase() : f.sameSite) {
        case !0:
        case "strict":
          g += "; SameSite=Strict";
          break;
        case "lax":
          g += "; SameSite=Lax";
          break;
        case "none":
          g += "; SameSite=None";
          break;
        default:
          throw new TypeError(`option sameSite is invalid: ${f.sameSite}`);
      }
    return g;
  }
  function c(d) {
    if (d.indexOf("%") === -1)
      return d;
    try {
      return decodeURIComponent(d);
    } catch {
      return d;
    }
  }
  function h(d) {
    return n.call(d) === "[object Date]";
  }
  return N;
}
var le = dt(), L = { exports: {} }, ue;
function ct() {
  if (ue) return L.exports;
  ue = 1;
  var e = {
    decodeValues: !0,
    map: !1,
    silent: !1
  };
  function t(o) {
    return typeof o == "string" && !!o.trim();
  }
  function r(o, l) {
    var i = o.split(";").filter(t), u = i.shift(), c = a(u), h = c.name, d = c.value;
    l = l ? Object.assign({}, e, l) : e;
    try {
      d = l.decodeValues ? decodeURIComponent(d) : d;
    } catch (f) {
      console.error(
        "set-cookie-parser encountered an error while decoding a cookie with value '" + d + "'. Set options.decodeValues to false to disable this feature.",
        f
      );
    }
    var p = {
      name: h,
      value: d
    };
    return i.forEach(function(f) {
      var y = f.split("="), m = y.shift().trimLeft().toLowerCase(), g = y.join("=");
      m === "expires" ? p.expires = new Date(g) : m === "max-age" ? p.maxAge = parseInt(g, 10) : m === "secure" ? p.secure = !0 : m === "httponly" ? p.httpOnly = !0 : m === "samesite" ? p.sameSite = g : m === "partitioned" ? p.partitioned = !0 : p[m] = g;
    }), p;
  }
  function a(o) {
    var l = "", i = "", u = o.split("=");
    return u.length > 1 ? (l = u.shift(), i = u.join("=")) : i = o, { name: l, value: i };
  }
  function n(o, l) {
    if (l = l ? Object.assign({}, e, l) : e, !o)
      return l.map ? {} : [];
    if (o.headers)
      if (typeof o.headers.getSetCookie == "function")
        o = o.headers.getSetCookie();
      else if (o.headers["set-cookie"])
        o = o.headers["set-cookie"];
      else {
        var i = o.headers[Object.keys(o.headers).find(function(c) {
          return c.toLowerCase() === "set-cookie";
        })];
        !i && o.headers.cookie && !l.silent && console.warn(
          "Warning: set-cookie-parser appears to have been called on a request object. It is designed to parse Set-Cookie headers from responses, not Cookie headers from requests. Set the option {silent: true} to suppress this warning."
        ), o = i;
      }
    if (Array.isArray(o) || (o = [o]), l.map) {
      var u = {};
      return o.filter(t).reduce(function(c, h) {
        var d = r(h, l);
        return c[d.name] = d, c;
      }, u);
    } else
      return o.filter(t).map(function(c) {
        return r(c, l);
      });
  }
  function s(o) {
    if (Array.isArray(o))
      return o;
    if (typeof o != "string")
      return [];
    var l = [], i = 0, u, c, h, d, p;
    function f() {
      for (; i < o.length && /\s/.test(o.charAt(i)); )
        i += 1;
      return i < o.length;
    }
    function y() {
      return c = o.charAt(i), c !== "=" && c !== ";" && c !== ",";
    }
    for (; i < o.length; ) {
      for (u = i, p = !1; f(); )
        if (c = o.charAt(i), c === ",") {
          for (h = i, i += 1, f(), d = i; i < o.length && y(); )
            i += 1;
          i < o.length && o.charAt(i) === "=" ? (p = !0, i = d, l.push(o.substring(u, h)), u = i) : i = h + 1;
        } else
          i += 1;
      (!p || i >= o.length) && l.push(o.substring(u, o.length));
    }
    return l;
  }
  return L.exports = n, L.exports.parse = n, L.exports.parseString = r, L.exports.splitCookiesString = s, L.exports;
}
var ft = /* @__PURE__ */ ct();
/**
 * react-router v7.12.0
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
function er({
  context: e,
  url: t,
  nonce: r
}) {
  typeof t == "string" && (t = new URL(t));
  let { manifest: a, routeModules: n, criticalCss: s, serverHandoffString: o } = e, l = ze(
    a.routes,
    n,
    e.future,
    e.isSpaMode
  );
  e.staticHandlerContext.loaderData = {
    ...e.staticHandlerContext.loaderData
  };
  for (let u of e.staticHandlerContext.matches) {
    let c = u.route.id, h = n[c], d = e.manifest.routes[c];
    h && d && Z(
      c,
      h.clientLoader,
      d.hasLoader,
      e.isSpaMode
    ) && (h.HydrateFallback || !d.hasLoader) && delete e.staticHandlerContext.loaderData[c];
  }
  let i = ve(l, e.staticHandlerContext);
  return /* @__PURE__ */ b.createElement(b.Fragment, null, /* @__PURE__ */ b.createElement(
    ee.Provider,
    {
      value: {
        manifest: a,
        routeModules: n,
        criticalCss: s,
        serverHandoffString: o,
        future: e.future,
        ssr: e.ssr,
        isSpaMode: e.isSpaMode,
        routeDiscovery: e.routeDiscovery,
        serializeError: e.serializeError,
        renderMeta: e.renderMeta
      }
    },
    /* @__PURE__ */ b.createElement($e, { location: i.state.location }, /* @__PURE__ */ b.createElement(
      Ee,
      {
        router: i,
        context: e.staticHandlerContext,
        hydrate: !1
      }
    ))
  ), e.serverHandoffStream ? /* @__PURE__ */ b.createElement(b.Suspense, null, /* @__PURE__ */ b.createElement(
    je,
    {
      context: e,
      identifier: 0,
      reader: e.serverHandoffStream.getReader(),
      textDecoder: new TextDecoder(),
      nonce: r
    }
  )) : null);
}
function tr(e, t) {
  return function({
    initialEntries: a,
    initialIndex: n,
    hydrationData: s,
    future: o
  }) {
    let l = b.useRef(), i = b.useRef();
    if (l.current == null) {
      i.current = {
        future: {
          unstable_subResourceIntegrity: o?.unstable_subResourceIntegrity === !0,
          v8_middleware: o?.v8_middleware === !0,
          unstable_trailingSlashAwareDataRequests: o?.unstable_trailingSlashAwareDataRequests === !0
        },
        manifest: {
          routes: {},
          entry: { imports: [], module: "" },
          url: "",
          version: ""
        },
        routeModules: {},
        ssr: !1,
        isSpaMode: !1,
        routeDiscovery: { mode: "lazy", manifestPath: "/__manifest" }
      };
      let u = xe(
        // @ts-expect-error `StubRouteObject` is stricter about `loader`/`action`
        // types compared to `AgnosticRouteObject`
        Ve(e, (c) => c),
        t !== void 0 ? t : o?.v8_middleware ? new J() : {},
        i.current.manifest,
        i.current.routeModules
      );
      l.current = We(u, {
        initialEntries: a,
        initialIndex: n,
        hydrationData: s
      });
    }
    return /* @__PURE__ */ b.createElement(ee.Provider, { value: i.current }, /* @__PURE__ */ b.createElement(Xe, { router: l.current }));
  };
}
function xe(e, t, r, a, n) {
  return e.map((s) => {
    if (!s.id)
      throw new Error(
        "Expected a route.id in react-router processRoutes() function"
      );
    let o = {
      id: s.id,
      path: s.path,
      index: s.index,
      Component: s.Component ? Ze(s.Component) : void 0,
      HydrateFallback: s.HydrateFallback ? Ye(s.HydrateFallback) : void 0,
      ErrorBoundary: s.ErrorBoundary ? Ke(s.ErrorBoundary) : void 0,
      action: s.action ? (i) => s.action({ ...i, context: t }) : void 0,
      loader: s.loader ? (i) => s.loader({ ...i, context: t }) : void 0,
      middleware: s.middleware ? s.middleware.map(
        (i) => (...u) => i(
          { ...u[0], context: t },
          u[1]
        )
      ) : void 0,
      handle: s.handle,
      shouldRevalidate: s.shouldRevalidate
    }, l = {
      id: s.id,
      path: s.path,
      index: s.index,
      parentId: n,
      hasAction: s.action != null,
      hasLoader: s.loader != null,
      // When testing routes, you should be stubbing loader/action/middleware,
      // not trying to re-implement the full loader/clientLoader/SSR/hydration
      // flow. That is better tested via E2E tests.
      hasClientAction: !1,
      hasClientLoader: !1,
      hasClientMiddleware: !1,
      hasErrorBoundary: s.ErrorBoundary != null,
      // any need for these?
      module: "build/stub-path-to-module.js",
      clientActionModule: void 0,
      clientLoaderModule: void 0,
      clientMiddlewareModule: void 0,
      hydrateFallbackModule: void 0
    };
    return r.routes[o.id] = l, a[s.id] = {
      default: o.Component || et,
      ErrorBoundary: o.ErrorBoundary || void 0,
      handle: s.handle,
      links: s.links,
      meta: s.meta,
      shouldRevalidate: s.shouldRevalidate
    }, s.children && (o.children = xe(
      s.children,
      t,
      r,
      a,
      o.id
    )), o;
  });
}
var re = /* @__PURE__ */ new TextEncoder(), ht = async (e, t) => {
  let r = re.encode(e), a = await Ae(t, ["sign"]), n = await crypto.subtle.sign("HMAC", a, r), s = btoa(String.fromCharCode(...new Uint8Array(n))).replace(
    /=+$/,
    ""
  );
  return e + "." + s;
}, pt = async (e, t) => {
  let r = e.lastIndexOf("."), a = e.slice(0, r), n = e.slice(r + 1), s = re.encode(a), o = await Ae(t, ["verify"]);
  try {
    let l = mt(atob(n));
    return await crypto.subtle.verify("HMAC", o, l, s) ? a : !1;
  } catch {
    return !1;
  }
}, Ae = async (e, t) => crypto.subtle.importKey(
  "raw",
  re.encode(e),
  { name: "HMAC", hash: "SHA-256" },
  !1,
  t
);
function mt(e) {
  let t = new Uint8Array(e.length);
  for (let r = 0; r < e.length; r++)
    t[r] = e.charCodeAt(r);
  return t;
}
var De = (e, t = {}) => {
  let { secrets: r = [], ...a } = {
    path: "/",
    sameSite: "lax",
    ...t
  };
  return vt(e, a.expires), {
    get name() {
      return e;
    },
    get isSigned() {
      return r.length > 0;
    },
    get expires() {
      return typeof a.maxAge < "u" ? new Date(Date.now() + a.maxAge * 1e3) : a.expires;
    },
    async parse(n, s) {
      if (!n) return null;
      let o = le.parse(n, { ...a, ...s });
      if (e in o) {
        let l = o[e];
        return typeof l == "string" && l !== "" ? await wt(l, r) : "";
      } else
        return null;
    },
    async serialize(n, s) {
      return le.serialize(
        e,
        n === "" ? "" : await yt(n, r),
        {
          ...a,
          ...s
        }
      );
    }
  };
}, He = (e) => e != null && typeof e.name == "string" && typeof e.isSigned == "boolean" && typeof e.parse == "function" && typeof e.serialize == "function";
async function yt(e, t) {
  let r = gt(e);
  return t.length > 0 && (r = await ht(r, t[0])), r;
}
async function wt(e, t) {
  if (t.length > 0) {
    for (let r of t) {
      let a = await pt(e, r);
      if (a !== !1)
        return de(a);
    }
    return null;
  }
  return de(e);
}
function gt(e) {
  return btoa(St(encodeURIComponent(JSON.stringify(e))));
}
function de(e) {
  try {
    return JSON.parse(decodeURIComponent(Rt(atob(e))));
  } catch {
    return {};
  }
}
function Rt(e) {
  let t = e.toString(), r = "", a = 0, n, s;
  for (; a < t.length; )
    n = t.charAt(a++), /[\w*+\-./@]/.exec(n) ? r += n : (s = n.charCodeAt(0), s < 256 ? r += "%" + ce(s, 2) : r += "%u" + ce(s, 4).toUpperCase());
  return r;
}
function ce(e, t) {
  let r = e.toString(16);
  for (; r.length < t; ) r = "0" + r;
  return r;
}
function St(e) {
  let t = e.toString(), r = "", a = 0, n, s;
  for (; a < t.length; ) {
    if (n = t.charAt(a++), n === "%") {
      if (t.charAt(a) === "u") {
        if (s = t.slice(a + 1, a + 5), /^[\da-f]{4}$/i.exec(s)) {
          r += String.fromCharCode(parseInt(s, 16)), a += 5;
          continue;
        }
      } else if (s = t.slice(a, a + 2), /^[\da-f]{2}$/i.exec(s)) {
        r += String.fromCharCode(parseInt(s, 16)), a += 2;
        continue;
      }
    }
    r += n;
  }
  return r;
}
function vt(e, t) {
  _e(
    !t,
    `The "${e}" cookie has an "expires" property set. This will cause the expires value to not be updated when the session is committed. Instead, you should set the expires value when serializing the cookie. You can use \`commitSession(session, { expires })\` if using a session storage object, or \`cookie.serialize("value", { expires })\` if you're using the cookie directly.`
  );
}
function Et(e) {
  return Object.keys(e).reduce((t, r) => {
    let a = e[r];
    return a && (t[r] = a.module), t;
  }, {});
}
var Ct = /* @__PURE__ */ ((e) => (e.Development = "development", e.Production = "production", e.Test = "test", e))(Ct || {});
function bt(e) {
  return e === "development" || e === "production" || e === "test";
}
function q(e, t) {
  if (e instanceof Error && t !== "development") {
    let r = new Error("Unexpected Server Error");
    return r.stack = void 0, r;
  }
  return e;
}
function $(e, t) {
  return Object.entries(e).reduce((r, [a, n]) => Object.assign(r, { [a]: q(n, t) }), {});
}
function Te(e, t) {
  let r = q(e, t);
  return {
    message: r.message,
    stack: r.stack
  };
}
function fe(e, t) {
  if (!e) return null;
  let r = Object.entries(e), a = {};
  for (let [n, s] of r)
    if (k(s))
      a[n] = { ...s, __type: "RouteErrorResponse" };
    else if (s instanceof Error) {
      let o = q(s, t);
      a[n] = {
        message: o.message,
        stack: o.stack,
        __type: "Error",
        // If this is a subclass (i.e., ReferenceError), send up the type so we
        // can re-create the same type during hydration.  This will only apply
        // in dev mode since all production errors are sanitized to normal
        // Error instances
        ...o.name !== "Error" ? {
          __subType: o.name
        } : {}
      };
    } else
      a[n] = s;
  return a;
}
function G(e, t, r) {
  let a = Ce(
    e,
    t,
    r
  );
  return a ? a.map((n) => ({
    params: n.params,
    pathname: n.pathname,
    route: n.route
  })) : null;
}
async function he(e, t) {
  let r = await e({
    request: xt(_t(t.request)),
    params: t.params,
    context: t.context,
    unstable_pattern: t.unstable_pattern
  });
  if (ot(r) && r.init && r.init.status && te(r.init.status))
    throw new Response(null, r.init);
  return r;
}
function _t(e) {
  let t = new URL(e.url), r = t.searchParams.getAll("index");
  t.searchParams.delete("index");
  let a = [];
  for (let s of r)
    s && a.push(s);
  for (let s of a)
    t.searchParams.append("index", s);
  let n = {
    method: e.method,
    body: e.body,
    headers: e.headers,
    signal: e.signal
  };
  return n.body && (n.duplex = "half"), new Request(t.href, n);
}
function xt(e) {
  let t = new URL(e.url);
  t.searchParams.delete("_routes");
  let r = {
    method: e.method,
    body: e.body,
    headers: e.headers,
    signal: e.signal
  };
  return r.body && (r.duplex = "half"), new Request(t.href, r);
}
function z(e, t) {
  if (e === !1 || e === null || typeof e > "u")
    throw console.error(
      "The following error is a bug in React Router; please open an issue! https://github.com/remix-run/react-router/issues/new/choose"
    ), new Error(t);
}
var ke = "__reactRouterDevServerHooks";
function rr(e) {
  globalThis[ke] = e;
}
function V() {
  return globalThis[ke];
}
function Fe(e, t) {
  if (typeof process < "u")
    try {
      if (process.env?.IS_RR_BUILD_REQUEST === "yes")
        return e.headers.get(t);
    } catch {
    }
  return null;
}
function Pe(e) {
  let t = {};
  return Object.values(e).forEach((r) => {
    if (r) {
      let a = r.parentId || "";
      t[a] || (t[a] = []), t[a].push(r);
    }
  }), t;
}
function Ue(e, t = "", r = Pe(e)) {
  return (r[t] || []).map((a) => ({
    ...a,
    children: Ue(e, a.id, r)
  }));
}
function Le(e, t, r = "", a = Pe(e)) {
  return (a[r] || []).map((n) => {
    let s = {
      // Always include root due to default boundaries
      hasErrorBoundary: n.id === "root" || n.module.ErrorBoundary != null,
      id: n.id,
      path: n.path,
      middleware: n.module.middleware,
      // Need to use RR's version in the param typed here to permit the optional
      // context even though we know it'll always be provided in remix
      loader: n.module.loader ? async (o) => {
        let l = Fe(
          o.request,
          "X-React-Router-Prerender-Data"
        );
        if (l != null) {
          let u = l && decodeURI(l);
          z(u, "Missing prerendered data for route");
          let c = new TextEncoder().encode(u), h = new ReadableStream({
            start(f) {
              f.enqueue(c), f.close();
            }
          }), p = (await tt(h, global)).value;
          if (p && I in p) {
            let f = p[I], y = { status: f.status };
            throw f.reload ? rt(f.redirect, y) : f.replace ? at(f.redirect, y) : nt(f.redirect, y);
          } else {
            z(
              p && n.id in p,
              "Unable to decode prerendered data"
            );
            let f = p[n.id];
            return z(
              "data" in f,
              "Unable to process prerendered data"
            ), f.data;
          }
        }
        return await he(n.module.loader, o);
      } : void 0,
      action: n.module.action ? (o) => he(n.module.action, o) : void 0,
      handle: n.module.handle
    };
    return n.index ? {
      index: !0,
      ...s
    } : {
      caseSensitive: n.caseSensitive,
      children: Le(
        e,
        t,
        n.id,
        a
      ),
      ...s
    };
  });
}
function pe(e) {
  return Q(JSON.stringify(e));
}
function ae(e, t) {
  return At(e, (r) => {
    let a = t.routes[r.route.id];
    return z(a, `Route with id "${r.route.id}" not found in build`), a.module.headers;
  });
}
function At(e, t, r) {
  let a = e.errors ? e.matches.findIndex((l) => e.errors[l.route.id]) : -1, n = a >= 0 ? e.matches.slice(0, a + 1) : e.matches, s;
  if (a >= 0) {
    let { actionHeaders: l, actionData: i, loaderHeaders: u, loaderData: c } = e;
    e.matches.slice(a).some((h) => {
      let d = h.route.id;
      return l[d] && (!i || !i.hasOwnProperty(d)) ? s = l[d] : u[d] && !c.hasOwnProperty(d) && (s = u[d]), s != null;
    });
  }
  const o = new Headers(r);
  return n.reduce((l, i, u) => {
    let { id: c } = i.route, h = e.loaderHeaders[c] || new Headers(), d = e.actionHeaders[c] || new Headers(), p = s != null && u === n.length - 1, f = p && s !== h && s !== d, y = t(i);
    if (y == null) {
      let g = new Headers(l);
      return f && F(s, g), F(d, g), F(h, g), g;
    }
    let m = new Headers(
      typeof y == "function" ? y({
        loaderHeaders: h,
        parentHeaders: l,
        actionHeaders: d,
        errorHeaders: p ? s : void 0
      }) : y
    );
    return f && F(s, m), F(d, m), F(h, m), F(l, m), m;
  }, new Headers(o));
}
function F(e, t) {
  let r = e.get("Set-Cookie");
  if (r) {
    let a = ft.splitCookiesString(r), n = new Set(t.getSetCookie());
    a.forEach((s) => {
      n.has(s) || t.append("Set-Cookie", s);
    });
  }
}
function Ne(e, t) {
  let r = e.get("origin"), a = typeof r == "string" && r !== "null" ? new URL(r).host : r, n = Tt(e);
  if (a && (!n || a !== n.value) && !Ht(a, t))
    throw n ? new Error(
      `${n.type} header does not match \`origin\` header from a forwarded action request. Aborting the action.`
    ) : new Error(
      "`x-forwarded-host` or `host` headers are not provided. One of these is needed to compare the `origin` header from a forwarded action request. Aborting the action."
    );
}
function Dt(e, t) {
  const r = e.split("."), a = t.split(".");
  if (a.length < 1 || r.length < a.length || a.length === 1 && (a[0] === "*" || a[0] === "**"))
    return !1;
  for (; a.length; ) {
    const n = a.pop(), s = r.pop();
    switch (n) {
      case "":
        return !1;
      case "*": {
        if (s)
          continue;
        return !1;
      }
      case "**":
        return a.length > 0 ? !1 : s !== void 0;
      case void 0:
      default:
        if (s !== n)
          return !1;
    }
  }
  return r.length === 0;
}
function Ht(e, t = []) {
  return t.some(
    (r) => r && (r === e || Dt(e, r))
  );
}
function Tt(e) {
  let r = e.get("x-forwarded-host")?.split(",")[0]?.trim(), a = e.get("host");
  return r ? {
    type: "x-forwarded-host",
    value: r
  } : a ? {
    type: "host",
    value: a
  } : void 0;
}
var Oe = /* @__PURE__ */ new Set([
  ...lt,
  304
]);
async function kt(e, t, r, a, n, s, o) {
  try {
    Ne(
      a.headers,
      Array.isArray(e.allowedActionOrigins) ? e.allowedActionOrigins : []
    );
    let c = new Request(n, {
      method: a.method,
      body: a.body,
      headers: a.headers,
      signal: a.signal,
      ...a.body ? { duplex: "half" } : void 0
    }), h = await r.query(c, {
      requestContext: s,
      skipLoaderErrorBubbling: !0,
      skipRevalidation: !0,
      generateMiddlewareResponse: e.future.v8_middleware ? async (d) => {
        try {
          let p = await d(c);
          return l(p);
        } catch (p) {
          return i(p);
        }
      } : void 0
    });
    return l(h);
  } catch (c) {
    return i(c);
  }
  function l(c) {
    return P(c) ? c : u(c);
  }
  function i(c) {
    return o(c), B(a, e, t, {
      result: { error: c },
      headers: new Headers(),
      status: 500
    });
  }
  function u(c) {
    let h = ae(c, e);
    if (te(c.statusCode) && h.has("Location"))
      return new Response(null, { status: c.statusCode, headers: h });
    c.errors && (Object.values(c.errors).forEach((p) => {
      (!k(p) || p.error) && o(p);
    }), c.errors = $(c.errors, t));
    let d;
    return c.errors ? d = { error: Object.values(c.errors)[0] } : d = {
      data: Object.values(c.actionData || {})[0]
    }, B(a, e, t, {
      result: d,
      headers: h,
      status: c.statusCode
    });
  }
}
async function Ft(e, t, r, a, n, s, o) {
  let l = new URL(a.url).searchParams.get("_routes"), i = l ? new Set(l.split(",")) : null;
  try {
    let d = new Request(n, {
      headers: a.headers,
      signal: a.signal
    }), p = await r.query(d, {
      requestContext: s,
      filterMatchesToLoad: (f) => !i || i.has(f.route.id),
      skipLoaderErrorBubbling: !0,
      generateMiddlewareResponse: e.future.v8_middleware ? async (f) => {
        try {
          let y = await f(d);
          return u(y);
        } catch (y) {
          return c(y);
        }
      } : void 0
    });
    return u(p);
  } catch (d) {
    return c(d);
  }
  function u(d) {
    return P(d) ? d : h(d);
  }
  function c(d) {
    return o(d), B(a, e, t, {
      result: { error: d },
      headers: new Headers(),
      status: 500
    });
  }
  function h(d) {
    let p = ae(d, e);
    if (te(d.statusCode) && p.has("Location"))
      return new Response(null, { status: d.statusCode, headers: p });
    d.errors && (Object.values(d.errors).forEach((m) => {
      (!k(m) || m.error) && o(m);
    }), d.errors = $(d.errors, t));
    let f = {}, y = new Set(
      d.matches.filter(
        (m) => i ? i.has(m.route.id) : m.route.loader != null
      ).map((m) => m.route.id)
    );
    if (d.errors)
      for (let [m, g] of Object.entries(d.errors))
        f[m] = { error: g };
    for (let [m, g] of Object.entries(d.loaderData))
      !(m in f) && y.has(m) && (f[m] = { data: g });
    return B(a, e, t, {
      result: f,
      headers: p,
      status: d.statusCode
    });
  }
}
function B(e, t, r, {
  result: a,
  headers: n,
  status: s
}) {
  let o = new Headers(n);
  return o.set("X-Remix-Response", "yes"), Oe.has(s) ? new Response(null, { status: s, headers: o }) : (o.set("Content-Type", "text/x-script"), o.delete("Content-Length"), new Response(
    K(
      a,
      e.signal,
      t.entry.module.streamTimeout,
      r
    ),
    {
      status: s || 200,
      headers: o
    }
  ));
}
function me(e, t, r, a) {
  let n = Pt(
    e.status,
    e.headers,
    r.basename
  ), s = new Headers(e.headers);
  return s.delete("Location"), s.set("Content-Type", "text/x-script"), B(t, r, a, {
    result: t.method === "GET" ? { [I]: n } : n,
    headers: s,
    status: be
  });
}
function Pt(e, t, r) {
  let a = t.get("Location");
  return r && (a = M(a, r) || a), {
    redirect: a,
    status: e,
    revalidate: (
      // Technically X-Remix-Revalidate isn't needed here - that was an implementation
      // detail of ?_data requests as our way to tell the front end to revalidate when
      // we didn't have a response body to include that information in.
      // With single fetch, we tell the front end via this revalidate boolean field.
      // However, we're respecting it for now because it may be something folks have
      // used in their own responses
      // TODO(v3): Consider removing or making this official public API
      t.has("X-Remix-Revalidate") || t.has("Set-Cookie")
    ),
    reload: t.has("X-Remix-Reload-Document"),
    replace: t.has("X-Remix-Replace")
  };
}
function K(e, t, r, a) {
  let n = new AbortController(), s = setTimeout(
    () => n.abort(new Error("Server Timeout")),
    typeof r == "number" ? r : 4950
  );
  return t.addEventListener("abort", () => clearTimeout(s)), ut(e, {
    signal: n.signal,
    plugins: [
      (o) => {
        if (o instanceof Error) {
          let { name: l, message: i, stack: u } = a === "production" ? q(o, a) : o;
          return ["SanitizedError", l, i, u];
        }
        if (o instanceof O) {
          let { data: l, status: i, statusText: u } = o;
          return ["ErrorResponse", l, i, u];
        }
        if (o && typeof o == "object" && I in o)
          return ["SingleFetchRedirect", o[I]];
      }
    ],
    postPlugins: [
      (o) => {
        if (o && typeof o == "object")
          return [
            "SingleFetchClassInstance",
            Object.fromEntries(Object.entries(o))
          ];
      },
      () => ["SingleFetchFallback"]
    ]
  });
}
function ye(e, t) {
  let r = Ue(e.routes), a = Le(e.routes, e.future), n = bt(t) ? t : "production", s = Qe(a, {
    basename: e.basename,
    unstable_instrumentations: e.entry.module.unstable_instrumentations
  }), o = e.entry.module.handleError || ((i, { request: u }) => {
    n !== "test" && !u.signal.aborted && console.error(
      // @ts-expect-error This is "private" from users but intended for internal use
      k(i) && i.error ? i.error : i
    );
  }), l = async (i, u) => {
    let c = {}, h, d = (S) => {
      t === "development" && V()?.processRequestError?.(S), o(S, {
        context: h,
        params: c,
        request: i
      });
    };
    if (e.future.v8_middleware) {
      if (u && !(u instanceof J)) {
        let S = new Error(
          "Invalid `context` value provided to `handleRequest`. When middleware is enabled you must return an instance of `RouterContextProvider` from your `getLoadContext` function."
        );
        return d(S), j(S, n);
      }
      h = u || new J();
    } else
      h = u || {};
    let p = new URL(i.url), f = e.basename || "/", y = p.pathname;
    e.future.unstable_trailingSlashAwareDataRequests ? y.endsWith("/_.data") ? y = y.replace(/_.data$/, "") : y = y.replace(/\.data$/, "") : (M(y, f) === "/_root.data" ? y = f : y.endsWith(".data") && (y = y.replace(/\.data$/, "")), M(y, f) !== "/" && y.endsWith("/") && (y = y.slice(0, -1)));
    let m = Fe(i, "X-React-Router-SPA-Mode") === "yes";
    if (!e.ssr) {
      let S = decodeURI(y);
      if (f !== "/") {
        let E = M(S, f);
        if (E == null)
          return o(
            new O(
              404,
              "Not Found",
              `Refusing to prerender the \`${S}\` path because it does not start with the basename \`${f}\``
            ),
            {
              context: h,
              params: c,
              request: i
            }
          ), new Response("Not Found", {
            status: 404,
            statusText: "Not Found"
          });
        S = E;
      }
      if (e.prerender.length === 0)
        m = !0;
      else if (!e.prerender.includes(S) && !e.prerender.includes(S + "/")) {
        if (p.pathname.endsWith(".data"))
          return o(
            new O(
              404,
              "Not Found",
              `Refusing to SSR the path \`${S}\` because \`ssr:false\` is set and the path is not included in the \`prerender\` config, so in production the path will be a 404.`
            ),
            {
              context: h,
              params: c,
              request: i
            }
          ), new Response("Not Found", {
            status: 404,
            statusText: "Not Found"
          });
        m = !0;
      }
    }
    let g = st(
      e.routeDiscovery.manifestPath,
      f
    );
    if (p.pathname === g)
      try {
        return await Ut(e, r, p);
      } catch (S) {
        return d(S), new Response("Unknown Server Error", { status: 500 });
      }
    let w = G(r, y, e.basename);
    w && w.length > 0 && Object.assign(c, w[0].params);
    let R;
    if (p.pathname.endsWith(".data")) {
      let S = new URL(i.url);
      S.pathname = y;
      let E = G(
        r,
        S.pathname,
        e.basename
      );
      R = await Lt(
        n,
        e,
        s,
        i,
        S,
        h,
        d
      ), oe(R) && (R = me(
        R,
        i,
        e,
        n
      )), e.entry.module.handleDataRequest && (R = await e.entry.module.handleDataRequest(R, {
        context: h,
        params: E ? E[0].params : {},
        request: i
      }), oe(R) && (R = me(
        R,
        i,
        e,
        n
      )));
    } else if (!m && w && w[w.length - 1].route.module.default == null && w[w.length - 1].route.module.ErrorBoundary == null)
      R = await Ot(
        n,
        e,
        s,
        w.slice(-1)[0].route.id,
        i,
        h,
        d
      );
    else {
      let { pathname: S } = p, E;
      e.unstable_getCriticalCss ? E = await e.unstable_getCriticalCss({ pathname: S }) : t === "development" && V()?.getCriticalCss && (E = await V()?.getCriticalCss?.(S)), R = await Nt(
        n,
        e,
        s,
        i,
        h,
        d,
        m,
        E
      );
    }
    return i.method === "HEAD" ? new Response(null, {
      headers: R.headers,
      status: R.status,
      statusText: R.statusText
    }) : R;
  };
  return e.entry.module.unstable_instrumentations && (l = Ge(
    l,
    e.entry.module.unstable_instrumentations.map((i) => i.handler).filter(Boolean)
  )), {
    routes: r,
    dataRoutes: a,
    serverMode: n,
    staticHandler: s,
    errorHandler: o,
    requestHandler: l
  };
}
var ar = (e, t) => {
  let r, a, n, s, o, l;
  return async function(u, c) {
    if (r = typeof e == "function" ? await e() : e, typeof e == "function") {
      let h = ye(r, t);
      a = h.routes, n = h.serverMode, s = h.staticHandler, o = h.errorHandler, l = h.requestHandler;
    } else if (!a || !n || !s || !o || !l) {
      let h = ye(r, t);
      a = h.routes, n = h.serverMode, s = h.staticHandler, o = h.errorHandler, l = h.requestHandler;
    }
    return l(u, c);
  };
};
async function Ut(e, t, r) {
  if (e.assets.version !== r.searchParams.get("version"))
    return new Response(null, {
      status: 204,
      headers: {
        "X-Remix-Reload-Document": "true"
      }
    });
  let a = {};
  if (r.searchParams.has("paths")) {
    let n = /* @__PURE__ */ new Set();
    (r.searchParams.get("paths") || "").split(",").filter(Boolean).forEach((l) => {
      l.startsWith("/") || (l = `/${l}`);
      let i = l.split("/").slice(1);
      i.forEach((u, c) => {
        let h = i.slice(0, c + 1).join("/");
        n.add(`/${h}`);
      });
    });
    for (let l of n) {
      let i = G(t, l, e.basename);
      if (i)
        for (let u of i) {
          let c = u.route.id, h = e.assets.routes[c];
          h && (a[c] = h);
        }
    }
    return Response.json(a, {
      headers: {
        "Cache-Control": "public, max-age=31536000, immutable"
      }
    });
  }
  return new Response("Invalid Request", { status: 400 });
}
async function Lt(e, t, r, a, n, s, o) {
  return a.method !== "GET" ? await kt(
    t,
    e,
    r,
    a,
    n,
    s,
    o
  ) : await Ft(
    t,
    e,
    r,
    a,
    n,
    s,
    o
  );
}
async function Nt(e, t, r, a, n, s, o, l) {
  try {
    a.method === "POST" && Ne(
      a.headers,
      Array.isArray(t.allowedActionOrigins) ? t.allowedActionOrigins : []
    );
    let u = await r.query(a, {
      requestContext: n,
      generateMiddlewareResponse: t.future.v8_middleware ? async (c) => {
        try {
          let h = await c(a);
          return P(h) || (h = await i(h, o)), h;
        } catch (h) {
          return s(h), new Response(null, { status: 500 });
        }
      } : void 0
    });
    return P(u) || (u = await i(u, o)), u;
  } catch (u) {
    return s(u), new Response(null, { status: 500 });
  }
  async function i(u, c) {
    let h = ae(u, t);
    if (Oe.has(u.statusCode))
      return new Response(null, { status: u.statusCode, headers: h });
    u.errors && (Object.values(u.errors).forEach((m) => {
      (!k(m) || m.error) && s(m);
    }), u.errors = $(u.errors, e));
    let d = {
      loaderData: u.loaderData,
      actionData: u.actionData,
      errors: fe(u.errors, e)
    }, p = {
      basename: t.basename,
      future: t.future,
      routeDiscovery: t.routeDiscovery,
      ssr: t.ssr,
      isSpaMode: c
    }, f = {
      manifest: t.assets,
      routeModules: Et(t.routes),
      staticHandlerContext: u,
      criticalCss: l,
      serverHandoffString: pe({
        ...p,
        criticalCss: l
      }),
      serverHandoffStream: K(
        d,
        a.signal,
        t.entry.module.streamTimeout,
        e
      ),
      renderMeta: {},
      future: t.future,
      ssr: t.ssr,
      routeDiscovery: t.routeDiscovery,
      isSpaMode: c,
      serializeError: (m) => Te(m, e)
    }, y = t.entry.module.default;
    try {
      return await y(
        a,
        u.statusCode,
        h,
        f,
        n
      );
    } catch (m) {
      s(m);
      let g = m;
      if (P(m))
        try {
          let R = await Bt(m);
          g = new O(
            m.status,
            m.statusText,
            R
          );
        } catch {
        }
      u = it(
        r.dataRoutes,
        u,
        g
      ), u.errors && (u.errors = $(u.errors, e));
      let w = {
        loaderData: u.loaderData,
        actionData: u.actionData,
        errors: fe(u.errors, e)
      };
      f = {
        ...f,
        staticHandlerContext: u,
        serverHandoffString: pe(p),
        serverHandoffStream: K(
          w,
          a.signal,
          t.entry.module.streamTimeout,
          e
        ),
        renderMeta: {}
      };
      try {
        return await y(
          a,
          u.statusCode,
          h,
          f,
          n
        );
      } catch (R) {
        return s(R), j(R, e);
      }
    }
  }
}
async function Ot(e, t, r, a, n, s, o) {
  try {
    let u = await r.queryRoute(n, {
      routeId: a,
      requestContext: s,
      generateMiddlewareResponse: t.future.v8_middleware ? async (c) => {
        try {
          let h = await c(n);
          return l(h);
        } catch (h) {
          return i(h);
        }
      } : void 0
    });
    return l(u);
  } catch (u) {
    return i(u);
  }
  function l(u) {
    return P(u) ? u : typeof u == "string" ? new Response(u) : Response.json(u);
  }
  function i(u) {
    if (P(u))
      return u;
    if (k(u))
      return o(u), It(u, e);
    if (u instanceof Error && u.message === "Expected a response from queryRoute") {
      let c = new Error(
        "Expected a Response to be returned from resource route handler"
      );
      return o(c), j(c, e);
    }
    return o(u), j(u, e);
  }
}
function It(e, t) {
  return Response.json(
    Te(
      // @ts-expect-error This is "private" from users but intended for internal use
      e.error || new Error("Unexpected Server Error"),
      t
    ),
    {
      status: e.status,
      statusText: e.statusText
    }
  );
}
function j(e, t) {
  let r = "Unexpected Server Error";
  return t !== "production" && (r += `

${String(e)}`), new Response(r, {
    status: 500,
    headers: {
      "Content-Type": "text/plain"
    }
  });
}
function Bt(e) {
  let t = e.headers.get("Content-Type");
  return t && /\bapplication\/json\b/.test(t) ? e.body == null ? null : e.json() : e.text();
}
function W(e) {
  return `__flash_${e}__`;
}
var Ie = (e = {}, t = "") => {
  let r = new Map(Object.entries(e));
  return {
    get id() {
      return t;
    },
    get data() {
      return Object.fromEntries(r);
    },
    has(a) {
      return r.has(a) || r.has(W(a));
    },
    get(a) {
      if (r.has(a)) return r.get(a);
      let n = W(a);
      if (r.has(n)) {
        let s = r.get(n);
        return r.delete(n), s;
      }
    },
    set(a, n) {
      r.set(a, n);
    },
    flash(a, n) {
      r.set(W(a), n);
    },
    unset(a) {
      r.delete(a);
    }
  };
}, nr = (e) => e != null && typeof e.id == "string" && typeof e.data < "u" && typeof e.has == "function" && typeof e.get == "function" && typeof e.set == "function" && typeof e.flash == "function" && typeof e.unset == "function";
function Mt({
  cookie: e,
  createData: t,
  readData: r,
  updateData: a,
  deleteData: n
}) {
  let s = He(e) ? e : De(e?.name || "__session", e);
  return Be(s), {
    async getSession(o, l) {
      let i = o && await s.parse(o, l), u = i && await r(i);
      return Ie(u || {}, i || "");
    },
    async commitSession(o, l) {
      let { id: i, data: u } = o, c = l?.maxAge != null ? new Date(Date.now() + l.maxAge * 1e3) : l?.expires != null ? l.expires : s.expires;
      return i ? await a(i, u, c) : i = await t(u, c), s.serialize(i, l);
    },
    async destroySession(o, l) {
      return await n(o.id), s.serialize("", {
        ...l,
        maxAge: void 0,
        expires: /* @__PURE__ */ new Date(0)
      });
    }
  };
}
function Be(e) {
  _e(
    e.isSigned,
    `The "${e.name}" cookie is not signed, but session cookies should be signed to prevent tampering on the client before they are sent back to the server. See https://reactrouter.com/explanation/sessions-and-cookies#signing-cookies for more information.`
  );
}
function sr({ cookie: e } = {}) {
  let t = He(e) ? e : De(e?.name || "__session", e);
  return Be(t), {
    async getSession(r, a) {
      return Ie(
        r && await t.parse(r, a) || {}
      );
    },
    async commitSession(r, a) {
      let n = await t.serialize(r.data, a);
      if (n.length > 4096)
        throw new Error(
          "Cookie length will exceed browser maximum. Length: " + n.length
        );
      return n;
    },
    async destroySession(r, a) {
      return t.serialize("", {
        ...a,
        maxAge: void 0,
        expires: /* @__PURE__ */ new Date(0)
      });
    }
  };
}
function or({ cookie: e } = {}) {
  let t = /* @__PURE__ */ new Map();
  return Mt({
    cookie: e,
    async createData(r, a) {
      let n = Math.random().toString(36).substring(2, 10);
      return t.set(n, { data: r, expires: a }), n;
    },
    async readData(r) {
      if (t.has(r)) {
        let { data: a, expires: n } = t.get(r);
        if (!n || n > /* @__PURE__ */ new Date())
          return a;
        n && t.delete(r);
      }
      return null;
    },
    async updateData(r, a, n) {
      t.set(r, { data: a, expires: n });
    },
    async deleteData(r) {
      t.delete(r);
    }
  });
}
function ir(e, ...t) {
  let r = t[0], a = zt(e).replace(
    /\/:([\w-]+)(\?)?/g,
    // same regex as in .\router\utils.ts: compilePath().
    (n, s, o) => {
      const l = o === void 0, i = r?.[s];
      if (l && i === void 0)
        throw new Error(
          `Path '${e}' requires param '${s}' but it was not provided`
        );
      return i === void 0 ? "" : "/" + i;
    }
  );
  if (e.endsWith("*")) {
    const n = r?.["*"];
    n !== void 0 && (a += "/" + n);
  }
  return a || "/";
}
function zt(e) {
  let t = e.length - 1, r = e[t];
  if (r !== "*" && r !== "/") return e;
  for (t--; t >= 0 && e[t] === "/"; t--)
    ;
  return e.slice(0, t + 1);
}
var Y = new TextEncoder(), we = "</body></html>";
function ge(e) {
  let t = new TextDecoder(), r, a = new Promise(
    (i) => r = i
  ), n = !1, s = [], o = null;
  function l(i) {
    for (let u of s) {
      let c = t.decode(u, { stream: !0 });
      c.endsWith(we) && (c = c.slice(0, -we.length)), i.enqueue(Y.encode(c));
    }
    s.length = 0, o = null;
  }
  return new TransformStream({
    transform(i, u) {
      s.push(i), !o && (o = setTimeout(async () => {
        l(u), n || (n = !0, $t(e, u).catch((c) => u.error(c)).then(r));
      }, 0));
    },
    async flush(i) {
      await a, o && (clearTimeout(o), l(i)), i.enqueue(Y.encode("</body></html>"));
    }
  });
}
async function $t(e, t) {
  let r = new TextDecoder("utf-8", { fatal: !0 });
  const a = e.getReader();
  try {
    let s;
    for (; (s = await a.read()) && !s.done; ) {
      const o = s.value;
      try {
        X(
          JSON.stringify(r.decode(o, { stream: !0 })),
          t
        );
      } catch {
        let i = JSON.stringify(btoa(String.fromCodePoint(...o)));
        X(
          `Uint8Array.from(atob(${i}), m => m.codePointAt(0))`,
          t
        );
      }
    }
  } finally {
    a.releaseLock();
  }
  let n = r.decode();
  n.length && X(JSON.stringify(n), t);
}
function X(e, t) {
  t.enqueue(
    Y.encode(
      `<script>${jt(
        `(self.__FLIGHT_DATA||=[]).push(${e})`
      )}<\/script>`
    )
  );
}
function jt(e) {
  return e.replace(/<!--/g, "<\\!--").replace(/<\/(script)/gi, "</\\$1");
}
var qt = class extends _.Component {
  constructor(e) {
    super(e), this.state = { error: null, location: e.location };
  }
  static getDerivedStateFromError(e) {
    return { error: e };
  }
  static getDerivedStateFromProps(e, t) {
    return t.location !== e.location ? { error: null, location: e.location } : { error: t.error, location: t.location };
  }
  render() {
    return this.state.error ? /* @__PURE__ */ _.createElement(
      Me,
      {
        error: this.state.error,
        renderAppShell: !0
      }
    ) : this.props.children;
  }
};
function Re({
  renderAppShell: e,
  title: t,
  children: r
}) {
  return e ? /* @__PURE__ */ _.createElement("html", { lang: "en" }, /* @__PURE__ */ _.createElement("head", null, /* @__PURE__ */ _.createElement("meta", { charSet: "utf-8" }), /* @__PURE__ */ _.createElement(
    "meta",
    {
      name: "viewport",
      content: "width=device-width,initial-scale=1,viewport-fit=cover"
    }
  ), /* @__PURE__ */ _.createElement("title", null, t)), /* @__PURE__ */ _.createElement("body", null, /* @__PURE__ */ _.createElement("main", { style: { fontFamily: "system-ui, sans-serif", padding: "2rem" } }, r))) : r;
}
function Me({
  error: e,
  renderAppShell: t
}) {
  console.error(e);
  let r = /* @__PURE__ */ _.createElement(
    "script",
    {
      dangerouslySetInnerHTML: {
        __html: `
        console.log(
          "ðŸ’¿ Hey developer ðŸ‘‹. You can provide a way better UX than this when your app throws errors. Check out https://reactrouter.com/how-to/error-boundary for more information."
        );
      `
      }
    }
  );
  if (k(e))
    return /* @__PURE__ */ _.createElement(
      Re,
      {
        renderAppShell: t,
        title: "Unhandled Thrown Response!"
      },
      /* @__PURE__ */ _.createElement("h1", { style: { fontSize: "24px" } }, e.status, " ", e.statusText),
      r
    );
  let a;
  if (e instanceof Error)
    a = e;
  else {
    let n = e == null ? "Unknown Error" : typeof e == "object" && "toString" in e ? e.toString() : JSON.stringify(e);
    a = new Error(n);
  }
  return /* @__PURE__ */ _.createElement(Re, { renderAppShell: t, title: "Application Error!" }, /* @__PURE__ */ _.createElement("h1", { style: { fontSize: "24px" } }, "Application Error"), /* @__PURE__ */ _.createElement(
    "pre",
    {
      style: {
        padding: "2rem",
        background: "hsla(10, 50%, 50%, 0.1)",
        color: "red",
        overflow: "auto"
      }
    },
    a.stack
  ), r);
}
function lr({
  hasRootLayout: e
}) {
  let t = qe();
  if (e === void 0)
    throw new Error("Missing 'hasRootLayout' prop");
  return /* @__PURE__ */ _.createElement(
    Me,
    {
      renderAppShell: !e,
      error: t
    }
  );
}
function Vt(e) {
  const t = {};
  for (const r of e.matches)
    Wt(t, r);
  return t;
}
function Wt(e, t) {
  t = Array.isArray(t) ? t : [t];
  for (const r of t)
    e[r.id] = {
      links: r.links,
      meta: r.meta,
      default: Xt
    };
}
var Xt = () => null, Jt = "use", Se = b[Jt];
function Qt(e) {
  if (Se)
    return Se(e);
  throw new Error("React Router v7 requires React 19+ for RSC features.");
}
async function ur({
  request: e,
  serverResponse: t,
  createFromReadableStream: r,
  renderHTML: a,
  hydrate: n = !0
}) {
  const s = new URL(e.url);
  if (Gt(s) || Kt(s) || e.headers.has("rsc-action-id") || t.headers.get("React-Router-Resource") === "true")
    return t;
  if (!t.body)
    throw new Error("Missing body in server response");
  const i = t.clone();
  let u = null;
  n && (u = t.clone());
  const c = t.body;
  let h, d = [];
  const p = () => h ? new ReadableStream({
    start(w) {
      h.forEach((R) => w.enqueue(R)), d.push(w);
    }
  }) : (h = [], c.pipeThrough(
    new TransformStream({
      transform(w, R) {
        h.push(w), R.enqueue(w), d.forEach((S) => S.enqueue(w));
      },
      flush() {
        d.forEach((w) => w.close()), d = [];
      }
    })
  ));
  let f = null;
  const y = () => {
    const w = Promise.resolve(
      r(p())
    );
    return Object.defineProperties(w, {
      _deepestRenderedBoundaryId: {
        get() {
          return f;
        },
        set(R) {
          f = R;
        }
      },
      formState: {
        get() {
          return w.then(
            (R) => R.type === "render" ? R.formState : void 0
          );
        }
      }
    });
  };
  let m, g;
  try {
    if (!i.body)
      throw new Error("Failed to clone server response");
    const w = await r(
      i.body
    );
    if (t.status === be && w.type === "redirect") {
      const v = new Headers(t.headers);
      return v.delete("Content-Encoding"), v.delete("Content-Length"), v.delete("Content-Type"), v.delete("X-Remix-Response"), v.set("Location", w.location), new Response(u?.body || "", {
        headers: v,
        status: w.status,
        statusText: t.statusText
      });
    }
    let R = new Headers(), S = t.status, E = t.statusText, H = await a(y, {
      onError(v) {
        if (typeof v == "object" && v && "digest" in v && typeof v.digest == "string") {
          if (m = ne(v.digest), m)
            return v.digest;
          let C = se(v.digest);
          if (C)
            return g = C, S = C.status, E = C.statusText, v.digest;
        }
      },
      onHeaders(v) {
        for (const [C, D] of v)
          R.append(C, D);
      }
    });
    const x = new Headers(R);
    for (const [v, C] of t.headers)
      x.append(v, C);
    if (x.set("Content-Type", "text/html; charset=utf-8"), m)
      return x.set("Location", m.location), new Response(H, {
        status: m.status,
        headers: x
      });
    const A = new TransformStream({
      flush(v) {
        m && v.enqueue(
          new TextEncoder().encode(
            `<meta http-equiv="refresh" content="0;url=${Q(m.location)}"/>`
          )
        );
      }
    });
    if (!n)
      return new Response(H.pipeThrough(A), {
        status: S,
        statusText: E,
        headers: x
      });
    if (!u?.body)
      throw new Error("Failed to clone server response");
    const U = H.pipeThrough(ge(u.body)).pipeThrough(A);
    return new Response(U, {
      status: S,
      statusText: E,
      headers: x
    });
  } catch (w) {
    if (w instanceof Response)
      return w;
    if (m)
      return new Response(`Redirect: ${m.location}`, {
        status: m.status,
        headers: {
          Location: m.location
        }
      });
    try {
      w = g ?? w;
      let [R, S] = k(w) ? [w.status, w.statusText] : [500, ""], E, H = new Headers();
      const x = await a(
        () => {
          const D = Promise.resolve(
            r(p())
          ).then(
            (T) => Object.assign(T, {
              status: R,
              errors: f ? {
                [f]: w
              } : {}
            })
          );
          return Object.defineProperties(D, {
            _deepestRenderedBoundaryId: {
              get() {
                return f;
              },
              set(T) {
                f = T;
              }
            },
            formState: {
              get() {
                return D.then(
                  (T) => T.type === "render" ? T.formState : void 0
                );
              }
            }
          });
        },
        {
          onError(C) {
            if (typeof C == "object" && C && "digest" in C && typeof C.digest == "string") {
              if (E = ne(C.digest), E)
                return C.digest;
              let D = se(
                C.digest
              );
              if (D)
                return R = D.status, S = D.statusText, C.digest;
            }
          },
          onHeaders(C) {
            for (const [D, T] of C)
              H.append(D, T);
          }
        }
      ), A = new Headers(H);
      for (const [C, D] of t.headers)
        A.append(C, D);
      if (A.set("Content-Type", "text/html; charset=utf-8"), E)
        return A.set("Location", E.location), new Response(x, {
          status: E.status,
          headers: A
        });
      const U = new TransformStream({
        flush(C) {
          E && C.enqueue(
            new TextEncoder().encode(
              `<meta http-equiv="refresh" content="0;url=${Q(E.location)}"/>`
            )
          );
        }
      });
      if (!n)
        return new Response(x.pipeThrough(U), {
          status: R,
          statusText: S,
          headers: A
        });
      if (!u?.body)
        throw new Error("Failed to clone server response");
      const v = x.pipeThrough(ge(u.body)).pipeThrough(U);
      return new Response(v, {
        status: R,
        statusText: S,
        headers: A
      });
    } catch {
    }
    throw w;
  }
}
function dr({ getPayload: e }) {
  const t = e(), r = Qt(t);
  if (r.type === "redirect")
    throw new Response(null, {
      status: r.status,
      headers: {
        Location: r.location
      }
    });
  if (r.type !== "render") return null;
  let a = { ...r.loaderData };
  for (const l of r.matches)
    Z(
      l.id,
      l.clientLoader,
      l.hasLoader,
      !1
    ) && (l.hydrateFallbackElement || !l.hasLoader) && delete a[l.id];
  const n = {
    get _deepestRenderedBoundaryId() {
      return t._deepestRenderedBoundaryId ?? null;
    },
    set _deepestRenderedBoundaryId(l) {
      t._deepestRenderedBoundaryId = l;
    },
    actionData: r.actionData,
    actionHeaders: {},
    basename: r.basename,
    errors: r.errors,
    loaderData: a,
    loaderHeaders: {},
    location: r.location,
    statusCode: 200,
    matches: r.matches.map((l) => ({
      params: l.params,
      pathname: l.pathname,
      pathnameBase: l.pathnameBase,
      route: {
        id: l.id,
        action: l.hasAction || !!l.clientAction,
        handle: l.handle,
        hasErrorBoundary: l.hasErrorBoundary,
        loader: l.hasLoader || !!l.clientLoader,
        index: l.index,
        path: l.path,
        shouldRevalidate: l.shouldRevalidate
      }
    }))
  }, s = ve(
    r.matches.reduceRight((l, i) => {
      const u = {
        id: i.id,
        action: i.hasAction || !!i.clientAction,
        element: i.element,
        errorElement: i.errorElement,
        handle: i.handle,
        hasErrorBoundary: !!i.errorElement,
        hydrateFallbackElement: i.hydrateFallbackElement,
        index: i.index,
        loader: i.hasLoader || !!i.clientLoader,
        path: i.path,
        shouldRevalidate: i.shouldRevalidate
      };
      return l.length > 0 && (u.children = l), [u];
    }, []),
    n
  ), o = {
    future: {
      // These flags have no runtime impact so can always be false.  If we add
      // flags that drive runtime behavior they'll need to be proxied through.
      v8_middleware: !1,
      unstable_subResourceIntegrity: !1,
      unstable_trailingSlashAwareDataRequests: !0
      // always on for RSC
    },
    isSpaMode: !1,
    ssr: !0,
    criticalCss: "",
    manifest: {
      routes: {},
      version: "1",
      url: "",
      entry: {
        module: "",
        imports: []
      }
    },
    routeDiscovery: { mode: "lazy", manifestPath: "/__manifest" },
    routeModules: Vt(r)
  };
  return /* @__PURE__ */ b.createElement(Je.Provider, { value: !0 }, /* @__PURE__ */ b.createElement(qt, { location: r.location }, /* @__PURE__ */ b.createElement(ee.Provider, { value: o }, /* @__PURE__ */ b.createElement(
    Ee,
    {
      context: n,
      router: s,
      hydrate: !1,
      nonce: r.nonce
    }
  ))));
}
function Gt(e) {
  return e.pathname.endsWith(".rsc");
}
function Kt(e) {
  return e.pathname.endsWith(".manifest");
}
function cr(e) {
  if (!e) return null;
  let t = Object.entries(e), r = {};
  for (let [a, n] of t)
    if (n && n.__type === "RouteErrorResponse")
      r[a] = new O(
        n.status,
        n.statusText,
        n.data,
        n.internal === !0
      );
    else if (n && n.__type === "Error") {
      if (n.__subType) {
        let s = window[n.__subType];
        if (typeof s == "function")
          try {
            let o = new s(n.message);
            o.stack = n.stack, r[a] = o;
          } catch {
          }
      }
      if (r[a] == null) {
        let s = new Error(n.message);
        s.stack = n.stack, r[a] = s;
      }
    } else
      r[a] = n;
  return r;
}
function fr({
  state: e,
  routes: t,
  getRouteInfo: r,
  location: a,
  basename: n,
  isSpaMode: s
}) {
  let o = {
    ...e,
    loaderData: { ...e.loaderData }
  }, l = Ce(t, a, n);
  if (l)
    for (let i of l) {
      let u = i.route.id, c = r(u);
      Z(
        u,
        c.clientLoader,
        c.hasLoader,
        s
      ) && (c.hasHydrateFallback || !c.hasLoader) ? delete o.loaderData[u] : c.hasLoader || (o.loaderData[u] = null);
    }
  return o;
}
export {
  mr as Await,
  yr as BrowserRouter,
  wr as Form,
  gr as HashRouter,
  Rr as IDLE_BLOCKER,
  Sr as IDLE_FETCHER,
  vr as IDLE_NAVIGATION,
  Er as Link,
  Cr as Links,
  br as MemoryRouter,
  _r as Meta,
  xr as NavLink,
  Ar as Navigate,
  Dr as NavigationType,
  et as Outlet,
  Hr as PrefetchPageLinks,
  Tr as Route,
  kr as Router,
  J as RouterContextProvider,
  Xe as RouterProvider,
  Fr as Routes,
  Pr as Scripts,
  Ur as ScrollRestoration,
  er as ServerRouter,
  Lr as StaticRouter,
  Ee as StaticRouterProvider,
  Nr as UNSAFE_AwaitContextProvider,
  Or as UNSAFE_DataRouterContext,
  Ir as UNSAFE_DataRouterStateContext,
  O as UNSAFE_ErrorResponseImpl,
  Br as UNSAFE_FetchersContext,
  ee as UNSAFE_FrameworkContext,
  Mr as UNSAFE_LocationContext,
  zr as UNSAFE_NavigationContext,
  lr as UNSAFE_RSCDefaultRootErrorBoundary,
  $e as UNSAFE_RemixErrorBoundary,
  $r as UNSAFE_RouteContext,
  Ct as UNSAFE_ServerMode,
  I as UNSAFE_SingleFetchRedirectSymbol,
  jr as UNSAFE_ViewTransitionContext,
  qr as UNSAFE_WithComponentProps,
  Vr as UNSAFE_WithErrorBoundaryProps,
  Wr as UNSAFE_WithHydrateFallbackProps,
  Xr as UNSAFE_createBrowserHistory,
  Jr as UNSAFE_createClientRoutes,
  Qr as UNSAFE_createClientRoutesWithHMRRevalidationOptOut,
  Gr as UNSAFE_createHashHistory,
  Kr as UNSAFE_createMemoryHistory,
  Yr as UNSAFE_createRouter,
  tt as UNSAFE_decodeViaTurboStream,
  cr as UNSAFE_deserializeErrors,
  fr as UNSAFE_getHydrationData,
  Zr as UNSAFE_getPatchRoutesOnNavigationFunction,
  ea as UNSAFE_getTurboStreamSingleFetchDataStrategy,
  ta as UNSAFE_hydrationRouteProperties,
  ra as UNSAFE_invariant,
  aa as UNSAFE_mapRouteProperties,
  Z as UNSAFE_shouldHydrateRouteLoader,
  na as UNSAFE_useFogOFWarDiscovery,
  sa as UNSAFE_useScrollRestoration,
  Ze as UNSAFE_withComponentProps,
  Ke as UNSAFE_withErrorBoundaryProps,
  Ye as UNSAFE_withHydrateFallbackProps,
  oa as createBrowserRouter,
  ia as createContext,
  De as createCookie,
  sr as createCookieSessionStorage,
  la as createHashRouter,
  We as createMemoryRouter,
  or as createMemorySessionStorage,
  ua as createPath,
  ar as createRequestHandler,
  da as createRoutesFromChildren,
  ca as createRoutesFromElements,
  tr as createRoutesStub,
  fa as createSearchParams,
  Ie as createSession,
  Mt as createSessionStorage,
  ha as createStaticHandler,
  ve as createStaticRouter,
  pa as data,
  ma as generatePath,
  ir as href,
  He as isCookie,
  k as isRouteErrorResponse,
  nr as isSession,
  ya as matchPath,
  Ce as matchRoutes,
  wa as parsePath,
  nt as redirect,
  rt as redirectDocument,
  ga as renderMatches,
  at as replace,
  Ra as resolvePath,
  Sa as unstable_HistoryRouter,
  dr as unstable_RSCStaticRouter,
  ur as unstable_routeRSCServerRequest,
  rr as unstable_setDevServerHooks,
  va as unstable_usePrompt,
  Ea as unstable_useRoute,
  Ca as useActionData,
  ba as useAsyncError,
  _a as useAsyncValue,
  xa as useBeforeUnload,
  Aa as useBlocker,
  Da as useFetcher,
  Ha as useFetchers,
  Ta as useFormAction,
  ka as useHref,
  Fa as useInRouterContext,
  Pa as useLinkClickHandler,
  Ua as useLoaderData,
  La as useLocation,
  Na as useMatch,
  Oa as useMatches,
  Ia as useNavigate,
  Ba as useNavigation,
  Ma as useNavigationType,
  za as useOutlet,
  $a as useOutletContext,
  ja as useParams,
  qa as useResolvedPath,
  Va as useRevalidator,
  qe as useRouteError,
  Wa as useRouteLoaderData,
  Xa as useRoutes,
  Ja as useSearchParams,
  Qa as useSubmit,
  Ga as useViewTransitionState
};
//# sourceMappingURL=zudoku.router.js.map
