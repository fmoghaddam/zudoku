import * as o from "react";
import { g as l } from "./mutation-DtwNNkmQ.js";
import { S as p, b, h as a, n as h, e as d, f as m, g as f } from "./useQuery-DSKGiCQr.js";
var v = class extends p {
  #s;
  #i = void 0;
  #t;
  #e;
  constructor(t, s) {
    super(), this.#s = t, this.setOptions(s), this.bindMethods(), this.#r();
  }
  bindMethods() {
    this.mutate = this.mutate.bind(this), this.reset = this.reset.bind(this);
  }
  setOptions(t) {
    const s = this.options;
    this.options = this.#s.defaultMutationOptions(t), b(this.options, s) || this.#s.getMutationCache().notify({
      type: "observerOptionsUpdated",
      mutation: this.#t,
      observer: this
    }), s?.mutationKey && this.options.mutationKey && a(s.mutationKey) !== a(this.options.mutationKey) ? this.reset() : this.#t?.state.status === "pending" && this.#t.setOptions(this.options);
  }
  onUnsubscribe() {
    this.hasListeners() || this.#t?.removeObserver(this);
  }
  onMutationUpdate(t) {
    this.#r(), this.#o(t);
  }
  getCurrentResult() {
    return this.#i;
  }
  reset() {
    this.#t?.removeObserver(this), this.#t = void 0, this.#r(), this.#o();
  }
  mutate(t, s) {
    return this.#e = s, this.#t?.removeObserver(this), this.#t = this.#s.getMutationCache().build(this.#s, this.options), this.#t.addObserver(this), this.#t.execute(t);
  }
  #r() {
    const t = this.#t?.state ?? l();
    this.#i = {
      ...t,
      isPending: t.status === "pending",
      isSuccess: t.status === "success",
      isError: t.status === "error",
      isIdle: t.status === "idle",
      mutate: this.mutate,
      reset: this.reset
    };
  }
  #o(t) {
    h.batch(() => {
      if (this.#e && this.hasListeners()) {
        const s = this.#i.variables, i = this.#i.context, e = {
          client: this.#s,
          meta: this.options.meta,
          mutationKey: this.options.mutationKey
        };
        t?.type === "success" ? (this.#e.onSuccess?.(
          t.data,
          s,
          i,
          e
        ), this.#e.onSettled?.(
          t.data,
          null,
          s,
          i,
          e
        )) : t?.type === "error" && (this.#e.onError?.(
          t.error,
          s,
          i,
          e
        ), this.#e.onSettled?.(
          void 0,
          t.error,
          s,
          i,
          e
        ));
      }
      this.listeners.forEach((s) => {
        s(this.#i);
      });
    });
  }
};
function g(t, s) {
  const i = d(s), [e] = o.useState(
    () => new v(
      i,
      t
    )
  );
  o.useEffect(() => {
    e.setOptions(t);
  }, [e, t]);
  const r = o.useSyncExternalStore(
    o.useCallback(
      (n) => e.subscribe(h.batchCalls(n)),
      [e]
    ),
    () => e.getCurrentResult(),
    () => e.getCurrentResult()
  ), u = o.useCallback(
    (n, c) => {
      e.mutate(n, c).catch(m);
    },
    [e]
  );
  if (r.error && f(e.options.throwOnError, [r.error]))
    throw r.error;
  return { ...r, mutate: u, mutateAsync: r.mutate };
}
export {
  v as M,
  g as u
};
//# sourceMappingURL=useMutation-CgOLW9Kh.js.map
