import { j as R } from "../jsx-runtime-BzflLqGi.js";
import * as j from "react";
import { useRef as qt, useState as $t, useCallback as fn, useEffect as It } from "react";
import { ArrowLeft as dn, ArrowRight as pn } from "lucide-react";
import { c as gt } from "../cn-5-Gd1Dss.js";
import { Button as Xt } from "./Button.js";
function mn(t) {
  return Object.prototype.toString.call(t) === "[object Object]";
}
function Kt(t) {
  return mn(t) || Array.isArray(t);
}
function gn() {
  return !!(typeof window < "u" && window.document && window.document.createElement);
}
function At(t, n) {
  const o = Object.keys(t), r = Object.keys(n);
  if (o.length !== r.length) return !1;
  const i = JSON.stringify(Object.keys(t.breakpoints || {})), s = JSON.stringify(Object.keys(n.breakpoints || {}));
  return i !== s ? !1 : o.every((e) => {
    const a = t[e], c = n[e];
    return typeof a == "function" ? `${a}` == `${c}` : !Kt(a) || !Kt(c) ? a === c : At(a, c);
  });
}
function Ut(t) {
  return t.concat().sort((n, o) => n.name > o.name ? 1 : -1).map((n) => n.options);
}
function hn(t, n) {
  if (t.length !== n.length) return !1;
  const o = Ut(t), r = Ut(n);
  return o.every((i, s) => {
    const e = r[s];
    return At(i, e);
  });
}
function Dt(t) {
  return typeof t == "number";
}
function Tt(t) {
  return typeof t == "string";
}
function xt(t) {
  return typeof t == "boolean";
}
function Qt(t) {
  return Object.prototype.toString.call(t) === "[object Object]";
}
function D(t) {
  return Math.abs(t);
}
function Pt(t) {
  return Math.sign(t);
}
function ft(t, n) {
  return D(t - n);
}
function Sn(t, n) {
  if (t === 0 || n === 0 || D(t) <= D(n)) return 0;
  const o = ft(D(t), D(n));
  return D(o / t);
}
function yn(t) {
  return Math.round(t * 100) / 100;
}
function dt(t) {
  return pt(t).map(Number);
}
function V(t) {
  return t[ht(t)];
}
function ht(t) {
  return Math.max(0, t.length - 1);
}
function Ot(t, n) {
  return n === ht(t);
}
function Jt(t, n = 0) {
  return Array.from(Array(t), (o, r) => n + r);
}
function pt(t) {
  return Object.keys(t);
}
function Yt(t, n) {
  return [t, n].reduce((o, r) => (pt(r).forEach((i) => {
    const s = o[i], e = r[i], a = Qt(s) && Qt(e);
    o[i] = a ? Yt(s, e) : e;
  }), o), {});
}
function Nt(t, n) {
  return typeof n.MouseEvent < "u" && t instanceof n.MouseEvent;
}
function xn(t, n) {
  const o = {
    start: r,
    center: i,
    end: s
  };
  function r() {
    return 0;
  }
  function i(c) {
    return s(c) / 2;
  }
  function s(c) {
    return n - c;
  }
  function e(c, u) {
    return Tt(t) ? o[t](c) : t(n, c, u);
  }
  return {
    measure: e
  };
}
function mt() {
  let t = [];
  function n(i, s, e, a = {
    passive: !0
  }) {
    let c;
    if ("addEventListener" in i)
      i.addEventListener(s, e, a), c = () => i.removeEventListener(s, e, a);
    else {
      const u = i;
      u.addListener(e), c = () => u.removeListener(e);
    }
    return t.push(c), r;
  }
  function o() {
    t = t.filter((i) => i());
  }
  const r = {
    add: n,
    clear: o
  };
  return r;
}
function bn(t, n, o, r) {
  const i = mt(), s = 1e3 / 60;
  let e = null, a = 0, c = 0;
  function u() {
    i.add(t, "visibilitychange", () => {
      t.hidden && l();
    });
  }
  function S() {
    x(), i.clear();
  }
  function d(h) {
    if (!c) return;
    e || (e = h, o(), o());
    const f = h - e;
    for (e = h, a += f; a >= s; )
      o(), a -= s;
    const g = a / s;
    r(g), c && (c = n.requestAnimationFrame(d));
  }
  function p() {
    c || (c = n.requestAnimationFrame(d));
  }
  function x() {
    n.cancelAnimationFrame(c), e = null, a = 0, c = 0;
  }
  function l() {
    e = null, a = 0;
  }
  return {
    init: u,
    destroy: S,
    start: p,
    stop: x,
    update: o,
    render: r
  };
}
function En(t, n) {
  const o = n === "rtl", r = t === "y", i = r ? "y" : "x", s = r ? "x" : "y", e = !r && o ? -1 : 1, a = S(), c = d();
  function u(l) {
    const {
      height: m,
      width: h
    } = l;
    return r ? m : h;
  }
  function S() {
    return r ? "top" : o ? "right" : "left";
  }
  function d() {
    return r ? "bottom" : o ? "left" : "right";
  }
  function p(l) {
    return l * e;
  }
  return {
    scroll: i,
    cross: s,
    startEdge: a,
    endEdge: c,
    measureSize: u,
    direction: p
  };
}
function et(t = 0, n = 0) {
  const o = D(t - n);
  function r(u) {
    return u < t;
  }
  function i(u) {
    return u > n;
  }
  function s(u) {
    return r(u) || i(u);
  }
  function e(u) {
    return s(u) ? r(u) ? t : n : u;
  }
  function a(u) {
    return o ? u - o * Math.ceil((u - n) / o) : u;
  }
  return {
    length: o,
    max: n,
    min: t,
    constrain: e,
    reachedAny: s,
    reachedMax: i,
    reachedMin: r,
    removeOffset: a
  };
}
function _t(t, n, o) {
  const {
    constrain: r
  } = et(0, t), i = t + 1;
  let s = e(n);
  function e(p) {
    return o ? D((i + p) % i) : r(p);
  }
  function a() {
    return s;
  }
  function c(p) {
    return s = e(p), d;
  }
  function u(p) {
    return S().set(a() + p);
  }
  function S() {
    return _t(t, a(), o);
  }
  const d = {
    get: a,
    set: c,
    add: u,
    clone: S
  };
  return d;
}
function vn(t, n, o, r, i, s, e, a, c, u, S, d, p, x, l, m, h, f, g) {
  const {
    cross: b,
    direction: L
  } = t, N = ["INPUT", "SELECT", "TEXTAREA"], C = {
    passive: !1
  }, E = mt(), v = mt(), w = et(50, 225).constrain(x.measure(20)), P = {
    mouse: 300,
    touch: 400
  }, I = {
    mouse: 500,
    touch: 600
  }, F = l ? 43 : 25;
  let G = !1, H = 0, q = 0, W = !1, _ = !1, U = !1, Q = !1;
  function it(y) {
    if (!g) return;
    function T(k) {
      (xt(g) || g(y, k)) && ut(k);
    }
    const O = n;
    E.add(O, "dragstart", (k) => k.preventDefault(), C).add(O, "touchmove", () => {
    }, C).add(O, "touchend", () => {
    }).add(O, "touchstart", T).add(O, "mousedown", T).add(O, "touchcancel", M).add(O, "contextmenu", M).add(O, "click", X, !0);
  }
  function $() {
    E.clear(), v.clear();
  }
  function ot() {
    const y = Q ? o : n;
    v.add(y, "touchmove", z, C).add(y, "touchend", M).add(y, "mousemove", z, C).add(y, "mouseup", M);
  }
  function rt(y) {
    const T = y.nodeName || "";
    return N.includes(T);
  }
  function J() {
    return (l ? I : P)[Q ? "mouse" : "touch"];
  }
  function ct(y, T) {
    const O = d.add(Pt(y) * -1), k = S.byDistance(y, !l).distance;
    return l || D(y) < w ? k : h && T ? k * 0.5 : S.byIndex(O.get(), 0).distance;
  }
  function ut(y) {
    const T = Nt(y, r);
    Q = T, U = l && T && !y.buttons && G, G = ft(i.get(), e.get()) >= 2, !(T && y.button !== 0) && (rt(y.target) || (W = !0, s.pointerDown(y), u.useFriction(0).useDuration(0), i.set(e), ot(), H = s.readPoint(y), q = s.readPoint(y, b), p.emit("pointerDown")));
  }
  function z(y) {
    if (!Nt(y, r) && y.touches.length >= 2) return M(y);
    const O = s.readPoint(y), k = s.readPoint(y, b), K = ft(O, H), Y = ft(k, q);
    if (!_ && !Q && (!y.cancelable || (_ = K > Y, !_)))
      return M(y);
    const tt = s.pointerMove(y);
    K > m && (U = !0), u.useFriction(0.3).useDuration(0.75), a.start(), i.add(L(tt)), y.preventDefault();
  }
  function M(y) {
    const O = S.byDistance(0, !1).index !== d.get(), k = s.pointerUp(y) * J(), K = ct(L(k), O), Y = Sn(k, K), tt = F - 10 * Y, Z = f + Y / 50;
    _ = !1, W = !1, v.clear(), u.useDuration(tt).useFriction(Z), c.distance(K, !l), Q = !1, p.emit("pointerUp");
  }
  function X(y) {
    U && (y.stopPropagation(), y.preventDefault(), U = !1);
  }
  function B() {
    return W;
  }
  return {
    init: it,
    destroy: $,
    pointerDown: B
  };
}
function Ln(t, n) {
  let r, i;
  function s(d) {
    return d.timeStamp;
  }
  function e(d, p) {
    const l = `client${(p || t.scroll) === "x" ? "X" : "Y"}`;
    return (Nt(d, n) ? d : d.touches[0])[l];
  }
  function a(d) {
    return r = d, i = d, e(d);
  }
  function c(d) {
    const p = e(d) - e(i), x = s(d) - s(r) > 170;
    return i = d, x && (r = d), p;
  }
  function u(d) {
    if (!r || !i) return 0;
    const p = e(i) - e(r), x = s(d) - s(r), l = s(d) - s(i) > 170, m = p / x;
    return x && !l && D(m) > 0.1 ? m : 0;
  }
  return {
    pointerDown: a,
    pointerMove: c,
    pointerUp: u,
    readPoint: e
  };
}
function Cn() {
  function t(o) {
    const {
      offsetTop: r,
      offsetLeft: i,
      offsetWidth: s,
      offsetHeight: e
    } = o;
    return {
      top: r,
      right: i + s,
      bottom: r + e,
      left: i,
      width: s,
      height: e
    };
  }
  return {
    measure: t
  };
}
function wn(t) {
  function n(r) {
    return t * (r / 100);
  }
  return {
    measure: n
  };
}
function In(t, n, o, r, i, s, e) {
  const a = [t].concat(r);
  let c, u, S = [], d = !1;
  function p(h) {
    return i.measureSize(e.measure(h));
  }
  function x(h) {
    if (!s) return;
    u = p(t), S = r.map(p);
    function f(g) {
      for (const b of g) {
        if (d) return;
        const L = b.target === t, N = r.indexOf(b.target), C = L ? u : S[N], E = p(L ? t : r[N]);
        if (D(E - C) >= 0.5) {
          h.reInit(), n.emit("resize");
          break;
        }
      }
    }
    c = new ResizeObserver((g) => {
      (xt(s) || s(h, g)) && f(g);
    }), o.requestAnimationFrame(() => {
      a.forEach((g) => c.observe(g));
    });
  }
  function l() {
    d = !0, c && c.disconnect();
  }
  return {
    init: x,
    destroy: l
  };
}
function Tn(t, n, o, r, i, s) {
  let e = 0, a = 0, c = i, u = s, S = t.get(), d = 0;
  function p() {
    const C = r.get() - t.get(), E = !c;
    let v = 0;
    return E ? (e = 0, o.set(r), t.set(r), v = C) : (o.set(t), e += C / c, e *= u, S += e, t.add(e), v = S - d), a = Pt(v), d = S, N;
  }
  function x() {
    const C = r.get() - n.get();
    return D(C) < 1e-3;
  }
  function l() {
    return c;
  }
  function m() {
    return a;
  }
  function h() {
    return e;
  }
  function f() {
    return b(i);
  }
  function g() {
    return L(s);
  }
  function b(C) {
    return c = C, N;
  }
  function L(C) {
    return u = C, N;
  }
  const N = {
    direction: m,
    duration: l,
    velocity: h,
    seek: p,
    settled: x,
    useBaseFriction: g,
    useBaseDuration: f,
    useFriction: L,
    useDuration: b
  };
  return N;
}
function Nn(t, n, o, r, i) {
  const s = i.measure(10), e = i.measure(50), a = et(0.1, 0.99);
  let c = !1;
  function u() {
    return !(c || !t.reachedAny(o.get()) || !t.reachedAny(n.get()));
  }
  function S(x) {
    if (!u()) return;
    const l = t.reachedMin(n.get()) ? "min" : "max", m = D(t[l] - n.get()), h = o.get() - n.get(), f = a.constrain(m / e);
    o.subtract(h * f), !x && D(h) < s && (o.set(t.constrain(o.get())), r.useDuration(25).useBaseFriction());
  }
  function d(x) {
    c = !x;
  }
  return {
    shouldConstrain: u,
    constrain: S,
    toggleActive: d
  };
}
function An(t, n, o, r, i) {
  const s = et(-n + t, 0), e = d(), a = S(), c = p();
  function u(l, m) {
    return ft(l, m) <= 1;
  }
  function S() {
    const l = e[0], m = V(e), h = e.lastIndexOf(l), f = e.indexOf(m) + 1;
    return et(h, f);
  }
  function d() {
    return o.map((l, m) => {
      const {
        min: h,
        max: f
      } = s, g = s.constrain(l), b = !m, L = Ot(o, m);
      return b ? f : L || u(h, g) ? h : u(f, g) ? f : g;
    }).map((l) => parseFloat(l.toFixed(3)));
  }
  function p() {
    if (n <= t + i) return [s.max];
    if (r === "keepSnaps") return e;
    const {
      min: l,
      max: m
    } = a;
    return e.slice(l, m);
  }
  return {
    snapsContained: c,
    scrollContainLimit: a
  };
}
function Dn(t, n, o) {
  const r = n[0], i = o ? r - t : V(n);
  return {
    limit: et(i, r)
  };
}
function Pn(t, n, o, r) {
  const s = n.min + 0.1, e = n.max + 0.1, {
    reachedMin: a,
    reachedMax: c
  } = et(s, e);
  function u(p) {
    return p === 1 ? c(o.get()) : p === -1 ? a(o.get()) : !1;
  }
  function S(p) {
    if (!u(p)) return;
    const x = t * (p * -1);
    r.forEach((l) => l.add(x));
  }
  return {
    loop: S
  };
}
function On(t) {
  const {
    max: n,
    length: o
  } = t;
  function r(s) {
    const e = s - n;
    return o ? e / -o : 0;
  }
  return {
    get: r
  };
}
function Mn(t, n, o, r, i) {
  const {
    startEdge: s,
    endEdge: e
  } = t, {
    groupSlides: a
  } = i, c = d().map(n.measure), u = p(), S = x();
  function d() {
    return a(r).map((m) => V(m)[e] - m[0][s]).map(D);
  }
  function p() {
    return r.map((m) => o[s] - m[s]).map((m) => -D(m));
  }
  function x() {
    return a(u).map((m) => m[0]).map((m, h) => m + c[h]);
  }
  return {
    snaps: u,
    snapsAligned: S
  };
}
function kn(t, n, o, r, i, s) {
  const {
    groupSlides: e
  } = i, {
    min: a,
    max: c
  } = r, u = S();
  function S() {
    const p = e(s), x = !t || n === "keepSnaps";
    return o.length === 1 ? [s] : x ? p : p.slice(a, c).map((l, m, h) => {
      const f = !m, g = Ot(h, m);
      if (f) {
        const b = V(h[0]) + 1;
        return Jt(b);
      }
      if (g) {
        const b = ht(s) - V(h)[0] + 1;
        return Jt(b, V(h)[0]);
      }
      return l;
    });
  }
  return {
    slideRegistry: u
  };
}
function jn(t, n, o, r, i) {
  const {
    reachedAny: s,
    removeOffset: e,
    constrain: a
  } = r;
  function c(l) {
    return l.concat().sort((m, h) => D(m) - D(h))[0];
  }
  function u(l) {
    const m = t ? e(l) : a(l), h = n.map((g, b) => ({
      diff: S(g - m, 0),
      index: b
    })).sort((g, b) => D(g.diff) - D(b.diff)), {
      index: f
    } = h[0];
    return {
      index: f,
      distance: m
    };
  }
  function S(l, m) {
    const h = [l, l + o, l - o];
    if (!t) return l;
    if (!m) return c(h);
    const f = h.filter((g) => Pt(g) === m);
    return f.length ? c(f) : V(h) - o;
  }
  function d(l, m) {
    const h = n[l] - i.get(), f = S(h, m);
    return {
      index: l,
      distance: f
    };
  }
  function p(l, m) {
    const h = i.get() + l, {
      index: f,
      distance: g
    } = u(h), b = !t && s(h);
    if (!m || b) return {
      index: f,
      distance: l
    };
    const L = n[f] - g, N = l + S(L, 0);
    return {
      index: f,
      distance: N
    };
  }
  return {
    byDistance: p,
    byIndex: d,
    shortcut: S
  };
}
function Fn(t, n, o, r, i, s, e) {
  function a(d) {
    const p = d.distance, x = d.index !== n.get();
    s.add(p), p && (r.duration() ? t.start() : (t.update(), t.render(1), t.update())), x && (o.set(n.get()), n.set(d.index), e.emit("select"));
  }
  function c(d, p) {
    const x = i.byDistance(d, p);
    a(x);
  }
  function u(d, p) {
    const x = n.clone().set(d), l = i.byIndex(x.get(), p);
    a(l);
  }
  return {
    distance: c,
    index: u
  };
}
function zn(t, n, o, r, i, s, e, a) {
  const c = {
    passive: !0,
    capture: !0
  };
  let u = 0;
  function S(x) {
    if (!a) return;
    function l(m) {
      if ((/* @__PURE__ */ new Date()).getTime() - u > 10) return;
      e.emit("slideFocusStart"), t.scrollLeft = 0;
      const g = o.findIndex((b) => b.includes(m));
      Dt(g) && (i.useDuration(0), r.index(g, 0), e.emit("slideFocus"));
    }
    s.add(document, "keydown", d, !1), n.forEach((m, h) => {
      s.add(m, "focus", (f) => {
        (xt(a) || a(x, f)) && l(h);
      }, c);
    });
  }
  function d(x) {
    x.code === "Tab" && (u = (/* @__PURE__ */ new Date()).getTime());
  }
  return {
    init: S
  };
}
function lt(t) {
  let n = t;
  function o() {
    return n;
  }
  function r(c) {
    n = e(c);
  }
  function i(c) {
    n += e(c);
  }
  function s(c) {
    n -= e(c);
  }
  function e(c) {
    return Dt(c) ? c : c.get();
  }
  return {
    get: o,
    set: r,
    add: i,
    subtract: s
  };
}
function Zt(t, n) {
  const o = t.scroll === "x" ? e : a, r = n.style;
  let i = null, s = !1;
  function e(p) {
    return `translate3d(${p}px,0px,0px)`;
  }
  function a(p) {
    return `translate3d(0px,${p}px,0px)`;
  }
  function c(p) {
    if (s) return;
    const x = yn(t.direction(p));
    x !== i && (r.transform = o(x), i = x);
  }
  function u(p) {
    s = !p;
  }
  function S() {
    s || (r.transform = "", n.getAttribute("style") || n.removeAttribute("style"));
  }
  return {
    clear: S,
    to: c,
    toggleActive: u
  };
}
function Bn(t, n, o, r, i, s, e, a, c) {
  const S = dt(i), d = dt(i).reverse(), p = f().concat(g());
  function x(E, v) {
    return E.reduce((w, P) => w - i[P], v);
  }
  function l(E, v) {
    return E.reduce((w, P) => x(w, v) > 0 ? w.concat([P]) : w, []);
  }
  function m(E) {
    return s.map((v, w) => ({
      start: v - r[w] + 0.5 + E,
      end: v + n - 0.5 + E
    }));
  }
  function h(E, v, w) {
    const P = m(v);
    return E.map((I) => {
      const F = w ? 0 : -o, G = w ? o : 0, H = w ? "end" : "start", q = P[I][H];
      return {
        index: I,
        loopPoint: q,
        slideLocation: lt(-1),
        translate: Zt(t, c[I]),
        target: () => a.get() > q ? F : G
      };
    });
  }
  function f() {
    const E = e[0], v = l(d, E);
    return h(v, o, !1);
  }
  function g() {
    const E = n - e[0] - 1, v = l(S, E);
    return h(v, -o, !0);
  }
  function b() {
    return p.every(({
      index: E
    }) => {
      const v = S.filter((w) => w !== E);
      return x(v, n) <= 0.1;
    });
  }
  function L() {
    p.forEach((E) => {
      const {
        target: v,
        translate: w,
        slideLocation: P
      } = E, I = v();
      I !== P.get() && (w.to(I), P.set(I));
    });
  }
  function N() {
    p.forEach((E) => E.translate.clear());
  }
  return {
    canLoop: b,
    clear: N,
    loop: L,
    loopPoints: p
  };
}
function Rn(t, n, o) {
  let r, i = !1;
  function s(c) {
    if (!o) return;
    function u(S) {
      for (const d of S)
        if (d.type === "childList") {
          c.reInit(), n.emit("slidesChanged");
          break;
        }
    }
    r = new MutationObserver((S) => {
      i || (xt(o) || o(c, S)) && u(S);
    }), r.observe(t, {
      childList: !0
    });
  }
  function e() {
    r && r.disconnect(), i = !0;
  }
  return {
    init: s,
    destroy: e
  };
}
function Vn(t, n, o, r) {
  const i = {};
  let s = null, e = null, a, c = !1;
  function u() {
    a = new IntersectionObserver((l) => {
      c || (l.forEach((m) => {
        const h = n.indexOf(m.target);
        i[h] = m;
      }), s = null, e = null, o.emit("slidesInView"));
    }, {
      root: t.parentElement,
      threshold: r
    }), n.forEach((l) => a.observe(l));
  }
  function S() {
    a && a.disconnect(), c = !0;
  }
  function d(l) {
    return pt(i).reduce((m, h) => {
      const f = parseInt(h), {
        isIntersecting: g
      } = i[f];
      return (l && g || !l && !g) && m.push(f), m;
    }, []);
  }
  function p(l = !0) {
    if (l && s) return s;
    if (!l && e) return e;
    const m = d(l);
    return l && (s = m), l || (e = m), m;
  }
  return {
    init: u,
    destroy: S,
    get: p
  };
}
function Gn(t, n, o, r, i, s) {
  const {
    measureSize: e,
    startEdge: a,
    endEdge: c
  } = t, u = o[0] && i, S = l(), d = m(), p = o.map(e), x = h();
  function l() {
    if (!u) return 0;
    const g = o[0];
    return D(n[a] - g[a]);
  }
  function m() {
    if (!u) return 0;
    const g = s.getComputedStyle(V(r));
    return parseFloat(g.getPropertyValue(`margin-${c}`));
  }
  function h() {
    return o.map((g, b, L) => {
      const N = !b, C = Ot(L, b);
      return N ? p[b] + S : C ? p[b] + d : L[b + 1][a] - g[a];
    }).map(D);
  }
  return {
    slideSizes: p,
    slideSizesWithGaps: x,
    startGap: S,
    endGap: d
  };
}
function Hn(t, n, o, r, i, s, e, a, c) {
  const {
    startEdge: u,
    endEdge: S,
    direction: d
  } = t, p = Dt(o);
  function x(f, g) {
    return dt(f).filter((b) => b % g === 0).map((b) => f.slice(b, b + g));
  }
  function l(f) {
    return f.length ? dt(f).reduce((g, b, L) => {
      const N = V(g) || 0, C = N === 0, E = b === ht(f), v = i[u] - s[N][u], w = i[u] - s[b][S], P = !r && C ? d(e) : 0, I = !r && E ? d(a) : 0, F = D(w - I - (v + P));
      return L && F > n + c && g.push(b), E && g.push(f.length), g;
    }, []).map((g, b, L) => {
      const N = Math.max(L[b - 1] || 0);
      return f.slice(N, g);
    }) : [];
  }
  function m(f) {
    return p ? x(f, o) : l(f);
  }
  return {
    groupSlides: m
  };
}
function qn(t, n, o, r, i, s, e) {
  const {
    align: a,
    axis: c,
    direction: u,
    startIndex: S,
    loop: d,
    duration: p,
    dragFree: x,
    dragThreshold: l,
    inViewThreshold: m,
    slidesToScroll: h,
    skipSnaps: f,
    containScroll: g,
    watchResize: b,
    watchSlides: L,
    watchDrag: N,
    watchFocus: C
  } = s, E = 2, v = Cn(), w = v.measure(n), P = o.map(v.measure), I = En(c, u), F = I.measureSize(w), G = wn(F), H = xn(a, F), q = !d && !!g, W = d || !!g, {
    slideSizes: _,
    slideSizesWithGaps: U,
    startGap: Q,
    endGap: it
  } = Gn(I, w, P, o, W, i), $ = Hn(I, F, h, d, w, P, Q, it, E), {
    snaps: ot,
    snapsAligned: rt
  } = Mn(I, H, w, P, $), J = -V(ot) + V(U), {
    snapsContained: ct,
    scrollContainLimit: ut
  } = An(F, J, rt, g, E), z = q ? ct : rt, {
    limit: M
  } = Dn(J, z, d), X = _t(ht(z), S, d), B = X.clone(), A = dt(o), y = ({
    dragHandler: st,
    scrollBody: Ct,
    scrollBounds: wt,
    options: {
      loop: St
    }
  }) => {
    St || wt.constrain(st.pointerDown()), Ct.seek();
  }, T = ({
    scrollBody: st,
    translate: Ct,
    location: wt,
    offsetLocation: St,
    previousLocation: en,
    scrollLooper: on,
    slideLooper: rn,
    dragHandler: sn,
    animation: cn,
    eventHandler: zt,
    scrollBounds: un,
    options: {
      loop: Bt
    }
  }, Rt) => {
    const Vt = st.settled(), an = !un.shouldConstrain(), Gt = Bt ? Vt : Vt && an, Ht = Gt && !sn.pointerDown();
    Ht && cn.stop();
    const ln = wt.get() * Rt + en.get() * (1 - Rt);
    St.set(ln), Bt && (on.loop(st.direction()), rn.loop()), Ct.to(St.get()), Ht && zt.emit("settle"), Gt || zt.emit("scroll");
  }, O = bn(r, i, () => y(Lt), (st) => T(Lt, st)), k = 0.68, K = z[X.get()], Y = lt(K), tt = lt(K), Z = lt(K), nt = lt(K), at = Tn(Y, Z, tt, nt, p, k), Et = jn(d, z, J, M, nt), vt = Fn(O, X, B, at, Et, nt, e), kt = On(M), jt = mt(), tn = Vn(n, o, e, m), {
    slideRegistry: Ft
  } = kn(q, g, z, ut, $, A), nn = zn(t, o, Ft, vt, at, jt, e, C), Lt = {
    ownerDocument: r,
    ownerWindow: i,
    eventHandler: e,
    containerRect: w,
    slideRects: P,
    animation: O,
    axis: I,
    dragHandler: vn(I, t, r, i, nt, Ln(I, i), Y, O, vt, at, Et, X, e, G, x, l, f, k, N),
    eventStore: jt,
    percentOfView: G,
    index: X,
    indexPrevious: B,
    limit: M,
    location: Y,
    offsetLocation: Z,
    previousLocation: tt,
    options: s,
    resizeHandler: In(n, e, i, o, I, b, v),
    scrollBody: at,
    scrollBounds: Nn(M, Z, nt, at, G),
    scrollLooper: Pn(J, M, Z, [Y, Z, tt, nt]),
    scrollProgress: kt,
    scrollSnapList: z.map(kt.get),
    scrollSnaps: z,
    scrollTarget: Et,
    scrollTo: vt,
    slideLooper: Bn(I, F, J, _, U, ot, z, Z, o),
    slideFocus: nn,
    slidesHandler: Rn(n, e, L),
    slidesInView: tn,
    slideIndexes: A,
    slideRegistry: Ft,
    slidesToScroll: $,
    target: nt,
    translate: Zt(I, n)
  };
  return Lt;
}
function $n() {
  let t = {}, n;
  function o(u) {
    n = u;
  }
  function r(u) {
    return t[u] || [];
  }
  function i(u) {
    return r(u).forEach((S) => S(n, u)), c;
  }
  function s(u, S) {
    return t[u] = r(u).concat([S]), c;
  }
  function e(u, S) {
    return t[u] = r(u).filter((d) => d !== S), c;
  }
  function a() {
    t = {};
  }
  const c = {
    init: o,
    emit: i,
    off: e,
    on: s,
    clear: a
  };
  return c;
}
const Kn = {
  align: "center",
  axis: "x",
  container: null,
  slides: null,
  containScroll: "trimSnaps",
  direction: "ltr",
  slidesToScroll: 1,
  inViewThreshold: 0,
  breakpoints: {},
  dragFree: !1,
  dragThreshold: 10,
  loop: !1,
  skipSnaps: !1,
  duration: 25,
  startIndex: 0,
  active: !0,
  watchDrag: !0,
  watchResize: !0,
  watchSlides: !0,
  watchFocus: !0
};
function Un(t) {
  function n(s, e) {
    return Yt(s, e || {});
  }
  function o(s) {
    const e = s.breakpoints || {}, a = pt(e).filter((c) => t.matchMedia(c).matches).map((c) => e[c]).reduce((c, u) => n(c, u), {});
    return n(s, a);
  }
  function r(s) {
    return s.map((e) => pt(e.breakpoints || {})).reduce((e, a) => e.concat(a), []).map(t.matchMedia);
  }
  return {
    mergeOptions: n,
    optionsAtMedia: o,
    optionsMediaQueries: r
  };
}
function Qn(t) {
  let n = [];
  function o(s, e) {
    return n = e.filter(({
      options: a
    }) => t.optionsAtMedia(a).active !== !1), n.forEach((a) => a.init(s, t)), e.reduce((a, c) => Object.assign(a, {
      [c.name]: c
    }), {});
  }
  function r() {
    n = n.filter((s) => s.destroy());
  }
  return {
    init: o,
    destroy: r
  };
}
function yt(t, n, o) {
  const r = t.ownerDocument, i = r.defaultView, s = Un(i), e = Qn(s), a = mt(), c = $n(), {
    mergeOptions: u,
    optionsAtMedia: S,
    optionsMediaQueries: d
  } = s, {
    on: p,
    off: x,
    emit: l
  } = c, m = I;
  let h = !1, f, g = u(Kn, yt.globalOptions), b = u(g), L = [], N, C, E;
  function v() {
    const {
      container: A,
      slides: y
    } = b;
    C = (Tt(A) ? t.querySelector(A) : A) || t.children[0];
    const O = Tt(y) ? C.querySelectorAll(y) : y;
    E = [].slice.call(O || C.children);
  }
  function w(A) {
    const y = qn(t, C, E, r, i, A, c);
    if (A.loop && !y.slideLooper.canLoop()) {
      const T = Object.assign({}, A, {
        loop: !1
      });
      return w(T);
    }
    return y;
  }
  function P(A, y) {
    h || (g = u(g, A), b = S(g), L = y || L, v(), f = w(b), d([g, ...L.map(({
      options: T
    }) => T)]).forEach((T) => a.add(T, "change", I)), b.active && (f.translate.to(f.location.get()), f.animation.init(), f.slidesInView.init(), f.slideFocus.init(B), f.eventHandler.init(B), f.resizeHandler.init(B), f.slidesHandler.init(B), f.options.loop && f.slideLooper.loop(), C.offsetParent && E.length && f.dragHandler.init(B), N = e.init(B, L)));
  }
  function I(A, y) {
    const T = $();
    F(), P(u({
      startIndex: T
    }, A), y), c.emit("reInit");
  }
  function F() {
    f.dragHandler.destroy(), f.eventStore.clear(), f.translate.clear(), f.slideLooper.clear(), f.resizeHandler.destroy(), f.slidesHandler.destroy(), f.slidesInView.destroy(), f.animation.destroy(), e.destroy(), a.clear();
  }
  function G() {
    h || (h = !0, a.clear(), F(), c.emit("destroy"), c.clear());
  }
  function H(A, y, T) {
    !b.active || h || (f.scrollBody.useBaseFriction().useDuration(y === !0 ? 0 : b.duration), f.scrollTo.index(A, T || 0));
  }
  function q(A) {
    const y = f.index.add(1).get();
    H(y, A, -1);
  }
  function W(A) {
    const y = f.index.add(-1).get();
    H(y, A, 1);
  }
  function _() {
    return f.index.add(1).get() !== $();
  }
  function U() {
    return f.index.add(-1).get() !== $();
  }
  function Q() {
    return f.scrollSnapList;
  }
  function it() {
    return f.scrollProgress.get(f.offsetLocation.get());
  }
  function $() {
    return f.index.get();
  }
  function ot() {
    return f.indexPrevious.get();
  }
  function rt() {
    return f.slidesInView.get();
  }
  function J() {
    return f.slidesInView.get(!1);
  }
  function ct() {
    return N;
  }
  function ut() {
    return f;
  }
  function z() {
    return t;
  }
  function M() {
    return C;
  }
  function X() {
    return E;
  }
  const B = {
    canScrollNext: _,
    canScrollPrev: U,
    containerNode: M,
    internalEngine: ut,
    destroy: G,
    off: x,
    on: p,
    emit: l,
    plugins: ct,
    previousScrollSnap: ot,
    reInit: m,
    rootNode: z,
    scrollNext: q,
    scrollPrev: W,
    scrollProgress: it,
    scrollSnapList: Q,
    scrollTo: H,
    selectedScrollSnap: $,
    slideNodes: X,
    slidesInView: rt,
    slidesNotInView: J
  };
  return P(n, o), setTimeout(() => c.emit("init"), 0), B;
}
yt.globalOptions = void 0;
function Mt(t = {}, n = []) {
  const o = qt(t), r = qt(n), [i, s] = $t(), [e, a] = $t(), c = fn(() => {
    i && i.reInit(o.current, r.current);
  }, [i]);
  return It(() => {
    At(o.current, t) || (o.current = t, c());
  }, [t, c]), It(() => {
    hn(r.current, n) || (r.current = n, c());
  }, [n, c]), It(() => {
    if (gn() && e) {
      yt.globalOptions = Mt.globalOptions;
      const u = yt(e, o.current, r.current);
      return s(u), () => u.destroy();
    } else
      s(void 0);
  }, [e, s]), [a, i];
}
Mt.globalOptions = void 0;
const Wt = j.createContext(null);
function bt() {
  const t = j.useContext(Wt);
  if (!t)
    throw new Error("useCarousel must be used within a <Carousel />");
  return t;
}
const Jn = j.forwardRef(
  ({
    orientation: t = "horizontal",
    opts: n,
    setApi: o,
    plugins: r,
    className: i,
    children: s,
    ...e
  }, a) => {
    const [c, u] = Mt(
      {
        ...n,
        axis: t === "horizontal" ? "x" : "y"
      },
      r
    ), [S, d] = j.useState(!1), [p, x] = j.useState(!1), l = j.useCallback((g) => {
      g && (d(g.canScrollPrev()), x(g.canScrollNext()));
    }, []), m = j.useCallback(() => {
      u?.scrollPrev();
    }, [u]), h = j.useCallback(() => {
      u?.scrollNext();
    }, [u]), f = j.useCallback(
      (g) => {
        g.key === "ArrowLeft" ? (g.preventDefault(), m()) : g.key === "ArrowRight" && (g.preventDefault(), h());
      },
      [m, h]
    );
    return j.useEffect(() => {
      !u || !o || o(u);
    }, [u, o]), j.useEffect(() => {
      if (u)
        return l(u), u.on("reInit", l), u.on("select", l), () => {
          u.off("select", l);
        };
    }, [u, l]), /* @__PURE__ */ R.jsx(
      Wt.Provider,
      {
        value: {
          carouselRef: c,
          api: u,
          opts: n,
          orientation: t || (n?.axis === "y" ? "vertical" : "horizontal"),
          scrollPrev: m,
          scrollNext: h,
          canScrollPrev: S,
          canScrollNext: p
        },
        children: /* @__PURE__ */ R.jsx(
          "div",
          {
            ref: a,
            onKeyDownCapture: f,
            className: gt("relative", i),
            role: "region",
            "aria-roledescription": "carousel",
            ...e,
            children: s
          }
        )
      }
    );
  }
);
Jn.displayName = "Carousel";
const Xn = j.forwardRef(({ className: t, ...n }, o) => {
  const { carouselRef: r, orientation: i } = bt();
  return /* @__PURE__ */ R.jsx("div", { ref: r, className: "overflow-hidden", children: /* @__PURE__ */ R.jsx(
    "div",
    {
      ref: o,
      className: gt(
        "flex",
        i === "horizontal" ? "-ml-4" : "-mt-4 flex-col",
        t
      ),
      ...n
    }
  ) });
});
Xn.displayName = "CarouselContent";
const Yn = j.forwardRef(({ className: t, ...n }, o) => {
  const { orientation: r } = bt();
  return /* @__PURE__ */ R.jsx(
    "div",
    {
      ref: o,
      role: "group",
      "aria-roledescription": "slide",
      className: gt(
        "min-w-0 shrink-0 grow-0 basis-full",
        r === "horizontal" ? "pl-4" : "pt-4",
        t
      ),
      ...n
    }
  );
});
Yn.displayName = "CarouselItem";
const _n = j.forwardRef(({ className: t, variant: n = "outline", size: o = "icon", ...r }, i) => {
  const { orientation: s, scrollPrev: e, canScrollPrev: a } = bt();
  return /* @__PURE__ */ R.jsxs(
    Xt,
    {
      ref: i,
      variant: n,
      size: o,
      className: gt(
        "absolute  h-8 w-8 rounded-full",
        s === "horizontal" ? "-left-12 top-1/2 -translate-y-1/2" : "-top-12 left-1/2 -translate-x-1/2 rotate-90",
        t
      ),
      disabled: !a,
      onClick: e,
      ...r,
      children: [
        /* @__PURE__ */ R.jsx(dn, { className: "h-4 w-4" }),
        /* @__PURE__ */ R.jsx("span", { className: "sr-only", children: "Previous slide" })
      ]
    }
  );
});
_n.displayName = "CarouselPrevious";
const Zn = j.forwardRef(({ className: t, variant: n = "outline", size: o = "icon", ...r }, i) => {
  const { orientation: s, scrollNext: e, canScrollNext: a } = bt();
  return /* @__PURE__ */ R.jsxs(
    Xt,
    {
      ref: i,
      variant: n,
      size: o,
      className: gt(
        "absolute h-8 w-8 rounded-full",
        s === "horizontal" ? "-right-12 top-1/2 -translate-y-1/2" : "-bottom-12 left-1/2 -translate-x-1/2 rotate-90",
        t
      ),
      disabled: !a,
      onClick: e,
      ...r,
      children: [
        /* @__PURE__ */ R.jsx(pn, { className: "h-4 w-4" }),
        /* @__PURE__ */ R.jsx("span", { className: "sr-only", children: "Next slide" })
      ]
    }
  );
});
Zn.displayName = "CarouselNext";
export {
  Jn as Carousel,
  Xn as CarouselContent,
  Yn as CarouselItem,
  Zn as CarouselNext,
  _n as CarouselPrevious
};
//# sourceMappingURL=Carousel.js.map
