import * as p from "react";
import { j as tt } from "./jsx-runtime-BzflLqGi.js";
var H = class {
  constructor() {
    this.listeners = /* @__PURE__ */ new Set(), this.subscribe = this.subscribe.bind(this);
  }
  subscribe(t) {
    return this.listeners.add(t), this.onSubscribe(), () => {
      this.listeners.delete(t), this.onUnsubscribe();
    };
  }
  hasListeners() {
    return this.listeners.size > 0;
  }
  onSubscribe() {
  }
  onUnsubscribe() {
  }
}, ht = {
  // We need the wrapper function syntax below instead of direct references to
  // global setTimeout etc.
  //
  // BAD: `setTimeout: setTimeout`
  // GOOD: `setTimeout: (cb, delay) => setTimeout(cb, delay)`
  //
  // If we use direct references here, then anything that wants to spy on or
  // replace the global setTimeout (like tests) won't work since we'll already
  // have a hard reference to the original implementation at the time when this
  // file was imported.
  setTimeout: (t, e) => setTimeout(t, e),
  clearTimeout: (t) => clearTimeout(t),
  setInterval: (t, e) => setInterval(t, e),
  clearInterval: (t) => clearInterval(t)
}, lt = class {
  // We cannot have TimeoutManager<T> as we must instantiate it with a concrete
  // type at app boot; and if we leave that type, then any new timer provider
  // would need to support ReturnType<typeof setTimeout>, which is infeasible.
  //
  // We settle for type safety for the TimeoutProvider type, and accept that
  // this class is unsafe internally to allow for extension.
  #e = ht;
  #t = !1;
  setTimeoutProvider(t) {
    process.env.NODE_ENV !== "production" && this.#t && t !== this.#e && console.error(
      "[timeoutManager]: Switching provider after calls to previous provider might result in unexpected behavior.",
      { previous: this.#e, provider: t }
    ), this.#e = t, process.env.NODE_ENV !== "production" && (this.#t = !1);
  }
  setTimeout(t, e) {
    return process.env.NODE_ENV !== "production" && (this.#t = !0), this.#e.setTimeout(t, e);
  }
  clearTimeout(t) {
    this.#e.clearTimeout(t);
  }
  setInterval(t, e) {
    return process.env.NODE_ENV !== "production" && (this.#t = !0), this.#e.setInterval(t, e);
  }
  clearInterval(t) {
    this.#e.clearInterval(t);
  }
}, w = new lt();
function ft(t) {
  setTimeout(t, 0);
}
var E = typeof window > "u" || "Deno" in globalThis;
function C() {
}
function _t(t, e) {
  return typeof t == "function" ? t(e) : t;
}
function Q(t) {
  return typeof t == "number" && t >= 0 && t !== 1 / 0;
}
function et(t, e) {
  return Math.max(t + (e || 0) - Date.now(), 0);
}
function I(t, e) {
  return typeof t == "function" ? t(e) : t;
}
function v(t, e) {
  return typeof t == "function" ? t(e) : t;
}
function Lt(t, e) {
  const {
    type: s = "all",
    exact: r,
    fetchStatus: n,
    predicate: u,
    queryKey: a,
    stale: i
  } = t;
  if (a) {
    if (r) {
      if (e.queryHash !== dt(a, e.options))
        return !1;
    } else if (!V(e.queryKey, a))
      return !1;
  }
  if (s !== "all") {
    const o = e.isActive();
    if (s === "active" && !o || s === "inactive" && o)
      return !1;
  }
  return !(typeof i == "boolean" && e.isStale() !== i || n && n !== e.state.fetchStatus || u && !u(e));
}
function Kt(t, e) {
  const { exact: s, status: r, predicate: n, mutationKey: u } = t;
  if (u) {
    if (!e.options.mutationKey)
      return !1;
    if (s) {
      if (j(e.options.mutationKey) !== j(u))
        return !1;
    } else if (!V(e.options.mutationKey, u))
      return !1;
  }
  return !(r && e.state.status !== r || n && !n(e));
}
function dt(t, e) {
  return (e?.queryKeyHashFn || j)(t);
}
function j(t) {
  return JSON.stringify(
    t,
    (e, s) => A(s) ? Object.keys(s).sort().reduce((r, n) => (r[n] = s[n], r), {}) : s
  );
}
function V(t, e) {
  return t === e ? !0 : typeof t != typeof e ? !1 : t && e && typeof t == "object" && typeof e == "object" ? Object.keys(e).every((s) => V(t[s], e[s])) : !1;
}
var pt = Object.prototype.hasOwnProperty;
function q(t, e) {
  if (t === e)
    return t;
  const s = z(t) && z(e);
  if (!s && !(A(t) && A(e))) return e;
  const n = (s ? t : Object.keys(t)).length, u = s ? e : Object.keys(e), a = u.length, i = s ? new Array(a) : {};
  let o = 0;
  for (let l = 0; l < a; l++) {
    const c = s ? l : u[l], d = t[c], h = e[c];
    if (d === h) {
      i[c] = d, (s ? l < n : pt.call(t, c)) && o++;
      continue;
    }
    if (d === null || h === null || typeof d != "object" || typeof h != "object") {
      i[c] = h;
      continue;
    }
    const R = q(d, h);
    i[c] = R, R === d && o++;
  }
  return n === a && o === n ? t : i;
}
function N(t, e) {
  if (!e || Object.keys(t).length !== Object.keys(e).length)
    return !1;
  for (const s in t)
    if (t[s] !== e[s])
      return !1;
  return !0;
}
function z(t) {
  return Array.isArray(t) && t.length === Object.keys(t).length;
}
function A(t) {
  if (!$(t))
    return !1;
  const e = t.constructor;
  if (e === void 0)
    return !0;
  const s = e.prototype;
  return !(!$(s) || !s.hasOwnProperty("isPrototypeOf") || Object.getPrototypeOf(t) !== Object.prototype);
}
function $(t) {
  return Object.prototype.toString.call(t) === "[object Object]";
}
function yt(t) {
  return new Promise((e) => {
    w.setTimeout(e, t);
  });
}
function k(t, e, s) {
  if (typeof s.structuralSharing == "function")
    return s.structuralSharing(t, e);
  if (s.structuralSharing !== !1) {
    if (process.env.NODE_ENV !== "production")
      try {
        return q(t, e);
      } catch (r) {
        throw console.error(
          `Structural sharing requires data to be JSON serializable. To fix this, turn off structuralSharing or return JSON-serializable data from your queryFn. [${s.queryHash}]: ${r}`
        ), r;
      }
    return q(t, e);
  }
  return e;
}
function Ht(t) {
  return t;
}
function Vt(t, e, s = 0) {
  const r = [...t, e];
  return s && r.length > s ? r.slice(1) : r;
}
function Bt(t, e, s = 0) {
  const r = [e, ...t];
  return s && r.length > s ? r.slice(0, -1) : r;
}
var _ = Symbol();
function vt(t, e) {
  return process.env.NODE_ENV !== "production" && t.queryFn === _ && console.error(
    `Attempted to invoke queryFn when set to skipToken. This is likely a configuration error. Query hash: '${t.queryHash}'`
  ), !t.queryFn && e?.initialPromise ? () => e.initialPromise : !t.queryFn || t.queryFn === _ ? () => Promise.reject(new Error(`Missing queryFn: '${t.queryHash}'`)) : t.queryFn;
}
function mt(t, e) {
  return typeof t == "function" ? t(...e) : !!t;
}
var bt = class extends H {
  #e;
  #t;
  #s;
  constructor() {
    super(), this.#s = (t) => {
      if (!E && window.addEventListener) {
        const e = () => t();
        return window.addEventListener("visibilitychange", e, !1), () => {
          window.removeEventListener("visibilitychange", e);
        };
      }
    };
  }
  onSubscribe() {
    this.#t || this.setEventListener(this.#s);
  }
  onUnsubscribe() {
    this.hasListeners() || (this.#t?.(), this.#t = void 0);
  }
  setEventListener(t) {
    this.#s = t, this.#t?.(), this.#t = t((e) => {
      typeof e == "boolean" ? this.setFocused(e) : this.onFocus();
    });
  }
  setFocused(t) {
    this.#e !== t && (this.#e = t, this.onFocus());
  }
  onFocus() {
    const t = this.isFocused();
    this.listeners.forEach((e) => {
      e(t);
    });
  }
  isFocused() {
    return typeof this.#e == "boolean" ? this.#e : globalThis.document?.visibilityState !== "hidden";
  }
}, st = new bt();
function L() {
  let t, e;
  const s = new Promise((n, u) => {
    t = n, e = u;
  });
  s.status = "pending", s.catch(() => {
  });
  function r(n) {
    Object.assign(s, n), delete s.resolve, delete s.reject;
  }
  return s.resolve = (n) => {
    r({
      status: "fulfilled",
      value: n
    }), t(n);
  }, s.reject = (n) => {
    r({
      status: "rejected",
      reason: n
    }), e(n);
  }, s;
}
function Gt(t) {
  let e;
  if (t.then((s) => (e = s, s), C)?.catch(C), e !== void 0)
    return { data: e };
}
var gt = ft;
function St() {
  let t = [], e = 0, s = (i) => {
    i();
  }, r = (i) => {
    i();
  }, n = gt;
  const u = (i) => {
    e ? t.push(i) : n(() => {
      s(i);
    });
  }, a = () => {
    const i = t;
    t = [], i.length && n(() => {
      r(() => {
        i.forEach((o) => {
          s(o);
        });
      });
    });
  };
  return {
    batch: (i) => {
      let o;
      e++;
      try {
        o = i();
      } finally {
        e--, e || a();
      }
      return o;
    },
    /**
     * All calls to the wrapped function will be batched.
     */
    batchCalls: (i) => (...o) => {
      u(() => {
        i(...o);
      });
    },
    schedule: u,
    /**
     * Use this method to set a custom notify function.
     * This can be used to for example wrap notifications with `React.act` while running tests.
     */
    setNotifyFunction: (i) => {
      s = i;
    },
    /**
     * Use this method to set a custom function to batch notifications together into a single tick.
     * By default React Query will use the batch function provided by ReactDOM or React Native.
     */
    setBatchNotifyFunction: (i) => {
      r = i;
    },
    setScheduler: (i) => {
      n = i;
    }
  };
}
var B = St(), Rt = class extends H {
  #e = !0;
  #t;
  #s;
  constructor() {
    super(), this.#s = (t) => {
      if (!E && window.addEventListener) {
        const e = () => t(!0), s = () => t(!1);
        return window.addEventListener("online", e, !1), window.addEventListener("offline", s, !1), () => {
          window.removeEventListener("online", e), window.removeEventListener("offline", s);
        };
      }
    };
  }
  onSubscribe() {
    this.#t || this.setEventListener(this.#s);
  }
  onUnsubscribe() {
    this.hasListeners() || (this.#t?.(), this.#t = void 0);
  }
  setEventListener(t) {
    this.#s = t, this.#t?.(), this.#t = t(this.setOnline.bind(this));
  }
  setOnline(t) {
    this.#e !== t && (this.#e = t, this.listeners.forEach((s) => {
      s(t);
    }));
  }
  isOnline() {
    return this.#e;
  }
}, rt = new Rt();
function Ot(t) {
  return Math.min(1e3 * 2 ** t, 3e4);
}
function it(t) {
  return (t ?? "online") === "online" ? rt.isOnline() : !0;
}
var U = class extends Error {
  constructor(t) {
    super("CancelledError"), this.revert = t?.revert, this.silent = t?.silent;
  }
};
function zt(t) {
  return t instanceof U;
}
function wt(t) {
  let e = !1, s = 0, r;
  const n = L(), u = () => n.status !== "pending", a = (f) => {
    if (!u()) {
      const g = new U(f);
      h(g), t.onCancel?.(g);
    }
  }, i = () => {
    e = !0;
  }, o = () => {
    e = !1;
  }, l = () => st.isFocused() && (t.networkMode === "always" || rt.isOnline()) && t.canRun(), c = () => it(t.networkMode) && t.canRun(), d = (f) => {
    u() || (r?.(), n.resolve(f));
  }, h = (f) => {
    u() || (r?.(), n.reject(f));
  }, R = () => new Promise((f) => {
    r = (g) => {
      (u() || l()) && f(g);
    }, t.onPause?.();
  }).then(() => {
    r = void 0, u() || t.onContinue?.();
  }), F = () => {
    if (u())
      return;
    let f;
    const g = s === 0 ? t.initialPromise : void 0;
    try {
      f = g ?? t.fn();
    } catch (m) {
      f = Promise.reject(m);
    }
    Promise.resolve(f).then(d).catch((m) => {
      if (u())
        return;
      const S = t.retry ?? (E ? 0 : 3), O = t.retryDelay ?? Ot, P = typeof O == "function" ? O(s, m) : O, D = S === !0 || typeof S == "number" && s < S || typeof S == "function" && S(s, m);
      if (e || !D) {
        h(m);
        return;
      }
      s++, t.onFail?.(s, m), yt(P).then(() => l() ? void 0 : R()).then(() => {
        e ? h(m) : F();
      });
    });
  };
  return {
    promise: n,
    status: () => n.status,
    cancel: a,
    continue: () => (r?.(), n),
    cancelRetry: i,
    continueRetry: o,
    canStart: c,
    start: () => (c() ? F() : R().then(F), n)
  };
}
var Et = class {
  #e;
  destroy() {
    this.clearGcTimeout();
  }
  scheduleGc() {
    this.clearGcTimeout(), Q(this.gcTime) && (this.#e = w.setTimeout(() => {
      this.optionalRemove();
    }, this.gcTime));
  }
  updateGcTime(t) {
    this.gcTime = Math.max(
      this.gcTime || 0,
      t ?? (E ? 1 / 0 : 300 * 1e3)
    );
  }
  clearGcTimeout() {
    this.#e && (w.clearTimeout(this.#e), this.#e = void 0);
  }
}, $t = class extends Et {
  #e;
  #t;
  #s;
  #i;
  #r;
  #o;
  #a;
  constructor(t) {
    super(), this.#a = !1, this.#o = t.defaultOptions, this.setOptions(t.options), this.observers = [], this.#i = t.client, this.#s = this.#i.getQueryCache(), this.queryKey = t.queryKey, this.queryHash = t.queryHash, this.#e = W(this.options), this.state = t.state ?? this.#e, this.scheduleGc();
  }
  get meta() {
    return this.options.meta;
  }
  get promise() {
    return this.#r?.promise;
  }
  setOptions(t) {
    if (this.options = { ...this.#o, ...t }, this.updateGcTime(this.options.gcTime), this.state && this.state.data === void 0) {
      const e = W(this.options);
      e.data !== void 0 && (this.setState(
        J(e.data, e.dataUpdatedAt)
      ), this.#e = e);
    }
  }
  optionalRemove() {
    !this.observers.length && this.state.fetchStatus === "idle" && this.#s.remove(this);
  }
  setData(t, e) {
    const s = k(this.state.data, t, this.options);
    return this.#n({
      data: s,
      type: "success",
      dataUpdatedAt: e?.updatedAt,
      manual: e?.manual
    }), s;
  }
  setState(t, e) {
    this.#n({ type: "setState", state: t, setStateOptions: e });
  }
  cancel(t) {
    const e = this.#r?.promise;
    return this.#r?.cancel(t), e ? e.then(C).catch(C) : Promise.resolve();
  }
  destroy() {
    super.destroy(), this.cancel({ silent: !0 });
  }
  reset() {
    this.destroy(), this.setState(this.#e);
  }
  isActive() {
    return this.observers.some(
      (t) => v(t.options.enabled, this) !== !1
    );
  }
  isDisabled() {
    return this.getObserversCount() > 0 ? !this.isActive() : this.options.queryFn === _ || this.state.dataUpdateCount + this.state.errorUpdateCount === 0;
  }
  isStatic() {
    return this.getObserversCount() > 0 ? this.observers.some(
      (t) => I(t.options.staleTime, this) === "static"
    ) : !1;
  }
  isStale() {
    return this.getObserversCount() > 0 ? this.observers.some(
      (t) => t.getCurrentResult().isStale
    ) : this.state.data === void 0 || this.state.isInvalidated;
  }
  isStaleByTime(t = 0) {
    return this.state.data === void 0 ? !0 : t === "static" ? !1 : this.state.isInvalidated ? !0 : !et(this.state.dataUpdatedAt, t);
  }
  onFocus() {
    this.observers.find((e) => e.shouldFetchOnWindowFocus())?.refetch({ cancelRefetch: !1 }), this.#r?.continue();
  }
  onOnline() {
    this.observers.find((e) => e.shouldFetchOnReconnect())?.refetch({ cancelRefetch: !1 }), this.#r?.continue();
  }
  addObserver(t) {
    this.observers.includes(t) || (this.observers.push(t), this.clearGcTimeout(), this.#s.notify({ type: "observerAdded", query: this, observer: t }));
  }
  removeObserver(t) {
    this.observers.includes(t) && (this.observers = this.observers.filter((e) => e !== t), this.observers.length || (this.#r && (this.#a ? this.#r.cancel({ revert: !0 }) : this.#r.cancelRetry()), this.scheduleGc()), this.#s.notify({ type: "observerRemoved", query: this, observer: t }));
  }
  getObserversCount() {
    return this.observers.length;
  }
  invalidate() {
    this.state.isInvalidated || this.#n({ type: "invalidate" });
  }
  async fetch(t, e) {
    if (this.state.fetchStatus !== "idle" && // If the promise in the retyer is already rejected, we have to definitely
    // re-start the fetch; there is a chance that the query is still in a
    // pending state when that happens
    this.#r?.status() !== "rejected") {
      if (this.state.data !== void 0 && e?.cancelRefetch)
        this.cancel({ silent: !0 });
      else if (this.#r)
        return this.#r.continueRetry(), this.#r.promise;
    }
    if (t && this.setOptions(t), !this.options.queryFn) {
      const i = this.observers.find((o) => o.options.queryFn);
      i && this.setOptions(i.options);
    }
    process.env.NODE_ENV !== "production" && (Array.isArray(this.options.queryKey) || console.error(
      "As of v4, queryKey needs to be an Array. If you are using a string like 'repoData', please change it to an Array, e.g. ['repoData']"
    ));
    const s = new AbortController(), r = (i) => {
      Object.defineProperty(i, "signal", {
        enumerable: !0,
        get: () => (this.#a = !0, s.signal)
      });
    }, n = () => {
      const i = vt(this.options, e), l = (() => {
        const c = {
          client: this.#i,
          queryKey: this.queryKey,
          meta: this.meta
        };
        return r(c), c;
      })();
      return this.#a = !1, this.options.persister ? this.options.persister(
        i,
        l,
        this
      ) : i(l);
    }, a = (() => {
      const i = {
        fetchOptions: e,
        options: this.options,
        queryKey: this.queryKey,
        client: this.#i,
        state: this.state,
        fetchFn: n
      };
      return r(i), i;
    })();
    this.options.behavior?.onFetch(a, this), this.#t = this.state, (this.state.fetchStatus === "idle" || this.state.fetchMeta !== a.fetchOptions?.meta) && this.#n({ type: "fetch", meta: a.fetchOptions?.meta }), this.#r = wt({
      initialPromise: e?.initialPromise,
      fn: a.fetchFn,
      onCancel: (i) => {
        i instanceof U && i.revert && this.setState({
          ...this.#t,
          fetchStatus: "idle"
        }), s.abort();
      },
      onFail: (i, o) => {
        this.#n({ type: "failed", failureCount: i, error: o });
      },
      onPause: () => {
        this.#n({ type: "pause" });
      },
      onContinue: () => {
        this.#n({ type: "continue" });
      },
      retry: a.options.retry,
      retryDelay: a.options.retryDelay,
      networkMode: a.options.networkMode,
      canRun: () => !0
    });
    try {
      const i = await this.#r.start();
      if (i === void 0)
        throw process.env.NODE_ENV !== "production" && console.error(
          `Query data cannot be undefined. Please make sure to return a value other than undefined from your query function. Affected query key: ${this.queryHash}`
        ), new Error(`${this.queryHash} data is undefined`);
      return this.setData(i), this.#s.config.onSuccess?.(i, this), this.#s.config.onSettled?.(
        i,
        this.state.error,
        this
      ), i;
    } catch (i) {
      if (i instanceof U) {
        if (i.silent)
          return this.#r.promise;
        if (i.revert) {
          if (this.state.data === void 0)
            throw i;
          return this.state.data;
        }
      }
      throw this.#n({
        type: "error",
        error: i
      }), this.#s.config.onError?.(
        i,
        this
      ), this.#s.config.onSettled?.(
        this.state.data,
        i,
        this
      ), i;
    } finally {
      this.scheduleGc();
    }
  }
  #n(t) {
    const e = (s) => {
      switch (t.type) {
        case "failed":
          return {
            ...s,
            fetchFailureCount: t.failureCount,
            fetchFailureReason: t.error
          };
        case "pause":
          return {
            ...s,
            fetchStatus: "paused"
          };
        case "continue":
          return {
            ...s,
            fetchStatus: "fetching"
          };
        case "fetch":
          return {
            ...s,
            ...nt(s.data, this.options),
            fetchMeta: t.meta ?? null
          };
        case "success":
          const r = {
            ...s,
            ...J(t.data, t.dataUpdatedAt),
            dataUpdateCount: s.dataUpdateCount + 1,
            ...!t.manual && {
              fetchStatus: "idle",
              fetchFailureCount: 0,
              fetchFailureReason: null
            }
          };
          return this.#t = t.manual ? r : void 0, r;
        case "error":
          const n = t.error;
          return {
            ...s,
            error: n,
            errorUpdateCount: s.errorUpdateCount + 1,
            errorUpdatedAt: Date.now(),
            fetchFailureCount: s.fetchFailureCount + 1,
            fetchFailureReason: n,
            fetchStatus: "idle",
            status: "error"
          };
        case "invalidate":
          return {
            ...s,
            isInvalidated: !0
          };
        case "setState":
          return {
            ...s,
            ...t.state
          };
      }
    };
    this.state = e(this.state), B.batch(() => {
      this.observers.forEach((s) => {
        s.onQueryUpdate();
      }), this.#s.notify({ query: this, type: "updated", action: t });
    });
  }
};
function nt(t, e) {
  return {
    fetchFailureCount: 0,
    fetchFailureReason: null,
    fetchStatus: it(e.networkMode) ? "fetching" : "paused",
    ...t === void 0 && {
      error: null,
      status: "pending"
    }
  };
}
function J(t, e) {
  return {
    data: t,
    dataUpdatedAt: e ?? Date.now(),
    error: null,
    isInvalidated: !1,
    status: "success"
  };
}
function W(t) {
  const e = typeof t.initialData == "function" ? t.initialData() : t.initialData, s = e !== void 0, r = s ? typeof t.initialDataUpdatedAt == "function" ? t.initialDataUpdatedAt() : t.initialDataUpdatedAt : 0;
  return {
    data: e,
    dataUpdateCount: 0,
    dataUpdatedAt: s ? r ?? Date.now() : 0,
    error: null,
    errorUpdateCount: 0,
    errorUpdatedAt: 0,
    fetchFailureCount: 0,
    fetchFailureReason: null,
    fetchMeta: null,
    isInvalidated: !1,
    status: s ? "success" : "pending",
    fetchStatus: "idle"
  };
}
var Ct = class extends H {
  constructor(t, e) {
    super(), this.options = e, this.#e = t, this.#n = null, this.#a = L(), this.bindMethods(), this.setOptions(e);
  }
  #e;
  #t = void 0;
  #s = void 0;
  #i = void 0;
  #r;
  #o;
  #a;
  #n;
  #y;
  #f;
  // This property keeps track of the last query with defined data.
  // It will be used to pass the previous data and query to the placeholder function between renders.
  #d;
  #c;
  #h;
  #u;
  #p = /* @__PURE__ */ new Set();
  bindMethods() {
    this.refetch = this.refetch.bind(this);
  }
  onSubscribe() {
    this.listeners.size === 1 && (this.#t.addObserver(this), Z(this.#t, this.options) ? this.#l() : this.updateResult(), this.#g());
  }
  onUnsubscribe() {
    this.hasListeners() || this.destroy();
  }
  shouldFetchOnReconnect() {
    return K(
      this.#t,
      this.options,
      this.options.refetchOnReconnect
    );
  }
  shouldFetchOnWindowFocus() {
    return K(
      this.#t,
      this.options,
      this.options.refetchOnWindowFocus
    );
  }
  destroy() {
    this.listeners = /* @__PURE__ */ new Set(), this.#S(), this.#R(), this.#t.removeObserver(this);
  }
  setOptions(t) {
    const e = this.options, s = this.#t;
    if (this.options = this.#e.defaultQueryOptions(t), this.options.enabled !== void 0 && typeof this.options.enabled != "boolean" && typeof this.options.enabled != "function" && typeof v(this.options.enabled, this.#t) != "boolean")
      throw new Error(
        "Expected enabled to be a boolean or a callback that returns a boolean"
      );
    this.#O(), this.#t.setOptions(this.options), e._defaulted && !N(this.options, e) && this.#e.getQueryCache().notify({
      type: "observerOptionsUpdated",
      query: this.#t,
      observer: this
    });
    const r = this.hasListeners();
    r && X(
      this.#t,
      s,
      this.options,
      e
    ) && this.#l(), this.updateResult(), r && (this.#t !== s || v(this.options.enabled, this.#t) !== v(e.enabled, this.#t) || I(this.options.staleTime, this.#t) !== I(e.staleTime, this.#t)) && this.#v();
    const n = this.#m();
    r && (this.#t !== s || v(this.options.enabled, this.#t) !== v(e.enabled, this.#t) || n !== this.#u) && this.#b(n);
  }
  getOptimisticResult(t) {
    const e = this.#e.getQueryCache().build(this.#e, t), s = this.createResult(e, t);
    return Tt(this, s) && (this.#i = s, this.#o = this.options, this.#r = this.#t.state), s;
  }
  getCurrentResult() {
    return this.#i;
  }
  trackResult(t, e) {
    return new Proxy(t, {
      get: (s, r) => (this.trackProp(r), e?.(r), r === "promise" && (this.trackProp("data"), !this.options.experimental_prefetchInRender && this.#a.status === "pending" && this.#a.reject(
        new Error(
          "experimental_prefetchInRender feature flag is not enabled"
        )
      )), Reflect.get(s, r))
    });
  }
  trackProp(t) {
    this.#p.add(t);
  }
  getCurrentQuery() {
    return this.#t;
  }
  refetch({ ...t } = {}) {
    return this.fetch({
      ...t
    });
  }
  fetchOptimistic(t) {
    const e = this.#e.defaultQueryOptions(t), s = this.#e.getQueryCache().build(this.#e, e);
    return s.fetch().then(() => this.createResult(s, e));
  }
  fetch(t) {
    return this.#l({
      ...t,
      cancelRefetch: t.cancelRefetch ?? !0
    }).then(() => (this.updateResult(), this.#i));
  }
  #l(t) {
    this.#O();
    let e = this.#t.fetch(
      this.options,
      t
    );
    return t?.throwOnError || (e = e.catch(C)), e;
  }
  #v() {
    this.#S();
    const t = I(
      this.options.staleTime,
      this.#t
    );
    if (E || this.#i.isStale || !Q(t))
      return;
    const s = et(this.#i.dataUpdatedAt, t) + 1;
    this.#c = w.setTimeout(() => {
      this.#i.isStale || this.updateResult();
    }, s);
  }
  #m() {
    return (typeof this.options.refetchInterval == "function" ? this.options.refetchInterval(this.#t) : this.options.refetchInterval) ?? !1;
  }
  #b(t) {
    this.#R(), this.#u = t, !(E || v(this.options.enabled, this.#t) === !1 || !Q(this.#u) || this.#u === 0) && (this.#h = w.setInterval(() => {
      (this.options.refetchIntervalInBackground || st.isFocused()) && this.#l();
    }, this.#u));
  }
  #g() {
    this.#v(), this.#b(this.#m());
  }
  #S() {
    this.#c && (w.clearTimeout(this.#c), this.#c = void 0);
  }
  #R() {
    this.#h && (w.clearInterval(this.#h), this.#h = void 0);
  }
  createResult(t, e) {
    const s = this.#t, r = this.options, n = this.#i, u = this.#r, a = this.#o, o = t !== s ? t.state : this.#s, { state: l } = t;
    let c = { ...l }, d = !1, h;
    if (e._optimisticResults) {
      const y = this.hasListeners(), M = !y && Z(t, e), T = y && X(t, s, e, r);
      (M || T) && (c = {
        ...c,
        ...nt(l.data, t.options)
      }), e._optimisticResults === "isRestoring" && (c.fetchStatus = "idle");
    }
    let { error: R, errorUpdatedAt: F, status: f } = c;
    h = c.data;
    let g = !1;
    if (e.placeholderData !== void 0 && h === void 0 && f === "pending") {
      let y;
      n?.isPlaceholderData && e.placeholderData === a?.placeholderData ? (y = n.data, g = !0) : y = typeof e.placeholderData == "function" ? e.placeholderData(
        this.#d?.state.data,
        this.#d
      ) : e.placeholderData, y !== void 0 && (f = "success", h = k(
        n?.data,
        y,
        e
      ), d = !0);
    }
    if (e.select && h !== void 0 && !g)
      if (n && h === u?.data && e.select === this.#y)
        h = this.#f;
      else
        try {
          this.#y = e.select, h = e.select(h), h = k(n?.data, h, e), this.#f = h, this.#n = null;
        } catch (y) {
          this.#n = y;
        }
    this.#n && (R = this.#n, h = this.#f, F = Date.now(), f = "error");
    const m = c.fetchStatus === "fetching", S = f === "pending", O = f === "error", P = S && m, D = h !== void 0, b = {
      status: f,
      fetchStatus: c.fetchStatus,
      isPending: S,
      isSuccess: f === "success",
      isError: O,
      isInitialLoading: P,
      isLoading: P,
      data: h,
      dataUpdatedAt: c.dataUpdatedAt,
      error: R,
      errorUpdatedAt: F,
      failureCount: c.fetchFailureCount,
      failureReason: c.fetchFailureReason,
      errorUpdateCount: c.errorUpdateCount,
      isFetched: c.dataUpdateCount > 0 || c.errorUpdateCount > 0,
      isFetchedAfterMount: c.dataUpdateCount > o.dataUpdateCount || c.errorUpdateCount > o.errorUpdateCount,
      isFetching: m,
      isRefetching: m && !S,
      isLoadingError: O && !D,
      isPaused: c.fetchStatus === "paused",
      isPlaceholderData: d,
      isRefetchError: O && D,
      isStale: G(t, e),
      refetch: this.refetch,
      promise: this.#a,
      isEnabled: v(e.enabled, t) !== !1
    };
    if (this.options.experimental_prefetchInRender) {
      const y = (x) => {
        b.status === "error" ? x.reject(b.error) : b.data !== void 0 && x.resolve(b.data);
      }, M = () => {
        const x = this.#a = b.promise = L();
        y(x);
      }, T = this.#a;
      switch (T.status) {
        case "pending":
          t.queryHash === s.queryHash && y(T);
          break;
        case "fulfilled":
          (b.status === "error" || b.data !== T.value) && M();
          break;
        case "rejected":
          (b.status !== "error" || b.error !== T.reason) && M();
          break;
      }
    }
    return b;
  }
  updateResult() {
    const t = this.#i, e = this.createResult(this.#t, this.options);
    if (this.#r = this.#t.state, this.#o = this.options, this.#r.data !== void 0 && (this.#d = this.#t), N(e, t))
      return;
    this.#i = e;
    const s = () => {
      if (!t)
        return !0;
      const { notifyOnChangeProps: r } = this.options, n = typeof r == "function" ? r() : r;
      if (n === "all" || !n && !this.#p.size)
        return !0;
      const u = new Set(
        n ?? this.#p
      );
      return this.options.throwOnError && u.add("error"), Object.keys(this.#i).some((a) => {
        const i = a;
        return this.#i[i] !== t[i] && u.has(i);
      });
    };
    this.#w({ listeners: s() });
  }
  #O() {
    const t = this.#e.getQueryCache().build(this.#e, this.options);
    if (t === this.#t)
      return;
    const e = this.#t;
    this.#t = t, this.#s = t.state, this.hasListeners() && (e?.removeObserver(this), t.addObserver(this));
  }
  onQueryUpdate() {
    this.updateResult(), this.hasListeners() && this.#g();
  }
  #w(t) {
    B.batch(() => {
      t.listeners && this.listeners.forEach((e) => {
        e(this.#i);
      }), this.#e.getQueryCache().notify({
        query: this.#t,
        type: "observerResultsUpdated"
      });
    });
  }
};
function Ft(t, e) {
  return v(e.enabled, t) !== !1 && t.state.data === void 0 && !(t.state.status === "error" && e.retryOnMount === !1);
}
function Z(t, e) {
  return Ft(t, e) || t.state.data !== void 0 && K(t, e, e.refetchOnMount);
}
function K(t, e, s) {
  if (v(e.enabled, t) !== !1 && I(e.staleTime, t) !== "static") {
    const r = typeof s == "function" ? s(t) : s;
    return r === "always" || r !== !1 && G(t, e);
  }
  return !1;
}
function X(t, e, s, r) {
  return (t !== e || v(r.enabled, t) === !1) && (!s.suspense || t.state.status !== "error") && G(t, s);
}
function G(t, e) {
  return v(e.enabled, t) !== !1 && t.isStaleByTime(I(e.staleTime, t));
}
function Tt(t, e) {
  return !N(t.getCurrentResult(), e);
}
var at = p.createContext(
  void 0
), It = (t) => {
  const e = p.useContext(at);
  if (t)
    return t;
  if (!e)
    throw new Error("No QueryClient set, use QueryClientProvider to set one");
  return e;
}, Jt = ({
  client: t,
  children: e
}) => (p.useEffect(() => (t.mount(), () => {
  t.unmount();
}), [t]), /* @__PURE__ */ tt.jsx(at.Provider, { value: t, children: e })), ot = p.createContext(!1), Pt = () => p.useContext(ot), Wt = ot.Provider;
function ut() {
  let t = !1;
  return {
    clearReset: () => {
      t = !1;
    },
    reset: () => {
      t = !0;
    },
    isReset: () => t
  };
}
var ct = p.createContext(ut()), Dt = () => p.useContext(ct), Zt = ({
  children: t
}) => {
  const [e] = p.useState(() => ut());
  return /* @__PURE__ */ tt.jsx(ct.Provider, { value: e, children: typeof t == "function" ? t(e) : t });
}, Mt = (t, e) => {
  (t.suspense || t.throwOnError || t.experimental_prefetchInRender) && (e.isReset() || (t.retryOnMount = !1));
}, xt = (t) => {
  p.useEffect(() => {
    t.clearReset();
  }, [t]);
}, Ut = ({
  result: t,
  errorResetBoundary: e,
  throwOnError: s,
  query: r,
  suspense: n
}) => t.isError && !e.isReset() && !t.isFetching && r && (n && t.data === void 0 || mt(s, [t.error, r])), Xt = (t, e) => e.state.data === void 0, Qt = (t) => {
  if (t.suspense) {
    const s = (n) => n === "static" ? n : Math.max(n ?? 1e3, 1e3), r = t.staleTime;
    t.staleTime = typeof r == "function" ? (...n) => s(r(...n)) : s(r), typeof t.gcTime == "number" && (t.gcTime = Math.max(
      t.gcTime,
      1e3
    ));
  }
}, jt = (t, e) => t.isLoading && t.isFetching && !e, qt = (t, e) => t?.suspense && e.isPending, Y = (t, e, s) => e.fetchOptimistic(t).catch(() => {
  s.clearReset();
});
function Nt(t, e, s) {
  if (process.env.NODE_ENV !== "production" && (typeof t != "object" || Array.isArray(t)))
    throw new Error(
      'Bad argument type. Starting with v5, only the "Object" form is allowed when calling query related functions. Please use the error stack to find the culprit call. More info here: https://tanstack.com/query/latest/docs/react/guides/migrating-to-v5#supports-a-single-signature-one-object'
    );
  const r = Pt(), n = Dt(), u = It(s), a = u.defaultQueryOptions(t);
  u.getDefaultOptions().queries?._experimental_beforeQuery?.(
    a
  ), process.env.NODE_ENV !== "production" && (a.queryFn || console.error(
    `[${a.queryHash}]: No queryFn was passed as an option, and no default queryFn was found. The queryFn parameter is only optional when using a default queryFn. More info here: https://tanstack.com/query/latest/docs/framework/react/guides/default-query-function`
  )), a._optimisticResults = r ? "isRestoring" : "optimistic", Qt(a), Mt(a, n), xt(n);
  const i = !u.getQueryCache().get(a.queryHash), [o] = p.useState(
    () => new e(
      u,
      a
    )
  ), l = o.getOptimisticResult(a), c = !r && t.subscribed !== !1;
  if (p.useSyncExternalStore(
    p.useCallback(
      (d) => {
        const h = c ? o.subscribe(B.batchCalls(d)) : C;
        return o.updateResult(), h;
      },
      [o, c]
    ),
    () => o.getCurrentResult(),
    () => o.getCurrentResult()
  ), p.useEffect(() => {
    o.setOptions(a);
  }, [a, o]), qt(a, l))
    throw Y(a, o, n);
  if (Ut({
    result: l,
    errorResetBoundary: n,
    throwOnError: a.throwOnError,
    query: u.getQueryCache().get(a.queryHash),
    suspense: a.suspense
  }))
    throw l.error;
  return u.getDefaultOptions().queries?._experimental_afterQuery?.(
    a,
    l
  ), a.experimental_prefetchInRender && !E && jt(l, r) && (i ? (
    // Fetch immediately on render in order to ensure `.promise` is resolved even if the component is unmounted
    Y(a, o, n)
  ) : (
    // subscribe to the "cache promise" so that we can finalize the currentThenable once data comes in
    u.getQueryCache().get(a.queryHash)?.promise
  ))?.catch(C).finally(() => {
    o.updateResult();
  }), a.notifyOnChangeProps ? l : o.trackResult(l);
}
function Yt(t, e) {
  return Nt(t, Ct, e);
}
export {
  Pt as A,
  Dt as B,
  Qt as C,
  Mt as D,
  xt as E,
  qt as F,
  Y as G,
  jt as H,
  Ut as I,
  Wt as J,
  at as K,
  Jt as L,
  Zt as M,
  U as N,
  gt as O,
  zt as P,
  Ct as Q,
  Et as R,
  H as S,
  E as T,
  w as U,
  Nt as a,
  N as b,
  wt as c,
  Xt as d,
  It as e,
  C as f,
  mt as g,
  j as h,
  vt as i,
  Bt as j,
  Ht as k,
  Vt as l,
  Kt as m,
  B as n,
  dt as o,
  $t as p,
  Lt as q,
  st as r,
  _ as s,
  Gt as t,
  Yt as u,
  rt as v,
  I as w,
  _t as x,
  V as y,
  q as z
};
//# sourceMappingURL=useQuery-DSKGiCQr.js.map
