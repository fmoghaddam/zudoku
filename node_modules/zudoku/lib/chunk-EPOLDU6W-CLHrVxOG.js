import * as c from "react";
/**
 * react-router v7.12.0
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
var Ga = (e) => {
  throw TypeError(e);
}, Yo = (e, t, r) => t.has(e) || Ga("Cannot " + r), sr = (e, t, r) => (Yo(e, t, "read from private field"), r ? r.call(e) : t.get(e)), Jo = (e, t, r) => t.has(e) ? Ga("Cannot add the same private member more than once") : t instanceof WeakSet ? t.add(e) : t.set(e, r), Vo = /* @__PURE__ */ ((e) => (e.Pop = "POP", e.Push = "PUSH", e.Replace = "REPLACE", e))(Vo || {}), ga = "popstate";
function Xa(e = {}) {
  let { initialEntries: t = ["/"], initialIndex: r, v5Compat: a = !1 } = e, n;
  n = t.map(
    (f, y) => h(
      f,
      typeof f == "string" ? null : f.state,
      y === 0 ? "default" : void 0
    )
  );
  let o = s(
    r ?? n.length - 1
  ), i = "POP", l = null;
  function s(f) {
    return Math.min(Math.max(f, 0), n.length - 1);
  }
  function u() {
    return n[o];
  }
  function h(f, y = null, w) {
    let v = Ie(
      n ? u().pathname : "/",
      f,
      y,
      w
    );
    return Q(
      v.pathname.charAt(0) === "/",
      `relative pathnames are not supported in memory history: ${JSON.stringify(
        f
      )}`
    ), v;
  }
  function d(f) {
    return typeof f == "string" ? f : ce(f);
  }
  return {
    get index() {
      return o;
    },
    get action() {
      return i;
    },
    get location() {
      return u();
    },
    createHref: d,
    createURL(f) {
      return new URL(d(f), "http://localhost");
    },
    encodeLocation(f) {
      let y = typeof f == "string" ? Ce(f) : f;
      return {
        pathname: y.pathname || "",
        search: y.search || "",
        hash: y.hash || ""
      };
    },
    push(f, y) {
      i = "PUSH";
      let w = h(f, y);
      o += 1, n.splice(o, n.length, w), a && l && l({ action: i, location: w, delta: 1 });
    },
    replace(f, y) {
      i = "REPLACE";
      let w = h(f, y);
      n[o] = w, a && l && l({ action: i, location: w, delta: 0 });
    },
    go(f) {
      i = "POP";
      let y = s(o + f), w = n[y];
      o = y, l && l({ action: i, location: w, delta: f });
    },
    listen(f) {
      return l = f, () => {
        l = null;
      };
    }
  };
}
function Qa(e = {}) {
  function t(a, n) {
    let { pathname: o, search: i, hash: l } = a.location;
    return Ie(
      "",
      { pathname: o, search: i, hash: l },
      // state defaults to `null` because `window.history.state` does
      n.state && n.state.usr || null,
      n.state && n.state.key || "default"
    );
  }
  function r(a, n) {
    return typeof n == "string" ? n : ce(n);
  }
  return qa(
    t,
    r,
    null,
    e
  );
}
function Za(e = {}) {
  function t(n, o) {
    let {
      pathname: i = "/",
      search: l = "",
      hash: s = ""
    } = Ce(n.location.hash.substring(1));
    return !i.startsWith("/") && !i.startsWith(".") && (i = "/" + i), Ie(
      "",
      { pathname: i, search: l, hash: s },
      // state defaults to `null` because `window.history.state` does
      o.state && o.state.usr || null,
      o.state && o.state.key || "default"
    );
  }
  function r(n, o) {
    let i = n.document.querySelector("base"), l = "";
    if (i && i.getAttribute("href")) {
      let s = n.location.href, u = s.indexOf("#");
      l = u === -1 ? s : s.slice(0, u);
    }
    return l + "#" + (typeof o == "string" ? o : ce(o));
  }
  function a(n, o) {
    Q(
      n.pathname.charAt(0) === "/",
      `relative pathnames are not supported in hash history.push(${JSON.stringify(
        o
      )})`
    );
  }
  return qa(
    t,
    r,
    a,
    e
  );
}
function I(e, t) {
  if (e === !1 || e === null || typeof e > "u")
    throw new Error(t);
}
function Q(e, t) {
  if (!e) {
    typeof console < "u" && console.warn(t);
    try {
      throw new Error(t);
    } catch {
    }
  }
}
function Ko() {
  return Math.random().toString(36).substring(2, 10);
}
function wa(e, t) {
  return {
    usr: e.state,
    key: e.key,
    idx: t
  };
}
function Ie(e, t, r = null, a) {
  return {
    pathname: typeof e == "string" ? e : e.pathname,
    search: "",
    hash: "",
    ...typeof t == "string" ? Ce(t) : t,
    state: r,
    // TODO: This could be cleaned up.  push/replace should probably just take
    // full Locations now and avoid the need to run through this flow at all
    // But that's a pretty big refactor to the current test suite so going to
    // keep as is for the time being and just let any incoming keys take precedence
    key: t && t.key || a || Ko()
  };
}
function ce({
  pathname: e = "/",
  search: t = "",
  hash: r = ""
}) {
  return t && t !== "?" && (e += t.charAt(0) === "?" ? t : "?" + t), r && r !== "#" && (e += r.charAt(0) === "#" ? r : "#" + r), e;
}
function Ce(e) {
  let t = {};
  if (e) {
    let r = e.indexOf("#");
    r >= 0 && (t.hash = e.substring(r), e = e.substring(0, r));
    let a = e.indexOf("?");
    a >= 0 && (t.search = e.substring(a), e = e.substring(0, a)), e && (t.pathname = e);
  }
  return t;
}
function qa(e, t, r, a = {}) {
  let { window: n = document.defaultView, v5Compat: o = !1 } = a, i = n.history, l = "POP", s = null, u = h();
  u == null && (u = 0, i.replaceState({ ...i.state, idx: u }, ""));
  function h() {
    return (i.state || { idx: null }).idx;
  }
  function d() {
    l = "POP";
    let v = h(), x = v == null ? null : v - u;
    u = v, s && s({ action: l, location: w.location, delta: x });
  }
  function p(v, x) {
    l = "PUSH";
    let E = Ie(w.location, v, x);
    r && r(E, v), u = h() + 1;
    let P = wa(E, u), L = w.createHref(E);
    try {
      i.pushState(P, "", L);
    } catch (C) {
      if (C instanceof DOMException && C.name === "DataCloneError")
        throw C;
      n.location.assign(L);
    }
    o && s && s({ action: l, location: w.location, delta: 1 });
  }
  function f(v, x) {
    l = "REPLACE";
    let E = Ie(w.location, v, x);
    r && r(E, v), u = h();
    let P = wa(E, u), L = w.createHref(E);
    i.replaceState(P, "", L), o && s && s({ action: l, location: w.location, delta: 0 });
  }
  function y(v) {
    return en(v);
  }
  let w = {
    get action() {
      return l;
    },
    get location() {
      return e(n, i);
    },
    listen(v) {
      if (s)
        throw new Error("A history only accepts one active listener");
      return n.addEventListener(ga, d), s = v, () => {
        n.removeEventListener(ga, d), s = null;
      };
    },
    createHref(v) {
      return t(n, v);
    },
    createURL: y,
    encodeLocation(v) {
      let x = y(v);
      return {
        pathname: x.pathname,
        search: x.search,
        hash: x.hash
      };
    },
    push: p,
    replace: f,
    go(v) {
      return i.go(v);
    }
  };
  return w;
}
function en(e, t = !1) {
  let r = "http://localhost";
  typeof window < "u" && (r = window.location.origin !== "null" ? window.location.origin : window.location.href), I(r, "No window.location.(origin|href) available to create URL");
  let a = typeof e == "string" ? e : ce(e);
  return a = a.replace(/ $/, "%20"), !t && a.startsWith("//") && (a = r + a), new URL(a, r);
}
function $s(e) {
  return { defaultValue: e };
}
var Et, it = class {
  /**
   * Create a new `RouterContextProvider` instance
   * @param init An optional initial context map to populate the provider with
   */
  constructor(e) {
    if (Jo(this, Et, /* @__PURE__ */ new Map()), e)
      for (let [t, r] of e)
        this.set(t, r);
  }
  /**
   * Access a value from the context. If no value has been set for the context,
   * it will return the context's `defaultValue` if provided, or throw an error
   * if no `defaultValue` was set.
   * @param context The context to get the value for
   * @returns The value for the context, or the context's `defaultValue` if no
   * value was set
   */
  get(e) {
    if (sr(this, Et).has(e))
      return sr(this, Et).get(e);
    if (e.defaultValue !== void 0)
      return e.defaultValue;
    throw new Error("No value found for context");
  }
  /**
   * Set a value for the context. If the context already has a value set, this
   * will overwrite it.
   *
   * @param context The context to set the value for
   * @param value The value to set for the context
   * @returns {void}
   */
  set(e, t) {
    sr(this, Et).set(e, t);
  }
};
Et = /* @__PURE__ */ new WeakMap();
var Go = /* @__PURE__ */ new Set([
  "lazy",
  "caseSensitive",
  "path",
  "id",
  "index",
  "children"
]);
function Xo(e) {
  return Go.has(
    e
  );
}
var Qo = /* @__PURE__ */ new Set([
  "lazy",
  "caseSensitive",
  "path",
  "id",
  "index",
  "middleware",
  "children"
]);
function Zo(e) {
  return Qo.has(
    e
  );
}
function qo(e) {
  return e.index === !0;
}
function et(e, t, r = [], a = {}, n = !1) {
  return e.map((o, i) => {
    let l = [...r, String(i)], s = typeof o.id == "string" ? o.id : l.join("-");
    if (I(
      o.index !== !0 || !o.children,
      "Cannot specify children on an index route"
    ), I(
      n || !a[s],
      `Found a route id collision on id "${s}".  Route id's must be globally unique within Data Router usages`
    ), qo(o)) {
      let u = {
        ...o,
        id: s
      };
      return a[s] = ba(
        u,
        t(u)
      ), u;
    } else {
      let u = {
        ...o,
        id: s,
        children: void 0
      };
      return a[s] = ba(
        u,
        t(u)
      ), o.children && (u.children = et(
        o.children,
        t,
        l,
        a,
        n
      )), u;
    }
  });
}
function ba(e, t) {
  return Object.assign(e, {
    ...t,
    ...typeof t.lazy == "object" && t.lazy != null ? {
      lazy: {
        ...e.lazy,
        ...t.lazy
      }
    } : {}
  });
}
function De(e, t, r = "/") {
  return Rt(e, t, r, !1);
}
function Rt(e, t, r, a) {
  let n = typeof t == "string" ? Ce(t) : t, o = fe(n.pathname || "/", r);
  if (o == null)
    return null;
  let i = rn(e);
  ei(i);
  let l = null;
  for (let s = 0; l == null && s < i.length; ++s) {
    let u = on(o);
    l = ui(
      i[s],
      u,
      a
    );
  }
  return l;
}
function tn(e, t) {
  let { route: r, pathname: a, params: n } = e;
  return {
    id: r.id,
    pathname: a,
    params: n,
    data: t[r.id],
    loaderData: t[r.id],
    handle: r.handle
  };
}
function rn(e, t = [], r = [], a = "", n = !1) {
  let o = (i, l, s = n, u) => {
    let h = {
      relativePath: u === void 0 ? i.path || "" : u,
      caseSensitive: i.caseSensitive === !0,
      childrenIndex: l,
      route: i
    };
    if (h.relativePath.startsWith("/")) {
      if (!h.relativePath.startsWith(a) && s)
        return;
      I(
        h.relativePath.startsWith(a),
        `Absolute route path "${h.relativePath}" nested under path "${a}" is not valid. An absolute child route path must start with the combined path of all its parent routes.`
      ), h.relativePath = h.relativePath.slice(a.length);
    }
    let d = Me([a, h.relativePath]), p = r.concat(h);
    i.children && i.children.length > 0 && (I(
      // Our types know better, but runtime JS may not!
      // @ts-expect-error
      i.index !== !0,
      `Index routes must not have child routes. Please remove all child routes from route path "${d}".`
    ), rn(
      i.children,
      t,
      p,
      d,
      s
    )), !(i.path == null && !i.index) && t.push({
      path: d,
      score: li(d, i.index),
      routesMeta: p
    });
  };
  return e.forEach((i, l) => {
    if (i.path === "" || !i.path?.includes("?"))
      o(i, l);
    else
      for (let s of an(i.path))
        o(i, l, !0, s);
  }), t;
}
function an(e) {
  let t = e.split("/");
  if (t.length === 0) return [];
  let [r, ...a] = t, n = r.endsWith("?"), o = r.replace(/\?$/, "");
  if (a.length === 0)
    return n ? [o, ""] : [o];
  let i = an(a.join("/")), l = [];
  return l.push(
    ...i.map(
      (s) => s === "" ? o : [o, s].join("/")
    )
  ), n && l.push(...i), l.map(
    (s) => e.startsWith("/") && s === "" ? "/" : s
  );
}
function ei(e) {
  e.sort(
    (t, r) => t.score !== r.score ? r.score - t.score : si(
      t.routesMeta.map((a) => a.childrenIndex),
      r.routesMeta.map((a) => a.childrenIndex)
    )
  );
}
var ti = /^:[\w-]+$/, ri = 3, ai = 2, ni = 1, oi = 10, ii = -2, Ea = (e) => e === "*";
function li(e, t) {
  let r = e.split("/"), a = r.length;
  return r.some(Ea) && (a += ii), t && (a += ai), r.filter((n) => !Ea(n)).reduce(
    (n, o) => n + (ti.test(o) ? ri : o === "" ? ni : oi),
    a
  );
}
function si(e, t) {
  return e.length === t.length && e.slice(0, -1).every((a, n) => a === t[n]) ? (
    // If two routes are siblings, we should try to match the earlier sibling
    // first. This allows people to have fine-grained control over the matching
    // behavior by simply putting routes with identical paths in the order they
    // want them tried.
    e[e.length - 1] - t[t.length - 1]
  ) : (
    // Otherwise, it doesn't really make sense to rank non-siblings by index,
    // so they sort equally.
    0
  );
}
function ui(e, t, r = !1) {
  let { routesMeta: a } = e, n = {}, o = "/", i = [];
  for (let l = 0; l < a.length; ++l) {
    let s = a[l], u = l === a.length - 1, h = o === "/" ? t : t.slice(o.length) || "/", d = xt(
      { path: s.relativePath, caseSensitive: s.caseSensitive, end: u },
      h
    ), p = s.route;
    if (!d && u && r && !a[a.length - 1].route.index && (d = xt(
      {
        path: s.relativePath,
        caseSensitive: s.caseSensitive,
        end: !1
      },
      h
    )), !d)
      return null;
    Object.assign(n, d.params), i.push({
      // TODO: Can this as be avoided?
      params: n,
      pathname: Me([o, d.pathname]),
      pathnameBase: fi(
        Me([o, d.pathnameBase])
      ),
      route: p
    }), d.pathnameBase !== "/" && (o = Me([o, d.pathnameBase]));
  }
  return i;
}
function Ns(e, t = {}) {
  let r = e;
  r.endsWith("*") && r !== "*" && !r.endsWith("/*") && (Q(
    !1,
    `Route path "${r}" will be treated as if it were "${r.replace(/\*$/, "/*")}" because the \`*\` character must always follow a \`/\` in the pattern. To get rid of this warning, please change the route path to "${r.replace(/\*$/, "/*")}".`
  ), r = r.replace(/\*$/, "/*"));
  const a = r.startsWith("/") ? "/" : "", n = (i) => i == null ? "" : typeof i == "string" ? i : String(i), o = r.split(/\/+/).map((i, l, s) => {
    if (l === s.length - 1 && i === "*")
      return n(t["*"]);
    const h = i.match(/^:([\w-]+)(\??)(.*)/);
    if (h) {
      const [, d, p, f] = h;
      let y = t[d];
      return I(p === "?" || y != null, `Missing ":${d}" param`), encodeURIComponent(n(y)) + f;
    }
    return i.replace(/\?$/g, "");
  }).filter((i) => !!i);
  return a + o.join("/");
}
function xt(e, t) {
  typeof e == "string" && (e = { path: e, caseSensitive: !1, end: !0 });
  let [r, a] = nn(
    e.path,
    e.caseSensitive,
    e.end
  ), n = t.match(r);
  if (!n) return null;
  let o = n[0], i = o.replace(/(.)\/+$/, "$1"), l = n.slice(1);
  return {
    params: a.reduce(
      (u, { paramName: h, isOptional: d }, p) => {
        if (h === "*") {
          let y = l[p] || "";
          i = o.slice(0, o.length - y.length).replace(/(.)\/+$/, "$1");
        }
        const f = l[p];
        return d && !f ? u[h] = void 0 : u[h] = (f || "").replace(/%2F/g, "/"), u;
      },
      {}
    ),
    pathname: o,
    pathnameBase: i,
    pattern: e
  };
}
function nn(e, t = !1, r = !0) {
  Q(
    e === "*" || !e.endsWith("*") || e.endsWith("/*"),
    `Route path "${e}" will be treated as if it were "${e.replace(/\*$/, "/*")}" because the \`*\` character must always follow a \`/\` in the pattern. To get rid of this warning, please change the route path to "${e.replace(/\*$/, "/*")}".`
  );
  let a = [], n = "^" + e.replace(/\/*\*?$/, "").replace(/^\/*/, "/").replace(/[\\.*+^${}|()[\]]/g, "\\$&").replace(
    /\/:([\w-]+)(\?)?/g,
    (i, l, s) => (a.push({ paramName: l, isOptional: s != null }), s ? "/?([^\\/]+)?" : "/([^\\/]+)")
  ).replace(/\/([\w-]+)\?(\/|$)/g, "(/$1)?$2");
  return e.endsWith("*") ? (a.push({ paramName: "*" }), n += e === "*" || e === "/*" ? "(.*)$" : "(?:\\/(.+)|\\/*)$") : r ? n += "\\/*$" : e !== "" && e !== "/" && (n += "(?:(?=\\/|$))"), [new RegExp(n, t ? void 0 : "i"), a];
}
function on(e) {
  try {
    return e.split("/").map((t) => decodeURIComponent(t).replace(/\//g, "%2F")).join("/");
  } catch (t) {
    return Q(
      !1,
      `The URL path "${e}" could not be decoded because it is a malformed URL segment. This is probably due to a bad percent encoding (${t}).`
    ), e;
  }
}
function fe(e, t) {
  if (t === "/") return e;
  if (!e.toLowerCase().startsWith(t.toLowerCase()))
    return null;
  let r = t.endsWith("/") ? t.length - 1 : t.length, a = e.charAt(r);
  return a && a !== "/" ? null : e.slice(r) || "/";
}
function ci({
  basename: e,
  pathname: t
}) {
  return t === "/" ? e : Me([e, t]);
}
var ln = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i, Gt = (e) => ln.test(e);
function di(e, t = "/") {
  let {
    pathname: r,
    search: a = "",
    hash: n = ""
  } = typeof e == "string" ? Ce(e) : e, o;
  if (r)
    if (Gt(r))
      o = r;
    else {
      if (r.includes("//")) {
        let i = r;
        r = r.replace(/\/\/+/g, "/"), Q(
          !1,
          `Pathnames cannot have embedded double slashes - normalizing ${i} -> ${r}`
        );
      }
      r.startsWith("/") ? o = Ra(r.substring(1), "/") : o = Ra(r, t);
    }
  else
    o = t;
  return {
    pathname: o,
    search: hi(a),
    hash: mi(n)
  };
}
function Ra(e, t) {
  let r = t.replace(/\/+$/, "").split("/");
  return e.split("/").forEach((n) => {
    n === ".." ? r.length > 1 && r.pop() : n !== "." && r.push(n);
  }), r.length > 1 ? r.join("/") : "/";
}
function ur(e, t, r, a) {
  return `Cannot include a '${e}' character in a manually specified \`to.${t}\` field [${JSON.stringify(
    a
  )}].  Please separate it out to the \`to.${r}\` field. Alternatively you may provide the full path as a string in <Link to="..."> and the router will parse it for you.`;
}
function sn(e) {
  return e.filter(
    (t, r) => r === 0 || t.route.path && t.route.path.length > 0
  );
}
function Xt(e) {
  let t = sn(e);
  return t.map(
    (r, a) => a === t.length - 1 ? r.pathname : r.pathnameBase
  );
}
function Qt(e, t, r, a = !1) {
  let n;
  typeof e == "string" ? n = Ce(e) : (n = { ...e }, I(
    !n.pathname || !n.pathname.includes("?"),
    ur("?", "pathname", "search", n)
  ), I(
    !n.pathname || !n.pathname.includes("#"),
    ur("#", "pathname", "hash", n)
  ), I(
    !n.search || !n.search.includes("#"),
    ur("#", "search", "hash", n)
  ));
  let o = e === "" || n.pathname === "", i = o ? "/" : n.pathname, l;
  if (i == null)
    l = r;
  else {
    let d = t.length - 1;
    if (!a && i.startsWith("..")) {
      let p = i.split("/");
      for (; p[0] === ".."; )
        p.shift(), d -= 1;
      n.pathname = p.join("/");
    }
    l = d >= 0 ? t[d] : "/";
  }
  let s = di(n, l), u = i && i !== "/" && i.endsWith("/"), h = (o || i === ".") && r.endsWith("/");
  return !s.pathname.endsWith("/") && (u || h) && (s.pathname += "/"), s;
}
var Me = (e) => e.join("/").replace(/\/\/+/g, "/"), fi = (e) => e.replace(/\/+$/, "").replace(/^\/*/, "/"), hi = (e) => !e || e === "?" ? "" : e.startsWith("?") ? e : "?" + e, mi = (e) => !e || e === "#" ? "" : e.startsWith("#") ? e : "#" + e, pi = class {
  constructor(e, t) {
    this.type = "DataWithResponseInit", this.data = e, this.init = t || null;
  }
};
function yi(e, t) {
  return new pi(
    e,
    typeof t == "number" ? { status: t } : t
  );
}
var Nr = (e, t = 302) => {
  let r = t;
  typeof r == "number" ? r = { status: r } : typeof r.status > "u" && (r.status = 302);
  let a = new Headers(r.headers);
  return a.set("Location", e), new Response(null, { ...r, headers: a });
}, Fs = (e, t) => {
  let r = Nr(e, t);
  return r.headers.set("X-Remix-Reload-Document", "true"), r;
}, ks = (e, t) => {
  let r = Nr(e, t);
  return r.headers.set("X-Remix-Replace", "true"), r;
}, Te = class {
  constructor(e, t, r, a = !1) {
    this.status = e, this.statusText = t || "", this.internal = a, r instanceof Error ? (this.data = r.toString(), this.error = r) : this.data = r;
  }
};
function Pe(e) {
  return e != null && typeof e.status == "number" && typeof e.statusText == "string" && typeof e.internal == "boolean" && "data" in e;
}
function _e(e) {
  return e.map((t) => t.route.path).filter(Boolean).join("/").replace(/\/\/*/g, "/") || "/";
}
var un = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u";
function cn(e, t) {
  let r = e;
  if (typeof r != "string" || !ln.test(r))
    return {
      absoluteURL: void 0,
      isExternal: !1,
      to: r
    };
  let a = r, n = !1;
  if (un)
    try {
      let o = new URL(window.location.href), i = r.startsWith("//") ? new URL(o.protocol + r) : new URL(r), l = fe(i.pathname, t);
      i.origin === o.origin && l != null ? r = l + i.search + i.hash : n = !0;
    } catch {
      Q(
        !1,
        `<Link to="${r}"> contains an invalid URL which will probably break when clicked - please update to a valid URL path.`
      );
    }
  return {
    absoluteURL: a,
    isExternal: n,
    to: r
  };
}
var Ue = Symbol("Uninstrumented");
function dn(e, t) {
  let r = {
    lazy: [],
    "lazy.loader": [],
    "lazy.action": [],
    "lazy.middleware": [],
    middleware: [],
    loader: [],
    action: []
  };
  e.forEach(
    (n) => n({
      id: t.id,
      index: t.index,
      path: t.path,
      instrument(o) {
        let i = Object.keys(r);
        for (let l of i)
          o[l] && r[l].push(o[l]);
      }
    })
  );
  let a = {};
  if (typeof t.lazy == "function" && r.lazy.length > 0) {
    let n = Ze(r.lazy, t.lazy, () => {
    });
    n && (a.lazy = n);
  }
  if (typeof t.lazy == "object") {
    let n = t.lazy;
    ["middleware", "loader", "action"].forEach((o) => {
      let i = n[o], l = r[`lazy.${o}`];
      if (typeof i == "function" && l.length > 0) {
        let s = Ze(l, i, () => {
        });
        s && (a.lazy = Object.assign(a.lazy || {}, {
          [o]: s
        }));
      }
    });
  }
  return ["loader", "action"].forEach((n) => {
    let o = t[n];
    if (typeof o == "function" && r[n].length > 0) {
      let i = o[Ue] ?? o, l = Ze(
        r[n],
        i,
        (...s) => Sa(s[0])
      );
      l && (n === "loader" && i.hydrate === !0 && (l.hydrate = !0), l[Ue] = i, a[n] = l);
    }
  }), t.middleware && t.middleware.length > 0 && r.middleware.length > 0 && (a.middleware = t.middleware.map((n) => {
    let o = n[Ue] ?? n, i = Ze(
      r.middleware,
      o,
      (...l) => Sa(l[0])
    );
    return i ? (i[Ue] = o, i) : n;
  })), a;
}
function vi(e, t) {
  let r = {
    navigate: [],
    fetch: []
  };
  if (t.forEach(
    (a) => a({
      instrument(n) {
        let o = Object.keys(n);
        for (let i of o)
          n[i] && r[i].push(n[i]);
      }
    })
  ), r.navigate.length > 0) {
    let a = e.navigate[Ue] ?? e.navigate, n = Ze(
      r.navigate,
      a,
      (...o) => {
        let [i, l] = o;
        return {
          to: typeof i == "number" || typeof i == "string" ? i : i ? ce(i) : ".",
          ...xa(e, l ?? {})
        };
      }
    );
    n && (n[Ue] = a, e.navigate = n);
  }
  if (r.fetch.length > 0) {
    let a = e.fetch[Ue] ?? e.fetch, n = Ze(r.fetch, a, (...o) => {
      let [i, , l, s] = o;
      return {
        href: l ?? ".",
        fetcherKey: i,
        ...xa(e, s ?? {})
      };
    });
    n && (n[Ue] = a, e.fetch = n);
  }
  return e;
}
function _s(e, t) {
  let r = {
    request: []
  };
  t.forEach(
    (n) => n({
      instrument(o) {
        let i = Object.keys(o);
        for (let l of i)
          o[l] && r[l].push(o[l]);
      }
    })
  );
  let a = e;
  return r.request.length > 0 && (a = Ze(r.request, e, (...n) => {
    let [o, i] = n;
    return {
      request: hn(o),
      context: i != null ? mn(i) : i
    };
  })), a;
}
function Ze(e, t, r) {
  return e.length === 0 ? null : async (...a) => {
    let n = await fn(
      e,
      r(...a),
      () => t(...a),
      e.length - 1
    );
    if (n.type === "error")
      throw n.value;
    return n.value;
  };
}
async function fn(e, t, r, a) {
  let n = e[a], o;
  if (n) {
    let i, l = async () => (i ? console.error("You cannot call instrumented handlers more than once") : i = fn(e, t, r, a - 1), o = await i, I(o, "Expected a result"), o.type === "error" && o.value instanceof Error ? { status: "error", error: o.value } : { status: "success", error: void 0 });
    try {
      await n(l, t);
    } catch (s) {
      console.error("An instrumentation function threw an error:", s);
    }
    i || await l(), await i;
  } else
    try {
      o = { type: "success", value: await r() };
    } catch (i) {
      o = { type: "error", value: i };
    }
  return o || {
    type: "error",
    value: new Error("No result assigned in instrumentation chain.")
  };
}
function Sa(e) {
  let { request: t, context: r, params: a, unstable_pattern: n } = e;
  return {
    request: hn(t),
    params: { ...a },
    unstable_pattern: n,
    context: mn(r)
  };
}
function xa(e, t) {
  return {
    currentUrl: ce(e.state.location),
    ..."formMethod" in t ? { formMethod: t.formMethod } : {},
    ..."formEncType" in t ? { formEncType: t.formEncType } : {},
    ..."formData" in t ? { formData: t.formData } : {},
    ..."body" in t ? { body: t.body } : {}
  };
}
function hn(e) {
  return {
    method: e.method,
    url: e.url,
    headers: {
      get: (...t) => e.headers.get(...t)
    }
  };
}
function mn(e) {
  if (wi(e)) {
    let t = { ...e };
    return Object.freeze(t), t;
  } else
    return {
      get: (t) => e.get(t)
    };
}
var gi = Object.getOwnPropertyNames(Object.prototype).sort().join("\0");
function wi(e) {
  if (e === null || typeof e != "object")
    return !1;
  const t = Object.getPrototypeOf(e);
  return t === Object.prototype || t === null || Object.getOwnPropertyNames(t).sort().join("\0") === gi;
}
var pn = [
  "POST",
  "PUT",
  "PATCH",
  "DELETE"
], bi = new Set(
  pn
), Ei = [
  "GET",
  ...pn
], Ri = new Set(Ei), yn = /* @__PURE__ */ new Set([301, 302, 303, 307, 308]), Si = /* @__PURE__ */ new Set([307, 308]), zt = {
  state: "idle",
  location: void 0,
  formMethod: void 0,
  formAction: void 0,
  formEncType: void 0,
  formData: void 0,
  json: void 0,
  text: void 0
}, Fr = {
  state: "idle",
  data: void 0,
  formMethod: void 0,
  formAction: void 0,
  formEncType: void 0,
  formData: void 0,
  json: void 0,
  text: void 0
}, Qe = {
  state: "unblocked",
  proceed: void 0,
  reset: void 0,
  location: void 0
}, vn = (e) => ({
  hasErrorBoundary: !!e.hasErrorBoundary
}), gn = "remix-router-transitions", wn = Symbol("ResetLoaderData");
function kr(e) {
  const t = e.window ? e.window : typeof window < "u" ? window : void 0, r = typeof t < "u" && typeof t.document < "u" && typeof t.document.createElement < "u";
  I(
    e.routes.length > 0,
    "You must provide a non-empty routes array to createRouter"
  );
  let a = e.hydrationRouteProperties || [], n = e.mapRouteProperties || vn, o = n;
  if (e.unstable_instrumentations) {
    let m = e.unstable_instrumentations;
    o = (g) => ({
      ...n(g),
      ...dn(
        m.map((R) => R.route).filter(Boolean),
        g
      )
    });
  }
  let i = {}, l = et(
    e.routes,
    o,
    void 0,
    i
  ), s, u = e.basename || "/";
  u.startsWith("/") || (u = `/${u}`);
  let h = e.dataStrategy || Ti, d = {
    ...e.future
  }, p = null, f = /* @__PURE__ */ new Set(), y = null, w = null, v = null, x = e.hydrationData != null, E = De(l, e.history.location, u), P = !1, L = null, C;
  if (E == null && !e.patchRoutesOnNavigation) {
    let m = ee(404, {
      pathname: e.history.location.pathname
    }), { matches: g, route: R } = lt(l);
    C = !0, E = g, L = { [R.id]: m };
  } else if (E && !e.hydrationData && $t(
    E,
    l,
    e.history.location.pathname
  ).active && (E = null), E)
    if (E.some((m) => m.route.lazy))
      C = !1;
    else if (!E.some((m) => _r(m.route)))
      C = !0;
    else {
      let m = e.hydrationData ? e.hydrationData.loaderData : null, g = e.hydrationData ? e.hydrationData.errors : null;
      if (g) {
        let R = E.findIndex(
          (D) => g[D.route.id] !== void 0
        );
        C = E.slice(0, R + 1).every(
          (D) => !vr(D.route, m, g)
        );
      } else
        C = E.every(
          (R) => !vr(R.route, m, g)
        );
    }
  else {
    C = !1, E = [];
    let m = $t(
      null,
      l,
      e.history.location.pathname
    );
    m.active && m.matches && (P = !0, E = m.matches);
  }
  let S, b = {
    historyAction: e.history.action,
    location: e.history.location,
    matches: E,
    initialized: C,
    navigation: zt,
    // Don't restore on initial updateState() if we were SSR'd
    restoreScrollPosition: e.hydrationData != null ? !1 : null,
    preventScrollReset: !1,
    revalidation: "idle",
    loaderData: e.hydrationData && e.hydrationData.loaderData || {},
    actionData: e.hydrationData && e.hydrationData.actionData || null,
    errors: e.hydrationData && e.hydrationData.errors || L,
    fetchers: /* @__PURE__ */ new Map(),
    blockers: /* @__PURE__ */ new Map()
  }, T = "POP", O = null, j = !1, $, z = !1, V = /* @__PURE__ */ new Map(), Z = null, W = !1, G = !1, we = /* @__PURE__ */ new Set(), K = /* @__PURE__ */ new Map(), te = 0, me = -1, Le = /* @__PURE__ */ new Map(), pe = /* @__PURE__ */ new Set(), be = /* @__PURE__ */ new Map(), Ee = /* @__PURE__ */ new Map(), ye = /* @__PURE__ */ new Set(), Ye = /* @__PURE__ */ new Map(), Mt, pt = null;
  function Lo() {
    if (p = e.history.listen(
      ({ action: m, location: g, delta: R }) => {
        if (Mt) {
          Mt(), Mt = void 0;
          return;
        }
        Q(
          Ye.size === 0 || R != null,
          "You are trying to use a blocker on a POP navigation to a location that was not created by @remix-run/router. This will fail silently in production. This can happen if you are navigating outside the router via `window.history.pushState`/`window.location.hash` instead of using router navigation APIs.  This can also happen if you are using createHashRouter and the user manually changes the URL."
        );
        let D = ha({
          currentLocation: b.location,
          nextLocation: g,
          historyAction: m
        });
        if (D && R != null) {
          let M = new Promise((k) => {
            Mt = k;
          });
          e.history.go(R * -1), Tt(D, {
            state: "blocked",
            location: g,
            proceed() {
              Tt(D, {
                state: "proceeding",
                proceed: void 0,
                reset: void 0,
                location: g
              }), M.then(() => e.history.go(R));
            },
            reset() {
              let k = new Map(b.blockers);
              k.set(D, Qe), ie({ blockers: k });
            }
          }), O?.resolve(), O = null;
          return;
        }
        return Je(m, g);
      }
    ), r) {
      Ai(t, V);
      let m = () => ji(t, V);
      t.addEventListener("pagehide", m), Z = () => t.removeEventListener("pagehide", m);
    }
    return b.initialized || Je("POP", b.location, {
      initialHydration: !0
    }), S;
  }
  function Do() {
    p && p(), Z && Z(), f.clear(), $ && $.abort(), b.fetchers.forEach((m, g) => or(g)), b.blockers.forEach((m, g) => fa(g));
  }
  function Oo(m) {
    return f.add(m), () => f.delete(m);
  }
  function ie(m, g = {}) {
    m.matches && (m.matches = m.matches.map((M) => {
      let k = i[M.route.id], N = M.route;
      return N.element !== k.element || N.errorElement !== k.errorElement || N.hydrateFallbackElement !== k.hydrateFallbackElement ? {
        ...M,
        route: k
      } : M;
    })), b = {
      ...b,
      ...m
    };
    let R = [], D = [];
    b.fetchers.forEach((M, k) => {
      M.state === "idle" && (ye.has(k) ? R.push(k) : D.push(k));
    }), ye.forEach((M) => {
      !b.fetchers.has(M) && !K.has(M) && R.push(M);
    }), [...f].forEach(
      (M) => M(b, {
        deletedFetchers: R,
        newErrors: m.errors ?? null,
        viewTransitionOpts: g.viewTransitionOpts,
        flushSync: g.flushSync === !0
      })
    ), R.forEach((M) => or(M)), D.forEach((M) => b.fetchers.delete(M));
  }
  function at(m, g, { flushSync: R } = {}) {
    let D = b.actionData != null && b.navigation.formMethod != null && oe(b.navigation.formMethod) && b.navigation.state === "loading" && m.state?._isRedirect !== !0, M;
    g.actionData ? Object.keys(g.actionData).length > 0 ? M = g.actionData : M = null : D ? M = b.actionData : M = null;
    let k = g.loaderData ? _a(
      b.loaderData,
      g.loaderData,
      g.matches || [],
      g.errors
    ) : b.loaderData, N = b.blockers;
    N.size > 0 && (N = new Map(N), N.forEach((U, A) => N.set(A, Qe)));
    let F = W ? !1 : pa(m, g.matches || b.matches), _ = j === !0 || b.navigation.formMethod != null && oe(b.navigation.formMethod) && m.state?._isRedirect !== !0;
    s && (l = s, s = void 0), W || T === "POP" || (T === "PUSH" ? e.history.push(m, m.state) : T === "REPLACE" && e.history.replace(m, m.state));
    let H;
    if (T === "POP") {
      let U = V.get(b.location.pathname);
      U && U.has(m.pathname) ? H = {
        currentLocation: b.location,
        nextLocation: m
      } : V.has(m.pathname) && (H = {
        currentLocation: m,
        nextLocation: b.location
      });
    } else if (z) {
      let U = V.get(b.location.pathname);
      U ? U.add(m.pathname) : (U = /* @__PURE__ */ new Set([m.pathname]), V.set(b.location.pathname, U)), H = {
        currentLocation: b.location,
        nextLocation: m
      };
    }
    ie(
      {
        ...g,
        // matches, errors, fetchers go through as-is
        actionData: M,
        loaderData: k,
        historyAction: T,
        location: m,
        initialized: !0,
        navigation: zt,
        revalidation: "idle",
        restoreScrollPosition: F,
        preventScrollReset: _,
        blockers: N
      },
      {
        viewTransitionOpts: H,
        flushSync: R === !0
      }
    ), T = "POP", j = !1, z = !1, W = !1, G = !1, O?.resolve(), O = null, pt?.resolve(), pt = null;
  }
  async function oa(m, g) {
    if (O?.resolve(), O = null, typeof m == "number") {
      O || (O = ja());
      let J = O.promise;
      return e.history.go(m), J;
    }
    let R = yr(
      b.location,
      b.matches,
      u,
      m,
      g?.fromRouteId,
      g?.relative
    ), { path: D, submission: M, error: k } = Ca(
      !1,
      R,
      g
    ), N = b.location, F = Ie(b.location, D, g && g.state);
    F = {
      ...F,
      ...e.history.encodeLocation(F)
    };
    let _ = g && g.replace != null ? g.replace : void 0, H = "PUSH";
    _ === !0 ? H = "REPLACE" : _ === !1 || M != null && oe(M.formMethod) && M.formAction === b.location.pathname + b.location.search && (H = "REPLACE");
    let U = g && "preventScrollReset" in g ? g.preventScrollReset === !0 : void 0, A = (g && g.flushSync) === !0, Y = ha({
      currentLocation: N,
      nextLocation: F,
      historyAction: H
    });
    if (Y) {
      Tt(Y, {
        state: "blocked",
        location: F,
        proceed() {
          Tt(Y, {
            state: "proceeding",
            proceed: void 0,
            reset: void 0,
            location: F
          }), oa(m, g);
        },
        reset() {
          let J = new Map(b.blockers);
          J.set(Y, Qe), ie({ blockers: J });
        }
      });
      return;
    }
    await Je(H, F, {
      submission: M,
      // Send through the formData serialization error if we have one so we can
      // render at the right error boundary after we match routes
      pendingError: k,
      preventScrollReset: U,
      replace: g && g.replace,
      enableViewTransition: g && g.viewTransition,
      flushSync: A,
      callSiteDefaultShouldRevalidate: g && g.unstable_defaultShouldRevalidate
    });
  }
  function Mo() {
    pt || (pt = ja()), nr(), ie({ revalidation: "loading" });
    let m = pt.promise;
    return b.navigation.state === "submitting" ? m : b.navigation.state === "idle" ? (Je(b.historyAction, b.location, {
      startUninterruptedRevalidation: !0
    }), m) : (Je(
      T || b.historyAction,
      b.navigation.location,
      {
        overrideNavigation: b.navigation,
        // Proxy through any rending view transition
        enableViewTransition: z === !0
      }
    ), m);
  }
  async function Je(m, g, R) {
    $ && $.abort(), $ = null, T = m, W = (R && R.startUninterruptedRevalidation) === !0, Uo(b.location, b.matches), j = (R && R.preventScrollReset) === !0, z = (R && R.enableViewTransition) === !0;
    let D = s || l, M = R && R.overrideNavigation, k = R?.initialHydration && b.matches && b.matches.length > 0 && !P ? (
      // `matchRoutes()` has already been called if we're in here via `router.initialize()`
      b.matches
    ) : De(D, g, u), N = (R && R.flushSync) === !0;
    if (k && b.initialized && !G && Ni(b.location, g) && !(R && R.submission && oe(R.submission.formMethod))) {
      at(g, { matches: k }, { flushSync: N });
      return;
    }
    let F = $t(k, D, g.pathname);
    if (F.active && F.matches && (k = F.matches), !k) {
      let { error: re, notFoundMatches: de, route: X } = ir(
        g.pathname
      );
      at(
        g,
        {
          matches: de,
          loaderData: {},
          errors: {
            [X.id]: re
          }
        },
        { flushSync: N }
      );
      return;
    }
    $ = new AbortController();
    let _ = ot(
      e.history,
      g,
      $.signal,
      R && R.submission
    ), H = e.getContext ? await e.getContext() : new it(), U;
    if (R && R.pendingError)
      U = [
        xe(k).route.id,
        { type: "error", error: R.pendingError }
      ];
    else if (R && R.submission && oe(R.submission.formMethod)) {
      let re = await To(
        _,
        g,
        R.submission,
        k,
        H,
        F.active,
        R && R.initialHydration === !0,
        { replace: R.replace, flushSync: N }
      );
      if (re.shortCircuited)
        return;
      if (re.pendingActionResult) {
        let [de, X] = re.pendingActionResult;
        if (ae(X) && Pe(X.error) && X.error.status === 404) {
          $ = null, at(g, {
            matches: re.matches,
            loaderData: {},
            errors: {
              [de]: X.error
            }
          });
          return;
        }
      }
      k = re.matches || k, U = re.pendingActionResult, M = cr(g, R.submission), N = !1, F.active = !1, _ = ot(
        e.history,
        _.url,
        _.signal
      );
    }
    let {
      shortCircuited: A,
      matches: Y,
      loaderData: J,
      errors: ne
    } = await $o(
      _,
      g,
      k,
      H,
      F.active,
      M,
      R && R.submission,
      R && R.fetcherSubmission,
      R && R.replace,
      R && R.initialHydration === !0,
      N,
      U,
      R && R.callSiteDefaultShouldRevalidate
    );
    A || ($ = null, at(g, {
      matches: Y || k,
      ...Ia(U),
      loaderData: J,
      errors: ne
    }));
  }
  async function To(m, g, R, D, M, k, N, F = {}) {
    nr();
    let _ = _i(g, R);
    if (ie({ navigation: _ }, { flushSync: F.flushSync === !0 }), k) {
      let A = await Nt(
        D,
        g.pathname,
        m.signal
      );
      if (A.type === "aborted")
        return { shortCircuited: !0 };
      if (A.type === "error") {
        if (A.partialMatches.length === 0) {
          let { matches: J, route: ne } = lt(l);
          return {
            matches: J,
            pendingActionResult: [
              ne.id,
              {
                type: "error",
                error: A.error
              }
            ]
          };
        }
        let Y = xe(A.partialMatches).route.id;
        return {
          matches: A.partialMatches,
          pendingActionResult: [
            Y,
            {
              type: "error",
              error: A.error
            }
          ]
        };
      } else if (A.matches)
        D = A.matches;
      else {
        let { notFoundMatches: Y, error: J, route: ne } = ir(
          g.pathname
        );
        return {
          matches: Y,
          pendingActionResult: [
            ne.id,
            {
              type: "error",
              error: J
            }
          ]
        };
      }
    }
    let H, U = st(D, g);
    if (!U.route.action && !U.route.lazy)
      H = {
        type: "error",
        error: ee(405, {
          method: m.method,
          pathname: g.pathname,
          routeId: U.route.id
        })
      };
    else {
      let A = Be(
        o,
        i,
        m,
        D,
        U,
        N ? [] : a,
        M
      ), Y = await yt(
        m,
        A,
        M,
        null
      );
      if (H = Y[U.route.id], !H) {
        for (let J of D)
          if (Y[J.route.id]) {
            H = Y[J.route.id];
            break;
          }
      }
      if (m.signal.aborted)
        return { shortCircuited: !0 };
    }
    if (ze(H)) {
      let A;
      return F && F.replace != null ? A = F.replace : A = Na(
        H.response.headers.get("Location"),
        new URL(m.url),
        u,
        e.history
      ) === b.location.pathname + b.location.search, await Ve(m, H, !0, {
        submission: R,
        replace: A
      }), { shortCircuited: !0 };
    }
    if (ae(H)) {
      let A = xe(D, U.route.id);
      return (F && F.replace) !== !0 && (T = "PUSH"), {
        matches: D,
        pendingActionResult: [
          A.route.id,
          H,
          U.route.id
        ]
      };
    }
    return {
      matches: D,
      pendingActionResult: [U.route.id, H]
    };
  }
  async function $o(m, g, R, D, M, k, N, F, _, H, U, A, Y) {
    let J = k || cr(g, N), ne = N || F || Aa(J), re = !W && !H;
    if (M) {
      if (re) {
        let le = ia(A);
        ie(
          {
            navigation: J,
            ...le !== void 0 ? { actionData: le } : {}
          },
          {
            flushSync: U
          }
        );
      }
      let B = await Nt(
        R,
        g.pathname,
        m.signal
      );
      if (B.type === "aborted")
        return { shortCircuited: !0 };
      if (B.type === "error") {
        if (B.partialMatches.length === 0) {
          let { matches: nt, route: Xe } = lt(l);
          return {
            matches: nt,
            loaderData: {},
            errors: {
              [Xe.id]: B.error
            }
          };
        }
        let le = xe(B.partialMatches).route.id;
        return {
          matches: B.partialMatches,
          loaderData: {},
          errors: {
            [le]: B.error
          }
        };
      } else if (B.matches)
        R = B.matches;
      else {
        let { error: le, notFoundMatches: nt, route: Xe } = ir(
          g.pathname
        );
        return {
          matches: nt,
          loaderData: {},
          errors: {
            [Xe.id]: le
          }
        };
      }
    }
    let de = s || l, { dsMatches: X, revalidatingFetchers: Re } = La(
      m,
      D,
      o,
      i,
      e.history,
      b,
      R,
      ne,
      g,
      H ? [] : a,
      H === !0,
      G,
      we,
      ye,
      be,
      pe,
      de,
      u,
      e.patchRoutesOnNavigation != null,
      A,
      Y
    );
    if (me = ++te, !e.dataStrategy && !X.some((B) => B.shouldLoad) && !X.some(
      (B) => B.route.middleware && B.route.middleware.length > 0
    ) && Re.length === 0) {
      let B = ca();
      return at(
        g,
        {
          matches: R,
          loaderData: {},
          // Commit pending error if we're short circuiting
          errors: A && ae(A[1]) ? { [A[0]]: A[1].error } : null,
          ...Ia(A),
          ...B ? { fetchers: new Map(b.fetchers) } : {}
        },
        { flushSync: U }
      ), { shortCircuited: !0 };
    }
    if (re) {
      let B = {};
      if (!M) {
        B.navigation = J;
        let le = ia(A);
        le !== void 0 && (B.actionData = le);
      }
      Re.length > 0 && (B.fetchers = No(Re)), ie(B, { flushSync: U });
    }
    Re.forEach((B) => {
      Fe(B.key), B.controller && K.set(B.key, B.controller);
    });
    let Ke = () => Re.forEach((B) => Fe(B.key));
    $ && $.signal.addEventListener(
      "abort",
      Ke
    );
    let { loaderResults: vt, fetcherResults: He } = await la(
      X,
      Re,
      m,
      D
    );
    if (m.signal.aborted)
      return { shortCircuited: !0 };
    $ && $.signal.removeEventListener(
      "abort",
      Ke
    ), Re.forEach((B) => K.delete(B.key));
    let Oe = It(vt);
    if (Oe)
      return await Ve(m, Oe.result, !0, {
        replace: _
      }), { shortCircuited: !0 };
    if (Oe = It(He), Oe)
      return pe.add(Oe.key), await Ve(m, Oe.result, !0, {
        replace: _
      }), { shortCircuited: !0 };
    let { loaderData: lr, errors: gt } = ka(
      b,
      R,
      vt,
      A,
      Re,
      He
    );
    H && b.errors && (gt = { ...b.errors, ...gt });
    let Ge = ca(), Ft = da(me), kt = Ge || Ft || Re.length > 0;
    return {
      matches: R,
      loaderData: lr,
      errors: gt,
      ...kt ? { fetchers: new Map(b.fetchers) } : {}
    };
  }
  function ia(m) {
    if (m && !ae(m[1]))
      return {
        [m[0]]: m[1].data
      };
    if (b.actionData)
      return Object.keys(b.actionData).length === 0 ? null : b.actionData;
  }
  function No(m) {
    return m.forEach((g) => {
      let R = b.fetchers.get(g.key), D = wt(
        void 0,
        R ? R.data : void 0
      );
      b.fetchers.set(g.key, D);
    }), new Map(b.fetchers);
  }
  async function Fo(m, g, R, D) {
    Fe(m);
    let M = (D && D.flushSync) === !0, k = s || l, N = yr(
      b.location,
      b.matches,
      u,
      R,
      g,
      D?.relative
    ), F = De(k, N, u), _ = $t(F, k, N);
    if (_.active && _.matches && (F = _.matches), !F) {
      Ne(
        m,
        g,
        ee(404, { pathname: N }),
        { flushSync: M }
      );
      return;
    }
    let { path: H, submission: U, error: A } = Ca(
      !0,
      N,
      D
    );
    if (A) {
      Ne(m, g, A, { flushSync: M });
      return;
    }
    let Y = e.getContext ? await e.getContext() : new it(), J = (D && D.preventScrollReset) === !0;
    if (U && oe(U.formMethod)) {
      await ko(
        m,
        g,
        H,
        F,
        Y,
        _.active,
        M,
        J,
        U,
        D && D.unstable_defaultShouldRevalidate
      );
      return;
    }
    be.set(m, { routeId: g, path: H }), await _o(
      m,
      g,
      H,
      F,
      Y,
      _.active,
      M,
      J,
      U
    );
  }
  async function ko(m, g, R, D, M, k, N, F, _, H) {
    nr(), be.delete(m);
    let U = b.fetchers.get(m);
    $e(m, Ii(_, U), {
      flushSync: N
    });
    let A = new AbortController(), Y = ot(
      e.history,
      R,
      A.signal,
      _
    );
    if (k) {
      let q = await Nt(
        D,
        new URL(Y.url).pathname,
        Y.signal,
        m
      );
      if (q.type === "aborted")
        return;
      if (q.type === "error") {
        Ne(m, g, q.error, { flushSync: N });
        return;
      } else if (q.matches)
        D = q.matches;
      else {
        Ne(
          m,
          g,
          ee(404, { pathname: R }),
          { flushSync: N }
        );
        return;
      }
    }
    let J = st(D, R);
    if (!J.route.action && !J.route.lazy) {
      let q = ee(405, {
        method: _.formMethod,
        pathname: R,
        routeId: g
      });
      Ne(m, g, q, { flushSync: N });
      return;
    }
    K.set(m, A);
    let ne = te, re = Be(
      o,
      i,
      Y,
      D,
      J,
      a,
      M
    ), de = await yt(
      Y,
      re,
      M,
      m
    ), X = de[J.route.id];
    if (!X) {
      for (let q of re)
        if (de[q.route.id]) {
          X = de[q.route.id];
          break;
        }
    }
    if (Y.signal.aborted) {
      K.get(m) === A && K.delete(m);
      return;
    }
    if (ye.has(m)) {
      if (ze(X) || ae(X)) {
        $e(m, ke(void 0));
        return;
      }
    } else {
      if (ze(X))
        if (K.delete(m), me > ne) {
          $e(m, ke(void 0));
          return;
        } else
          return pe.add(m), $e(m, wt(_)), Ve(Y, X, !1, {
            fetcherSubmission: _,
            preventScrollReset: F
          });
      if (ae(X)) {
        Ne(m, g, X.error);
        return;
      }
    }
    let Re = b.navigation.location || b.location, Ke = ot(
      e.history,
      Re,
      A.signal
    ), vt = s || l, He = b.navigation.state !== "idle" ? De(vt, b.navigation.location, u) : b.matches;
    I(He, "Didn't find any matches after fetcher action");
    let Oe = ++te;
    Le.set(m, Oe);
    let lr = wt(_, X.data);
    b.fetchers.set(m, lr);
    let { dsMatches: gt, revalidatingFetchers: Ge } = La(
      Ke,
      M,
      o,
      i,
      e.history,
      b,
      He,
      _,
      Re,
      a,
      !1,
      G,
      we,
      ye,
      be,
      pe,
      vt,
      u,
      e.patchRoutesOnNavigation != null,
      [J.route.id, X],
      H
    );
    Ge.filter((q) => q.key !== m).forEach((q) => {
      let _t = q.key, va = b.fetchers.get(_t), Wo = wt(
        void 0,
        va ? va.data : void 0
      );
      b.fetchers.set(_t, Wo), Fe(_t), q.controller && K.set(_t, q.controller);
    }), ie({ fetchers: new Map(b.fetchers) });
    let Ft = () => Ge.forEach((q) => Fe(q.key));
    A.signal.addEventListener(
      "abort",
      Ft
    );
    let { loaderResults: kt, fetcherResults: B } = await la(
      gt,
      Ge,
      Ke,
      M
    );
    if (A.signal.aborted)
      return;
    if (A.signal.removeEventListener(
      "abort",
      Ft
    ), Le.delete(m), K.delete(m), Ge.forEach((q) => K.delete(q.key)), b.fetchers.has(m)) {
      let q = ke(X.data);
      b.fetchers.set(m, q);
    }
    let le = It(kt);
    if (le)
      return Ve(
        Ke,
        le.result,
        !1,
        { preventScrollReset: F }
      );
    if (le = It(B), le)
      return pe.add(le.key), Ve(
        Ke,
        le.result,
        !1,
        { preventScrollReset: F }
      );
    let { loaderData: nt, errors: Xe } = ka(
      b,
      He,
      kt,
      void 0,
      Ge,
      B
    );
    da(Oe), b.navigation.state === "loading" && Oe > me ? (I(T, "Expected pending action"), $ && $.abort(), at(b.navigation.location, {
      matches: He,
      loaderData: nt,
      errors: Xe,
      fetchers: new Map(b.fetchers)
    })) : (ie({
      errors: Xe,
      loaderData: _a(
        b.loaderData,
        nt,
        He,
        Xe
      ),
      fetchers: new Map(b.fetchers)
    }), G = !1);
  }
  async function _o(m, g, R, D, M, k, N, F, _) {
    let H = b.fetchers.get(m);
    $e(
      m,
      wt(
        _,
        H ? H.data : void 0
      ),
      { flushSync: N }
    );
    let U = new AbortController(), A = ot(
      e.history,
      R,
      U.signal
    );
    if (k) {
      let X = await Nt(
        D,
        new URL(A.url).pathname,
        A.signal,
        m
      );
      if (X.type === "aborted")
        return;
      if (X.type === "error") {
        Ne(m, g, X.error, { flushSync: N });
        return;
      } else if (X.matches)
        D = X.matches;
      else {
        Ne(
          m,
          g,
          ee(404, { pathname: R }),
          { flushSync: N }
        );
        return;
      }
    }
    let Y = st(D, R);
    K.set(m, U);
    let J = te, ne = Be(
      o,
      i,
      A,
      D,
      Y,
      a,
      M
    ), de = (await yt(
      A,
      ne,
      M,
      m
    ))[Y.route.id];
    if (K.get(m) === U && K.delete(m), !A.signal.aborted) {
      if (ye.has(m)) {
        $e(m, ke(void 0));
        return;
      }
      if (ze(de))
        if (me > J) {
          $e(m, ke(void 0));
          return;
        } else {
          pe.add(m), await Ve(A, de, !1, {
            preventScrollReset: F
          });
          return;
        }
      if (ae(de)) {
        Ne(m, g, de.error);
        return;
      }
      $e(m, ke(de.data));
    }
  }
  async function Ve(m, g, R, {
    submission: D,
    fetcherSubmission: M,
    preventScrollReset: k,
    replace: N
  } = {}) {
    R || (O?.resolve(), O = null), g.response.headers.has("X-Remix-Revalidate") && (G = !0);
    let F = g.response.headers.get("Location");
    I(F, "Expected a Location header on the redirect Response"), F = Na(
      F,
      new URL(m.url),
      u,
      e.history
    );
    let _ = Ie(b.location, F, {
      _isRedirect: !0
    });
    if (r) {
      let ne = !1;
      if (g.response.headers.has("X-Remix-Reload-Document"))
        ne = !0;
      else if (Gt(F)) {
        const re = en(F, !0);
        ne = // Hard reload if it's an absolute URL to a new origin
        re.origin !== t.location.origin || // Hard reload if it's an absolute URL that does not match our basename
        fe(re.pathname, u) == null;
      }
      if (ne) {
        N ? t.location.replace(F) : t.location.assign(F);
        return;
      }
    }
    $ = null;
    let H = N === !0 || g.response.headers.has("X-Remix-Replace") ? "REPLACE" : "PUSH", { formMethod: U, formAction: A, formEncType: Y } = b.navigation;
    !D && !M && U && A && Y && (D = Aa(b.navigation));
    let J = D || M;
    if (Si.has(g.response.status) && J && oe(J.formMethod))
      await Je(H, _, {
        submission: {
          ...J,
          formAction: F
        },
        // Preserve these flags across redirects
        preventScrollReset: k || j,
        enableViewTransition: R ? z : void 0
      });
    else {
      let ne = cr(
        _,
        D
      );
      await Je(H, _, {
        overrideNavigation: ne,
        // Send fetcher submissions through for shouldRevalidate
        fetcherSubmission: M,
        // Preserve these flags across redirects
        preventScrollReset: k || j,
        enableViewTransition: R ? z : void 0
      });
    }
  }
  async function yt(m, g, R, D) {
    let M, k = {};
    try {
      M = await Pn(
        h,
        m,
        g,
        D,
        R,
        !1
      );
    } catch (N) {
      return g.filter((F) => F.shouldLoad).forEach((F) => {
        k[F.route.id] = {
          type: "error",
          error: N
        };
      }), k;
    }
    if (m.signal.aborted)
      return k;
    if (!oe(m.method))
      for (let N of g) {
        if (M[N.route.id]?.type === "error")
          break;
        !M.hasOwnProperty(N.route.id) && !b.loaderData.hasOwnProperty(N.route.id) && (!b.errors || !b.errors.hasOwnProperty(N.route.id)) && N.shouldCallHandler() && (M[N.route.id] = {
          type: "error",
          result: new Error(
            `No result returned from dataStrategy for route ${N.route.id}`
          )
        });
      }
    for (let [N, F] of Object.entries(M))
      if (Nn(F)) {
        let _ = F.result;
        k[N] = {
          type: "redirect",
          response: Dn(
            _,
            m,
            N,
            g,
            u
          )
        };
      } else
        k[N] = await Ln(F);
    return k;
  }
  async function la(m, g, R, D) {
    let M = yt(
      R,
      m,
      D,
      null
    ), k = Promise.all(
      g.map(async (_) => {
        if (_.matches && _.match && _.request && _.controller) {
          let U = (await yt(
            _.request,
            _.matches,
            D,
            _.key
          ))[_.match.route.id];
          return { [_.key]: U };
        } else
          return Promise.resolve({
            [_.key]: {
              type: "error",
              error: ee(404, {
                pathname: _.path
              })
            }
          });
      })
    ), N = await M, F = (await k).reduce(
      (_, H) => Object.assign(_, H),
      {}
    );
    return {
      loaderResults: N,
      fetcherResults: F
    };
  }
  function nr() {
    G = !0, be.forEach((m, g) => {
      K.has(g) && we.add(g), Fe(g);
    });
  }
  function $e(m, g, R = {}) {
    b.fetchers.set(m, g), ie(
      { fetchers: new Map(b.fetchers) },
      { flushSync: (R && R.flushSync) === !0 }
    );
  }
  function Ne(m, g, R, D = {}) {
    let M = xe(b.matches, g);
    or(m), ie(
      {
        errors: {
          [M.route.id]: R
        },
        fetchers: new Map(b.fetchers)
      },
      { flushSync: (D && D.flushSync) === !0 }
    );
  }
  function sa(m) {
    return Ee.set(m, (Ee.get(m) || 0) + 1), ye.has(m) && ye.delete(m), b.fetchers.get(m) || Fr;
  }
  function Io(m, g) {
    Fe(m, g?.reason), $e(m, ke(null));
  }
  function or(m) {
    let g = b.fetchers.get(m);
    K.has(m) && !(g && g.state === "loading" && Le.has(m)) && Fe(m), be.delete(m), Le.delete(m), pe.delete(m), ye.delete(m), we.delete(m), b.fetchers.delete(m);
  }
  function Ao(m) {
    let g = (Ee.get(m) || 0) - 1;
    g <= 0 ? (Ee.delete(m), ye.add(m)) : Ee.set(m, g), ie({ fetchers: new Map(b.fetchers) });
  }
  function Fe(m, g) {
    let R = K.get(m);
    R && (R.abort(g), K.delete(m));
  }
  function ua(m) {
    for (let g of m) {
      let R = sa(g), D = ke(R.data);
      b.fetchers.set(g, D);
    }
  }
  function ca() {
    let m = [], g = !1;
    for (let R of pe) {
      let D = b.fetchers.get(R);
      I(D, `Expected fetcher: ${R}`), D.state === "loading" && (pe.delete(R), m.push(R), g = !0);
    }
    return ua(m), g;
  }
  function da(m) {
    let g = [];
    for (let [R, D] of Le)
      if (D < m) {
        let M = b.fetchers.get(R);
        I(M, `Expected fetcher: ${R}`), M.state === "loading" && (Fe(R), Le.delete(R), g.push(R));
      }
    return ua(g), g.length > 0;
  }
  function jo(m, g) {
    let R = b.blockers.get(m) || Qe;
    return Ye.get(m) !== g && Ye.set(m, g), R;
  }
  function fa(m) {
    b.blockers.delete(m), Ye.delete(m);
  }
  function Tt(m, g) {
    let R = b.blockers.get(m) || Qe;
    I(
      R.state === "unblocked" && g.state === "blocked" || R.state === "blocked" && g.state === "blocked" || R.state === "blocked" && g.state === "proceeding" || R.state === "blocked" && g.state === "unblocked" || R.state === "proceeding" && g.state === "unblocked",
      `Invalid blocker state transition: ${R.state} -> ${g.state}`
    );
    let D = new Map(b.blockers);
    D.set(m, g), ie({ blockers: D });
  }
  function ha({
    currentLocation: m,
    nextLocation: g,
    historyAction: R
  }) {
    if (Ye.size === 0)
      return;
    Ye.size > 1 && Q(!1, "A router only supports one blocker at a time");
    let D = Array.from(Ye.entries()), [M, k] = D[D.length - 1], N = b.blockers.get(M);
    if (!(N && N.state === "proceeding") && k({ currentLocation: m, nextLocation: g, historyAction: R }))
      return M;
  }
  function ir(m) {
    let g = ee(404, { pathname: m }), R = s || l, { matches: D, route: M } = lt(R);
    return { notFoundMatches: D, route: M, error: g };
  }
  function Ho(m, g, R) {
    if (y = m, v = g, w = R || null, !x && b.navigation === zt) {
      x = !0;
      let D = pa(b.location, b.matches);
      D != null && ie({ restoreScrollPosition: D });
    }
    return () => {
      y = null, v = null, w = null;
    };
  }
  function ma(m, g) {
    return w && w(
      m,
      g.map((D) => tn(D, b.loaderData))
    ) || m.key;
  }
  function Uo(m, g) {
    if (y && v) {
      let R = ma(m, g);
      y[R] = v();
    }
  }
  function pa(m, g) {
    if (y) {
      let R = ma(m, g), D = y[R];
      if (typeof D == "number")
        return D;
    }
    return null;
  }
  function $t(m, g, R) {
    if (e.patchRoutesOnNavigation)
      if (m) {
        if (Object.keys(m[0].params).length > 0)
          return { active: !0, matches: Rt(
            g,
            R,
            u,
            !0
          ) };
      } else
        return { active: !0, matches: Rt(
          g,
          R,
          u,
          !0
        ) || [] };
    return { active: !1, matches: null };
  }
  async function Nt(m, g, R, D) {
    if (!e.patchRoutesOnNavigation)
      return { type: "success", matches: m };
    let M = m;
    for (; ; ) {
      let k = s == null, N = s || l, F = i;
      try {
        await e.patchRoutesOnNavigation({
          signal: R,
          path: g,
          matches: M,
          fetcherKey: D,
          patch: (U, A) => {
            R.aborted || Da(
              U,
              A,
              N,
              F,
              o,
              !1
            );
          }
        });
      } catch (U) {
        return { type: "error", error: U, partialMatches: M };
      } finally {
        k && !R.aborted && (l = [...l]);
      }
      if (R.aborted)
        return { type: "aborted" };
      let _ = De(N, g, u), H = null;
      if (_) {
        if (Object.keys(_[0].params).length === 0)
          return { type: "success", matches: _ };
        if (H = Rt(
          N,
          g,
          u,
          !0
        ), !(H && M.length < H.length && ya(
          M,
          H.slice(0, M.length)
        )))
          return { type: "success", matches: _ };
      }
      if (H || (H = Rt(
        N,
        g,
        u,
        !0
      )), !H || ya(M, H))
        return { type: "success", matches: null };
      M = H;
    }
  }
  function ya(m, g) {
    return m.length === g.length && m.every((R, D) => R.route.id === g[D].route.id);
  }
  function zo(m) {
    i = {}, s = et(
      m,
      o,
      void 0,
      i
    );
  }
  function Bo(m, g, R = !1) {
    let D = s == null;
    Da(
      m,
      g,
      s || l,
      i,
      o,
      R
    ), D && (l = [...l], ie({}));
  }
  return S = {
    get basename() {
      return u;
    },
    get future() {
      return d;
    },
    get state() {
      return b;
    },
    get routes() {
      return l;
    },
    get window() {
      return t;
    },
    initialize: Lo,
    subscribe: Oo,
    enableScrollRestoration: Ho,
    navigate: oa,
    fetch: Fo,
    revalidate: Mo,
    // Passthrough to history-aware createHref used by useHref so we get proper
    // hash-aware URLs in DOM paths
    createHref: (m) => e.history.createHref(m),
    encodeLocation: (m) => e.history.encodeLocation(m),
    getFetcher: sa,
    resetFetcher: Io,
    deleteFetcher: Ao,
    dispose: Do,
    getBlocker: jo,
    deleteBlocker: fa,
    patchRoutes: Bo,
    _internalFetchControllers: K,
    // TODO: Remove setRoutes, it's temporary to avoid dealing with
    // updating the tree while validating the update algorithm.
    _internalSetRoutes: zo,
    _internalSetStateDoNotUseOrYouWillBreakYourApp(m) {
      ie(m);
    }
  }, e.unstable_instrumentations && (S = vi(
    S,
    e.unstable_instrumentations.map((m) => m.router).filter(Boolean)
  )), S;
}
function xi(e, t) {
  I(
    e.length > 0,
    "You must provide a non-empty routes array to createStaticHandler"
  );
  let r = {}, a = (t ? t.basename : null) || "/", n = t?.mapRouteProperties || vn, o = n;
  if (t?.unstable_instrumentations) {
    let f = t.unstable_instrumentations;
    o = (y) => ({
      ...n(y),
      ...dn(
        f.map((w) => w.route).filter(Boolean),
        y
      )
    });
  }
  let i = et(
    e,
    o,
    void 0,
    r
  );
  async function l(f, {
    requestContext: y,
    filterMatchesToLoad: w,
    skipLoaderErrorBubbling: v,
    skipRevalidation: x,
    dataStrategy: E,
    generateMiddlewareResponse: P
  } = {}) {
    let L = new URL(f.url), C = f.method, S = Ie("", ce(L), null, "default"), b = De(i, S, a);
    if (y = y ?? new it(), !Rr(C) && C !== "HEAD") {
      let O = ee(405, { method: C }), { matches: j, route: $ } = lt(i), z = {
        basename: a,
        location: S,
        matches: j,
        loaderData: {},
        actionData: null,
        errors: {
          [$.id]: O
        },
        statusCode: O.status,
        loaderHeaders: {},
        actionHeaders: {}
      };
      return P ? P(() => Promise.resolve(z)) : z;
    } else if (!b) {
      let O = ee(404, { pathname: S.pathname }), { matches: j, route: $ } = lt(i), z = {
        basename: a,
        location: S,
        matches: j,
        loaderData: {},
        actionData: null,
        errors: {
          [$.id]: O
        },
        statusCode: O.status,
        loaderHeaders: {},
        actionHeaders: {}
      };
      return P ? P(() => Promise.resolve(z)) : z;
    }
    if (P) {
      I(
        y instanceof it,
        "When using middleware in `staticHandler.query()`, any provided `requestContext` must be an instance of `RouterContextProvider`"
      );
      try {
        await Ta(
          b,
          r,
          o
        );
        let O, j = await $a(
          {
            request: f,
            unstable_pattern: _e(b),
            matches: b,
            params: b[0].params,
            // If we're calling middleware then it must be enabled so we can cast
            // this to the proper type knowing it's not an `AppLoadContext`
            context: y
          },
          async () => await P(
            async (z, V = {}) => {
              let Z = await u(
                z,
                S,
                b,
                y,
                E || null,
                v === !0,
                null,
                "filterMatchesToLoad" in V ? V.filterMatchesToLoad ?? null : w ?? null,
                x === !0
              );
              return se(Z) ? Z : (O = { location: S, basename: a, ...Z }, O);
            }
          ),
          async ($, z) => {
            if (Er($))
              return $;
            if (se($))
              try {
                $ = new Te(
                  $.status,
                  $.statusText,
                  await Cn($)
                );
              } catch (V) {
                $ = V;
              }
            if (qe($) && ($ = Tn($)), O) {
              z in O.loaderData && (O.loaderData[z] = void 0);
              let V = Pi(
                i,
                O,
                $,
                v ? z : xe(b, z).route.id
              );
              return P(
                () => Promise.resolve(V)
              );
            } else {
              let V = v ? z : xe(
                b,
                b.find(
                  (W) => W.route.id === z || W.route.loader
                )?.route.id || z
              ).route.id, Z = {
                matches: b,
                location: S,
                basename: a,
                loaderData: {},
                actionData: null,
                errors: {
                  [V]: $
                },
                statusCode: Pe($) ? $.status : 500,
                actionHeaders: {},
                loaderHeaders: {}
              };
              return P(
                () => Promise.resolve(Z)
              );
            }
          }
        );
        return I(se(j), "Expected a response in query()"), j;
      } catch (O) {
        if (se(O))
          return O;
        throw O;
      }
    }
    let T = await u(
      f,
      S,
      b,
      y,
      E || null,
      v === !0,
      null,
      w || null,
      x === !0
    );
    return se(T) ? T : { location: S, basename: a, ...T };
  }
  async function s(f, {
    routeId: y,
    requestContext: w,
    dataStrategy: v,
    generateMiddlewareResponse: x
  } = {}) {
    let E = new URL(f.url), P = f.method, L = Ie("", ce(E), null, "default"), C = De(i, L, a);
    if (w = w ?? new it(), !Rr(P) && P !== "HEAD" && P !== "OPTIONS")
      throw ee(405, { method: P });
    if (!C)
      throw ee(404, { pathname: L.pathname });
    let S = y ? C.find((O) => O.route.id === y) : st(C, L);
    if (y && !S)
      throw ee(403, {
        pathname: L.pathname,
        routeId: y
      });
    if (!S)
      throw ee(404, { pathname: L.pathname });
    if (x)
      return I(
        w instanceof it,
        "When using middleware in `staticHandler.queryRoute()`, any provided `requestContext` must be an instance of `RouterContextProvider`"
      ), await Ta(C, r, o), await $a(
        {
          request: f,
          unstable_pattern: _e(C),
          matches: C,
          params: C[0].params,
          // If we're calling middleware then it must be enabled so we can cast
          // this to the proper type knowing it's not an `AppLoadContext`
          context: w
        },
        async () => await x(
          async ($) => {
            let z = await u(
              $,
              L,
              C,
              w,
              v || null,
              !1,
              S,
              null,
              !1
            ), V = T(z);
            return se(V) ? V : typeof V == "string" ? new Response(V) : Response.json(V);
          }
        ),
        (j) => {
          if (qe(j))
            return Promise.resolve(br(j));
          if (se(j))
            return Promise.resolve(j);
          throw j;
        }
      );
    let b = await u(
      f,
      L,
      C,
      w,
      v || null,
      !1,
      S,
      null,
      !1
    );
    return T(b);
    function T(O) {
      if (se(O))
        return O;
      let j = O.errors ? Object.values(O.errors)[0] : void 0;
      if (j !== void 0)
        throw j;
      if (O.actionData)
        return Object.values(O.actionData)[0];
      if (O.loaderData)
        return Object.values(O.loaderData)[0];
    }
  }
  async function u(f, y, w, v, x, E, P, L, C) {
    I(
      f.signal,
      "query()/queryRoute() requests must contain an AbortController signal"
    );
    try {
      if (oe(f.method))
        return await h(
          f,
          w,
          P || st(w, y),
          v,
          x,
          E,
          P != null,
          L,
          C
        );
      let S = await d(
        f,
        w,
        v,
        x,
        E,
        P,
        L
      );
      return se(S) ? S : {
        ...S,
        actionData: null,
        actionHeaders: {}
      };
    } catch (S) {
      if ($n(S) && se(S.result)) {
        if (S.type === "error")
          throw S.result;
        return S.result;
      }
      if (Er(S))
        return S;
      throw S;
    }
  }
  async function h(f, y, w, v, x, E, P, L, C) {
    let S;
    if (!w.route.action && !w.route.lazy) {
      let O = ee(405, {
        method: f.method,
        pathname: new URL(f.url).pathname,
        routeId: w.route.id
      });
      if (P)
        throw O;
      S = {
        type: "error",
        error: O
      };
    } else {
      let O = Be(
        o,
        r,
        f,
        y,
        w,
        [],
        v
      );
      S = (await p(
        f,
        O,
        P,
        v,
        x
      ))[w.route.id], f.signal.aborted && Pa(f, P);
    }
    if (ze(S))
      throw new Response(null, {
        status: S.response.status,
        headers: {
          Location: S.response.headers.get("Location")
        }
      });
    if (P) {
      if (ae(S))
        throw S.error;
      return {
        matches: [w],
        loaderData: {},
        actionData: { [w.route.id]: S.data },
        errors: null,
        // Note: statusCode + headers are unused here since queryRoute will
        // return the raw Response or value
        statusCode: 200,
        loaderHeaders: {},
        actionHeaders: {}
      };
    }
    if (C)
      if (ae(S)) {
        let O = E ? w : xe(y, w.route.id);
        return {
          statusCode: Pe(S.error) ? S.error.status : S.statusCode != null ? S.statusCode : 500,
          actionData: null,
          actionHeaders: {
            ...S.headers ? { [w.route.id]: S.headers } : {}
          },
          matches: y,
          loaderData: {},
          errors: {
            [O.route.id]: S.error
          },
          loaderHeaders: {}
        };
      } else
        return {
          actionData: {
            [w.route.id]: S.data
          },
          actionHeaders: S.headers ? { [w.route.id]: S.headers } : {},
          matches: y,
          loaderData: {},
          errors: null,
          statusCode: S.statusCode || 200,
          loaderHeaders: {}
        };
    let b = new Request(f.url, {
      headers: f.headers,
      redirect: f.redirect,
      signal: f.signal
    });
    if (ae(S)) {
      let O = E ? w : xe(y, w.route.id);
      return {
        ...await d(
          b,
          y,
          v,
          x,
          E,
          null,
          L,
          [O.route.id, S]
        ),
        statusCode: Pe(S.error) ? S.error.status : S.statusCode != null ? S.statusCode : 500,
        actionData: null,
        actionHeaders: {
          ...S.headers ? { [w.route.id]: S.headers } : {}
        }
      };
    }
    return {
      ...await d(
        b,
        y,
        v,
        x,
        E,
        null,
        L
      ),
      actionData: {
        [w.route.id]: S.data
      },
      // action status codes take precedence over loader status codes
      ...S.statusCode ? { statusCode: S.statusCode } : {},
      actionHeaders: S.headers ? { [w.route.id]: S.headers } : {}
    };
  }
  async function d(f, y, w, v, x, E, P, L) {
    let C = E != null;
    if (C && !E?.route.loader && !E?.route.lazy)
      throw ee(400, {
        method: f.method,
        pathname: new URL(f.url).pathname,
        routeId: E?.route.id
      });
    let S;
    if (E)
      S = Be(
        o,
        r,
        f,
        y,
        E,
        [],
        w
      );
    else {
      let O = L && ae(L[1]) ? (
        // Up to but not including the boundary
        y.findIndex(($) => $.route.id === L[0]) - 1
      ) : void 0, j = _e(y);
      S = y.map(($, z) => O != null && z > O ? Pt(
        o,
        r,
        f,
        j,
        $,
        [],
        w,
        !1
      ) : Pt(
        o,
        r,
        f,
        j,
        $,
        [],
        w,
        ($.route.loader || $.route.lazy) != null && (!P || P($))
      ));
    }
    if (!v && !S.some((O) => O.shouldLoad))
      return {
        matches: y,
        loaderData: {},
        errors: L && ae(L[1]) ? {
          [L[0]]: L[1].error
        } : null,
        statusCode: 200,
        loaderHeaders: {}
      };
    let b = await p(
      f,
      S,
      C,
      w,
      v
    );
    return f.signal.aborted && Pa(f, C), {
      ...On(
        y,
        b,
        L,
        !0,
        x
      ),
      matches: y
    };
  }
  async function p(f, y, w, v, x) {
    let E = await Pn(
      x || gr,
      f,
      y,
      null,
      v,
      !0
    ), P = {};
    return await Promise.all(
      y.map(async (L) => {
        if (!(L.route.id in E))
          return;
        let C = E[L.route.id];
        if (Nn(C)) {
          let S = C.result;
          throw Dn(
            S,
            f,
            L.route.id,
            y,
            a
          );
        }
        if (w) {
          if (se(C.result))
            throw C;
          if (qe(C.result))
            throw br(C.result);
        }
        P[L.route.id] = await Ln(C);
      })
    ), P;
  }
  return {
    dataRoutes: i,
    query: l,
    queryRoute: s
  };
}
function Pi(e, t, r, a) {
  let n = a || t._deepestRenderedBoundaryId || e[0].id;
  return {
    ...t,
    statusCode: Pe(r) ? r.status : 500,
    errors: {
      [n]: r
    }
  };
}
function Pa(e, t) {
  if (e.signal.reason !== void 0)
    throw e.signal.reason;
  let r = t ? "queryRoute" : "query";
  throw new Error(
    `${r}() call aborted without an \`AbortSignal.reason\`: ${e.method} ${e.url}`
  );
}
function Ci(e) {
  return e != null && ("formData" in e && e.formData != null || "body" in e && e.body !== void 0);
}
function yr(e, t, r, a, n, o) {
  let i, l;
  if (n) {
    i = [];
    for (let u of t)
      if (i.push(u), u.route.id === n) {
        l = u;
        break;
      }
  } else
    i = t, l = t[t.length - 1];
  let s = Qt(
    a || ".",
    Xt(i),
    fe(e.pathname, r) || e.pathname,
    o === "path"
  );
  if (a == null && (s.search = e.search, s.hash = e.hash), (a == null || a === "" || a === ".") && l) {
    let u = Ar(s.search);
    if (l.route.index && !u)
      s.search = s.search ? s.search.replace(/^\?/, "?index&") : "?index";
    else if (!l.route.index && u) {
      let h = new URLSearchParams(s.search), d = h.getAll("index");
      h.delete("index"), d.filter((f) => f).forEach((f) => h.append("index", f));
      let p = h.toString();
      s.search = p ? `?${p}` : "";
    }
  }
  return r !== "/" && (s.pathname = ci({ basename: r, pathname: s.pathname })), ce(s);
}
function Ca(e, t, r) {
  if (!r || !Ci(r))
    return { path: t };
  if (r.formMethod && !Rr(r.formMethod))
    return {
      path: t,
      error: ee(405, { method: r.formMethod })
    };
  let a = () => ({
    path: t,
    error: ee(400, { type: "invalid-body" })
  }), o = (r.formMethod || "get").toUpperCase(), i = Mn(t);
  if (r.body !== void 0) {
    if (r.formEncType === "text/plain") {
      if (!oe(o))
        return a();
      let d = typeof r.body == "string" ? r.body : r.body instanceof FormData || r.body instanceof URLSearchParams ? (
        // https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#plain-text-form-data
        Array.from(r.body.entries()).reduce(
          (p, [f, y]) => `${p}${f}=${y}
`,
          ""
        )
      ) : String(r.body);
      return {
        path: t,
        submission: {
          formMethod: o,
          formAction: i,
          formEncType: r.formEncType,
          formData: void 0,
          json: void 0,
          text: d
        }
      };
    } else if (r.formEncType === "application/json") {
      if (!oe(o))
        return a();
      try {
        let d = typeof r.body == "string" ? JSON.parse(r.body) : r.body;
        return {
          path: t,
          submission: {
            formMethod: o,
            formAction: i,
            formEncType: r.formEncType,
            formData: void 0,
            json: d,
            text: void 0
          }
        };
      } catch {
        return a();
      }
    }
  }
  I(
    typeof FormData == "function",
    "FormData is not available in this environment"
  );
  let l, s;
  if (r.formData)
    l = wr(r.formData), s = r.formData;
  else if (r.body instanceof FormData)
    l = wr(r.body), s = r.body;
  else if (r.body instanceof URLSearchParams)
    l = r.body, s = Fa(l);
  else if (r.body == null)
    l = new URLSearchParams(), s = new FormData();
  else
    try {
      l = new URLSearchParams(r.body), s = Fa(l);
    } catch {
      return a();
    }
  let u = {
    formMethod: o,
    formAction: i,
    formEncType: r && r.formEncType || "application/x-www-form-urlencoded",
    formData: s,
    json: void 0,
    text: void 0
  };
  if (oe(u.formMethod))
    return { path: t, submission: u };
  let h = Ce(t);
  return e && h.search && Ar(h.search) && l.append("index", ""), h.search = `?${l}`, { path: ce(h), submission: u };
}
function La(e, t, r, a, n, o, i, l, s, u, h, d, p, f, y, w, v, x, E, P, L) {
  let C = P ? ae(P[1]) ? P[1].error : P[1].data : void 0, S = n.createURL(o.location), b = n.createURL(s), T;
  if (h && o.errors) {
    let W = Object.keys(o.errors)[0];
    T = i.findIndex((G) => G.route.id === W);
  } else if (P && ae(P[1])) {
    let W = P[0];
    T = i.findIndex((G) => G.route.id === W) - 1;
  }
  let O = P ? P[1].statusCode : void 0, j = O && O >= 400, $ = {
    currentUrl: S,
    currentParams: o.matches[0]?.params || {},
    nextUrl: b,
    nextParams: i[0].params,
    ...l,
    actionResult: C,
    actionStatus: O
  }, z = _e(i), V = i.map((W, G) => {
    let { route: we } = W, K = null;
    if (T != null && G > T ? K = !1 : we.lazy ? K = !0 : _r(we) ? h ? K = vr(
      we,
      o.loaderData,
      o.errors
    ) : Li(o.loaderData, o.matches[G], W) && (K = !0) : K = !1, K !== null)
      return Pt(
        r,
        a,
        e,
        z,
        W,
        u,
        t,
        K
      );
    let te = !1;
    typeof L == "boolean" ? te = L : j ? te = !1 : (d || S.pathname + S.search === b.pathname + b.search || S.search !== b.search || Di(o.matches[G], W)) && (te = !0);
    let me = {
      ...$,
      defaultShouldRevalidate: te
    }, Le = St(W, me);
    return Pt(
      r,
      a,
      e,
      z,
      W,
      u,
      t,
      Le,
      me,
      L
    );
  }), Z = [];
  return y.forEach((W, G) => {
    if (h || !i.some((Ee) => Ee.route.id === W.routeId) || f.has(G))
      return;
    let we = o.fetchers.get(G), K = we && we.state !== "idle" && we.data === void 0, te = De(v, W.path, x);
    if (!te) {
      if (E && K)
        return;
      Z.push({
        key: G,
        routeId: W.routeId,
        path: W.path,
        matches: null,
        match: null,
        request: null,
        controller: null
      });
      return;
    }
    if (w.has(G))
      return;
    let me = st(te, W.path), Le = new AbortController(), pe = ot(
      n,
      W.path,
      Le.signal
    ), be = null;
    if (p.has(G))
      p.delete(G), be = Be(
        r,
        a,
        pe,
        te,
        me,
        u,
        t
      );
    else if (K)
      d && (be = Be(
        r,
        a,
        pe,
        te,
        me,
        u,
        t
      ));
    else {
      let Ee;
      typeof L == "boolean" ? Ee = L : j ? Ee = !1 : Ee = d;
      let ye = {
        ...$,
        defaultShouldRevalidate: Ee
      };
      St(me, ye) && (be = Be(
        r,
        a,
        pe,
        te,
        me,
        u,
        t,
        ye
      ));
    }
    be && Z.push({
      key: G,
      routeId: W.routeId,
      path: W.path,
      matches: be,
      match: me,
      request: pe,
      controller: Le
    });
  }), { dsMatches: V, revalidatingFetchers: Z };
}
function _r(e) {
  return e.loader != null || e.middleware != null && e.middleware.length > 0;
}
function vr(e, t, r) {
  if (e.lazy)
    return !0;
  if (!_r(e))
    return !1;
  let a = t != null && e.id in t, n = r != null && r[e.id] !== void 0;
  return !a && n ? !1 : typeof e.loader == "function" && e.loader.hydrate === !0 ? !0 : !a && !n;
}
function Li(e, t, r) {
  let a = (
    // [a] -> [a, b]
    !t || // [a, b] -> [a, c]
    r.route.id !== t.route.id
  ), n = !e.hasOwnProperty(r.route.id);
  return a || n;
}
function Di(e, t) {
  let r = e.route.path;
  return (
    // param change for this match, /users/123 -> /users/456
    e.pathname !== t.pathname || // splat param changed, which is not present in match.path
    // e.g. /files/images/avatar.jpg -> files/finances.xls
    r != null && r.endsWith("*") && e.params["*"] !== t.params["*"]
  );
}
function St(e, t) {
  if (e.route.shouldRevalidate) {
    let r = e.route.shouldRevalidate(t);
    if (typeof r == "boolean")
      return r;
  }
  return t.defaultShouldRevalidate;
}
function Da(e, t, r, a, n, o) {
  let i;
  if (e) {
    let u = a[e];
    I(
      u,
      `No route found to patch children into: routeId = ${e}`
    ), u.children || (u.children = []), i = u.children;
  } else
    i = r;
  let l = [], s = [];
  if (t.forEach((u) => {
    let h = i.find(
      (d) => bn(u, d)
    );
    h ? s.push({ existingRoute: h, newRoute: u }) : l.push(u);
  }), l.length > 0) {
    let u = et(
      l,
      n,
      [e || "_", "patch", String(i?.length || "0")],
      a
    );
    i.push(...u);
  }
  if (o && s.length > 0)
    for (let u = 0; u < s.length; u++) {
      let { existingRoute: h, newRoute: d } = s[u], p = h, [f] = et(
        [d],
        n,
        [],
        // Doesn't matter for mutated routes since they already have an id
        {},
        // Don't touch the manifest here since we're updating in place
        !0
      );
      Object.assign(p, {
        element: f.element ? f.element : p.element,
        errorElement: f.errorElement ? f.errorElement : p.errorElement,
        hydrateFallbackElement: f.hydrateFallbackElement ? f.hydrateFallbackElement : p.hydrateFallbackElement
      });
    }
}
function bn(e, t) {
  return "id" in e && "id" in t && e.id === t.id ? !0 : e.index === t.index && e.path === t.path && e.caseSensitive === t.caseSensitive ? (!e.children || e.children.length === 0) && (!t.children || t.children.length === 0) ? !0 : e.children.every(
    (r, a) => t.children?.some((n) => bn(r, n))
  ) : !1;
}
var Oa = /* @__PURE__ */ new WeakMap(), Ir = ({
  key: e,
  route: t,
  manifest: r,
  mapRouteProperties: a
}) => {
  let n = r[t.id];
  if (I(n, "No route found in manifest"), !n.lazy || typeof n.lazy != "object")
    return;
  let o = n.lazy[e];
  if (!o)
    return;
  let i = Oa.get(n);
  i || (i = {}, Oa.set(n, i));
  let l = i[e];
  if (l)
    return l;
  let s = (async () => {
    let u = Xo(e), d = n[e] !== void 0 && e !== "hasErrorBoundary";
    if (u)
      Q(
        !u,
        "Route property " + e + " is not a supported lazy route property. This property will be ignored."
      ), i[e] = Promise.resolve();
    else if (d)
      Q(
        !1,
        `Route "${n.id}" has a static property "${e}" defined. The lazy property will be ignored.`
      );
    else {
      let p = await o();
      p != null && (Object.assign(n, { [e]: p }), Object.assign(n, a(n)));
    }
    typeof n.lazy == "object" && (n.lazy[e] = void 0, Object.values(n.lazy).every((p) => p === void 0) && (n.lazy = void 0));
  })();
  return i[e] = s, s;
}, Ma = /* @__PURE__ */ new WeakMap();
function Oi(e, t, r, a, n) {
  let o = r[e.id];
  if (I(o, "No route found in manifest"), !e.lazy)
    return {
      lazyRoutePromise: void 0,
      lazyHandlerPromise: void 0
    };
  if (typeof e.lazy == "function") {
    let h = Ma.get(o);
    if (h)
      return {
        lazyRoutePromise: h,
        lazyHandlerPromise: h
      };
    let d = (async () => {
      I(
        typeof e.lazy == "function",
        "No lazy route function found"
      );
      let p = await e.lazy(), f = {};
      for (let y in p) {
        let w = p[y];
        if (w === void 0)
          continue;
        let v = Zo(y), E = o[y] !== void 0 && // This property isn't static since it should always be updated based
        // on the route updates
        y !== "hasErrorBoundary";
        v ? Q(
          !v,
          "Route property " + y + " is not a supported property to be returned from a lazy route function. This property will be ignored."
        ) : E ? Q(
          !E,
          `Route "${o.id}" has a static property "${y}" defined but its lazy function is also returning a value for this property. The lazy route property "${y}" will be ignored.`
        ) : f[y] = w;
      }
      Object.assign(o, f), Object.assign(o, {
        // To keep things framework agnostic, we use the provided `mapRouteProperties`
        // function to set the framework-aware properties (`element`/`hasErrorBoundary`)
        // since the logic will differ between frameworks.
        ...a(o),
        lazy: void 0
      });
    })();
    return Ma.set(o, d), d.catch(() => {
    }), {
      lazyRoutePromise: d,
      lazyHandlerPromise: d
    };
  }
  let i = Object.keys(e.lazy), l = [], s;
  for (let h of i) {
    if (n && n.includes(h))
      continue;
    let d = Ir({
      key: h,
      route: e,
      manifest: r,
      mapRouteProperties: a
    });
    d && (l.push(d), h === t && (s = d));
  }
  let u = l.length > 0 ? Promise.all(l).then(() => {
  }) : void 0;
  return u?.catch(() => {
  }), s?.catch(() => {
  }), {
    lazyRoutePromise: u,
    lazyHandlerPromise: s
  };
}
function Mi(e) {
  return e !== void 0;
}
function Ta(e, t, r) {
  let a = e.map(({ route: n }) => {
    if (!(typeof n.lazy != "object" || !n.lazy.middleware))
      return Ir({
        key: "middleware",
        route: n,
        manifest: t,
        mapRouteProperties: r
      });
  }).filter(Mi);
  return a.length > 0 ? Promise.all(a) : void 0;
}
async function gr(e) {
  let t = e.matches.filter((n) => n.shouldLoad), r = {};
  return (await Promise.all(t.map((n) => n.resolve()))).forEach((n, o) => {
    r[t[o].route.id] = n;
  }), r;
}
async function Ti(e) {
  return e.matches.some((t) => t.route.middleware) ? En(e, () => gr(e)) : gr(e);
}
function $a(e, t, r) {
  return Rn(
    e,
    t,
    a,
    se,
    r
  );
  function a(n) {
    return qe(n) ? br(n) : n;
  }
}
function En(e, t) {
  return Rn(
    e,
    t,
    (a) => {
      if (Er(a))
        throw a;
      return a;
    },
    Fi,
    r
  );
  function r(a, n, o) {
    if (o)
      return Promise.resolve(
        Object.assign(o.value, {
          [n]: { type: "error", result: a }
        })
      );
    {
      let { matches: i } = e, l = Math.min(
        // Throwing route
        Math.max(
          i.findIndex((u) => u.route.id === n),
          0
        ),
        // or the shallowest route that needs to load data
        Math.max(
          i.findIndex((u) => u.shouldCallHandler()),
          0
        )
      ), s = xe(
        i,
        i[l].route.id
      ).route.id;
      return Promise.resolve({
        [s]: { type: "error", result: a }
      });
    }
  }
}
async function Rn(e, t, r, a, n) {
  let { matches: o, request: i, params: l, context: s, unstable_pattern: u } = e, h = o.flatMap(
    (p) => p.route.middleware ? p.route.middleware.map((f) => [p.route.id, f]) : []
  );
  return await Sn(
    {
      request: i,
      params: l,
      context: s,
      unstable_pattern: u
    },
    h,
    t,
    r,
    a,
    n
  );
}
async function Sn(e, t, r, a, n, o, i = 0) {
  let { request: l } = e;
  if (l.signal.aborted)
    throw l.signal.reason ?? new Error(`Request aborted: ${l.method} ${l.url}`);
  let s = t[i];
  if (!s)
    return await r();
  let [u, h] = s, d, p = async () => {
    if (d)
      throw new Error("You may only call `next()` once per middleware");
    try {
      return d = { value: await Sn(
        e,
        t,
        r,
        a,
        n,
        o,
        i + 1
      ) }, d.value;
    } catch (f) {
      return d = { value: await o(f, u, d) }, d.value;
    }
  };
  try {
    let f = await h(e, p), y = f != null ? a(f) : void 0;
    return n(y) ? y : d ? y ?? d.value : (d = { value: await p() }, d.value);
  } catch (f) {
    return await o(f, u, d);
  }
}
function xn(e, t, r, a, n) {
  let o = Ir({
    key: "middleware",
    route: a.route,
    manifest: t,
    mapRouteProperties: e
  }), i = Oi(
    a.route,
    oe(r.method) ? "action" : "loader",
    t,
    e,
    n
  );
  return {
    middleware: o,
    route: i.lazyRoutePromise,
    handler: i.lazyHandlerPromise
  };
}
function Pt(e, t, r, a, n, o, i, l, s = null, u) {
  let h = !1, d = xn(
    e,
    t,
    r,
    n,
    o
  );
  return {
    ...n,
    _lazyPromises: d,
    shouldLoad: l,
    shouldRevalidateArgs: s,
    shouldCallHandler(p) {
      return h = !0, s ? typeof u == "boolean" ? St(n, {
        ...s,
        defaultShouldRevalidate: u
      }) : typeof p == "boolean" ? St(n, {
        ...s,
        defaultShouldRevalidate: p
      }) : St(n, s) : l;
    },
    resolve(p) {
      let { lazy: f, loader: y, middleware: w } = n.route, v = h || l || p && !oe(r.method) && (f || y), x = w && w.length > 0 && !y && !f;
      return v && (oe(r.method) || !x) ? $i({
        request: r,
        unstable_pattern: a,
        match: n,
        lazyHandlerPromise: d?.handler,
        lazyRoutePromise: d?.route,
        handlerOverride: p,
        scopedContext: i
      }) : Promise.resolve({ type: "data", result: void 0 });
    }
  };
}
function Be(e, t, r, a, n, o, i, l = null) {
  return a.map((s) => s.route.id !== n.route.id ? {
    ...s,
    shouldLoad: !1,
    shouldRevalidateArgs: l,
    shouldCallHandler: () => !1,
    _lazyPromises: xn(
      e,
      t,
      r,
      s,
      o
    ),
    resolve: () => Promise.resolve({ type: "data", result: void 0 })
  } : Pt(
    e,
    t,
    r,
    _e(a),
    s,
    o,
    i,
    !0,
    l
  ));
}
async function Pn(e, t, r, a, n, o) {
  r.some((u) => u._lazyPromises?.middleware) && await Promise.all(r.map((u) => u._lazyPromises?.middleware));
  let i = {
    request: t,
    unstable_pattern: _e(r),
    params: r[0].params,
    context: n,
    matches: r
  }, s = await e({
    ...i,
    fetcherKey: a,
    runClientMiddleware: o ? () => {
      throw new Error(
        "You cannot call `runClientMiddleware()` from a static handler `dataStrategy`. Middleware is run outside of `dataStrategy` during SSR in order to bubble up the Response.  You can enable middleware via the `respond` API in `query`/`queryRoute`"
      );
    } : (u) => {
      let h = i;
      return En(h, () => u({
        ...h,
        fetcherKey: a,
        runClientMiddleware: () => {
          throw new Error(
            "Cannot call `runClientMiddleware()` from within an `runClientMiddleware` handler"
          );
        }
      }));
    }
  });
  try {
    await Promise.all(
      r.flatMap((u) => [
        u._lazyPromises?.handler,
        u._lazyPromises?.route
      ])
    );
  } catch {
  }
  return s;
}
async function $i({
  request: e,
  unstable_pattern: t,
  match: r,
  lazyHandlerPromise: a,
  lazyRoutePromise: n,
  handlerOverride: o,
  scopedContext: i
}) {
  let l, s, u = oe(e.method), h = u ? "action" : "loader", d = (p) => {
    let f, y = new Promise((x, E) => f = E);
    s = () => f(), e.signal.addEventListener("abort", s);
    let w = (x) => typeof p != "function" ? Promise.reject(
      new Error(
        `You cannot call the handler for a route which defines a boolean "${h}" [routeId: ${r.route.id}]`
      )
    ) : p(
      {
        request: e,
        unstable_pattern: t,
        params: r.params,
        context: i
      },
      ...x !== void 0 ? [x] : []
    ), v = (async () => {
      try {
        return { type: "data", result: await (o ? o((E) => w(E)) : w()) };
      } catch (x) {
        return { type: "error", result: x };
      }
    })();
    return Promise.race([v, y]);
  };
  try {
    let p = u ? r.route.action : r.route.loader;
    if (a || n)
      if (p) {
        let f, [y] = await Promise.all([
          // If the handler throws, don't let it immediately bubble out,
          // since we need to let the lazy() execution finish so we know if this
          // route has a boundary that can handle the error
          d(p).catch((w) => {
            f = w;
          }),
          // Ensure all lazy route promises are resolved before continuing
          a,
          n
        ]);
        if (f !== void 0)
          throw f;
        l = y;
      } else {
        await a;
        let f = u ? r.route.action : r.route.loader;
        if (f)
          [l] = await Promise.all([d(f), n]);
        else if (h === "action") {
          let y = new URL(e.url), w = y.pathname + y.search;
          throw ee(405, {
            method: e.method,
            pathname: w,
            routeId: r.route.id
          });
        } else
          return { type: "data", result: void 0 };
      }
    else if (p)
      l = await d(p);
    else {
      let f = new URL(e.url), y = f.pathname + f.search;
      throw ee(404, {
        pathname: y
      });
    }
  } catch (p) {
    return { type: "error", result: p };
  } finally {
    s && e.signal.removeEventListener("abort", s);
  }
  return l;
}
async function Cn(e) {
  let t = e.headers.get("Content-Type");
  return t && /\bapplication\/json\b/.test(t) ? e.body == null ? null : e.json() : e.text();
}
async function Ln(e) {
  let { result: t, type: r } = e;
  if (se(t)) {
    let a;
    try {
      a = await Cn(t);
    } catch (n) {
      return { type: "error", error: n };
    }
    return r === "error" ? {
      type: "error",
      error: new Te(t.status, t.statusText, a),
      statusCode: t.status,
      headers: t.headers
    } : {
      type: "data",
      data: a,
      statusCode: t.status,
      headers: t.headers
    };
  }
  return r === "error" ? qe(t) ? t.data instanceof Error ? {
    type: "error",
    error: t.data,
    statusCode: t.init?.status,
    headers: t.init?.headers ? new Headers(t.init.headers) : void 0
  } : {
    type: "error",
    error: Tn(t),
    statusCode: Pe(t) ? t.status : void 0,
    headers: t.init?.headers ? new Headers(t.init.headers) : void 0
  } : {
    type: "error",
    error: t,
    statusCode: Pe(t) ? t.status : void 0
  } : qe(t) ? {
    type: "data",
    data: t.data,
    statusCode: t.init?.status,
    headers: t.init?.headers ? new Headers(t.init.headers) : void 0
  } : { type: "data", data: t };
}
function Dn(e, t, r, a, n) {
  let o = e.headers.get("Location");
  if (I(
    o,
    "Redirects returned/thrown from loaders/actions must have a Location header"
  ), !Gt(o)) {
    let i = a.slice(
      0,
      a.findIndex((l) => l.route.id === r) + 1
    );
    o = yr(
      new URL(t.url),
      i,
      n,
      o
    ), e.headers.set("Location", o);
  }
  return e;
}
function Na(e, t, r, a) {
  let n = [
    "about:",
    "blob:",
    "chrome:",
    "chrome-untrusted:",
    "content:",
    "data:",
    "devtools:",
    "file:",
    "filesystem:",
    // eslint-disable-next-line no-script-url
    "javascript:"
  ];
  if (Gt(e)) {
    let o = e, i = o.startsWith("//") ? new URL(t.protocol + o) : new URL(o);
    if (n.includes(i.protocol))
      throw new Error("Invalid redirect location");
    let l = fe(i.pathname, r) != null;
    if (i.origin === t.origin && l)
      return i.pathname + i.search + i.hash;
  }
  try {
    let o = a.createURL(e);
    if (n.includes(o.protocol))
      throw new Error("Invalid redirect location");
  } catch {
  }
  return e;
}
function ot(e, t, r, a) {
  let n = e.createURL(Mn(t)).toString(), o = { signal: r };
  if (a && oe(a.formMethod)) {
    let { formMethod: i, formEncType: l } = a;
    o.method = i.toUpperCase(), l === "application/json" ? (o.headers = new Headers({ "Content-Type": l }), o.body = JSON.stringify(a.json)) : l === "text/plain" ? o.body = a.text : l === "application/x-www-form-urlencoded" && a.formData ? o.body = wr(a.formData) : o.body = a.formData;
  }
  return new Request(n, o);
}
function wr(e) {
  let t = new URLSearchParams();
  for (let [r, a] of e.entries())
    t.append(r, typeof a == "string" ? a : a.name);
  return t;
}
function Fa(e) {
  let t = new FormData();
  for (let [r, a] of e.entries())
    t.append(r, a);
  return t;
}
function On(e, t, r, a = !1, n = !1) {
  let o = {}, i = null, l, s = !1, u = {}, h = r && ae(r[1]) ? r[1].error : void 0;
  return e.forEach((d) => {
    if (!(d.route.id in t))
      return;
    let p = d.route.id, f = t[p];
    if (I(
      !ze(f),
      "Cannot handle redirect results in processLoaderData"
    ), ae(f)) {
      let y = f.error;
      if (h !== void 0 && (y = h, h = void 0), i = i || {}, n)
        i[p] = y;
      else {
        let w = xe(e, p);
        i[w.route.id] == null && (i[w.route.id] = y);
      }
      a || (o[p] = wn), s || (s = !0, l = Pe(f.error) ? f.error.status : 500), f.headers && (u[p] = f.headers);
    } else
      o[p] = f.data, f.statusCode && f.statusCode !== 200 && !s && (l = f.statusCode), f.headers && (u[p] = f.headers);
  }), h !== void 0 && r && (i = { [r[0]]: h }, r[2] && (o[r[2]] = void 0)), {
    loaderData: o,
    errors: i,
    statusCode: l || 200,
    loaderHeaders: u
  };
}
function ka(e, t, r, a, n, o) {
  let { loaderData: i, errors: l } = On(
    t,
    r,
    a
  );
  return n.filter((s) => !s.matches || s.matches.some((u) => u.shouldLoad)).forEach((s) => {
    let { key: u, match: h, controller: d } = s;
    if (d && d.signal.aborted)
      return;
    let p = o[u];
    if (I(p, "Did not find corresponding fetcher result"), ae(p)) {
      let f = xe(e.matches, h?.route.id);
      l && l[f.route.id] || (l = {
        ...l,
        [f.route.id]: p.error
      }), e.fetchers.delete(u);
    } else if (ze(p))
      I(!1, "Unhandled fetcher revalidation redirect");
    else {
      let f = ke(p.data);
      e.fetchers.set(u, f);
    }
  }), { loaderData: i, errors: l };
}
function _a(e, t, r, a) {
  let n = Object.entries(t).filter(([, o]) => o !== wn).reduce((o, [i, l]) => (o[i] = l, o), {});
  for (let o of r) {
    let i = o.route.id;
    if (!t.hasOwnProperty(i) && e.hasOwnProperty(i) && o.route.loader && (n[i] = e[i]), a && a.hasOwnProperty(i))
      break;
  }
  return n;
}
function Ia(e) {
  return e ? ae(e[1]) ? {
    // Clear out prior actionData on errors
    actionData: {}
  } : {
    actionData: {
      [e[0]]: e[1].data
    }
  } : {};
}
function xe(e, t) {
  return (t ? e.slice(0, e.findIndex((a) => a.route.id === t) + 1) : [...e]).reverse().find((a) => a.route.hasErrorBoundary === !0) || e[0];
}
function lt(e) {
  let t = e.length === 1 ? e[0] : e.find((r) => r.index || !r.path || r.path === "/") || {
    id: "__shim-error-route__"
  };
  return {
    matches: [
      {
        params: {},
        pathname: "",
        pathnameBase: "",
        route: t
      }
    ],
    route: t
  };
}
function ee(e, {
  pathname: t,
  routeId: r,
  method: a,
  type: n,
  message: o
} = {}) {
  let i = "Unknown Server Error", l = "Unknown @remix-run/router error";
  return e === 400 ? (i = "Bad Request", a && t && r ? l = `You made a ${a} request to "${t}" but did not provide a \`loader\` for route "${r}", so there is no way to handle the request.` : n === "invalid-body" && (l = "Unable to encode submission body")) : e === 403 ? (i = "Forbidden", l = `Route "${r}" does not match URL "${t}"`) : e === 404 ? (i = "Not Found", l = `No route matches URL "${t}"`) : e === 405 && (i = "Method Not Allowed", a && t && r ? l = `You made a ${a.toUpperCase()} request to "${t}" but did not provide an \`action\` for route "${r}", so there is no way to handle the request.` : a && (l = `Invalid request method "${a.toUpperCase()}"`)), new Te(
    e || 500,
    i,
    new Error(l),
    !0
  );
}
function It(e) {
  let t = Object.entries(e);
  for (let r = t.length - 1; r >= 0; r--) {
    let [a, n] = t[r];
    if (ze(n))
      return { key: a, result: n };
  }
}
function Mn(e) {
  let t = typeof e == "string" ? Ce(e) : e;
  return ce({ ...t, hash: "" });
}
function Ni(e, t) {
  return e.pathname !== t.pathname || e.search !== t.search ? !1 : e.hash === "" ? t.hash !== "" : e.hash === t.hash ? !0 : t.hash !== "";
}
function br(e) {
  return Response.json(e.data, e.init ?? void 0);
}
function Tn(e) {
  return new Te(
    e.init?.status ?? 500,
    e.init?.statusText ?? "Internal Server Error",
    e.data
  );
}
function Fi(e) {
  return e != null && typeof e == "object" && Object.entries(e).every(
    ([t, r]) => typeof t == "string" && $n(r)
  );
}
function $n(e) {
  return e != null && typeof e == "object" && "type" in e && "result" in e && (e.type === "data" || e.type === "error");
}
function Nn(e) {
  return se(e.result) && yn.has(e.result.status);
}
function ae(e) {
  return e.type === "error";
}
function ze(e) {
  return (e && e.type) === "redirect";
}
function qe(e) {
  return typeof e == "object" && e != null && "type" in e && "data" in e && "init" in e && e.type === "DataWithResponseInit";
}
function se(e) {
  return e != null && typeof e.status == "number" && typeof e.statusText == "string" && typeof e.headers == "object" && typeof e.body < "u";
}
function ki(e) {
  return yn.has(e);
}
function Er(e) {
  return se(e) && ki(e.status) && e.headers.has("Location");
}
function Rr(e) {
  return Ri.has(e.toUpperCase());
}
function oe(e) {
  return bi.has(e.toUpperCase());
}
function Ar(e) {
  return new URLSearchParams(e).getAll("index").some((t) => t === "");
}
function st(e, t) {
  let r = typeof t == "string" ? Ce(t).search : t.search;
  if (e[e.length - 1].route.index && Ar(r || ""))
    return e[e.length - 1];
  let a = sn(e);
  return a[a.length - 1];
}
function Aa(e) {
  let { formMethod: t, formAction: r, formEncType: a, text: n, formData: o, json: i } = e;
  if (!(!t || !r || !a)) {
    if (n != null)
      return {
        formMethod: t,
        formAction: r,
        formEncType: a,
        formData: void 0,
        json: void 0,
        text: n
      };
    if (o != null)
      return {
        formMethod: t,
        formAction: r,
        formEncType: a,
        formData: o,
        json: void 0,
        text: void 0
      };
    if (i !== void 0)
      return {
        formMethod: t,
        formAction: r,
        formEncType: a,
        formData: void 0,
        json: i,
        text: void 0
      };
  }
}
function cr(e, t) {
  return t ? {
    state: "loading",
    location: e,
    formMethod: t.formMethod,
    formAction: t.formAction,
    formEncType: t.formEncType,
    formData: t.formData,
    json: t.json,
    text: t.text
  } : {
    state: "loading",
    location: e,
    formMethod: void 0,
    formAction: void 0,
    formEncType: void 0,
    formData: void 0,
    json: void 0,
    text: void 0
  };
}
function _i(e, t) {
  return {
    state: "submitting",
    location: e,
    formMethod: t.formMethod,
    formAction: t.formAction,
    formEncType: t.formEncType,
    formData: t.formData,
    json: t.json,
    text: t.text
  };
}
function wt(e, t) {
  return e ? {
    state: "loading",
    formMethod: e.formMethod,
    formAction: e.formAction,
    formEncType: e.formEncType,
    formData: e.formData,
    json: e.json,
    text: e.text,
    data: t
  } : {
    state: "loading",
    formMethod: void 0,
    formAction: void 0,
    formEncType: void 0,
    formData: void 0,
    json: void 0,
    text: void 0,
    data: t
  };
}
function Ii(e, t) {
  return {
    state: "submitting",
    formMethod: e.formMethod,
    formAction: e.formAction,
    formEncType: e.formEncType,
    formData: e.formData,
    json: e.json,
    text: e.text,
    data: t ? t.data : void 0
  };
}
function ke(e) {
  return {
    state: "idle",
    formMethod: void 0,
    formAction: void 0,
    formEncType: void 0,
    formData: void 0,
    json: void 0,
    text: void 0,
    data: e
  };
}
function Ai(e, t) {
  try {
    let r = e.sessionStorage.getItem(
      gn
    );
    if (r) {
      let a = JSON.parse(r);
      for (let [n, o] of Object.entries(a || {}))
        o && Array.isArray(o) && t.set(n, new Set(o || []));
    }
  } catch {
  }
}
function ji(e, t) {
  if (t.size > 0) {
    let r = {};
    for (let [a, n] of t)
      r[a] = [...n];
    try {
      e.sessionStorage.setItem(
        gn,
        JSON.stringify(r)
      );
    } catch (a) {
      Q(
        !1,
        `Failed to save applied view transitions in sessionStorage (${a}).`
      );
    }
  }
}
function ja() {
  let e, t, r = new Promise((a, n) => {
    e = async (o) => {
      a(o);
      try {
        await r;
      } catch {
      }
    }, t = async (o) => {
      n(o);
      try {
        await r;
      } catch {
      }
    };
  });
  return {
    promise: r,
    //@ts-ignore
    resolve: e,
    //@ts-ignore
    reject: t
  };
}
var Ae = c.createContext(null);
Ae.displayName = "DataRouter";
var We = c.createContext(null);
We.displayName = "DataRouterState";
var Fn = c.createContext(!1);
function kn() {
  return c.useContext(Fn);
}
var Zt = c.createContext({
  isTransitioning: !1
});
Zt.displayName = "ViewTransition";
var qt = c.createContext(
  /* @__PURE__ */ new Map()
);
qt.displayName = "Fetchers";
var dt = c.createContext(null);
dt.displayName = "Await";
var Is = (e) => c.createElement(dt.Provider, e), he = c.createContext(
  null
);
he.displayName = "Navigation";
var ft = c.createContext(
  null
);
ft.displayName = "Location";
var ve = c.createContext({
  outlet: null,
  matches: [],
  isDataRoute: !1
});
ve.displayName = "Route";
var jr = c.createContext(null);
jr.displayName = "RouteError";
var _n = "REACT_ROUTER_ERROR", Hi = "REDIRECT", Ui = "ROUTE_ERROR_RESPONSE";
function zi(e) {
  if (e.startsWith(`${_n}:${Hi}:{`))
    try {
      let t = JSON.parse(e.slice(28));
      if (typeof t == "object" && t && typeof t.status == "number" && typeof t.statusText == "string" && typeof t.location == "string" && typeof t.reloadDocument == "boolean" && typeof t.replace == "boolean")
        return t;
    } catch {
    }
}
function Bi(e) {
  if (e.startsWith(
    `${_n}:${Ui}:{`
  ))
    try {
      let t = JSON.parse(e.slice(40));
      if (typeof t == "object" && t && typeof t.status == "number" && typeof t.statusText == "string")
        return new Te(
          t.status,
          t.statusText,
          t.data
        );
    } catch {
    }
}
function Wi(e, { relative: t } = {}) {
  I(
    tt(),
    // TODO: This error is probably because they somehow have 2 versions of the
    // router loaded. We can help them understand how to avoid that.
    "useHref() may be used only in the context of a <Router> component."
  );
  let { basename: r, navigator: a } = c.useContext(he), { hash: n, pathname: o, search: i } = Dt(e, { relative: t }), l = o;
  return r !== "/" && (l = o === "/" ? r : Me([r, o])), a.createHref({ pathname: l, search: i, hash: n });
}
function tt() {
  return c.useContext(ft) != null;
}
function ge() {
  return I(
    tt(),
    // TODO: This error is probably because they somehow have 2 versions of the
    // router loaded. We can help them understand how to avoid that.
    "useLocation() may be used only in the context of a <Router> component."
  ), c.useContext(ft).location;
}
function As() {
  return c.useContext(ft).navigationType;
}
function js(e) {
  I(
    tt(),
    // TODO: This error is probably because they somehow have 2 versions of the
    // router loaded. We can help them understand how to avoid that.
    "useMatch() may be used only in the context of a <Router> component."
  );
  let { pathname: t } = ge();
  return c.useMemo(
    () => xt(e, on(t)),
    [t, e]
  );
}
var In = "You should call navigate() in a React.useEffect(), not when your component is first rendered.";
function An(e) {
  c.useContext(he).static || c.useLayoutEffect(e);
}
function Hr() {
  let { isDataRoute: e } = c.useContext(ve);
  return e ? nl() : Yi();
}
function Yi() {
  I(
    tt(),
    // TODO: This error is probably because they somehow have 2 versions of the
    // router loaded. We can help them understand how to avoid that.
    "useNavigate() may be used only in the context of a <Router> component."
  );
  let e = c.useContext(Ae), { basename: t, navigator: r } = c.useContext(he), { matches: a } = c.useContext(ve), { pathname: n } = ge(), o = JSON.stringify(Xt(a)), i = c.useRef(!1);
  return An(() => {
    i.current = !0;
  }), c.useCallback(
    (s, u = {}) => {
      if (Q(i.current, In), !i.current) return;
      if (typeof s == "number") {
        r.go(s);
        return;
      }
      let h = Qt(
        s,
        JSON.parse(o),
        n,
        u.relative === "path"
      );
      e == null && t !== "/" && (h.pathname = h.pathname === "/" ? t : Me([t, h.pathname])), (u.replace ? r.replace : r.push)(
        h,
        u.state,
        u
      );
    },
    [
      t,
      r,
      o,
      n,
      e
    ]
  );
}
var jn = c.createContext(null);
function Hs() {
  return c.useContext(jn);
}
function Ji(e) {
  let t = c.useContext(ve).outlet;
  return c.useMemo(
    () => t && /* @__PURE__ */ c.createElement(jn.Provider, { value: e }, t),
    [t, e]
  );
}
function Ur() {
  let { matches: e } = c.useContext(ve), t = e[e.length - 1];
  return t ? t.params : {};
}
function Dt(e, { relative: t } = {}) {
  let { matches: r } = c.useContext(ve), { pathname: a } = ge(), n = JSON.stringify(Xt(r));
  return c.useMemo(
    () => Qt(
      e,
      JSON.parse(n),
      a,
      t === "path"
    ),
    [e, n, a, t]
  );
}
function Vi(e, t) {
  return zr(e, t);
}
function zr(e, t, r, a, n) {
  I(
    tt(),
    // TODO: This error is probably because they somehow have 2 versions of the
    // router loaded. We can help them understand how to avoid that.
    "useRoutes() may be used only in the context of a <Router> component."
  );
  let { navigator: o } = c.useContext(he), { matches: i } = c.useContext(ve), l = i[i.length - 1], s = l ? l.params : {}, u = l ? l.pathname : "/", h = l ? l.pathnameBase : "/", d = l && l.route;
  {
    let E = d && d.path || "";
    zn(
      u,
      !d || E.endsWith("*") || E.endsWith("*?"),
      `You rendered descendant <Routes> (or called \`useRoutes()\`) at "${u}" (under <Route path="${E}">) but the parent route path has no trailing "*". This means if you navigate deeper, the parent won't match anymore and therefore the child routes will never render.

Please change the parent <Route path="${E}"> to <Route path="${E === "/" ? "*" : `${E}/*`}">.`
    );
  }
  let p = ge(), f;
  if (t) {
    let E = typeof t == "string" ? Ce(t) : t;
    I(
      h === "/" || E.pathname?.startsWith(h),
      `When overriding the location using \`<Routes location>\` or \`useRoutes(routes, location)\`, the location pathname must begin with the portion of the URL pathname that was matched by all parent routes. The current pathname base is "${h}" but pathname "${E.pathname}" was given in the \`location\` prop.`
    ), f = E;
  } else
    f = p;
  let y = f.pathname || "/", w = y;
  if (h !== "/") {
    let E = h.replace(/^\//, "").split("/");
    w = "/" + y.replace(/^\//, "").split("/").slice(E.length).join("/");
  }
  let v = De(e, { pathname: w });
  Q(
    d || v != null,
    `No routes matched location "${f.pathname}${f.search}${f.hash}" `
  ), Q(
    v == null || v[v.length - 1].route.element !== void 0 || v[v.length - 1].route.Component !== void 0 || v[v.length - 1].route.lazy !== void 0,
    `Matched leaf route at location "${f.pathname}${f.search}${f.hash}" does not have an element or Component. This means it will render an <Outlet /> with a null value by default resulting in an "empty" page.`
  );
  let x = Un(
    v && v.map(
      (E) => Object.assign({}, E, {
        params: Object.assign({}, s, E.params),
        pathname: Me([
          h,
          // Re-encode pathnames that were decoded inside matchRoutes.
          // Pre-encode `?` and `#` ahead of `encodeLocation` because it uses
          // `new URL()` internally and we need to prevent it from treating
          // them as separators
          o.encodeLocation ? o.encodeLocation(
            E.pathname.replace(/\?/g, "%3F").replace(/#/g, "%23")
          ).pathname : E.pathname
        ]),
        pathnameBase: E.pathnameBase === "/" ? h : Me([
          h,
          // Re-encode pathnames that were decoded inside matchRoutes
          // Pre-encode `?` and `#` ahead of `encodeLocation` because it uses
          // `new URL()` internally and we need to prevent it from treating
          // them as separators
          o.encodeLocation ? o.encodeLocation(
            E.pathnameBase.replace(/\?/g, "%3F").replace(/#/g, "%23")
          ).pathname : E.pathnameBase
        ])
      })
    ),
    i,
    r,
    a,
    n
  );
  return t && x ? /* @__PURE__ */ c.createElement(
    ft.Provider,
    {
      value: {
        location: {
          pathname: "/",
          search: "",
          hash: "",
          state: null,
          key: "default",
          ...f
        },
        navigationType: "POP"
        /* Pop */
      }
    },
    x
  ) : x;
}
function Ki() {
  let e = Kr(), t = Pe(e) ? `${e.status} ${e.statusText}` : e instanceof Error ? e.message : JSON.stringify(e), r = e instanceof Error ? e.stack : null, a = "rgba(200,200,200, 0.5)", n = { padding: "0.5rem", backgroundColor: a }, o = { padding: "2px 4px", backgroundColor: a }, i = null;
  return console.error(
    "Error handled by React Router default ErrorBoundary:",
    e
  ), i = /* @__PURE__ */ c.createElement(c.Fragment, null, /* @__PURE__ */ c.createElement("p", null, " Hey developer "), /* @__PURE__ */ c.createElement("p", null, "You can provide a way better UX than this when your app throws errors by providing your own ", /* @__PURE__ */ c.createElement("code", { style: o }, "ErrorBoundary"), " or", " ", /* @__PURE__ */ c.createElement("code", { style: o }, "errorElement"), " prop on your route.")), /* @__PURE__ */ c.createElement(c.Fragment, null, /* @__PURE__ */ c.createElement("h2", null, "Unexpected Application Error!"), /* @__PURE__ */ c.createElement("h3", { style: { fontStyle: "italic" } }, t), r ? /* @__PURE__ */ c.createElement("pre", { style: n }, r) : null, i);
}
var Gi = /* @__PURE__ */ c.createElement(Ki, null), Hn = class extends c.Component {
  constructor(e) {
    super(e), this.state = {
      location: e.location,
      revalidation: e.revalidation,
      error: e.error
    };
  }
  static getDerivedStateFromError(e) {
    return { error: e };
  }
  static getDerivedStateFromProps(e, t) {
    return t.location !== e.location || t.revalidation !== "idle" && e.revalidation === "idle" ? {
      error: e.error,
      location: e.location,
      revalidation: e.revalidation
    } : {
      error: e.error !== void 0 ? e.error : t.error,
      location: t.location,
      revalidation: e.revalidation || t.revalidation
    };
  }
  componentDidCatch(e, t) {
    this.props.onError ? this.props.onError(e, t) : console.error(
      "React Router caught the following error during render",
      e
    );
  }
  render() {
    let e = this.state.error;
    if (this.context && typeof e == "object" && e && "digest" in e && typeof e.digest == "string") {
      const r = Bi(e.digest);
      r && (e = r);
    }
    let t = e !== void 0 ? /* @__PURE__ */ c.createElement(ve.Provider, { value: this.props.routeContext }, /* @__PURE__ */ c.createElement(
      jr.Provider,
      {
        value: e,
        children: this.props.component
      }
    )) : this.props.children;
    return this.context ? /* @__PURE__ */ c.createElement(Xi, { error: e }, t) : t;
  }
};
Hn.contextType = Fn;
var dr = /* @__PURE__ */ new WeakMap();
function Xi({
  children: e,
  error: t
}) {
  let { basename: r } = c.useContext(he);
  if (typeof t == "object" && t && "digest" in t && typeof t.digest == "string") {
    let a = zi(t.digest);
    if (a) {
      let n = dr.get(t);
      if (n) throw n;
      let o = cn(a.location, r);
      if (un && !dr.get(t))
        if (o.isExternal || a.reloadDocument)
          window.location.href = o.absoluteURL || o.to;
        else {
          const i = Promise.resolve().then(
            () => window.__reactRouterDataRouter.navigate(o.to, {
              replace: a.replace
            })
          );
          throw dr.set(t, i), i;
        }
      return /* @__PURE__ */ c.createElement(
        "meta",
        {
          httpEquiv: "refresh",
          content: `0;url=${o.absoluteURL || o.to}`
        }
      );
    }
  }
  return e;
}
function Qi({ routeContext: e, match: t, children: r }) {
  let a = c.useContext(Ae);
  return a && a.static && a.staticContext && (t.route.errorElement || t.route.ErrorBoundary) && (a.staticContext._deepestRenderedBoundaryId = t.route.id), /* @__PURE__ */ c.createElement(ve.Provider, { value: e }, r);
}
function Un(e, t = [], r = null, a = null, n = null) {
  if (e == null) {
    if (!r)
      return null;
    if (r.errors)
      e = r.matches;
    else if (t.length === 0 && !r.initialized && r.matches.length > 0)
      e = r.matches;
    else
      return null;
  }
  let o = e, i = r?.errors;
  if (i != null) {
    let h = o.findIndex(
      (d) => d.route.id && i?.[d.route.id] !== void 0
    );
    I(
      h >= 0,
      `Could not find a matching route for errors on route IDs: ${Object.keys(
        i
      ).join(",")}`
    ), o = o.slice(
      0,
      Math.min(o.length, h + 1)
    );
  }
  let l = !1, s = -1;
  if (r)
    for (let h = 0; h < o.length; h++) {
      let d = o[h];
      if ((d.route.HydrateFallback || d.route.hydrateFallbackElement) && (s = h), d.route.id) {
        let { loaderData: p, errors: f } = r, y = d.route.loader && !p.hasOwnProperty(d.route.id) && (!f || f[d.route.id] === void 0);
        if (d.route.lazy || y) {
          l = !0, s >= 0 ? o = o.slice(0, s + 1) : o = [o[0]];
          break;
        }
      }
    }
  let u = r && a ? (h, d) => {
    a(h, {
      location: r.location,
      params: r.matches?.[0]?.params ?? {},
      unstable_pattern: _e(r.matches),
      errorInfo: d
    });
  } : void 0;
  return o.reduceRight(
    (h, d, p) => {
      let f, y = !1, w = null, v = null;
      r && (f = i && d.route.id ? i[d.route.id] : void 0, w = d.route.errorElement || Gi, l && (s < 0 && p === 0 ? (zn(
        "route-fallback",
        !1,
        "No `HydrateFallback` element provided to render during initial hydration"
      ), y = !0, v = null) : s === p && (y = !0, v = d.route.hydrateFallbackElement || null)));
      let x = t.concat(o.slice(0, p + 1)), E = () => {
        let P;
        return f ? P = w : y ? P = v : d.route.Component ? P = /* @__PURE__ */ c.createElement(d.route.Component, null) : d.route.element ? P = d.route.element : P = h, /* @__PURE__ */ c.createElement(
          Qi,
          {
            match: d,
            routeContext: {
              outlet: h,
              matches: x,
              isDataRoute: r != null
            },
            children: P
          }
        );
      };
      return r && (d.route.ErrorBoundary || d.route.errorElement || p === 0) ? /* @__PURE__ */ c.createElement(
        Hn,
        {
          location: r.location,
          revalidation: r.revalidation,
          component: w,
          error: f,
          children: E(),
          routeContext: { outlet: null, matches: x, isDataRoute: !0 },
          onError: u
        }
      ) : E();
    },
    null
  );
}
function Br(e) {
  return `${e} must be used within a data router.  See https://reactrouter.com/en/main/routers/picking-a-router.`;
}
function Wr(e) {
  let t = c.useContext(Ae);
  return I(t, Br(e)), t;
}
function je(e) {
  let t = c.useContext(We);
  return I(t, Br(e)), t;
}
function Zi(e) {
  let t = c.useContext(ve);
  return I(t, Br(e)), t;
}
function ht(e) {
  let t = Zi(e), r = t.matches[t.matches.length - 1];
  return I(
    r.route.id,
    `${e} can only be used on routes that contain a unique "id"`
  ), r.route.id;
}
function qi() {
  return ht(
    "useRouteId"
    /* UseRouteId */
  );
}
function el() {
  return je(
    "useNavigation"
    /* UseNavigation */
  ).navigation;
}
function Us() {
  let e = Wr(
    "useRevalidator"
    /* UseRevalidator */
  ), t = je(
    "useRevalidator"
    /* UseRevalidator */
  ), r = c.useCallback(async () => {
    await e.router.revalidate();
  }, [e.router]);
  return c.useMemo(
    () => ({ revalidate: r, state: t.revalidation }),
    [r, t.revalidation]
  );
}
function Yr() {
  let { matches: e, loaderData: t } = je(
    "useMatches"
    /* UseMatches */
  );
  return c.useMemo(
    () => e.map((r) => tn(r, t)),
    [e, t]
  );
}
function Jr() {
  let e = je(
    "useLoaderData"
    /* UseLoaderData */
  ), t = ht(
    "useLoaderData"
    /* UseLoaderData */
  );
  return e.loaderData[t];
}
function zs(e) {
  return je(
    "useRouteLoaderData"
    /* UseRouteLoaderData */
  ).loaderData[e];
}
function Vr() {
  let e = je(
    "useActionData"
    /* UseActionData */
  ), t = ht(
    "useLoaderData"
    /* UseLoaderData */
  );
  return e.actionData ? e.actionData[t] : void 0;
}
function Kr() {
  let e = c.useContext(jr), t = je(
    "useRouteError"
    /* UseRouteError */
  ), r = ht(
    "useRouteError"
    /* UseRouteError */
  );
  return e !== void 0 ? e : t.errors?.[r];
}
function tl() {
  return c.useContext(dt)?._data;
}
function Bs() {
  return c.useContext(dt)?._error;
}
var rl = 0;
function al(e) {
  let { router: t, basename: r } = Wr(
    "useBlocker"
    /* UseBlocker */
  ), a = je(
    "useBlocker"
    /* UseBlocker */
  ), [n, o] = c.useState(""), i = c.useCallback(
    (l) => {
      if (typeof e != "function")
        return !!e;
      if (r === "/")
        return e(l);
      let { currentLocation: s, nextLocation: u, historyAction: h } = l;
      return e({
        currentLocation: {
          ...s,
          pathname: fe(s.pathname, r) || s.pathname
        },
        nextLocation: {
          ...u,
          pathname: fe(u.pathname, r) || u.pathname
        },
        historyAction: h
      });
    },
    [r, e]
  );
  return c.useEffect(() => {
    let l = String(++rl);
    return o(l), () => t.deleteBlocker(l);
  }, [t]), c.useEffect(() => {
    n !== "" && t.getBlocker(n, i);
  }, [t, n, i]), n && a.blockers.has(n) ? a.blockers.get(n) : Qe;
}
function nl() {
  let { router: e } = Wr(
    "useNavigate"
    /* UseNavigateStable */
  ), t = ht(
    "useNavigate"
    /* UseNavigateStable */
  ), r = c.useRef(!1);
  return An(() => {
    r.current = !0;
  }), c.useCallback(
    async (n, o = {}) => {
      Q(r.current, In), r.current && (typeof n == "number" ? await e.navigate(n) : await e.navigate(n, { fromRouteId: t, ...o }));
    },
    [e, t]
  );
}
var Ha = {};
function zn(e, t, r) {
  !t && !Ha[e] && (Ha[e] = !0, Q(!1, r));
}
function Ws(...e) {
  const t = ht(
    "useRoute"
    /* UseRoute */
  ), r = e[0] ?? t, a = je(
    "useRoute"
    /* UseRoute */
  ), n = a.matches.find(({ route: o }) => o.id === r);
  if (n !== void 0)
    return {
      handle: n.route.handle,
      loaderData: a.loaderData[r],
      actionData: a.actionData?.[r]
    };
}
var Ua = {};
function Sr(e, t) {
  !e && !Ua[t] && (Ua[t] = !0, console.warn(t));
}
var ol = "useOptimistic", za = c[ol], il = () => {
};
function ll(e) {
  return za ? za(e) : [e, il];
}
function Ot(e) {
  let t = {
    // Note: this check also occurs in createRoutesFromChildren so update
    // there if you change this -- please and thank you!
    hasErrorBoundary: e.hasErrorBoundary || e.ErrorBoundary != null || e.errorElement != null
  };
  return e.Component && (e.element && Q(
    !1,
    "You should not include both `Component` and `element` on your route - `Component` will be used."
  ), Object.assign(t, {
    element: c.createElement(e.Component),
    Component: void 0
  })), e.HydrateFallback && (e.hydrateFallbackElement && Q(
    !1,
    "You should not include both `HydrateFallback` and `hydrateFallbackElement` on your route - `HydrateFallback` will be used."
  ), Object.assign(t, {
    hydrateFallbackElement: c.createElement(e.HydrateFallback),
    HydrateFallback: void 0
  })), e.ErrorBoundary && (e.errorElement && Q(
    !1,
    "You should not include both `ErrorBoundary` and `errorElement` on your route - `ErrorBoundary` will be used."
  ), Object.assign(t, {
    errorElement: c.createElement(e.ErrorBoundary),
    ErrorBoundary: void 0
  })), t;
}
var Gr = [
  "HydrateFallback",
  "hydrateFallbackElement"
];
function Ys(e, t) {
  return kr({
    basename: t?.basename,
    getContext: t?.getContext,
    future: t?.future,
    history: Xa({
      initialEntries: t?.initialEntries,
      initialIndex: t?.initialIndex
    }),
    hydrationData: t?.hydrationData,
    routes: e,
    hydrationRouteProperties: Gr,
    mapRouteProperties: Ot,
    dataStrategy: t?.dataStrategy,
    patchRoutesOnNavigation: t?.patchRoutesOnNavigation,
    unstable_instrumentations: t?.unstable_instrumentations
  }).initialize();
}
var sl = class {
  constructor() {
    this.status = "pending", this.promise = new Promise((e, t) => {
      this.resolve = (r) => {
        this.status === "pending" && (this.status = "resolved", e(r));
      }, this.reject = (r) => {
        this.status === "pending" && (this.status = "rejected", t(r));
      };
    });
  }
};
function Js({
  router: e,
  flushSync: t,
  onError: r,
  unstable_useTransitions: a
}) {
  a = kn() || a;
  let [o, i] = c.useState(e.state), [l, s] = ll(o), [u, h] = c.useState(), [d, p] = c.useState({
    isTransitioning: !1
  }), [f, y] = c.useState(), [w, v] = c.useState(), [x, E] = c.useState(), P = c.useRef(/* @__PURE__ */ new Map()), L = c.useCallback(
    (T, { deletedFetchers: O, newErrors: j, flushSync: $, viewTransitionOpts: z }) => {
      j && r && Object.values(j).forEach(
        (Z) => r(Z, {
          location: T.location,
          params: T.matches[0]?.params ?? {},
          unstable_pattern: _e(T.matches)
        })
      ), T.fetchers.forEach((Z, W) => {
        Z.data !== void 0 && P.current.set(W, Z.data);
      }), O.forEach((Z) => P.current.delete(Z)), Sr(
        $ === !1 || t != null,
        'You provided the `flushSync` option to a router update, but you are not using the `<RouterProvider>` from `react-router/dom` so `ReactDOM.flushSync()` is unavailable.  Please update your app to `import { RouterProvider } from "react-router/dom"` and ensure you have `react-dom` installed as a dependency to use the `flushSync` option.'
      );
      let V = e.window != null && e.window.document != null && typeof e.window.document.startViewTransition == "function";
      if (Sr(
        z == null || V,
        "You provided the `viewTransition` option to a router update, but you do not appear to be running in a DOM environment as `window.startViewTransition` is not available."
      ), !z || !V) {
        t && $ ? t(() => i(T)) : a === !1 ? i(T) : c.startTransition(() => {
          a === !0 && s((Z) => Ba(Z, T)), i(T);
        });
        return;
      }
      if (t && $) {
        t(() => {
          w && (f?.resolve(), w.skipTransition()), p({
            isTransitioning: !0,
            flushSync: !0,
            currentLocation: z.currentLocation,
            nextLocation: z.nextLocation
          });
        });
        let Z = e.window.document.startViewTransition(() => {
          t(() => i(T));
        });
        Z.finished.finally(() => {
          t(() => {
            y(void 0), v(void 0), h(void 0), p({ isTransitioning: !1 });
          });
        }), t(() => v(Z));
        return;
      }
      w ? (f?.resolve(), w.skipTransition(), E({
        state: T,
        currentLocation: z.currentLocation,
        nextLocation: z.nextLocation
      })) : (h(T), p({
        isTransitioning: !0,
        flushSync: !1,
        currentLocation: z.currentLocation,
        nextLocation: z.nextLocation
      }));
    },
    [
      e.window,
      t,
      w,
      f,
      a,
      s,
      r
    ]
  );
  c.useLayoutEffect(() => e.subscribe(L), [e, L]), c.useEffect(() => {
    d.isTransitioning && !d.flushSync && y(new sl());
  }, [d]), c.useEffect(() => {
    if (f && u && e.window) {
      let T = u, O = f.promise, j = e.window.document.startViewTransition(async () => {
        a === !1 ? i(T) : c.startTransition(() => {
          a === !0 && s(($) => Ba($, T)), i(T);
        }), await O;
      });
      j.finished.finally(() => {
        y(void 0), v(void 0), h(void 0), p({ isTransitioning: !1 });
      }), v(j);
    }
  }, [
    u,
    f,
    e.window,
    a,
    s
  ]), c.useEffect(() => {
    f && u && l.location.key === u.location.key && f.resolve();
  }, [f, w, l.location, u]), c.useEffect(() => {
    !d.isTransitioning && x && (h(x.state), p({
      isTransitioning: !0,
      flushSync: !1,
      currentLocation: x.currentLocation,
      nextLocation: x.nextLocation
    }), E(void 0));
  }, [d.isTransitioning, x]);
  let C = c.useMemo(() => ({
    createHref: e.createHref,
    encodeLocation: e.encodeLocation,
    go: (T) => e.navigate(T),
    push: (T, O, j) => e.navigate(T, {
      state: O,
      preventScrollReset: j?.preventScrollReset
    }),
    replace: (T, O, j) => e.navigate(T, {
      replace: !0,
      state: O,
      preventScrollReset: j?.preventScrollReset
    })
  }), [e]), S = e.basename || "/", b = c.useMemo(
    () => ({
      router: e,
      navigator: C,
      static: !1,
      basename: S,
      onError: r
    }),
    [e, C, S, r]
  );
  return /* @__PURE__ */ c.createElement(c.Fragment, null, /* @__PURE__ */ c.createElement(Ae.Provider, { value: b }, /* @__PURE__ */ c.createElement(We.Provider, { value: l }, /* @__PURE__ */ c.createElement(qt.Provider, { value: P.current }, /* @__PURE__ */ c.createElement(Zt.Provider, { value: d }, /* @__PURE__ */ c.createElement(
    rt,
    {
      basename: S,
      location: l.location,
      navigationType: l.historyAction,
      navigator: C,
      unstable_useTransitions: a
    },
    /* @__PURE__ */ c.createElement(
      ul,
      {
        routes: e.routes,
        future: e.future,
        state: l,
        onError: r
      }
    )
  ))))), null);
}
function Ba(e, t) {
  return {
    // Don't surface "current location specific" stuff mid-navigation
    // (historyAction, location, matches, loaderData, errors, initialized,
    // restoreScroll, preventScrollReset, blockers, etc.)
    ...e,
    // Only surface "pending/in-flight stuff"
    // (navigation, revalidation, actionData, fetchers, )
    navigation: t.navigation.state !== "idle" ? t.navigation : e.navigation,
    revalidation: t.revalidation !== "idle" ? t.revalidation : e.revalidation,
    actionData: t.navigation.state !== "submitting" ? t.actionData : e.actionData,
    fetchers: t.fetchers
  };
}
var ul = c.memo(cl);
function cl({
  routes: e,
  future: t,
  state: r,
  onError: a
}) {
  return zr(e, void 0, r, a, t);
}
function Vs({
  basename: e,
  children: t,
  initialEntries: r,
  initialIndex: a,
  unstable_useTransitions: n
}) {
  let o = c.useRef();
  o.current == null && (o.current = Xa({
    initialEntries: r,
    initialIndex: a,
    v5Compat: !0
  }));
  let i = o.current, [l, s] = c.useState({
    action: i.action,
    location: i.location
  }), u = c.useCallback(
    (h) => {
      n === !1 ? s(h) : c.startTransition(() => s(h));
    },
    [n]
  );
  return c.useLayoutEffect(() => i.listen(u), [i, u]), /* @__PURE__ */ c.createElement(
    rt,
    {
      basename: e,
      children: t,
      location: l.location,
      navigationType: l.action,
      navigator: i,
      unstable_useTransitions: n
    }
  );
}
function Ks({
  to: e,
  replace: t,
  state: r,
  relative: a
}) {
  I(
    tt(),
    // TODO: This error is probably because they somehow have 2 versions of
    // the router loaded. We can help them understand how to avoid that.
    "<Navigate> may be used only in the context of a <Router> component."
  );
  let { static: n } = c.useContext(he);
  Q(
    !n,
    "<Navigate> must not be used on the initial render in a <StaticRouter>. This is a no-op, but you should modify your code so the <Navigate> is only ever rendered in response to some user interaction or state change."
  );
  let { matches: o } = c.useContext(ve), { pathname: i } = ge(), l = Hr(), s = Qt(
    e,
    Xt(o),
    i,
    a === "path"
  ), u = JSON.stringify(s);
  return c.useEffect(() => {
    l(JSON.parse(u), { replace: t, state: r, relative: a });
  }, [l, u, a, t, r]), null;
}
function Gs(e) {
  return Ji(e.context);
}
function dl(e) {
  I(
    !1,
    "A <Route> is only ever to be used as the child of <Routes> element, never rendered directly. Please wrap your <Route> in a <Routes>."
  );
}
function rt({
  basename: e = "/",
  children: t = null,
  location: r,
  navigationType: a = "POP",
  navigator: n,
  static: o = !1,
  unstable_useTransitions: i
}) {
  I(
    !tt(),
    "You cannot render a <Router> inside another <Router>. You should never have more than one in your app."
  );
  let l = e.replace(/^\/*/, "/"), s = c.useMemo(
    () => ({
      basename: l,
      navigator: n,
      static: o,
      unstable_useTransitions: i,
      future: {}
    }),
    [l, n, o, i]
  );
  typeof r == "string" && (r = Ce(r));
  let {
    pathname: u = "/",
    search: h = "",
    hash: d = "",
    state: p = null,
    key: f = "default"
  } = r, y = c.useMemo(() => {
    let w = fe(u, l);
    return w == null ? null : {
      location: {
        pathname: w,
        search: h,
        hash: d,
        state: p,
        key: f
      },
      navigationType: a
    };
  }, [l, u, h, d, p, f, a]);
  return Q(
    y != null,
    `<Router basename="${l}"> is not able to match the URL "${u}${h}${d}" because it does not start with the basename, so the <Router> won't render anything.`
  ), y == null ? null : /* @__PURE__ */ c.createElement(he.Provider, { value: s }, /* @__PURE__ */ c.createElement(ft.Provider, { children: t, value: y }));
}
function Xs({
  children: e,
  location: t
}) {
  return Vi(Jt(e), t);
}
function Qs({
  children: e,
  errorElement: t,
  resolve: r
}) {
  let a = c.useContext(Ae), n = c.useContext(We), o = c.useCallback(
    (i, l) => {
      a && a.onError && n && a.onError(i, {
        location: n.location,
        params: n.matches[0]?.params || {},
        unstable_pattern: _e(n.matches),
        errorInfo: l
      });
    },
    [a, n]
  );
  return /* @__PURE__ */ c.createElement(
    fl,
    {
      resolve: r,
      errorElement: t,
      onError: o
    },
    /* @__PURE__ */ c.createElement(hl, null, e)
  );
}
var fl = class extends c.Component {
  constructor(e) {
    super(e), this.state = { error: null };
  }
  static getDerivedStateFromError(e) {
    return { error: e };
  }
  componentDidCatch(e, t) {
    this.props.onError ? this.props.onError(e, t) : console.error(
      "<Await> caught the following error during render",
      e,
      t
    );
  }
  render() {
    let { children: e, errorElement: t, resolve: r } = this.props, a = null, n = 0;
    if (!(r instanceof Promise))
      n = 1, a = Promise.resolve(), Object.defineProperty(a, "_tracked", { get: () => !0 }), Object.defineProperty(a, "_data", { get: () => r });
    else if (this.state.error) {
      n = 2;
      let o = this.state.error;
      a = Promise.reject().catch(() => {
      }), Object.defineProperty(a, "_tracked", { get: () => !0 }), Object.defineProperty(a, "_error", { get: () => o });
    } else r._tracked ? (a = r, n = "_error" in a ? 2 : "_data" in a ? 1 : 0) : (n = 0, Object.defineProperty(r, "_tracked", { get: () => !0 }), a = r.then(
      (o) => Object.defineProperty(r, "_data", { get: () => o }),
      (o) => {
        this.props.onError?.(o), Object.defineProperty(r, "_error", { get: () => o });
      }
    ));
    if (n === 2 && !t)
      throw a._error;
    if (n === 2)
      return /* @__PURE__ */ c.createElement(dt.Provider, { value: a, children: t });
    if (n === 1)
      return /* @__PURE__ */ c.createElement(dt.Provider, { value: a, children: e });
    throw a;
  }
};
function hl({
  children: e
}) {
  let t = tl(), r = typeof e == "function" ? e(t) : e;
  return /* @__PURE__ */ c.createElement(c.Fragment, null, r);
}
function Jt(e, t = []) {
  let r = [];
  return c.Children.forEach(e, (a, n) => {
    if (!c.isValidElement(a))
      return;
    let o = [...t, n];
    if (a.type === c.Fragment) {
      r.push.apply(
        r,
        Jt(a.props.children, o)
      );
      return;
    }
    I(
      a.type === dl,
      `[${typeof a.type == "string" ? a.type : a.type.name}] is not a <Route> component. All component children of <Routes> must be a <Route> or <React.Fragment>`
    ), I(
      !a.props.index || !a.props.children,
      "An index route cannot have child routes."
    );
    let i = {
      id: a.props.id || o.join("-"),
      caseSensitive: a.props.caseSensitive,
      element: a.props.element,
      Component: a.props.Component,
      index: a.props.index,
      path: a.props.path,
      middleware: a.props.middleware,
      loader: a.props.loader,
      action: a.props.action,
      hydrateFallbackElement: a.props.hydrateFallbackElement,
      HydrateFallback: a.props.HydrateFallback,
      errorElement: a.props.errorElement,
      ErrorBoundary: a.props.ErrorBoundary,
      hasErrorBoundary: a.props.hasErrorBoundary === !0 || a.props.ErrorBoundary != null || a.props.errorElement != null,
      shouldRevalidate: a.props.shouldRevalidate,
      handle: a.props.handle,
      lazy: a.props.lazy
    };
    a.props.children && (i.children = Jt(
      a.props.children,
      o
    )), r.push(i);
  }), r;
}
var Zs = Jt;
function qs(e) {
  return Un(e);
}
function Bn() {
  return {
    params: Ur(),
    loaderData: Jr(),
    actionData: Vr(),
    matches: Yr()
  };
}
function eu({
  children: e
}) {
  const t = Bn();
  return c.cloneElement(e, t);
}
function tu(e) {
  return function() {
    const r = Bn();
    return c.createElement(e, r);
  };
}
function Wn() {
  return {
    params: Ur(),
    loaderData: Jr(),
    actionData: Vr()
  };
}
function ru({
  children: e
}) {
  const t = Wn();
  return c.cloneElement(e, t);
}
function au(e) {
  return function() {
    const r = Wn();
    return c.createElement(e, r);
  };
}
function Yn() {
  return {
    params: Ur(),
    loaderData: Jr(),
    actionData: Vr(),
    error: Kr()
  };
}
function nu({
  children: e
}) {
  const t = Yn();
  return c.cloneElement(e, t);
}
function ou(e) {
  return function() {
    const r = Yn();
    return c.createElement(e, r);
  };
}
var Bt = "get", Wt = "application/x-www-form-urlencoded";
function er(e) {
  return typeof HTMLElement < "u" && e instanceof HTMLElement;
}
function ml(e) {
  return er(e) && e.tagName.toLowerCase() === "button";
}
function pl(e) {
  return er(e) && e.tagName.toLowerCase() === "form";
}
function yl(e) {
  return er(e) && e.tagName.toLowerCase() === "input";
}
function vl(e) {
  return !!(e.metaKey || e.altKey || e.ctrlKey || e.shiftKey);
}
function gl(e, t) {
  return e.button === 0 && // Ignore everything but left clicks
  (!t || t === "_self") && // Let browser handle "target=_blank" etc.
  !vl(e);
}
function xr(e = "") {
  return new URLSearchParams(
    typeof e == "string" || Array.isArray(e) || e instanceof URLSearchParams ? e : Object.keys(e).reduce((t, r) => {
      let a = e[r];
      return t.concat(
        Array.isArray(a) ? a.map((n) => [r, n]) : [[r, a]]
      );
    }, [])
  );
}
function wl(e, t) {
  let r = xr(e);
  return t && t.forEach((a, n) => {
    r.has(n) || t.getAll(n).forEach((o) => {
      r.append(n, o);
    });
  }), r;
}
var At = null;
function bl() {
  if (At === null)
    try {
      new FormData(
        document.createElement("form"),
        // @ts-expect-error if FormData supports the submitter parameter, this will throw
        0
      ), At = !1;
    } catch {
      At = !0;
    }
  return At;
}
var El = /* @__PURE__ */ new Set([
  "application/x-www-form-urlencoded",
  "multipart/form-data",
  "text/plain"
]);
function fr(e) {
  return e != null && !El.has(e) ? (Q(
    !1,
    `"${e}" is not a valid \`encType\` for \`<Form>\`/\`<fetcher.Form>\` and will default to "${Wt}"`
  ), null) : e;
}
function Rl(e, t) {
  let r, a, n, o, i;
  if (pl(e)) {
    let l = e.getAttribute("action");
    a = l ? fe(l, t) : null, r = e.getAttribute("method") || Bt, n = fr(e.getAttribute("enctype")) || Wt, o = new FormData(e);
  } else if (ml(e) || yl(e) && (e.type === "submit" || e.type === "image")) {
    let l = e.form;
    if (l == null)
      throw new Error(
        'Cannot submit a <button> or <input type="submit"> without a <form>'
      );
    let s = e.getAttribute("formaction") || l.getAttribute("action");
    if (a = s ? fe(s, t) : null, r = e.getAttribute("formmethod") || l.getAttribute("method") || Bt, n = fr(e.getAttribute("formenctype")) || fr(l.getAttribute("enctype")) || Wt, o = new FormData(l, e), !bl()) {
      let { name: u, type: h, value: d } = e;
      if (h === "image") {
        let p = u ? `${u}.` : "";
        o.append(`${p}x`, "0"), o.append(`${p}y`, "0");
      } else u && o.append(u, d);
    }
  } else {
    if (er(e))
      throw new Error(
        'Cannot submit element that is not <form>, <button>, or <input type="submit|image">'
      );
    r = Bt, a = null, n = Wt, i = e;
  }
  return o && n === "text/plain" && (i = o, o = void 0), { action: a, method: r.toLowerCase(), encType: n, formData: o, body: i };
}
var Jn = -1, Vn = -2, Kn = -3, Gn = -4, Xr = -5, Xn = -6, Qn = -7, Zn = "B", qn = "D", ut = "E", Pr = "M", eo = "N", ct = "P", to = "R", Cr = "S", ro = "Y", ao = "U", Lr = "Z", no = class {
  constructor() {
    this.promise = new Promise((e, t) => {
      this.resolve = e, this.reject = t;
    });
  }
};
function Sl() {
  const e = new TextDecoder();
  let t = "";
  return new TransformStream({
    transform(r, a) {
      const n = e.decode(r, { stream: !0 }), o = (t + n).split(`
`);
      t = o.pop() || "";
      for (const i of o)
        a.enqueue(i);
    },
    flush(r) {
      t && r.enqueue(t);
    }
  });
}
function Se(e) {
  const { indices: t } = this, r = t.get(e);
  if (r) return [r];
  if (e === void 0) return Qn;
  if (e === null) return Xr;
  if (Number.isNaN(e)) return Vn;
  if (e === Number.POSITIVE_INFINITY) return Xn;
  if (e === Number.NEGATIVE_INFINITY) return Kn;
  if (e === 0 && 1 / e < 0) return Gn;
  const a = this.index++;
  return t.set(e, a), xl.call(this, e, a), a;
}
function xl(e, t) {
  const { deferred: r, plugins: a, postPlugins: n } = this, o = this.stringified, i = [[e, t]];
  for (; i.length > 0; ) {
    const [l, s] = i.pop(), u = (d) => Object.keys(d).map((p) => `"_${Se.call(this, p)}":${Se.call(this, d[p])}`).join(",");
    let h = null;
    switch (typeof l) {
      case "boolean":
      case "number":
      case "string":
        o[s] = JSON.stringify(l);
        break;
      case "bigint":
        o[s] = `["${Zn}","${l}"]`;
        break;
      case "symbol": {
        const d = Symbol.keyFor(l);
        d ? o[s] = `["${ro}",${JSON.stringify(d)}]` : h = new Error(
          "Cannot encode symbol unless created with Symbol.for()"
        );
        break;
      }
      case "object": {
        if (!l) {
          o[s] = `${Xr}`;
          break;
        }
        const d = Array.isArray(l);
        let p = !1;
        if (!d && a)
          for (const f of a) {
            const y = f(l);
            if (Array.isArray(y)) {
              p = !0;
              const [w, ...v] = y;
              o[s] = `[${JSON.stringify(w)}`, v.length > 0 && (o[s] += `,${v.map((x) => Se.call(this, x)).join(",")}`), o[s] += "]";
              break;
            }
          }
        if (!p) {
          let f = d ? "[" : "{";
          if (d) {
            for (let y = 0; y < l.length; y++)
              f += (y ? "," : "") + (y in l ? Se.call(this, l[y]) : Jn);
            o[s] = `${f}]`;
          } else if (l instanceof Date) {
            const y = l.getTime();
            o[s] = `["${qn}",${Number.isNaN(y) ? JSON.stringify("invalid") : y}]`;
          } else l instanceof URL ? o[s] = `["${ao}",${JSON.stringify(l.href)}]` : l instanceof RegExp ? o[s] = `["${to}",${JSON.stringify(
            l.source
          )},${JSON.stringify(l.flags)}]` : l instanceof Set ? l.size > 0 ? o[s] = `["${Cr}",${[...l].map((y) => Se.call(this, y)).join(",")}]` : o[s] = `["${Cr}"]` : l instanceof Map ? l.size > 0 ? o[s] = `["${Pr}",${[...l].flatMap(([y, w]) => [
            Se.call(this, y),
            Se.call(this, w)
          ]).join(",")}]` : o[s] = `["${Pr}"]` : l instanceof Promise ? (o[s] = `["${ct}",${s}]`, r[s] = l) : l instanceof Error ? (o[s] = `["${ut}",${JSON.stringify(l.message)}`, l.name !== "Error" && (o[s] += `,${JSON.stringify(l.name)}`), o[s] += "]") : Object.getPrototypeOf(l) === null ? o[s] = `["${eo}",{${u(l)}}]` : Cl(l) ? o[s] = `{${u(l)}}` : h = new Error("Cannot encode object with prototype");
        }
        break;
      }
      default: {
        const d = Array.isArray(l);
        let p = !1;
        if (!d && a)
          for (const f of a) {
            const y = f(l);
            if (Array.isArray(y)) {
              p = !0;
              const [w, ...v] = y;
              o[s] = `[${JSON.stringify(w)}`, v.length > 0 && (o[s] += `,${v.map((x) => Se.call(this, x)).join(",")}`), o[s] += "]";
              break;
            }
          }
        p || (h = new Error("Cannot encode function or unexpected type"));
      }
    }
    if (h) {
      let d = !1;
      if (n)
        for (const p of n) {
          const f = p(l);
          if (Array.isArray(f)) {
            d = !0;
            const [y, ...w] = f;
            o[s] = `[${JSON.stringify(y)}`, w.length > 0 && (o[s] += `,${w.map((v) => Se.call(this, v)).join(",")}`), o[s] += "]";
            break;
          }
        }
      if (!d)
        throw h;
    }
  }
}
var Pl = Object.getOwnPropertyNames(Object.prototype).sort().join("\0");
function Cl(e) {
  const t = Object.getPrototypeOf(e);
  return t === Object.prototype || t === null || Object.getOwnPropertyNames(t).sort().join("\0") === Pl;
}
var hr = typeof window < "u" ? window : typeof globalThis < "u" ? globalThis : void 0;
function Dr(e) {
  const { hydrated: t, values: r } = this;
  if (typeof e == "number") return Wa.call(this, e);
  if (!Array.isArray(e) || !e.length) throw new SyntaxError();
  const a = r.length;
  for (const n of e)
    r.push(n);
  return t.length = r.length, Wa.call(this, a);
}
function Wa(e) {
  const { hydrated: t, values: r, deferred: a, plugins: n } = this;
  let o;
  const i = [
    [
      e,
      (s) => {
        o = s;
      }
    ]
  ];
  let l = [];
  for (; i.length > 0; ) {
    const [s, u] = i.pop();
    switch (s) {
      case Qn:
        u(void 0);
        continue;
      case Xr:
        u(null);
        continue;
      case Vn:
        u(NaN);
        continue;
      case Xn:
        u(1 / 0);
        continue;
      case Kn:
        u(-1 / 0);
        continue;
      case Gn:
        u(-0);
        continue;
    }
    if (t[s]) {
      u(t[s]);
      continue;
    }
    const h = r[s];
    if (!h || typeof h != "object") {
      t[s] = h, u(h);
      continue;
    }
    if (Array.isArray(h))
      if (typeof h[0] == "string") {
        const [d, p, f] = h;
        switch (d) {
          case qn:
            u(t[s] = new Date(p));
            continue;
          case ao:
            u(t[s] = new URL(p));
            continue;
          case Zn:
            u(t[s] = BigInt(p));
            continue;
          case to:
            u(t[s] = new RegExp(p, f));
            continue;
          case ro:
            u(t[s] = Symbol.for(p));
            continue;
          case Cr:
            const y = /* @__PURE__ */ new Set();
            t[s] = y;
            for (let L = h.length - 1; L > 0; L--)
              i.push([
                h[L],
                (C) => {
                  y.add(C);
                }
              ]);
            u(y);
            continue;
          case Pr:
            const w = /* @__PURE__ */ new Map();
            t[s] = w;
            for (let L = h.length - 2; L > 0; L -= 2) {
              const C = [];
              i.push([
                h[L + 1],
                (S) => {
                  C[1] = S;
                }
              ]), i.push([
                h[L],
                (S) => {
                  C[0] = S;
                }
              ]), l.push(() => {
                w.set(C[0], C[1]);
              });
            }
            u(w);
            continue;
          case eo:
            const v = /* @__PURE__ */ Object.create(null);
            t[s] = v;
            for (const L of Object.keys(p).reverse()) {
              const C = [];
              i.push([
                p[L],
                (S) => {
                  C[1] = S;
                }
              ]), i.push([
                Number(L.slice(1)),
                (S) => {
                  C[0] = S;
                }
              ]), l.push(() => {
                v[C[0]] = C[1];
              });
            }
            u(v);
            continue;
          case ct:
            if (t[p])
              u(t[s] = t[p]);
            else {
              const L = new no();
              a[p] = L, u(t[s] = L.promise);
            }
            continue;
          case ut:
            const [, x, E] = h;
            let P = E && hr && hr[E] ? new hr[E](x) : new Error(x);
            t[s] = P, u(P);
            continue;
          case Lr:
            u(t[s] = t[p]);
            continue;
          default:
            if (Array.isArray(n)) {
              const L = [], C = h.slice(1);
              for (let S = 0; S < C.length; S++) {
                const b = C[S];
                i.push([
                  b,
                  (T) => {
                    L[S] = T;
                  }
                ]);
              }
              l.push(() => {
                for (const S of n) {
                  const b = S(h[0], ...L);
                  if (b) {
                    u(t[s] = b.value);
                    return;
                  }
                }
                throw new SyntaxError();
              });
              continue;
            }
            throw new SyntaxError();
        }
      } else {
        const d = [];
        t[s] = d;
        for (let p = 0; p < h.length; p++) {
          const f = h[p];
          f !== Jn && i.push([
            f,
            (y) => {
              d[p] = y;
            }
          ]);
        }
        u(d);
        continue;
      }
    else {
      const d = {};
      t[s] = d;
      for (const p of Object.keys(h).reverse()) {
        const f = [];
        i.push([
          h[p],
          (y) => {
            f[1] = y;
          }
        ]), i.push([
          Number(p.slice(1)),
          (y) => {
            f[0] = y;
          }
        ]), l.push(() => {
          d[f[0]] = f[1];
        });
      }
      u(d);
      continue;
    }
  }
  for (; l.length > 0; )
    l.pop()();
  return o;
}
async function Ll(e, t) {
  const { plugins: r } = t ?? {}, a = new no(), n = e.pipeThrough(Sl()).getReader(), o = {
    values: [],
    hydrated: [],
    deferred: {},
    plugins: r
  }, i = await Dl.call(o, n);
  let l = a.promise;
  return i.done ? a.resolve() : l = Ol.call(o, n).then(a.resolve).catch((s) => {
    for (const u of Object.values(o.deferred))
      u.reject(s);
    a.reject(s);
  }), {
    done: l.then(() => n.closed),
    value: i.value
  };
}
async function Dl(e) {
  const t = await e.read();
  if (!t.value)
    throw new SyntaxError();
  let r;
  try {
    r = JSON.parse(t.value);
  } catch {
    throw new SyntaxError();
  }
  return {
    done: t.done,
    value: Dr.call(this, r)
  };
}
async function Ol(e) {
  let t = await e.read();
  for (; !t.done; ) {
    if (!t.value) continue;
    const r = t.value;
    switch (r[0]) {
      case ct: {
        const a = r.indexOf(":"), n = Number(r.slice(1, a)), o = this.deferred[n];
        if (!o)
          throw new Error(`Deferred ID ${n} not found in stream`);
        const i = r.slice(a + 1);
        let l;
        try {
          l = JSON.parse(i);
        } catch {
          throw new SyntaxError();
        }
        const s = Dr.call(this, l);
        o.resolve(s);
        break;
      }
      case ut: {
        const a = r.indexOf(":"), n = Number(r.slice(1, a)), o = this.deferred[n];
        if (!o)
          throw new Error(`Deferred ID ${n} not found in stream`);
        const i = r.slice(a + 1);
        let l;
        try {
          l = JSON.parse(i);
        } catch {
          throw new SyntaxError();
        }
        const s = Dr.call(this, l);
        o.reject(s);
        break;
      }
      default:
        throw new SyntaxError();
    }
    t = await e.read();
  }
}
function iu(e, t) {
  const { plugins: r, postPlugins: a, signal: n } = t ?? {}, o = {
    deferred: {},
    index: 0,
    indices: /* @__PURE__ */ new Map(),
    stringified: [],
    plugins: r,
    postPlugins: a,
    signal: n
  }, i = new TextEncoder();
  let l = 0;
  return new ReadableStream({
    async start(u) {
      const h = Se.call(o, e);
      if (Array.isArray(h))
        throw new Error("This should never happen");
      h < 0 ? u.enqueue(i.encode(`${h}
`)) : (u.enqueue(
        i.encode(`[${o.stringified.join(",")}]
`)
      ), l = o.stringified.length - 1);
      const d = /* @__PURE__ */ new WeakSet();
      if (Object.keys(o.deferred).length) {
        let p;
        const f = new Promise((y, w) => {
          if (p = y, n) {
            const v = () => w(n.reason || new Error("Signal was aborted."));
            n.aborted ? v() : n.addEventListener("abort", (x) => {
              v();
            });
          }
        });
        for (; Object.keys(o.deferred).length > 0; ) {
          for (const [y, w] of Object.entries(
            o.deferred
          ))
            d.has(w) || d.add(
              // biome-ignore lint/suspicious/noAssignInExpressions: <explanation>
              o.deferred[Number(y)] = Promise.race([
                f,
                w
              ]).then(
                (v) => {
                  const x = Se.call(o, v);
                  if (Array.isArray(x))
                    u.enqueue(
                      i.encode(
                        `${ct}${y}:[["${Lr}",${x[0]}]]
`
                      )
                    ), o.index++, l++;
                  else if (x < 0)
                    u.enqueue(
                      i.encode(
                        `${ct}${y}:${x}
`
                      )
                    );
                  else {
                    const E = o.stringified.slice(l + 1).join(",");
                    u.enqueue(
                      i.encode(
                        `${ct}${y}:[${E}]
`
                      )
                    ), l = o.stringified.length - 1;
                  }
                },
                (v) => {
                  (!v || typeof v != "object" || !(v instanceof Error)) && (v = new Error("An unknown error occurred"));
                  const x = Se.call(o, v);
                  if (Array.isArray(x))
                    u.enqueue(
                      i.encode(
                        `${ut}${y}:[["${Lr}",${x[0]}]]
`
                      )
                    ), o.index++, l++;
                  else if (x < 0)
                    u.enqueue(
                      i.encode(
                        `${ut}${y}:${x}
`
                      )
                    );
                  else {
                    const E = o.stringified.slice(l + 1).join(",");
                    u.enqueue(
                      i.encode(
                        `${ut}${y}:[${E}]
`
                      )
                    ), l = o.stringified.length - 1;
                  }
                }
              ).finally(() => {
                delete o.deferred[Number(y)];
              })
            );
          await Promise.race(Object.values(o.deferred));
        }
        p();
      }
      await Promise.all(Object.values(o.deferred)), u.close();
    }
  });
}
async function Ml(e) {
  let t = { signal: e.signal };
  if (e.method !== "GET") {
    t.method = e.method;
    let r = e.headers.get("Content-Type");
    r && /\bapplication\/json\b/.test(r) ? (t.headers = { "Content-Type": r }, t.body = JSON.stringify(await e.json())) : r && /\btext\/plain\b/.test(r) ? (t.headers = { "Content-Type": r }, t.body = await e.text()) : r && /\bapplication\/x-www-form-urlencoded\b/.test(r) ? t.body = new URLSearchParams(await e.text()) : t.body = await e.formData();
  }
  return t;
}
var Tl = {
  "&": "\\u0026",
  ">": "\\u003e",
  "<": "\\u003c",
  "\u2028": "\\u2028",
  "\u2029": "\\u2029"
}, $l = /[&><\u2028\u2029]/g;
function Ct(e) {
  return e.replace($l, (t) => Tl[t]);
}
function ue(e, t) {
  if (e === !1 || e === null || typeof e > "u")
    throw new Error(t);
}
var Or = Symbol("SingleFetchRedirect"), oo = class extends Error {
}, Nl = 202, Fl = /* @__PURE__ */ new Set([100, 101, 204, 205]);
function kl({
  context: e,
  identifier: t,
  reader: r,
  textDecoder: a,
  nonce: n
}) {
  if (!e.renderMeta || !e.renderMeta.didRenderScripts)
    return null;
  e.renderMeta.streamCache || (e.renderMeta.streamCache = {});
  let { streamCache: o } = e.renderMeta, i = o[t];
  if (i || (i = o[t] = r.read().then((h) => {
    o[t].result = {
      done: h.done,
      value: a.decode(h.value, { stream: !0 })
    };
  }).catch((h) => {
    o[t].error = h;
  })), i.error)
    throw i.error;
  if (i.result === void 0)
    throw i;
  let { done: l, value: s } = i.result, u = s ? /* @__PURE__ */ c.createElement(
    "script",
    {
      nonce: n,
      dangerouslySetInnerHTML: {
        __html: `window.__reactRouterContext.streamController.enqueue(${Ct(
          JSON.stringify(s)
        )});`
      }
    }
  ) : null;
  return l ? /* @__PURE__ */ c.createElement(c.Fragment, null, u, /* @__PURE__ */ c.createElement(
    "script",
    {
      nonce: n,
      dangerouslySetInnerHTML: {
        __html: "window.__reactRouterContext.streamController.close();"
      }
    }
  )) : /* @__PURE__ */ c.createElement(c.Fragment, null, u, /* @__PURE__ */ c.createElement(c.Suspense, null, /* @__PURE__ */ c.createElement(
    kl,
    {
      context: e,
      identifier: t + 1,
      reader: r,
      textDecoder: a,
      nonce: n
    }
  )));
}
function lu(e, t, r, a, n, o) {
  let i = _l(
    e,
    (l) => {
      let s = t.routes[l.route.id];
      ue(s, "Route not found in manifest");
      let u = r[l.route.id];
      return {
        hasLoader: s.hasLoader,
        hasClientLoader: s.hasClientLoader,
        hasShouldRevalidate: !!u?.shouldRevalidate
      };
    },
    Bl,
    a,
    n,
    o
  );
  return async (l) => l.runClientMiddleware(i);
}
function _l(e, t, r, a, n, o, i = () => !0) {
  return async (l) => {
    let { request: s, matches: u, fetcherKey: h } = l, d = e();
    if (s.method !== "GET")
      return Il(
        l,
        r,
        n,
        o
      );
    let p = u.some((f) => {
      let { hasLoader: y, hasClientLoader: w } = t(f);
      return f.shouldCallHandler() && y && !w;
    });
    return !a && !p ? Al(
      l,
      t,
      r,
      n,
      o
    ) : h ? Ul(
      l,
      r,
      n,
      o
    ) : jl(
      l,
      d,
      t,
      r,
      a,
      n,
      o,
      i
    );
  };
}
async function Il(e, t, r, a) {
  let n = e.matches.find((l) => l.shouldCallHandler());
  ue(n, "No action match found");
  let o, i = await n.resolve(async (l) => await l(async () => {
    let { data: u, status: h } = await t(
      e,
      r,
      a,
      [n.route.id]
    );
    return o = h, Lt(u, n.route.id);
  }));
  return se(i.result) || Pe(i.result) || qe(i.result) ? { [n.route.id]: i } : {
    [n.route.id]: {
      type: i.type,
      result: yi(i.result, o)
    }
  };
}
async function Al(e, t, r, a, n) {
  let o = e.matches.filter((l) => l.shouldCallHandler()), i = {};
  return await Promise.all(
    o.map(
      (l) => l.resolve(async (s) => {
        try {
          let { hasClientLoader: u } = t(l), h = l.route.id, d = u ? await s(async () => {
            let { data: p } = await r(
              e,
              a,
              n,
              [h]
            );
            return Lt(p, h);
          }) : await s();
          i[l.route.id] = { type: "data", result: d };
        } catch (u) {
          i[l.route.id] = { type: "error", result: u };
        }
      })
    )
  ), i;
}
async function jl(e, t, r, a, n, o, i, l = () => !0) {
  let s = /* @__PURE__ */ new Set(), u = !1, h = e.matches.map(() => Ya()), d = Ya(), p = {}, f = Promise.all(
    e.matches.map(
      async (w, v) => w.resolve(async (x) => {
        h[v].resolve();
        let E = w.route.id, { hasLoader: P, hasClientLoader: L, hasShouldRevalidate: C } = r(w), S = !w.shouldRevalidateArgs || w.shouldRevalidateArgs.actionStatus == null || w.shouldRevalidateArgs.actionStatus < 400;
        if (!w.shouldCallHandler(S)) {
          u || (u = w.shouldRevalidateArgs != null && // This is a revalidation,
          P && // for a route with a server loader,
          C === !0);
          return;
        }
        if (l(w) && L) {
          P && (u = !0);
          try {
            let T = await x(async () => {
              let { data: O } = await a(
                e,
                o,
                i,
                [E]
              );
              return Lt(O, E);
            });
            p[E] = { type: "data", result: T };
          } catch (T) {
            p[E] = { type: "error", result: T };
          }
          return;
        }
        P && s.add(E);
        try {
          let T = await x(async () => {
            let O = await d.promise;
            return Lt(O, E);
          });
          p[E] = { type: "data", result: T };
        } catch (T) {
          p[E] = { type: "error", result: T };
        }
      })
    )
  );
  if (await Promise.all(h.map((w) => w.promise)), (!t.state.initialized && t.state.navigation.state === "idle" || s.size === 0) && !window.__reactRouterHdrActive)
    d.resolve({ routes: {} });
  else {
    let w = n && u && s.size > 0 ? [...s.keys()] : void 0;
    try {
      let v = await a(
        e,
        o,
        i,
        w
      );
      d.resolve(v.data);
    } catch (v) {
      d.reject(v);
    }
  }
  return await f, await Hl(
    d.promise,
    e.matches,
    s,
    p
  ), p;
}
async function Hl(e, t, r, a) {
  try {
    let n, o = await e;
    if ("routes" in o) {
      for (let i of t)
        if (i.route.id in o.routes) {
          let l = o.routes[i.route.id];
          if ("error" in l) {
            n = l.error, a[i.route.id]?.result == null && (a[i.route.id] = {
              type: "error",
              result: n
            });
            break;
          }
        }
    }
    n !== void 0 && Array.from(r.values()).forEach((i) => {
      a[i].result instanceof oo && (a[i].result = n);
    });
  } catch {
  }
}
async function Ul(e, t, r, a) {
  let n = e.matches.find((l) => l.shouldCallHandler());
  ue(n, "No fetcher match found");
  let o = n.route.id, i = await n.resolve(
    async (l) => l(async () => {
      let { data: s } = await t(e, r, a, [
        o
      ]);
      return Lt(s, o);
    })
  );
  return { [n.route.id]: i };
}
function zl(e) {
  let t = e.searchParams.getAll("index");
  e.searchParams.delete("index");
  let r = [];
  for (let a of t)
    a && r.push(a);
  for (let a of r)
    e.searchParams.append("index", a);
  return e;
}
function io(e, t, r, a) {
  let n = typeof e == "string" ? new URL(
    e,
    // This can be called during the SSR flow via PrefetchPageLinksImpl so
    // don't assume window is available
    typeof window > "u" ? "server://singlefetch/" : window.location.origin
  ) : e;
  return r ? n.pathname.endsWith("/") ? n.pathname = `${n.pathname}_.${a}` : n.pathname = `${n.pathname}.${a}` : n.pathname === "/" ? n.pathname = `_root.${a}` : t && fe(n.pathname, t) === "/" ? n.pathname = `${t.replace(/\/$/, "")}/_root.${a}` : n.pathname = `${n.pathname.replace(/\/$/, "")}.${a}`, n;
}
async function Bl(e, t, r, a) {
  let { request: n } = e, o = io(n.url, t, r, "data");
  n.method === "GET" && (o = zl(o), a && o.searchParams.set("_routes", a.join(",")));
  let i = await fetch(o, await Ml(n));
  if (i.status >= 400 && !i.headers.has("X-Remix-Response"))
    throw new Te(i.status, i.statusText, await i.text());
  if (i.status === 204 && i.headers.has("X-Remix-Redirect"))
    return {
      status: Nl,
      data: {
        redirect: {
          redirect: i.headers.get("X-Remix-Redirect"),
          status: Number(i.headers.get("X-Remix-Status") || "302"),
          revalidate: i.headers.get("X-Remix-Revalidate") === "true",
          reload: i.headers.get("X-Remix-Reload-Document") === "true",
          replace: i.headers.get("X-Remix-Replace") === "true"
        }
      }
    };
  if (Fl.has(i.status)) {
    let l = {};
    return a && n.method !== "GET" && (l[a[0]] = { data: void 0 }), {
      status: i.status,
      data: { routes: l }
    };
  }
  ue(i.body, "No response body to decode");
  try {
    let l = await Wl(i.body, window), s;
    if (n.method === "GET") {
      let u = l.value;
      Or in u ? s = { redirect: u[Or] } : s = { routes: u };
    } else {
      let u = l.value, h = a?.[0];
      ue(h, "No routeId found for single fetch call decoding"), "redirect" in u ? s = { redirect: u } : s = { routes: { [h]: u } };
    }
    return { status: i.status, data: s };
  } catch {
    throw new Error("Unable to decode turbo-stream response");
  }
}
function Wl(e, t) {
  return Ll(e, {
    plugins: [
      (r, ...a) => {
        if (r === "SanitizedError") {
          let [n, o, i] = a, l = Error;
          n && n in t && typeof t[n] == "function" && (l = t[n]);
          let s = new l(o);
          return s.stack = i, { value: s };
        }
        if (r === "ErrorResponse") {
          let [n, o, i] = a;
          return {
            value: new Te(o, i, n)
          };
        }
        if (r === "SingleFetchRedirect")
          return { value: { [Or]: a[0] } };
        if (r === "SingleFetchClassInstance")
          return { value: a[0] };
        if (r === "SingleFetchFallback")
          return { value: void 0 };
      }
    ]
  });
}
function Lt(e, t) {
  if ("redirect" in e) {
    let {
      redirect: a,
      revalidate: n,
      reload: o,
      replace: i,
      status: l
    } = e.redirect;
    throw Nr(a, {
      status: l,
      headers: {
        // Three R's of redirecting (lol Veep)
        ...n ? { "X-Remix-Revalidate": "yes" } : null,
        ...o ? { "X-Remix-Reload-Document": "yes" } : null,
        ...i ? { "X-Remix-Replace": "yes" } : null
      }
    });
  }
  let r = e.routes[t];
  if (r == null)
    throw new oo(
      `No result found for routeId "${t}"`
    );
  if ("error" in r)
    throw r.error;
  if ("data" in r)
    return r.data;
  throw new Error(`Invalid response found for routeId "${t}"`);
}
function Ya() {
  let e, t, r = new Promise((a, n) => {
    e = async (o) => {
      a(o);
      try {
        await r;
      } catch {
      }
    }, t = async (o) => {
      n(o);
      try {
        await r;
      } catch {
      }
    };
  });
  return {
    promise: r,
    //@ts-ignore
    resolve: e,
    //@ts-ignore
    reject: t
  };
}
async function lo(e, t) {
  if (e.id in t)
    return t[e.id];
  try {
    let r = await import(
      /* @vite-ignore */
      /* webpackIgnore: true */
      e.module
    );
    return t[e.id] = r, r;
  } catch (r) {
    return console.error(
      `Error loading route module \`${e.module}\`, reloading page...`
    ), console.error(r), window.__reactRouterContext && window.__reactRouterContext.isSpaMode, window.location.reload(), new Promise(() => {
    });
  }
}
function Yl(e, t, r) {
  let a = e.map((o) => {
    let i = t[o.route.id], l = r.routes[o.route.id];
    return [
      l && l.css ? l.css.map((s) => ({ rel: "stylesheet", href: s })) : [],
      i?.links?.() || []
    ];
  }).flat(2), n = Zr(e, r);
  return fo(a, n);
}
function so(e) {
  return e.css ? e.css.map((t) => ({ rel: "stylesheet", href: t })) : [];
}
async function Jl(e) {
  if (!e.css) return;
  let t = so(e);
  await Promise.all(t.map(co));
}
async function uo(e, t) {
  if (!e.css && !t.links || !Ql()) return;
  let r = [];
  if (e.css && r.push(...so(e)), t.links && r.push(...t.links()), r.length === 0) return;
  let a = [];
  for (let n of r)
    !Qr(n) && n.rel === "stylesheet" && a.push({
      ...n,
      rel: "preload",
      as: "style"
    });
  await Promise.all(a.map(co));
}
async function co(e) {
  return new Promise((t) => {
    if (e.media && !window.matchMedia(e.media).matches || document.querySelector(
      `link[rel="stylesheet"][href="${e.href}"]`
    ))
      return t();
    let r = document.createElement("link");
    Object.assign(r, e);
    function a() {
      document.head.contains(r) && document.head.removeChild(r);
    }
    r.onload = () => {
      a(), t();
    }, r.onerror = () => {
      a(), t();
    }, document.head.appendChild(r);
  });
}
function Qr(e) {
  return e != null && typeof e.page == "string";
}
function Vl(e) {
  return e == null ? !1 : e.href == null ? e.rel === "preload" && typeof e.imageSrcSet == "string" && typeof e.imageSizes == "string" : typeof e.rel == "string" && typeof e.href == "string";
}
async function Kl(e, t, r) {
  let a = await Promise.all(
    e.map(async (n) => {
      let o = t.routes[n.route.id];
      if (o) {
        let i = await lo(o, r);
        return i.links ? i.links() : [];
      }
      return [];
    })
  );
  return fo(
    a.flat(1).filter(Vl).filter((n) => n.rel === "stylesheet" || n.rel === "preload").map(
      (n) => n.rel === "stylesheet" ? { ...n, rel: "prefetch", as: "style" } : { ...n, rel: "prefetch" }
    )
  );
}
function Ja(e, t, r, a, n, o) {
  let i = (s, u) => r[u] ? s.route.id !== r[u].route.id : !0, l = (s, u) => (
    // param change, /users/123 -> /users/456
    r[u].pathname !== s.pathname || // splat param changed, which is not present in match.path
    // e.g. /files/images/avatar.jpg -> files/finances.xls
    r[u].route.path?.endsWith("*") && r[u].params["*"] !== s.params["*"]
  );
  return o === "assets" ? t.filter(
    (s, u) => i(s, u) || l(s, u)
  ) : o === "data" ? t.filter((s, u) => {
    let h = a.routes[s.route.id];
    if (!h || !h.hasLoader)
      return !1;
    if (i(s, u) || l(s, u))
      return !0;
    if (s.route.shouldRevalidate) {
      let d = s.route.shouldRevalidate({
        currentUrl: new URL(
          n.pathname + n.search + n.hash,
          window.origin
        ),
        currentParams: r[0]?.params || {},
        nextUrl: new URL(e, window.origin),
        nextParams: s.params,
        defaultShouldRevalidate: !0
      });
      if (typeof d == "boolean")
        return d;
    }
    return !0;
  }) : [];
}
function Zr(e, t, { includeHydrateFallback: r } = {}) {
  return Gl(
    e.map((a) => {
      let n = t.routes[a.route.id];
      if (!n) return [];
      let o = [n.module];
      return n.clientActionModule && (o = o.concat(n.clientActionModule)), n.clientLoaderModule && (o = o.concat(n.clientLoaderModule)), r && n.hydrateFallbackModule && (o = o.concat(n.hydrateFallbackModule)), n.imports && (o = o.concat(n.imports)), o;
    }).flat(1)
  );
}
function Gl(e) {
  return [...new Set(e)];
}
function Xl(e) {
  let t = {}, r = Object.keys(e).sort();
  for (let a of r)
    t[a] = e[a];
  return t;
}
function fo(e, t) {
  let r = /* @__PURE__ */ new Set(), a = new Set(t);
  return e.reduce((n, o) => {
    if (t && !Qr(o) && o.as === "script" && o.href && a.has(o.href))
      return n;
    let l = JSON.stringify(Xl(o));
    return r.has(l) || (r.add(l), n.push({ key: l, link: o })), n;
  }, []);
}
var jt;
function Ql() {
  if (jt !== void 0)
    return jt;
  let e = document.createElement("link");
  return jt = e.relList.supports("preload"), e = null, jt;
}
function Zl() {
  return /* @__PURE__ */ c.createElement(Mr, { title: "Loading...", renderScripts: !0 }, /* @__PURE__ */ c.createElement(
    "script",
    {
      dangerouslySetInnerHTML: {
        __html: `
              console.log(
                " Hey developer . You can provide a way better UX than this " +
                "when your app is loading JS modules and/or running \`clientLoader\` " +
                "functions. Check out https://reactrouter.com/start/framework/route-module#hydratefallback " +
                "for more information."
              );
            `
      }
    }
  ));
}
function qr(e) {
  let t = {};
  return Object.values(e).forEach((r) => {
    if (r) {
      let a = r.parentId || "";
      t[a] || (t[a] = []), t[a].push(r);
    }
  }), t;
}
function ho(e, t, r) {
  let a = mo(t), n = t.HydrateFallback && (!r || e.id === "root") ? t.HydrateFallback : e.id === "root" ? Zl : void 0, o = t.ErrorBoundary ? t.ErrorBoundary : e.id === "root" ? () => /* @__PURE__ */ c.createElement(vo, { error: Kr() }) : void 0;
  return e.id === "root" && t.Layout ? {
    ...a ? {
      element: /* @__PURE__ */ c.createElement(t.Layout, null, /* @__PURE__ */ c.createElement(a, null))
    } : { Component: a },
    ...o ? {
      errorElement: /* @__PURE__ */ c.createElement(t.Layout, null, /* @__PURE__ */ c.createElement(o, null))
    } : { ErrorBoundary: o },
    ...n ? {
      hydrateFallbackElement: /* @__PURE__ */ c.createElement(t.Layout, null, /* @__PURE__ */ c.createElement(n, null))
    } : { HydrateFallback: n }
  } : { Component: a, ErrorBoundary: o, HydrateFallback: n };
}
function ql(e, t, r, a, n = "", o = qr(e), i = Promise.resolve({ Component: () => null })) {
  return (o[n] || []).map((l) => {
    let s = t[l.id];
    ue(
      s,
      "No `routeModule` available to create server routes"
    );
    let u = {
      ...ho(l, s, a),
      caseSensitive: l.caseSensitive,
      id: l.id,
      index: l.index,
      path: l.path,
      handle: s.handle,
      // For SPA Mode, all routes are lazy except root.  However we tell the
      // router root is also lazy here too since we don't need a full
      // implementation - we just need a `lazy` prop to tell the RR rendering
      // where to stop which is always at the root route in SPA mode
      lazy: a ? () => i : void 0,
      // For partial hydration rendering, we need to indicate when the route
      // has a loader/clientLoader, but it won't ever be called during the static
      // render, so just give it a no-op function so we can render down to the
      // proper fallback
      loader: l.hasLoader || l.hasClientLoader ? () => null : void 0
      // We don't need middleware/action/shouldRevalidate on these routes since
      // they're for a static render
    }, h = ql(
      e,
      t,
      r,
      a,
      l.id,
      o,
      i
    );
    return h.length > 0 && (u.children = h), u;
  });
}
function su(e, t, r, a, n, o) {
  return ea(
    t,
    r,
    a,
    n,
    o,
    "",
    qr(t),
    e
  );
}
function Ht(e, t) {
  if (e === "loader" && !t.hasLoader || e === "action" && !t.hasAction) {
    let a = `You are trying to call ${e === "action" ? "serverAction()" : "serverLoader()"} on a route that does not have a server ${e} (routeId: "${t.id}")`;
    throw console.error(a), new Te(400, "Bad Request", new Error(a), !0);
  }
}
function mr(e, t) {
  let r = e === "clientAction" ? "a" : "an", a = `Route "${t}" does not have ${r} ${e}, but you are trying to submit to it. To fix this, please add ${r} \`${e}\` function to the route`;
  throw console.error(a), new Te(405, "Method Not Allowed", new Error(a), !0);
}
function ea(e, t, r, a, n, o = "", i = qr(e), l) {
  return (i[o] || []).map((s) => {
    let u = t[s.id];
    function h(E) {
      return ue(
        typeof E == "function",
        "No single fetch function available for route handler"
      ), E();
    }
    function d(E) {
      return s.hasLoader ? h(E) : Promise.resolve(null);
    }
    function p(E) {
      if (!s.hasAction)
        throw mr("action", s.id);
      return h(E);
    }
    function f(E) {
      import(
        /* @vite-ignore */
        /* webpackIgnore: true */
        E
      );
    }
    function y(E) {
      E.clientActionModule && f(E.clientActionModule), E.clientLoaderModule && f(E.clientLoaderModule);
    }
    async function w(E) {
      let P = t[s.id], L = P ? uo(s, P) : Promise.resolve();
      try {
        return E();
      } finally {
        await L;
      }
    }
    let v = {
      id: s.id,
      index: s.index,
      path: s.path
    };
    if (u) {
      Object.assign(v, {
        ...v,
        ...ho(s, u, n),
        middleware: u.clientMiddleware,
        handle: u.handle,
        shouldRevalidate: Va(
          v.path,
          u,
          s,
          a,
          l
        )
      });
      let E = r && r.loaderData && s.id in r.loaderData, P = E ? r?.loaderData?.[s.id] : void 0, L = r && r.errors && s.id in r.errors, C = L ? r?.errors?.[s.id] : void 0, S = l == null && (u.clientLoader?.hydrate === !0 || !s.hasLoader);
      v.loader = async ({ request: b, params: T, context: O, unstable_pattern: j }, $) => {
        try {
          return await w(async () => (ue(
            u,
            "No `routeModule` available for critical-route loader"
          ), u.clientLoader ? u.clientLoader({
            request: b,
            params: T,
            context: O,
            unstable_pattern: j,
            async serverLoader() {
              if (Ht("loader", s), S) {
                if (E)
                  return P;
                if (L)
                  throw C;
              }
              return d($);
            }
          }) : d($)));
        } finally {
          S = !1;
        }
      }, v.loader.hydrate = rs(
        s.id,
        u.clientLoader,
        s.hasLoader,
        n
      ), v.action = ({ request: b, params: T, context: O, unstable_pattern: j }, $) => w(async () => {
        if (ue(
          u,
          "No `routeModule` available for critical-route action"
        ), !u.clientAction) {
          if (n)
            throw mr("clientAction", s.id);
          return p($);
        }
        return u.clientAction({
          request: b,
          params: T,
          context: O,
          unstable_pattern: j,
          async serverAction() {
            return Ht("action", s), p($);
          }
        });
      });
    } else {
      s.hasClientLoader || (v.loader = (L, C) => w(() => d(C))), s.hasClientAction || (v.action = (L, C) => w(() => {
        if (n)
          throw mr("clientAction", s.id);
        return p(C);
      }));
      let E;
      async function P() {
        return E ? await E : (E = (async () => {
          (s.clientLoaderModule || s.clientActionModule) && await new Promise((C) => setTimeout(C, 0));
          let L = ts(
            s,
            t
          );
          return y(s), await L;
        })(), await E);
      }
      v.lazy = {
        loader: s.hasClientLoader ? async () => {
          let { clientLoader: L } = s.clientLoaderModule ? await import(
            /* @vite-ignore */
            /* webpackIgnore: true */
            s.clientLoaderModule
          ) : await P();
          return ue(L, "No `clientLoader` export found"), (C, S) => L({
            ...C,
            async serverLoader() {
              return Ht("loader", s), d(S);
            }
          });
        } : void 0,
        action: s.hasClientAction ? async () => {
          let L = s.clientActionModule ? import(
            /* @vite-ignore */
            /* webpackIgnore: true */
            s.clientActionModule
          ) : P();
          y(s);
          let { clientAction: C } = await L;
          return ue(C, "No `clientAction` export found"), (S, b) => C({
            ...S,
            async serverAction() {
              return Ht("action", s), p(b);
            }
          });
        } : void 0,
        middleware: s.hasClientMiddleware ? async () => {
          let { clientMiddleware: L } = s.clientMiddlewareModule ? await import(
            /* @vite-ignore */
            /* webpackIgnore: true */
            s.clientMiddlewareModule
          ) : await P();
          return ue(L, "No `clientMiddleware` export found"), L;
        } : void 0,
        shouldRevalidate: async () => {
          let L = await P();
          return Va(
            v.path,
            L,
            s,
            a,
            l
          );
        },
        handle: async () => (await P()).handle,
        // No need to wrap these in layout since the root route is never
        // loaded via route.lazy()
        Component: async () => (await P()).Component,
        ErrorBoundary: s.hasErrorBoundary ? async () => (await P()).ErrorBoundary : void 0
      };
    }
    let x = ea(
      e,
      t,
      r,
      a,
      n,
      s.id,
      i,
      l
    );
    return x.length > 0 && (v.children = x), v;
  });
}
function Va(e, t, r, a, n) {
  if (n)
    return es(
      r.id,
      t.shouldRevalidate,
      n
    );
  if (!a && r.hasLoader && !r.hasClientLoader) {
    let o = e ? nn(e)[1].map((l) => l.paramName) : [];
    const i = (l) => o.some((s) => l.currentParams[s] !== l.nextParams[s]);
    if (t.shouldRevalidate) {
      let l = t.shouldRevalidate;
      return (s) => l({
        ...s,
        defaultShouldRevalidate: i(s)
      });
    } else
      return (l) => i(l);
  }
  return t.shouldRevalidate;
}
function es(e, t, r) {
  let a = !1;
  return (n) => a ? t ? t(n) : n.defaultShouldRevalidate : (a = !0, r.has(e));
}
async function ts(e, t) {
  let r = lo(e, t), a = Jl(e), n = await r;
  return await Promise.all([
    a,
    uo(e, n)
  ]), {
    Component: mo(n),
    ErrorBoundary: n.ErrorBoundary,
    clientMiddleware: n.clientMiddleware,
    clientAction: n.clientAction,
    clientLoader: n.clientLoader,
    handle: n.handle,
    links: n.links,
    meta: n.meta,
    shouldRevalidate: n.shouldRevalidate
  };
}
function mo(e) {
  if (e.default == null) return;
  if (!(typeof e.default == "object" && Object.keys(e.default).length === 0))
    return e.default;
}
function rs(e, t, r, a) {
  return a && e !== "root" || t != null && (t.hydrate === !0 || r !== !0);
}
var Yt = /* @__PURE__ */ new Set(), as = 1e3, Vt = /* @__PURE__ */ new Set(), ns = 7680;
function ta(e, t) {
  return e.mode === "lazy" && t === !0;
}
function os({ sri: e, ...t }, r) {
  let a = new Set(r.state.matches.map((l) => l.route.id)), n = r.state.location.pathname.split("/").filter(Boolean), o = ["/"];
  for (n.pop(); n.length > 0; )
    o.push(`/${n.join("/")}`), n.pop();
  o.forEach((l) => {
    let s = De(r.routes, l, r.basename);
    s && s.forEach((u) => a.add(u.route.id));
  });
  let i = [...a].reduce(
    (l, s) => Object.assign(l, { [s]: t.routes[s] }),
    {}
  );
  return {
    ...t,
    routes: i,
    sri: e ? !0 : void 0
  };
}
function uu(e, t, r, a, n, o) {
  if (ta(a, r))
    return async ({ path: i, patch: l, signal: s, fetcherKey: u }) => {
      Vt.has(i) || await po(
        [i],
        u ? window.location.href : i,
        e,
        t,
        r,
        n,
        o,
        a.manifestPath,
        l,
        s
      );
    };
}
function cu(e, t, r, a, n, o) {
  c.useEffect(() => {
    if (!ta(n, a) || // @ts-expect-error - TS doesn't know about this yet
    window.navigator?.connection?.saveData === !0)
      return;
    function i(h) {
      let d = h.tagName === "FORM" ? h.getAttribute("action") : h.getAttribute("href");
      if (!d)
        return;
      let p = h.tagName === "A" ? h.pathname : new URL(d, window.location.origin).pathname;
      Vt.has(p) || Yt.add(p);
    }
    async function l() {
      document.querySelectorAll("a[data-discover], form[data-discover]").forEach(i);
      let h = Array.from(Yt.keys()).filter((d) => Vt.has(d) ? (Yt.delete(d), !1) : !0);
      if (h.length !== 0)
        try {
          await po(
            h,
            null,
            t,
            r,
            a,
            o,
            e.basename,
            n.manifestPath,
            e.patchRoutes
          );
        } catch (d) {
          console.error("Failed to fetch manifest patches", d);
        }
    }
    let s = ss(l, 100);
    l();
    let u = new MutationObserver(() => s());
    return u.observe(document.documentElement, {
      subtree: !0,
      childList: !0,
      attributes: !0,
      attributeFilter: ["data-discover", "href", "action"]
    }), () => u.disconnect();
  }, [a, o, t, r, e, n]);
}
function is(e, t) {
  let r = e || "/__manifest";
  return t == null ? r : `${t}${r}`.replace(/\/+/g, "/");
}
var pr = "react-router-manifest-version";
async function po(e, t, r, a, n, o, i, l, s, u) {
  const h = new URLSearchParams();
  h.set("paths", e.sort().join(",")), h.set("version", r.version);
  let d = new URL(
    is(l, i),
    window.location.origin
  );
  if (d.search = h.toString(), d.toString().length > ns) {
    Yt.clear();
    return;
  }
  let p;
  try {
    let v = await fetch(d, { signal: u });
    if (v.ok) {
      if (v.status === 204 && v.headers.has("X-Remix-Reload-Document")) {
        if (!t) {
          console.warn(
            "Detected a manifest version mismatch during eager route discovery. The next navigation/fetch to an undiscovered route will result in a new document navigation to sync up with the latest manifest."
          );
          return;
        }
        try {
          if (sessionStorage.getItem(pr) === r.version) {
            console.error(
              "Unable to discover routes due to manifest version mismatch."
            );
            return;
          }
          sessionStorage.setItem(pr, r.version);
        } catch {
        }
        window.location.href = t, console.warn("Detected manifest version mismatch, reloading..."), await new Promise(() => {
        });
      } else if (v.status >= 400)
        throw new Error(await v.text());
    } else throw new Error(`${v.status} ${v.statusText}`);
    try {
      sessionStorage.removeItem(pr);
    } catch {
    }
    p = await v.json();
  } catch (v) {
    if (u?.aborted) return;
    throw v;
  }
  let f = new Set(Object.keys(r.routes)), y = Object.values(p).reduce((v, x) => (x && !f.has(x.id) && (v[x.id] = x), v), {});
  Object.assign(r.routes, y), e.forEach((v) => ls(v, Vt));
  let w = /* @__PURE__ */ new Set();
  Object.values(y).forEach((v) => {
    v && (!v.parentId || !y[v.parentId]) && w.add(v.parentId);
  }), w.forEach(
    (v) => s(
      v || null,
      ea(y, a, null, n, o, v)
    )
  );
}
function ls(e, t) {
  if (t.size >= as) {
    let r = t.values().next().value;
    t.delete(r);
  }
  t.add(e);
}
function ss(e, t) {
  let r;
  return (...a) => {
    window.clearTimeout(r), r = window.setTimeout(() => e(...a), t);
  };
}
function ra() {
  let e = c.useContext(Ae);
  return ue(
    e,
    "You must render this element inside a <DataRouterContext.Provider> element"
  ), e;
}
function tr() {
  let e = c.useContext(We);
  return ue(
    e,
    "You must render this element inside a <DataRouterStateContext.Provider> element"
  ), e;
}
var rr = c.createContext(void 0);
rr.displayName = "FrameworkContext";
function mt() {
  let e = c.useContext(rr);
  return ue(
    e,
    "You must render this element inside a <HydratedRouter> element"
  ), e;
}
function us(e, t) {
  let r = c.useContext(rr), [a, n] = c.useState(!1), [o, i] = c.useState(!1), { onFocus: l, onBlur: s, onMouseEnter: u, onMouseLeave: h, onTouchStart: d } = t, p = c.useRef(null);
  c.useEffect(() => {
    if (e === "render" && i(!0), e === "viewport") {
      let w = (x) => {
        x.forEach((E) => {
          i(E.isIntersecting);
        });
      }, v = new IntersectionObserver(w, { threshold: 0.5 });
      return p.current && v.observe(p.current), () => {
        v.disconnect();
      };
    }
  }, [e]), c.useEffect(() => {
    if (a) {
      let w = setTimeout(() => {
        i(!0);
      }, 100);
      return () => {
        clearTimeout(w);
      };
    }
  }, [a]);
  let f = () => {
    n(!0);
  }, y = () => {
    n(!1), i(!1);
  };
  return r ? e !== "intent" ? [o, p, {}] : [
    o,
    p,
    {
      onFocus: bt(l, f),
      onBlur: bt(s, y),
      onMouseEnter: bt(u, f),
      onMouseLeave: bt(h, y),
      onTouchStart: bt(d, f)
    }
  ] : [!1, p, {}];
}
function bt(e, t) {
  return (r) => {
    e && e(r), r.defaultPrevented || t(r);
  };
}
function aa(e, t, r) {
  if (r && !Kt)
    return [e[0]];
  if (t) {
    let a = e.findIndex((n) => t[n.route.id] !== void 0);
    return e.slice(0, a + 1);
  }
  return e;
}
var Ka = "data-react-router-critical-css";
function du({ nonce: e }) {
  let { isSpaMode: t, manifest: r, routeModules: a, criticalCss: n } = mt(), { errors: o, matches: i } = tr(), l = aa(i, o, t), s = c.useMemo(
    () => Yl(l, a, r),
    [l, a, r]
  );
  return /* @__PURE__ */ c.createElement(c.Fragment, null, typeof n == "string" ? /* @__PURE__ */ c.createElement(
    "style",
    {
      [Ka]: "",
      dangerouslySetInnerHTML: { __html: n }
    }
  ) : null, typeof n == "object" ? /* @__PURE__ */ c.createElement(
    "link",
    {
      [Ka]: "",
      rel: "stylesheet",
      href: n.href,
      nonce: e
    }
  ) : null, s.map(
    ({ key: u, link: h }) => Qr(h) ? /* @__PURE__ */ c.createElement(yo, { key: u, nonce: e, ...h }) : /* @__PURE__ */ c.createElement("link", { key: u, nonce: e, ...h })
  ));
}
function yo({ page: e, ...t }) {
  let { router: r } = ra(), a = c.useMemo(
    () => De(r.routes, e, r.basename),
    [r.routes, e, r.basename]
  );
  return a ? /* @__PURE__ */ c.createElement(ds, { page: e, matches: a, ...t }) : null;
}
function cs(e) {
  let { manifest: t, routeModules: r } = mt(), [a, n] = c.useState([]);
  return c.useEffect(() => {
    let o = !1;
    return Kl(e, t, r).then(
      (i) => {
        o || n(i);
      }
    ), () => {
      o = !0;
    };
  }, [e, t, r]), a;
}
function ds({
  page: e,
  matches: t,
  ...r
}) {
  let a = ge(), { future: n, manifest: o, routeModules: i } = mt(), { basename: l } = ra(), { loaderData: s, matches: u } = tr(), h = c.useMemo(
    () => Ja(
      e,
      t,
      u,
      o,
      a,
      "data"
    ),
    [e, t, u, o, a]
  ), d = c.useMemo(
    () => Ja(
      e,
      t,
      u,
      o,
      a,
      "assets"
    ),
    [e, t, u, o, a]
  ), p = c.useMemo(() => {
    if (e === a.pathname + a.search + a.hash)
      return [];
    let w = /* @__PURE__ */ new Set(), v = !1;
    if (t.forEach((E) => {
      let P = o.routes[E.route.id];
      !P || !P.hasLoader || (!h.some((L) => L.route.id === E.route.id) && E.route.id in s && i[E.route.id]?.shouldRevalidate || P.hasClientLoader ? v = !0 : w.add(E.route.id));
    }), w.size === 0)
      return [];
    let x = io(
      e,
      l,
      n.unstable_trailingSlashAwareDataRequests,
      "data"
    );
    return v && w.size > 0 && x.searchParams.set(
      "_routes",
      t.filter((E) => w.has(E.route.id)).map((E) => E.route.id).join(",")
    ), [x.pathname + x.search];
  }, [
    l,
    n.unstable_trailingSlashAwareDataRequests,
    s,
    a,
    o,
    h,
    t,
    e,
    i
  ]), f = c.useMemo(
    () => Zr(d, o),
    [d, o]
  ), y = cs(d);
  return /* @__PURE__ */ c.createElement(c.Fragment, null, p.map((w) => /* @__PURE__ */ c.createElement("link", { key: w, rel: "prefetch", as: "fetch", href: w, ...r })), f.map((w) => /* @__PURE__ */ c.createElement("link", { key: w, rel: "modulepreload", href: w, ...r })), y.map(({ key: w, link: v }) => (
    // these don't spread `linkProps` because they are full link descriptors
    // already with their own props
    /* @__PURE__ */ c.createElement("link", { key: w, nonce: r.nonce, ...v })
  )));
}
function fu() {
  let { isSpaMode: e, routeModules: t } = mt(), {
    errors: r,
    matches: a,
    loaderData: n
  } = tr(), o = ge(), i = aa(a, r, e), l = null;
  r && (l = r[i[i.length - 1].route.id]);
  let s = [], u = null, h = [];
  for (let d = 0; d < i.length; d++) {
    let p = i[d], f = p.route.id, y = n[f], w = p.params, v = t[f], x = [], E = {
      id: f,
      data: y,
      loaderData: y,
      meta: [],
      params: p.params,
      pathname: p.pathname,
      handle: p.route.handle,
      error: l
    };
    if (h[d] = E, v?.meta ? x = typeof v.meta == "function" ? v.meta({
      data: y,
      loaderData: y,
      params: w,
      location: o,
      matches: h,
      error: l
    }) : Array.isArray(v.meta) ? [...v.meta] : v.meta : u && (x = [...u]), x = x || [], !Array.isArray(x))
      throw new Error(
        "The route at " + p.route.path + ` returns an invalid value. All route meta functions must return an array of meta objects.

To reference the meta function API, see https://remix.run/route/meta`
      );
    E.meta = x, h[d] = E, s = [...x], u = s;
  }
  return /* @__PURE__ */ c.createElement(c.Fragment, null, s.flat().map((d) => {
    if (!d)
      return null;
    if ("tagName" in d) {
      let { tagName: p, ...f } = d;
      if (!fs(p))
        return console.warn(
          `A meta object uses an invalid tagName: ${p}. Expected either 'link' or 'meta'`
        ), null;
      let y = p;
      return /* @__PURE__ */ c.createElement(y, { key: JSON.stringify(f), ...f });
    }
    if ("title" in d)
      return /* @__PURE__ */ c.createElement("title", { key: "title" }, String(d.title));
    if ("charset" in d && (d.charSet ?? (d.charSet = d.charset), delete d.charset), "charSet" in d && d.charSet != null)
      return typeof d.charSet == "string" ? /* @__PURE__ */ c.createElement("meta", { key: "charSet", charSet: d.charSet }) : null;
    if ("script:ld+json" in d)
      try {
        let p = JSON.stringify(d["script:ld+json"]);
        return /* @__PURE__ */ c.createElement(
          "script",
          {
            key: `script:ld+json:${p}`,
            type: "application/ld+json",
            dangerouslySetInnerHTML: { __html: Ct(p) }
          }
        );
      } catch {
        return null;
      }
    return /* @__PURE__ */ c.createElement("meta", { key: JSON.stringify(d), ...d });
  }));
}
function fs(e) {
  return typeof e == "string" && /^(meta|link)$/.test(e);
}
var Kt = !1;
function hs() {
  Kt = !0;
}
function ms(e) {
  let {
    manifest: t,
    serverHandoffString: r,
    isSpaMode: a,
    renderMeta: n,
    routeDiscovery: o,
    ssr: i
  } = mt(), { router: l, static: s, staticContext: u } = ra(), { matches: h } = tr(), d = kn(), p = ta(o, i);
  n && (n.didRenderScripts = !0);
  let f = aa(h, null, a);
  c.useEffect(() => {
    hs();
  }, []);
  let y = c.useMemo(() => {
    if (d)
      return null;
    let E = u ? `window.__reactRouterContext = ${r};window.__reactRouterContext.stream = new ReadableStream({start(controller){window.__reactRouterContext.streamController = controller;}}).pipeThrough(new TextEncoderStream());` : " ", P = s ? `${t.hmr?.runtime ? `import ${JSON.stringify(t.hmr.runtime)};` : ""}${p ? "" : `import ${JSON.stringify(t.url)}`};
${f.map((L, C) => {
      let S = `route${C}`, b = t.routes[L.route.id];
      ue(b, `Route ${L.route.id} not found in manifest`);
      let {
        clientActionModule: T,
        clientLoaderModule: O,
        clientMiddlewareModule: j,
        hydrateFallbackModule: $,
        module: z
      } = b, V = [
        ...T ? [
          {
            module: T,
            varName: `${S}_clientAction`
          }
        ] : [],
        ...O ? [
          {
            module: O,
            varName: `${S}_clientLoader`
          }
        ] : [],
        ...j ? [
          {
            module: j,
            varName: `${S}_clientMiddleware`
          }
        ] : [],
        ...$ ? [
          {
            module: $,
            varName: `${S}_HydrateFallback`
          }
        ] : [],
        { module: z, varName: `${S}_main` }
      ];
      if (V.length === 1)
        return `import * as ${S} from ${JSON.stringify(z)};`;
      let Z = V.map((G) => `import * as ${G.varName} from "${G.module}";`).join(`
`), W = `const ${S} = {${V.map((G) => `...${G.varName}`).join(",")}};`;
      return [Z, W].join(`
`);
    }).join(`
`)}
  ${p ? (
      // Inline a minimal manifest with the SSR matches
      `window.__reactRouterManifest = ${JSON.stringify(
        os(t, l),
        null,
        2
      )};`
    ) : ""}
  window.__reactRouterRouteModules = {${f.map((L, C) => `${JSON.stringify(L.route.id)}:route${C}`).join(",")}};

import(${JSON.stringify(t.entry.module)});` : " ";
    return /* @__PURE__ */ c.createElement(c.Fragment, null, /* @__PURE__ */ c.createElement(
      "script",
      {
        ...e,
        suppressHydrationWarning: !0,
        dangerouslySetInnerHTML: { __html: E },
        type: void 0
      }
    ), /* @__PURE__ */ c.createElement(
      "script",
      {
        ...e,
        suppressHydrationWarning: !0,
        dangerouslySetInnerHTML: { __html: P },
        type: "module",
        async: !0
      }
    ));
  }, []), w = Kt || d ? [] : ps(
    t.entry.imports.concat(
      Zr(f, t, {
        includeHydrateFallback: !0
      })
    )
  ), v = typeof t.sri == "object" ? t.sri : {};
  return Sr(
    !d,
    "The <Scripts /> element is a no-op when using RSC and can be safely removed."
  ), Kt || d ? null : /* @__PURE__ */ c.createElement(c.Fragment, null, typeof t.sri == "object" ? /* @__PURE__ */ c.createElement(
    "script",
    {
      ...e,
      "rr-importmap": "",
      type: "importmap",
      suppressHydrationWarning: !0,
      dangerouslySetInnerHTML: {
        __html: JSON.stringify({
          integrity: v
        })
      }
    }
  ) : null, p ? null : /* @__PURE__ */ c.createElement(
    "link",
    {
      rel: "modulepreload",
      href: t.url,
      crossOrigin: e.crossOrigin,
      integrity: v[t.url],
      suppressHydrationWarning: !0
    }
  ), /* @__PURE__ */ c.createElement(
    "link",
    {
      rel: "modulepreload",
      href: t.entry.module,
      crossOrigin: e.crossOrigin,
      integrity: v[t.entry.module],
      suppressHydrationWarning: !0
    }
  ), w.map((x) => /* @__PURE__ */ c.createElement(
    "link",
    {
      key: x,
      rel: "modulepreload",
      href: x,
      crossOrigin: e.crossOrigin,
      integrity: v[x],
      suppressHydrationWarning: !0
    }
  )), y);
}
function ps(e) {
  return [...new Set(e)];
}
function ys(...e) {
  return (t) => {
    e.forEach((r) => {
      typeof r == "function" ? r(t) : r != null && (r.current = t);
    });
  };
}
var hu = class extends c.Component {
  constructor(e) {
    super(e), this.state = { error: e.error || null, location: e.location };
  }
  static getDerivedStateFromError(e) {
    return { error: e };
  }
  static getDerivedStateFromProps(e, t) {
    return t.location !== e.location ? { error: e.error || null, location: e.location } : { error: e.error || t.error, location: t.location };
  }
  render() {
    return this.state.error ? /* @__PURE__ */ c.createElement(
      vo,
      {
        error: this.state.error,
        isOutsideRemixApp: !0
      }
    ) : this.props.children;
  }
};
function vo({
  error: e,
  isOutsideRemixApp: t
}) {
  console.error(e);
  let r = /* @__PURE__ */ c.createElement(
    "script",
    {
      dangerouslySetInnerHTML: {
        __html: `
        console.log(
          " Hey developer . You can provide a way better UX than this when your app throws errors. Check out https://reactrouter.com/how-to/error-boundary for more information."
        );
      `
      }
    }
  );
  if (Pe(e))
    return /* @__PURE__ */ c.createElement(Mr, { title: "Unhandled Thrown Response!" }, /* @__PURE__ */ c.createElement("h1", { style: { fontSize: "24px" } }, e.status, " ", e.statusText), r);
  let a;
  if (e instanceof Error)
    a = e;
  else {
    let n = e == null ? "Unknown Error" : typeof e == "object" && "toString" in e ? e.toString() : JSON.stringify(e);
    a = new Error(n);
  }
  return /* @__PURE__ */ c.createElement(
    Mr,
    {
      title: "Application Error!",
      isOutsideRemixApp: t
    },
    /* @__PURE__ */ c.createElement("h1", { style: { fontSize: "24px" } }, "Application Error"),
    /* @__PURE__ */ c.createElement(
      "pre",
      {
        style: {
          padding: "2rem",
          background: "hsla(10, 50%, 50%, 0.1)",
          color: "red",
          overflow: "auto"
        }
      },
      a.stack
    ),
    r
  );
}
function Mr({
  title: e,
  renderScripts: t,
  isOutsideRemixApp: r,
  children: a
}) {
  let { routeModules: n } = mt();
  return n.root?.Layout && !r ? a : /* @__PURE__ */ c.createElement("html", { lang: "en" }, /* @__PURE__ */ c.createElement("head", null, /* @__PURE__ */ c.createElement("meta", { charSet: "utf-8" }), /* @__PURE__ */ c.createElement(
    "meta",
    {
      name: "viewport",
      content: "width=device-width,initial-scale=1,viewport-fit=cover"
    }
  ), /* @__PURE__ */ c.createElement("title", null, e)), /* @__PURE__ */ c.createElement("body", null, /* @__PURE__ */ c.createElement("main", { style: { fontFamily: "system-ui, sans-serif", padding: "2rem" } }, a, t ? /* @__PURE__ */ c.createElement(ms, null) : null)));
}
var vs = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u";
try {
  vs && (window.__reactRouterVersion = // @ts-expect-error
  "7.12.0");
} catch {
}
function mu(e, t) {
  return kr({
    basename: t?.basename,
    getContext: t?.getContext,
    future: t?.future,
    history: Qa({ window: t?.window }),
    hydrationData: t?.hydrationData || go(),
    routes: e,
    mapRouteProperties: Ot,
    hydrationRouteProperties: Gr,
    dataStrategy: t?.dataStrategy,
    patchRoutesOnNavigation: t?.patchRoutesOnNavigation,
    window: t?.window,
    unstable_instrumentations: t?.unstable_instrumentations
  }).initialize();
}
function pu(e, t) {
  return kr({
    basename: t?.basename,
    getContext: t?.getContext,
    future: t?.future,
    history: Za({ window: t?.window }),
    hydrationData: t?.hydrationData || go(),
    routes: e,
    mapRouteProperties: Ot,
    hydrationRouteProperties: Gr,
    dataStrategy: t?.dataStrategy,
    patchRoutesOnNavigation: t?.patchRoutesOnNavigation,
    window: t?.window,
    unstable_instrumentations: t?.unstable_instrumentations
  }).initialize();
}
function go() {
  let e = window?.__staticRouterHydrationData;
  return e && e.errors && (e = {
    ...e,
    errors: gs(e.errors)
  }), e;
}
function gs(e) {
  if (!e) return null;
  let t = Object.entries(e), r = {};
  for (let [a, n] of t)
    if (n && n.__type === "RouteErrorResponse")
      r[a] = new Te(
        n.status,
        n.statusText,
        n.data,
        n.internal === !0
      );
    else if (n && n.__type === "Error") {
      if (n.__subType) {
        let o = window[n.__subType];
        if (typeof o == "function")
          try {
            let i = new o(n.message);
            i.stack = "", r[a] = i;
          } catch {
          }
      }
      if (r[a] == null) {
        let o = new Error(n.message);
        o.stack = "", r[a] = o;
      }
    } else
      r[a] = n;
  return r;
}
function yu({
  basename: e,
  children: t,
  unstable_useTransitions: r,
  window: a
}) {
  let n = c.useRef();
  n.current == null && (n.current = Qa({ window: a, v5Compat: !0 }));
  let o = n.current, [i, l] = c.useState({
    action: o.action,
    location: o.location
  }), s = c.useCallback(
    (u) => {
      r === !1 ? l(u) : c.startTransition(() => l(u));
    },
    [r]
  );
  return c.useLayoutEffect(() => o.listen(s), [o, s]), /* @__PURE__ */ c.createElement(
    rt,
    {
      basename: e,
      children: t,
      location: i.location,
      navigationType: i.action,
      navigator: o,
      unstable_useTransitions: r
    }
  );
}
function vu({
  basename: e,
  children: t,
  unstable_useTransitions: r,
  window: a
}) {
  let n = c.useRef();
  n.current == null && (n.current = Za({ window: a, v5Compat: !0 }));
  let o = n.current, [i, l] = c.useState({
    action: o.action,
    location: o.location
  }), s = c.useCallback(
    (u) => {
      r === !1 ? l(u) : c.startTransition(() => l(u));
    },
    [r]
  );
  return c.useLayoutEffect(() => o.listen(s), [o, s]), /* @__PURE__ */ c.createElement(
    rt,
    {
      basename: e,
      children: t,
      location: i.location,
      navigationType: i.action,
      navigator: o,
      unstable_useTransitions: r
    }
  );
}
function ws({
  basename: e,
  children: t,
  history: r,
  unstable_useTransitions: a
}) {
  let [n, o] = c.useState({
    action: r.action,
    location: r.location
  }), i = c.useCallback(
    (l) => {
      a === !1 ? o(l) : c.startTransition(() => o(l));
    },
    [a]
  );
  return c.useLayoutEffect(() => r.listen(i), [r, i]), /* @__PURE__ */ c.createElement(
    rt,
    {
      basename: e,
      children: t,
      location: n.location,
      navigationType: n.action,
      navigator: r,
      unstable_useTransitions: a
    }
  );
}
ws.displayName = "unstable_HistoryRouter";
var wo = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i, bo = c.forwardRef(
  function({
    onClick: t,
    discover: r = "render",
    prefetch: a = "none",
    relative: n,
    reloadDocument: o,
    replace: i,
    state: l,
    target: s,
    to: u,
    preventScrollReset: h,
    viewTransition: d,
    unstable_defaultShouldRevalidate: p,
    ...f
  }, y) {
    let { basename: w, unstable_useTransitions: v } = c.useContext(he), x = typeof u == "string" && wo.test(u), E = cn(u, w);
    u = E.to;
    let P = Wi(u, { relative: n }), [L, C, S] = us(
      a,
      f
    ), b = Rs(u, {
      replace: i,
      state: l,
      target: s,
      preventScrollReset: h,
      relative: n,
      viewTransition: d,
      unstable_defaultShouldRevalidate: p,
      unstable_useTransitions: v
    });
    function T(j) {
      t && t(j), j.defaultPrevented || b(j);
    }
    let O = (
      // eslint-disable-next-line jsx-a11y/anchor-has-content
      /* @__PURE__ */ c.createElement(
        "a",
        {
          ...f,
          ...S,
          href: E.absoluteURL || P,
          onClick: E.isExternal || o ? t : T,
          ref: ys(y, C),
          target: s,
          "data-discover": !x && r === "render" ? "true" : void 0
        }
      )
    );
    return L && !x ? /* @__PURE__ */ c.createElement(c.Fragment, null, O, /* @__PURE__ */ c.createElement(yo, { page: P })) : O;
  }
);
bo.displayName = "Link";
var bs = c.forwardRef(
  function({
    "aria-current": t = "page",
    caseSensitive: r = !1,
    className: a = "",
    end: n = !1,
    style: o,
    to: i,
    viewTransition: l,
    children: s,
    ...u
  }, h) {
    let d = Dt(i, { relative: u.relative }), p = ge(), f = c.useContext(We), { navigator: y, basename: w } = c.useContext(he), v = f != null && // Conditional usage is OK here because the usage of a data router is static
    // eslint-disable-next-line react-hooks/rules-of-hooks
    Ds(d) && l === !0, x = y.encodeLocation ? y.encodeLocation(d).pathname : d.pathname, E = p.pathname, P = f && f.navigation && f.navigation.location ? f.navigation.location.pathname : null;
    r || (E = E.toLowerCase(), P = P ? P.toLowerCase() : null, x = x.toLowerCase()), P && w && (P = fe(P, w) || P);
    const L = x !== "/" && x.endsWith("/") ? x.length - 1 : x.length;
    let C = E === x || !n && E.startsWith(x) && E.charAt(L) === "/", S = P != null && (P === x || !n && P.startsWith(x) && P.charAt(x.length) === "/"), b = {
      isActive: C,
      isPending: S,
      isTransitioning: v
    }, T = C ? t : void 0, O;
    typeof a == "function" ? O = a(b) : O = [
      a,
      C ? "active" : null,
      S ? "pending" : null,
      v ? "transitioning" : null
    ].filter(Boolean).join(" ");
    let j = typeof o == "function" ? o(b) : o;
    return /* @__PURE__ */ c.createElement(
      bo,
      {
        ...u,
        "aria-current": T,
        className: O,
        ref: h,
        style: j,
        to: i,
        viewTransition: l
      },
      typeof s == "function" ? s(b) : s
    );
  }
);
bs.displayName = "NavLink";
var Eo = c.forwardRef(
  ({
    discover: e = "render",
    fetcherKey: t,
    navigate: r,
    reloadDocument: a,
    replace: n,
    state: o,
    method: i = Bt,
    action: l,
    onSubmit: s,
    relative: u,
    preventScrollReset: h,
    viewTransition: d,
    unstable_defaultShouldRevalidate: p,
    ...f
  }, y) => {
    let { unstable_useTransitions: w } = c.useContext(he), v = So(), x = Ps(l, { relative: u }), E = i.toLowerCase() === "get" ? "get" : "post", P = typeof l == "string" && wo.test(l), L = (C) => {
      if (s && s(C), C.defaultPrevented) return;
      C.preventDefault();
      let S = C.nativeEvent.submitter, b = S?.getAttribute("formmethod") || i, T = () => v(S || C.currentTarget, {
        fetcherKey: t,
        method: b,
        navigate: r,
        replace: n,
        state: o,
        relative: u,
        preventScrollReset: h,
        viewTransition: d,
        unstable_defaultShouldRevalidate: p
      });
      w && r !== !1 ? c.startTransition(() => T()) : T();
    };
    return /* @__PURE__ */ c.createElement(
      "form",
      {
        ref: y,
        method: E,
        action: x,
        onSubmit: a ? s : L,
        ...f,
        "data-discover": !P && e === "render" ? "true" : void 0
      }
    );
  }
);
Eo.displayName = "Form";
function Es({
  getKey: e,
  storageKey: t,
  ...r
}) {
  let a = c.useContext(rr), { basename: n } = c.useContext(he), o = ge(), i = Yr();
  Cs({ getKey: e, storageKey: t });
  let l = c.useMemo(
    () => {
      if (!a || !e) return null;
      let u = $r(
        o,
        i,
        n,
        e
      );
      return u !== o.key ? u : null;
    },
    // Nah, we only need this the first time for the SSR render
    // eslint-disable-next-line react-hooks/exhaustive-deps
    []
  );
  if (!a || a.isSpaMode)
    return null;
  let s = ((u, h) => {
    if (!window.history.state || !window.history.state.key) {
      let d = Math.random().toString(32).slice(2);
      window.history.replaceState({ key: d }, "");
    }
    try {
      let p = JSON.parse(sessionStorage.getItem(u) || "{}")[h || window.history.state.key];
      typeof p == "number" && window.scrollTo(0, p);
    } catch (d) {
      console.error(d), sessionStorage.removeItem(u);
    }
  }).toString();
  return /* @__PURE__ */ c.createElement(
    "script",
    {
      ...r,
      suppressHydrationWarning: !0,
      dangerouslySetInnerHTML: {
        __html: `(${s})(${Ct(
          JSON.stringify(t || Tr)
        )}, ${Ct(JSON.stringify(l))})`
      }
    }
  );
}
Es.displayName = "ScrollRestoration";
function Ro(e) {
  return `${e} must be used within a data router.  See https://reactrouter.com/en/main/routers/picking-a-router.`;
}
function ar(e) {
  let t = c.useContext(Ae);
  return I(t, Ro(e)), t;
}
function na(e) {
  let t = c.useContext(We);
  return I(t, Ro(e)), t;
}
function Rs(e, {
  target: t,
  replace: r,
  state: a,
  preventScrollReset: n,
  relative: o,
  viewTransition: i,
  unstable_defaultShouldRevalidate: l,
  unstable_useTransitions: s
} = {}) {
  let u = Hr(), h = ge(), d = Dt(e, { relative: o });
  return c.useCallback(
    (p) => {
      if (gl(p, t)) {
        p.preventDefault();
        let f = r !== void 0 ? r : ce(h) === ce(d), y = () => u(e, {
          replace: f,
          state: a,
          preventScrollReset: n,
          relative: o,
          viewTransition: i,
          unstable_defaultShouldRevalidate: l
        });
        s ? c.startTransition(() => y()) : y();
      }
    },
    [
      h,
      u,
      d,
      r,
      a,
      t,
      e,
      n,
      o,
      i,
      l,
      s
    ]
  );
}
function gu(e) {
  Q(
    typeof URLSearchParams < "u",
    "You cannot use the `useSearchParams` hook in a browser that does not support the URLSearchParams API. If you need to support Internet Explorer 11, we recommend you load a polyfill such as https://github.com/ungap/url-search-params."
  );
  let t = c.useRef(xr(e)), r = c.useRef(!1), a = ge(), n = c.useMemo(
    () => (
      // Only merge in the defaults if we haven't yet called setSearchParams.
      // Once we call that we want those to take precedence, otherwise you can't
      // remove a param with setSearchParams({}) if it has an initial value
      wl(
        a.search,
        r.current ? null : t.current
      )
    ),
    [a.search]
  ), o = Hr(), i = c.useCallback(
    (l, s) => {
      const u = xr(
        typeof l == "function" ? l(new URLSearchParams(n)) : l
      );
      r.current = !0, o("?" + u, s);
    },
    [o, n]
  );
  return [n, i];
}
var Ss = 0, xs = () => `__${String(++Ss)}__`;
function So() {
  let { router: e } = ar(
    "useSubmit"
    /* UseSubmit */
  ), { basename: t } = c.useContext(he), r = qi(), a = e.fetch, n = e.navigate;
  return c.useCallback(
    async (o, i = {}) => {
      let { action: l, method: s, encType: u, formData: h, body: d } = Rl(
        o,
        t
      );
      if (i.navigate === !1) {
        let p = i.fetcherKey || xs();
        await a(p, r, i.action || l, {
          unstable_defaultShouldRevalidate: i.unstable_defaultShouldRevalidate,
          preventScrollReset: i.preventScrollReset,
          formData: h,
          body: d,
          formMethod: i.method || s,
          formEncType: i.encType || u,
          flushSync: i.flushSync
        });
      } else
        await n(i.action || l, {
          unstable_defaultShouldRevalidate: i.unstable_defaultShouldRevalidate,
          preventScrollReset: i.preventScrollReset,
          formData: h,
          body: d,
          formMethod: i.method || s,
          formEncType: i.encType || u,
          replace: i.replace,
          state: i.state,
          fromRouteId: r,
          flushSync: i.flushSync,
          viewTransition: i.viewTransition
        });
    },
    [a, n, t, r]
  );
}
function Ps(e, { relative: t } = {}) {
  let { basename: r } = c.useContext(he), a = c.useContext(ve);
  I(a, "useFormAction must be used inside a RouteContext");
  let [n] = a.matches.slice(-1), o = { ...Dt(e || ".", { relative: t }) }, i = ge();
  if (e == null) {
    o.search = i.search;
    let l = new URLSearchParams(o.search), s = l.getAll("index");
    if (s.some((h) => h === "")) {
      l.delete("index"), s.filter((d) => d).forEach((d) => l.append("index", d));
      let h = l.toString();
      o.search = h ? `?${h}` : "";
    }
  }
  return (!e || e === ".") && n.route.index && (o.search = o.search ? o.search.replace(/^\?/, "?index&") : "?index"), r !== "/" && (o.pathname = o.pathname === "/" ? r : Me([r, o.pathname])), ce(o);
}
function wu({
  key: e
} = {}) {
  let { router: t } = ar(
    "useFetcher"
    /* UseFetcher */
  ), r = na(
    "useFetcher"
    /* UseFetcher */
  ), a = c.useContext(qt), n = c.useContext(ve), o = n.matches[n.matches.length - 1]?.route.id;
  I(a, "useFetcher must be used inside a FetchersContext"), I(n, "useFetcher must be used inside a RouteContext"), I(
    o != null,
    'useFetcher can only be used on routes that contain a unique "id"'
  );
  let i = c.useId(), [l, s] = c.useState(e || i);
  e && e !== l && s(e);
  let { deleteFetcher: u, getFetcher: h, resetFetcher: d, fetch: p } = t;
  c.useEffect(() => (h(l), () => u(l)), [u, h, l]);
  let f = c.useCallback(
    async (C, S) => {
      I(o, "No routeId available for fetcher.load()"), await p(l, o, C, S);
    },
    [l, o, p]
  ), y = So(), w = c.useCallback(
    async (C, S) => {
      await y(C, {
        ...S,
        navigate: !1,
        fetcherKey: l
      });
    },
    [l, y]
  ), v = c.useCallback(
    (C) => d(l, C),
    [d, l]
  ), x = c.useMemo(() => {
    let C = c.forwardRef(
      (S, b) => /* @__PURE__ */ c.createElement(Eo, { ...S, navigate: !1, fetcherKey: l, ref: b })
    );
    return C.displayName = "fetcher.Form", C;
  }, [l]), E = r.fetchers.get(l) || Fr, P = a.get(l);
  return c.useMemo(
    () => ({
      Form: x,
      submit: w,
      load: f,
      reset: v,
      ...E,
      data: P
    }),
    [x, w, f, v, E, P]
  );
}
function bu() {
  let e = na(
    "useFetchers"
    /* UseFetchers */
  );
  return Array.from(e.fetchers.entries()).map(([t, r]) => ({
    ...r,
    key: t
  }));
}
var Tr = "react-router-scroll-positions", Ut = {};
function $r(e, t, r, a) {
  let n = null;
  return a && (r !== "/" ? n = a(
    {
      ...e,
      pathname: fe(e.pathname, r) || e.pathname
    },
    t
  ) : n = a(e, t)), n == null && (n = e.key), n;
}
function Cs({
  getKey: e,
  storageKey: t
} = {}) {
  let { router: r } = ar(
    "useScrollRestoration"
    /* UseScrollRestoration */
  ), { restoreScrollPosition: a, preventScrollReset: n } = na(
    "useScrollRestoration"
    /* UseScrollRestoration */
  ), { basename: o } = c.useContext(he), i = ge(), l = Yr(), s = el();
  c.useEffect(() => (window.history.scrollRestoration = "manual", () => {
    window.history.scrollRestoration = "auto";
  }), []), Ls(
    c.useCallback(() => {
      if (s.state === "idle") {
        let u = $r(i, l, o, e);
        Ut[u] = window.scrollY;
      }
      try {
        sessionStorage.setItem(
          t || Tr,
          JSON.stringify(Ut)
        );
      } catch (u) {
        Q(
          !1,
          `Failed to save scroll positions in sessionStorage, <ScrollRestoration /> will not work properly (${u}).`
        );
      }
      window.history.scrollRestoration = "auto";
    }, [s.state, e, o, i, l, t])
  ), typeof document < "u" && (c.useLayoutEffect(() => {
    try {
      let u = sessionStorage.getItem(
        t || Tr
      );
      u && (Ut = JSON.parse(u));
    } catch {
    }
  }, [t]), c.useLayoutEffect(() => {
    let u = r?.enableScrollRestoration(
      Ut,
      () => window.scrollY,
      e ? (h, d) => $r(h, d, o, e) : void 0
    );
    return () => u && u();
  }, [r, o, e]), c.useLayoutEffect(() => {
    if (a !== !1) {
      if (typeof a == "number") {
        window.scrollTo(0, a);
        return;
      }
      try {
        if (i.hash) {
          let u = document.getElementById(
            decodeURIComponent(i.hash.slice(1))
          );
          if (u) {
            u.scrollIntoView();
            return;
          }
        }
      } catch {
        Q(
          !1,
          `"${i.hash.slice(
            1
          )}" is not a decodable element ID. The view will not scroll to it.`
        );
      }
      n !== !0 && window.scrollTo(0, 0);
    }
  }, [i, a, n]));
}
function Eu(e, t) {
  let { capture: r } = t || {};
  c.useEffect(() => {
    let a = r != null ? { capture: r } : void 0;
    return window.addEventListener("beforeunload", e, a), () => {
      window.removeEventListener("beforeunload", e, a);
    };
  }, [e, r]);
}
function Ls(e, t) {
  let { capture: r } = {};
  c.useEffect(() => {
    let a = r != null ? { capture: r } : void 0;
    return window.addEventListener("pagehide", e, a), () => {
      window.removeEventListener("pagehide", e, a);
    };
  }, [e, r]);
}
function Ru({
  when: e,
  message: t
}) {
  let r = al(e);
  c.useEffect(() => {
    r.state === "blocked" && (window.confirm(t) ? setTimeout(r.proceed, 0) : r.reset());
  }, [r, t]), c.useEffect(() => {
    r.state === "blocked" && !e && r.reset();
  }, [r, e]);
}
function Ds(e, { relative: t } = {}) {
  let r = c.useContext(Zt);
  I(
    r != null,
    "`useViewTransitionState` must be used within `react-router-dom`'s `RouterProvider`.  Did you accidentally import `RouterProvider` from `react-router`?"
  );
  let { basename: a } = ar(
    "useViewTransitionState"
    /* useViewTransitionState */
  ), n = Dt(e, { relative: t });
  if (!r.isTransitioning)
    return !1;
  let o = fe(r.currentLocation.pathname, a) || r.currentLocation.pathname, i = fe(r.nextLocation.pathname, a) || r.nextLocation.pathname;
  return xt(n.pathname, i) != null || xt(n.pathname, o) != null;
}
function Su({
  basename: e,
  children: t,
  location: r = "/"
}) {
  typeof r == "string" && (r = Ce(r));
  let a = "POP", n = {
    pathname: r.pathname || "/",
    search: r.search || "",
    hash: r.hash || "",
    state: r.state != null ? r.state : null,
    key: r.key || "default"
  }, o = xo();
  return /* @__PURE__ */ c.createElement(
    rt,
    {
      basename: e,
      children: t,
      location: n,
      navigationType: a,
      navigator: o,
      static: !0,
      unstable_useTransitions: !1
    }
  );
}
function xu({
  context: e,
  router: t,
  hydrate: r = !0,
  nonce: a
}) {
  I(
    t && e,
    "You must provide `router` and `context` to <StaticRouterProvider>"
  );
  let n = {
    router: t,
    navigator: xo(),
    static: !0,
    staticContext: e,
    basename: e.basename || "/"
  }, o = /* @__PURE__ */ new Map(), i = "";
  if (r !== !1) {
    let s = {
      loaderData: e.loaderData,
      actionData: e.actionData,
      errors: Ms(e.errors)
    };
    i = `window.__staticRouterHydrationData = JSON.parse(${Ct(JSON.stringify(JSON.stringify(s)))});`;
  }
  let { state: l } = n.router;
  return /* @__PURE__ */ c.createElement(c.Fragment, null, /* @__PURE__ */ c.createElement(Ae.Provider, { value: n }, /* @__PURE__ */ c.createElement(We.Provider, { value: l }, /* @__PURE__ */ c.createElement(qt.Provider, { value: o }, /* @__PURE__ */ c.createElement(Zt.Provider, { value: { isTransitioning: !1 } }, /* @__PURE__ */ c.createElement(
    rt,
    {
      basename: n.basename,
      location: l.location,
      navigationType: l.historyAction,
      navigator: n.navigator,
      static: n.static,
      unstable_useTransitions: !1
    },
    /* @__PURE__ */ c.createElement(
      Os,
      {
        routes: t.routes,
        future: t.future,
        state: l
      }
    )
  ))))), i ? /* @__PURE__ */ c.createElement(
    "script",
    {
      suppressHydrationWarning: !0,
      nonce: a,
      dangerouslySetInnerHTML: { __html: i }
    }
  ) : null);
}
function Os({
  routes: e,
  future: t,
  state: r
}) {
  return zr(e, void 0, r, void 0, t);
}
function Ms(e) {
  if (!e) return null;
  let t = Object.entries(e), r = {};
  for (let [a, n] of t)
    Pe(n) ? r[a] = { ...n, __type: "RouteErrorResponse" } : n instanceof Error ? r[a] = {
      message: n.message,
      __type: "Error",
      // If this is a subclass (i.e., ReferenceError), send up the type so we
      // can re-create the same type during hydration.
      ...n.name !== "Error" ? {
        __subType: n.name
      } : {}
    } : r[a] = n;
  return r;
}
function xo() {
  return {
    createHref: Po,
    encodeLocation: Co,
    push(e) {
      throw new Error(
        `You cannot use navigator.push() on the server because it is a stateless environment. This error was probably triggered when you did a \`navigate(${JSON.stringify(e)})\` somewhere in your app.`
      );
    },
    replace(e) {
      throw new Error(
        `You cannot use navigator.replace() on the server because it is a stateless environment. This error was probably triggered when you did a \`navigate(${JSON.stringify(e)}, { replace: true })\` somewhere in your app.`
      );
    },
    go(e) {
      throw new Error(
        `You cannot use navigator.go() on the server because it is a stateless environment. This error was probably triggered when you did a \`navigate(${e})\` somewhere in your app.`
      );
    },
    back() {
      throw new Error(
        "You cannot use navigator.back() on the server because it is a stateless environment."
      );
    },
    forward() {
      throw new Error(
        "You cannot use navigator.forward() on the server because it is a stateless environment."
      );
    }
  };
}
function Pu(e, t) {
  return xi(e, {
    ...t,
    mapRouteProperties: Ot
  });
}
function Cu(e, t, r = {}) {
  let a = {}, n = et(
    e,
    Ot,
    void 0,
    a
  ), o = t.matches.map((l) => {
    let s = a[l.route.id] || l.route;
    return {
      ...l,
      route: s
    };
  }), i = (l) => `You cannot use router.${l}() on the server because it is a stateless environment`;
  return {
    get basename() {
      return t.basename;
    },
    get future() {
      return {
        v8_middleware: !1,
        ...r?.future
      };
    },
    get state() {
      return {
        historyAction: "POP",
        location: t.location,
        matches: o,
        loaderData: t.loaderData,
        actionData: t.actionData,
        errors: t.errors,
        initialized: !0,
        navigation: zt,
        restoreScrollPosition: null,
        preventScrollReset: !1,
        revalidation: "idle",
        fetchers: /* @__PURE__ */ new Map(),
        blockers: /* @__PURE__ */ new Map()
      };
    },
    get routes() {
      return n;
    },
    get window() {
    },
    initialize() {
      throw i("initialize");
    },
    subscribe() {
      throw i("subscribe");
    },
    enableScrollRestoration() {
      throw i("enableScrollRestoration");
    },
    navigate() {
      throw i("navigate");
    },
    fetch() {
      throw i("fetch");
    },
    revalidate() {
      throw i("revalidate");
    },
    createHref: Po,
    encodeLocation: Co,
    getFetcher() {
      return Fr;
    },
    deleteFetcher() {
      throw i("deleteFetcher");
    },
    resetFetcher() {
      throw i("resetFetcher");
    },
    dispose() {
      throw i("dispose");
    },
    getBlocker() {
      return Qe;
    },
    deleteBlocker() {
      throw i("deleteBlocker");
    },
    patchRoutes() {
      throw i("patchRoutes");
    },
    _internalFetchControllers: /* @__PURE__ */ new Map(),
    _internalSetRoutes() {
      throw i("_internalSetRoutes");
    },
    _internalSetStateDoNotUseOrYouWillBreakYourApp() {
      throw i("_internalSetStateDoNotUseOrYouWillBreakYourApp");
    }
  };
}
function Po(e) {
  return typeof e == "string" ? e : ce(e);
}
function Co(e) {
  let t = typeof e == "string" ? e : ce(e);
  t = t.replace(/ $/, "%20");
  let r = Ts.test(t) ? new URL(t) : new URL(t, "http://localhost");
  return {
    pathname: r.pathname,
    search: r.search,
    hash: r.hash
  };
}
var Ts = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i;
export {
  vu as $,
  _s as A,
  ou as B,
  au as C,
  tu as D,
  Te as E,
  rr as F,
  Wl as G,
  Or as H,
  Fs as I,
  ks as J,
  fe as K,
  bo as L,
  is as M,
  Ks as N,
  Gs as O,
  Er as P,
  qe as Q,
  hu as R,
  xu as S,
  ki as T,
  se as U,
  Pi as V,
  Fl as W,
  iu as X,
  Qs as Y,
  yu as Z,
  Eo as _,
  ge as a,
  tt as a$,
  Qe as a0,
  Fr as a1,
  zt as a2,
  du as a3,
  Vs as a4,
  fu as a5,
  bs as a6,
  Vo as a7,
  yo as a8,
  dl as a9,
  Ot as aA,
  cu as aB,
  Cs as aC,
  mu as aD,
  $s as aE,
  pu as aF,
  ce as aG,
  Jt as aH,
  Zs as aI,
  xr as aJ,
  Pu as aK,
  yi as aL,
  Ns as aM,
  Ce as aN,
  qs as aO,
  di as aP,
  ws as aQ,
  Ru as aR,
  Ws as aS,
  Vr as aT,
  Bs as aU,
  tl as aV,
  Eu as aW,
  wu as aX,
  bu as aY,
  Ps as aZ,
  Wi as a_,
  rt as aa,
  Xs as ab,
  ms as ac,
  Es as ad,
  Su as ae,
  Is as af,
  Ae as ag,
  We as ah,
  qt as ai,
  ft as aj,
  he as ak,
  ve as al,
  Zt as am,
  eu as an,
  nu as ao,
  ru as ap,
  Qa as aq,
  ea as ar,
  su as as,
  Za as at,
  Xa as au,
  kr as av,
  uu as aw,
  lu as ax,
  Gr as ay,
  I as az,
  gu as b,
  Rs as b0,
  Jr as b1,
  Yr as b2,
  el as b3,
  As as b4,
  Ji as b5,
  Hs as b6,
  Dt as b7,
  Us as b8,
  zs as b9,
  Vi as ba,
  So as bb,
  Ds as bc,
  al as c,
  js as d,
  Ur as e,
  ql as f,
  Cu as g,
  kl as h,
  Kr as i,
  De as j,
  it as k,
  et as l,
  xt as m,
  Ys as n,
  Js as o,
  Fn as p,
  Nl as q,
  Nr as r,
  rs as s,
  zi as t,
  Hr as u,
  Bi as v,
  Ct as w,
  Pe as x,
  Sr as y,
  xi as z
};
//# sourceMappingURL=chunk-EPOLDU6W-CLHrVxOG.js.map
