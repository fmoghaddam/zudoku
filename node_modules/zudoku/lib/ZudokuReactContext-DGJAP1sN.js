import y, { createContext as P } from "react";
const O = (t) => {
  let n;
  const e = /* @__PURE__ */ new Set(), o = (i, v) => {
    const m = typeof i == "function" ? i(n) : i;
    if (!Object.is(m, n)) {
      const h = n;
      n = v ?? (typeof m != "object" || m === null) ? m : Object.assign({}, n, m), e.forEach((f) => f(n, h));
    }
  }, a = () => n, l = { setState: o, getState: a, getInitialState: () => d, subscribe: (i) => (e.add(i), () => e.delete(i)) }, d = n = t(o, a, l);
  return l;
}, C = ((t) => t ? O(t) : O), k = (t) => t;
function T(t, n = k) {
  const e = y.useSyncExternalStore(
    t.subscribe,
    y.useCallback(() => n(t.getState()), [t, n]),
    y.useCallback(() => n(t.getInitialState()), [t, n])
  );
  return y.useDebugValue(e), e;
}
const j = (t) => {
  const n = C(t), e = (o) => T(n, o);
  return Object.assign(e, n), e;
}, A = ((t) => j);
function w(t, n) {
  let e;
  try {
    e = t();
  } catch {
    return;
  }
  return {
    getItem: (a) => {
      var s;
      const g = (d) => d === null ? null : JSON.parse(d, void 0), l = (s = e.getItem(a)) != null ? s : null;
      return l instanceof Promise ? l.then(g) : g(l);
    },
    setItem: (a, s) => e.setItem(a, JSON.stringify(s, void 0)),
    removeItem: (a) => e.removeItem(a)
  };
}
const I = (t) => (n) => {
  try {
    const e = t(n);
    return e instanceof Promise ? e : {
      then(o) {
        return I(o)(e);
      },
      catch(o) {
        return this;
      }
    };
  } catch (e) {
    return {
      then(o) {
        return this;
      },
      catch(o) {
        return I(o)(e);
      }
    };
  }
}, D = (t, n) => (e, o, a) => {
  let s = {
    storage: w(() => localStorage),
    partialize: (r) => r,
    version: 0,
    merge: (r, S) => ({
      ...S,
      ...r
    }),
    ...n
  }, g = !1;
  const l = /* @__PURE__ */ new Set(), d = /* @__PURE__ */ new Set();
  let i = s.storage;
  if (!i)
    return t(
      (...r) => {
        console.warn(
          `[zustand persist middleware] Unable to update item '${s.name}', the given storage is currently unavailable.`
        ), e(...r);
      },
      o,
      a
    );
  const v = () => {
    const r = s.partialize({ ...o() });
    return i.setItem(s.name, {
      state: r,
      version: s.version
    });
  }, m = a.setState;
  a.setState = (r, S) => (m(r, S), v());
  const h = t(
    (...r) => (e(...r), v()),
    o,
    a
  );
  a.getInitialState = () => h;
  let f;
  const _ = () => {
    var r, S;
    if (!i) return;
    g = !1, l.forEach((u) => {
      var c;
      return u((c = o()) != null ? c : h);
    });
    const p = ((S = s.onRehydrateStorage) == null ? void 0 : S.call(s, (r = o()) != null ? r : h)) || void 0;
    return I(i.getItem.bind(i))(s.name).then((u) => {
      if (u)
        if (typeof u.version == "number" && u.version !== s.version) {
          if (s.migrate) {
            const c = s.migrate(
              u.state,
              u.version
            );
            return c instanceof Promise ? c.then((b) => [!0, b]) : [!0, c];
          }
          console.error(
            "State loaded from storage couldn't be migrated since no migrate function was provided"
          );
        } else
          return [!1, u.state];
      return [!1, void 0];
    }).then((u) => {
      var c;
      const [b, E] = u;
      if (f = s.merge(
        E,
        (c = o()) != null ? c : h
      ), e(f, !0), b)
        return v();
    }).then(() => {
      p?.(f, void 0), f = o(), g = !0, d.forEach((u) => u(f));
    }).catch((u) => {
      p?.(void 0, u);
    });
  };
  return a.persist = {
    setOptions: (r) => {
      s = {
        ...s,
        ...r
      }, r.storage && (i = r.storage);
    },
    clearStorage: () => {
      i?.removeItem(s.name);
    },
    getOptions: () => s,
    rehydrate: () => _(),
    hasHydrated: () => g,
    onHydrate: (r) => (l.add(r), () => {
      l.delete(r);
    }),
    onFinishHydration: (r) => (d.add(r), () => {
      d.delete(r);
    })
  }, s.skipHydration || _(), f || h;
}, H = D, L = (t) => {
  const n = (e) => {
    e.key === t.persist.getOptions().name && e.newValue && t.persist.rehydrate();
  };
  if (!(typeof window > "u"))
    return window.addEventListener("storage", n), () => {
      window.removeEventListener("storage", n);
    };
}, R = A()(
  H(
    (t) => ({
      isAuthenticated: !1,
      isPending: !0,
      profile: null,
      providerData: null,
      setAuthenticationPending: () => t(() => ({
        isAuthenticated: !1,
        isPending: !1,
        profile: null,
        providerData: null
      })),
      setLoggedOut: () => t(() => ({
        isAuthenticated: !1,
        isPending: !1,
        profile: null,
        providerData: null
      })),
      setLoggedIn: ({
        profile: n,
        providerData: e
      }) => t(() => ({
        isAuthenticated: !0,
        isPending: !1,
        profile: n,
        providerData: e
      }))
    }),
    {
      merge: (t, n) => ({
        ...n,
        isPending: !1,
        ...typeof t == "object" ? t : {}
      }),
      name: "auth-state",
      storage: w(() => localStorage)
    }
  )
);
L(R);
globalThis.__ZUDOKU_CONTEXT ??= P(
  void 0
);
const N = globalThis.__ZUDOKU_CONTEXT;
export {
  N as Z,
  w as a,
  C as b,
  A as c,
  T as d,
  H as p,
  L as s,
  R as u
};
//# sourceMappingURL=ZudokuReactContext-DGJAP1sN.js.map
