import { R as r, c as u, n as h } from "./useQuery-DSKGiCQr.js";
var l = class extends r {
  #n;
  #e;
  #t;
  #i;
  constructor(t) {
    super(), this.#n = t.client, this.mutationId = t.mutationId, this.#t = t.mutationCache, this.#e = [], this.state = t.state || c(), this.setOptions(t.options), this.scheduleGc();
  }
  setOptions(t) {
    this.options = t, this.updateGcTime(this.options.gcTime);
  }
  get meta() {
    return this.options.meta;
  }
  addObserver(t) {
    this.#e.includes(t) || (this.#e.push(t), this.clearGcTimeout(), this.#t.notify({
      type: "observerAdded",
      mutation: this,
      observer: t
    }));
  }
  removeObserver(t) {
    this.#e = this.#e.filter((i) => i !== t), this.scheduleGc(), this.#t.notify({
      type: "observerRemoved",
      mutation: this,
      observer: t
    });
  }
  optionalRemove() {
    this.#e.length || (this.state.status === "pending" ? this.scheduleGc() : this.#t.remove(this));
  }
  continue() {
    return this.#i?.continue() ?? // continuing a mutation assumes that variables are set, mutation must have been dehydrated before
    this.execute(this.state.variables);
  }
  async execute(t) {
    const i = () => {
      this.#s({ type: "continue" });
    }, e = {
      client: this.#n,
      meta: this.options.meta,
      mutationKey: this.options.mutationKey
    };
    this.#i = u({
      fn: () => this.options.mutationFn ? this.options.mutationFn(t, e) : Promise.reject(new Error("No mutationFn found")),
      onFail: (s, n) => {
        this.#s({ type: "failed", failureCount: s, error: n });
      },
      onPause: () => {
        this.#s({ type: "pause" });
      },
      onContinue: i,
      retry: this.options.retry ?? 0,
      retryDelay: this.options.retryDelay,
      networkMode: this.options.networkMode,
      canRun: () => this.#t.canRun(this)
    });
    const a = this.state.status === "pending", o = !this.#i.canStart();
    try {
      if (a)
        i();
      else {
        this.#s({ type: "pending", variables: t, isPaused: o }), await this.#t.config.onMutate?.(
          t,
          this,
          e
        );
        const n = await this.options.onMutate?.(
          t,
          e
        );
        n !== this.state.context && this.#s({
          type: "pending",
          context: n,
          variables: t,
          isPaused: o
        });
      }
      const s = await this.#i.start();
      return await this.#t.config.onSuccess?.(
        s,
        t,
        this.state.context,
        this,
        e
      ), await this.options.onSuccess?.(
        s,
        t,
        this.state.context,
        e
      ), await this.#t.config.onSettled?.(
        s,
        null,
        this.state.variables,
        this.state.context,
        this,
        e
      ), await this.options.onSettled?.(
        s,
        null,
        t,
        this.state.context,
        e
      ), this.#s({ type: "success", data: s }), s;
    } catch (s) {
      try {
        throw await this.#t.config.onError?.(
          s,
          t,
          this.state.context,
          this,
          e
        ), await this.options.onError?.(
          s,
          t,
          this.state.context,
          e
        ), await this.#t.config.onSettled?.(
          void 0,
          s,
          this.state.variables,
          this.state.context,
          this,
          e
        ), await this.options.onSettled?.(
          void 0,
          s,
          t,
          this.state.context,
          e
        ), s;
      } finally {
        this.#s({ type: "error", error: s });
      }
    } finally {
      this.#t.runNext(this);
    }
  }
  #s(t) {
    const i = (e) => {
      switch (t.type) {
        case "failed":
          return {
            ...e,
            failureCount: t.failureCount,
            failureReason: t.error
          };
        case "pause":
          return {
            ...e,
            isPaused: !0
          };
        case "continue":
          return {
            ...e,
            isPaused: !1
          };
        case "pending":
          return {
            ...e,
            context: t.context,
            data: void 0,
            failureCount: 0,
            failureReason: null,
            error: null,
            isPaused: t.isPaused,
            status: "pending",
            variables: t.variables,
            submittedAt: Date.now()
          };
        case "success":
          return {
            ...e,
            data: t.data,
            failureCount: 0,
            failureReason: null,
            error: null,
            status: "success",
            isPaused: !1
          };
        case "error":
          return {
            ...e,
            data: void 0,
            error: t.error,
            failureCount: e.failureCount + 1,
            failureReason: t.error,
            isPaused: !1,
            status: "error"
          };
      }
    };
    this.state = i(this.state), h.batch(() => {
      this.#e.forEach((e) => {
        e.onMutationUpdate(t);
      }), this.#t.notify({
        mutation: this,
        type: "updated",
        action: t
      });
    });
  }
};
function c() {
  return {
    context: void 0,
    data: void 0,
    error: null,
    failureCount: 0,
    failureReason: null,
    isPaused: !1,
    status: "idle",
    variables: void 0,
    submittedAt: 0
  };
}
export {
  l as M,
  c as g
};
//# sourceMappingURL=mutation-DtwNNkmQ.js.map
