import { j as g } from "./jsx-runtime-BzflLqGi.js";
import { e as fo } from "./useQuery-DSKGiCQr.js";
import { H as ho } from "./index.esm-Ca5zvoff.js";
import { z as mo, J as po } from "./index-DAWHN3cH.js";
import { createContext as nn, use as Vi, useRef as Se, useEffect as ge, useCallback as Fe, useState as De, useMemo as ft, useContext as Eo, memo as Fn, Suspense as Mr, Fragment as go, useId as To, useLayoutEffect as bo, Component as Ao, createElement as pu } from "react";
import { a as kt, d as _o, a6 as vn, a_ as xo, L as Br, b3 as Wi, O as Co } from "./chunk-EPOLDU6W-CLHrVxOG.js";
import { isSearchPlugin as Io, isAuthenticationPlugin as So, isNavigationPlugin as Eu, isEventConsumerPlugin as No, needsInitialization as ko, isApiIdentityPlugin as yo, isProfileMenuPlugin as Qi, isMdxProviderPlugin as Oo, hasHead as Lo } from "./zudoku.plugins.js";
import { b as Ro, d as Do, u as gu, Z as Po } from "./ZudokuReactContext-DGJAP1sN.js";
import { f as wo, n as bn, j as Je, a as et, s as Fr, d as Mo, g as Bo, N as Fo } from "./ZudokuContext-Mfno-z8f.js";
import { Callout as $e } from "./ui/Callout.js";
import { s as An, p as tt, a as vr, v as Hn, b as vo, V as Ho, u as Uo, t as jo, c as Tu, d as bu, o as Ve, z as Gi, e as zo, f as qo, g as Yo, i as $i, j as Vo, k as Au, E as Wo, S as Qo, H as Go, l as $o } from "./SyntaxHighlight-B1AjydLl.js";
import { Button as Ki } from "./ui/Button.js";
import { c as Un, a as Ko } from "./index-DI5SPFK9.js";
import { LinkIcon as Xo, ChevronRightIcon as Xi, SearchIcon as Zi, XIcon as Zo, ExternalLinkIcon as Jo, CircleXIcon as el, SunIcon as tl, MoonIcon as nl, MenuIcon as rl } from "lucide-react";
import { a as ul, M as il } from "./useExposedProps-WhS0f5mn.js";
import { c as ie } from "./cn-5-Gd1Dss.js";
import { B as Nn } from "./Button-qpSb3K7a.js";
import { u as Xt } from "./hook-BqOwTUgE.js";
import { DropdownMenu as al, DropdownMenuTrigger as sl, DropdownMenuContent as ol, DropdownMenuLabel as ll, DropdownMenuSeparator as Kn, DropdownMenuSub as cl, DropdownMenuSubTrigger as fl, DropdownMenuPortal as dl, DropdownMenuSubContent as hl, DropdownMenuItem as ml } from "./ui/DropdownMenu.js";
import { C as Zt } from "./ClientOnly-E7hGysn1.js";
import { VisuallyHidden as pl } from "@radix-ui/react-visually-hidden";
import * as El from "@radix-ui/react-separator";
import { c as gl, d as Tl, a as bl, b as Al } from "./Drawer-Ch7927PF.js";
import { u as _l } from "./useSuspenseQuery-DbPM3Wv6.js";
import * as xt from "@radix-ui/react-tooltip";
import { cn as xl } from "./ui/util.js";
import * as Xn from "@radix-ui/react-collapsible";
import { Input as Cl } from "./ui/Input.js";
import "./ui/Textarea.js";
import { Slot as Il } from "@radix-ui/react-slot";
import { M as Sl } from "./Mermaid-CJQJeZ9Q.js";
import { CodeBlock as Nl } from "./ui/CodeBlock.js";
import { Stepper as kl } from "./ui/Stepper.js";
import { g as yl, Z as _u } from "./invariant-B_t_F2s_.js";
const Ji = nn({
  activeAnchor: "",
  setActiveAnchor: () => {
  },
  observe: () => {
  },
  unobserve: () => {
  }
}), Hr = () => Vi(Ji), Ol = () => {
  const e = Se(null), { observe: t, unobserve: n } = Hr();
  return ge(() => {
    const u = e.current;
    if (u)
      return t(u), () => n(u);
  }, [t, n]), { ref: Fe((u) => {
    u && (e.current = u);
  }, []) };
}, Ll = ({ children: e }) => {
  const [t, n] = De(""), r = Se(null), u = Se(/* @__PURE__ */ new Set()), a = Se(/* @__PURE__ */ new Set());
  ge(() => (r.current = new IntersectionObserver(
    (l) => {
      for (const c of l)
        c.isIntersecting && c.target.id && n(c.target.id);
    },
    {
      rootMargin: "0px 0px -80% 0px",
      threshold: 0.75
    }
  ), a.current.forEach((l) => {
    u.current.add(l), r.current?.observe(l);
  }), a.current.clear(), () => r.current?.disconnect()), []), ge(() => {
    const l = u.current, c = () => {
      const d = window.scrollY === 0, f = window.innerHeight + window.scrollY >= document.body.scrollHeight;
      if (d)
        n("");
      else if (f) {
        const h = Array.from(l).pop()?.id ?? "";
        n(h);
      }
    };
    return document.addEventListener("scroll", c), () => {
      l.clear(), document.removeEventListener("scroll", c);
    };
  }, []);
  const i = ft(() => ({
    observe: (l) => {
      if (l) {
        if (!r.current) {
          a.current.add(l);
          return;
        }
        u.current.add(l), r.current.observe(l);
      }
    },
    unobserve: (l) => {
      l && (a.current.delete(l), u.current.delete(l), r.current?.unobserve(l));
    }
  }), []), o = ft(
    () => ({ activeAnchor: t, setActiveAnchor: n, ...i }),
    [t, i]
  );
  return /* @__PURE__ */ g.jsx(Ji, { value: o, children: e });
}, Rl = Un("group relative", {
  variants: {
    level: {
      6: "text-md",
      5: "text-lg",
      4: "text-xl",
      3: "text-xl font-semibold",
      2: "text-2xl font-bold",
      1: "text-4xl font-extrabold"
    }
  },
  defaultVariants: {
    level: 1
  }
}), Dl = (e) => {
  switch (e) {
    case 1:
      return "h1";
    case 2:
      return "h2";
    case 3:
      return "h3";
    case 4:
      return "h4";
    case 5:
      return "h5";
    case 6:
      return "h6";
    default:
      return "h1";
  }
}, ot = ({
  level: e,
  children: t,
  id: n,
  className: r,
  registerNavigationAnchor: u
}) => {
  const a = Dl(e ?? 1), { ref: i } = Ol();
  return /* @__PURE__ */ g.jsxs(
    a,
    {
      className: Rl({ className: r, level: e }),
      ref: u ? i : void 0,
      id: n,
      children: [
        t,
        n && /* @__PURE__ */ g.jsx(
          "a",
          {
            href: `#${n}`,
            className: "ms-[0.33em] rounded text-[0.8em] text-muted-foreground p-0.5 -m-0.5 opacity-0 group-hover:opacity-50 hover:text-primary hover:!opacity-100 transition-opacity duration-200 inline-flex items-center align-middle",
            "aria-label": `Link to ${n}`,
            children: /* @__PURE__ */ g.jsx(Xo, { className: "size-[0.75em] min-w-4 min-h-4" })
          }
        )
      ]
    }
  );
}, Zn = {
  action: ["form"],
  cite: ["blockquote", "del", "ins", "q"],
  data: ["object"],
  formAction: ["button", "input"],
  href: ["a", "area", "base", "link"],
  icon: ["menuitem"],
  itemId: null,
  manifest: ["html"],
  ping: ["a", "area"],
  poster: ["video"],
  src: [
    "audio",
    "embed",
    "iframe",
    "img",
    "input",
    "script",
    "source",
    "track",
    "video"
  ]
}, Pl = {};
function Ur(e, t) {
  const n = Pl, r = typeof n.includeImageAlt == "boolean" ? n.includeImageAlt : !0, u = typeof n.includeHtml == "boolean" ? n.includeHtml : !0;
  return ea(e, r, u);
}
function ea(e, t, n) {
  if (wl(e)) {
    if ("value" in e)
      return e.type === "html" && !n ? "" : e.value;
    if (t && "alt" in e && e.alt)
      return e.alt;
    if ("children" in e)
      return xu(e.children, t, n);
  }
  return Array.isArray(e) ? xu(e, t, n) : "";
}
function xu(e, t, n) {
  const r = [];
  let u = -1;
  for (; ++u < e.length; )
    r[u] = ea(e[u], t, n);
  return r.join("");
}
function wl(e) {
  return !!(e && typeof e == "object");
}
const Cu = typeof document < "u" ? document.createElement("i") : null;
function jr(e) {
  const t = "&" + e + ";";
  Cu.innerHTML = t;
  const n = Cu.textContent;
  return n.charCodeAt(n.length - 1) === 59 && e !== "semi" || n === t ? !1 : n;
}
function ve(e, t, n, r) {
  const u = e.length;
  let a = 0, i;
  if (t < 0 ? t = -t > u ? 0 : u + t : t = t > u ? u : t, n = n > 0 ? n : 0, r.length < 1e4)
    i = Array.from(r), i.unshift(t, n), e.splice(...i);
  else
    for (n && e.splice(t, n); a < r.length; )
      i = r.slice(a, a + 1e4), i.unshift(t, 0), e.splice(...i), a += 1e4, t += 1e4;
}
function Ne(e, t) {
  return e.length > 0 ? (ve(e, e.length, 0, t), e) : t;
}
const Iu = {}.hasOwnProperty;
function Ml(e) {
  const t = {};
  let n = -1;
  for (; ++n < e.length; )
    Bl(t, e[n]);
  return t;
}
function Bl(e, t) {
  let n;
  for (n in t) {
    const u = (Iu.call(e, n) ? e[n] : void 0) || (e[n] = {}), a = t[n];
    let i;
    if (a)
      for (i in a) {
        Iu.call(u, i) || (u[i] = []);
        const o = a[i];
        Fl(
          // @ts-expect-error Looks like a list.
          u[i],
          Array.isArray(o) ? o : o ? [o] : []
        );
      }
  }
}
function Fl(e, t) {
  let n = -1;
  const r = [];
  for (; ++n < t.length; )
    (t[n].add === "after" ? e : r).push(t[n]);
  ve(e, 0, 0, r);
}
function ta(e, t) {
  const n = Number.parseInt(e, t);
  return (
    // C0 except for HT, LF, FF, CR, space.
    n < 9 || n === 11 || n > 13 && n < 32 || // Control character (DEL) of C0, and C1 controls.
    n > 126 && n < 160 || // Lone high surrogates and low surrogates.
    n > 55295 && n < 57344 || // Noncharacters.
    n > 64975 && n < 65008 || /* eslint-disable no-bitwise */
    (n & 65535) === 65535 || (n & 65535) === 65534 || /* eslint-enable no-bitwise */
    // Out of range
    n > 1114111 ? "�" : String.fromCodePoint(n)
  );
}
function Ct(e) {
  return e.replace(/[\t\n\r ]+/g, " ").replace(/^ | $/g, "").toLowerCase().toUpperCase();
}
const Ee = nt(/[A-Za-z]/), me = nt(/[\dA-Za-z]/), vl = nt(/[#-'*+\--9=?A-Z^-~]/);
function kn(e) {
  return (
    // Special whitespace codes (which have negative values), C0 and Control
    // character DEL
    e !== null && (e < 32 || e === 127)
  );
}
const br = nt(/\d/), Hl = nt(/[\dA-Fa-f]/), Ul = nt(/[!-/:-@[-`{-~]/);
function j(e) {
  return e !== null && e < -2;
}
function ne(e) {
  return e !== null && (e < 0 || e === 32);
}
function W(e) {
  return e === -2 || e === -1 || e === 32;
}
const jn = nt(/\p{P}|\p{S}/u), dt = nt(/\s/);
function nt(e) {
  return t;
  function t(n) {
    return n !== null && n > -1 && e.test(String.fromCharCode(n));
  }
}
function K(e, t, n, r) {
  const u = r ? r - 1 : Number.POSITIVE_INFINITY;
  let a = 0;
  return i;
  function i(l) {
    return W(l) ? (e.enter(n), o(l)) : t(l);
  }
  function o(l) {
    return W(l) && a++ < u ? (e.consume(l), o) : (e.exit(n), t(l));
  }
}
const jl = {
  tokenize: zl
};
function zl(e) {
  const t = e.attempt(
    this.parser.constructs.contentInitial,
    r,
    u
  );
  let n;
  return t;
  function r(o) {
    if (o === null) {
      e.consume(o);
      return;
    }
    return e.enter("lineEnding"), e.consume(o), e.exit("lineEnding"), K(e, t, "linePrefix");
  }
  function u(o) {
    return e.enter("paragraph"), a(o);
  }
  function a(o) {
    const l = e.enter("chunkText", {
      contentType: "text",
      previous: n
    });
    return n && (n.next = l), n = l, i(o);
  }
  function i(o) {
    if (o === null) {
      e.exit("chunkText"), e.exit("paragraph"), e.consume(o);
      return;
    }
    return j(o) ? (e.consume(o), e.exit("chunkText"), a) : (e.consume(o), i);
  }
}
const ql = {
  tokenize: Yl
}, Su = {
  tokenize: Vl
};
function Yl(e) {
  const t = this, n = [];
  let r = 0, u, a, i;
  return o;
  function o(O) {
    if (r < n.length) {
      const v = n[r];
      return t.containerState = v[1], e.attempt(
        v[0].continuation,
        l,
        c
      )(O);
    }
    return c(O);
  }
  function l(O) {
    if (r++, t.containerState._closeFlow) {
      t.containerState._closeFlow = void 0, u && w();
      const v = t.events.length;
      let R = v, N;
      for (; R--; )
        if (t.events[R][0] === "exit" && t.events[R][1].type === "chunkFlow") {
          N = t.events[R][1].end;
          break;
        }
      C(r);
      let z = v;
      for (; z < t.events.length; )
        t.events[z][1].end = Object.assign({}, N), z++;
      return ve(
        t.events,
        R + 1,
        0,
        t.events.slice(v)
      ), t.events.length = z, c(O);
    }
    return o(O);
  }
  function c(O) {
    if (r === n.length) {
      if (!u)
        return m(O);
      if (u.currentConstruct && u.currentConstruct.concrete)
        return b(O);
      t.interrupt = !!(u.currentConstruct && !u._gfmTableDynamicInterruptHack);
    }
    return t.containerState = {}, e.check(
      Su,
      d,
      f
    )(O);
  }
  function d(O) {
    return u && w(), C(r), m(O);
  }
  function f(O) {
    return t.parser.lazy[t.now().line] = r !== n.length, i = t.now().offset, b(O);
  }
  function m(O) {
    return t.containerState = {}, e.attempt(
      Su,
      h,
      b
    )(O);
  }
  function h(O) {
    return r++, n.push([t.currentConstruct, t.containerState]), m(O);
  }
  function b(O) {
    if (O === null) {
      u && w(), C(0), e.consume(O);
      return;
    }
    return u = u || t.parser.flow(t.now()), e.enter("chunkFlow", {
      contentType: "flow",
      previous: a,
      _tokenizer: u
    }), I(O);
  }
  function I(O) {
    if (O === null) {
      y(e.exit("chunkFlow"), !0), C(0), e.consume(O);
      return;
    }
    return j(O) ? (e.consume(O), y(e.exit("chunkFlow")), r = 0, t.interrupt = void 0, o) : (e.consume(O), I);
  }
  function y(O, v) {
    const R = t.sliceStream(O);
    if (v && R.push(null), O.previous = a, a && (a.next = O), a = O, u.defineSkip(O.start), u.write(R), t.parser.lazy[O.start.line]) {
      let N = u.events.length;
      for (; N--; )
        if (
          // The token starts before the line ending…
          u.events[N][1].start.offset < i && // …and either is not ended yet…
          (!u.events[N][1].end || // …or ends after it.
          u.events[N][1].end.offset > i)
        )
          return;
      const z = t.events.length;
      let X = z, Q, S;
      for (; X--; )
        if (t.events[X][0] === "exit" && t.events[X][1].type === "chunkFlow") {
          if (Q) {
            S = t.events[X][1].end;
            break;
          }
          Q = !0;
        }
      for (C(r), N = z; N < t.events.length; )
        t.events[N][1].end = Object.assign({}, S), N++;
      ve(
        t.events,
        X + 1,
        0,
        t.events.slice(z)
      ), t.events.length = N;
    }
  }
  function C(O) {
    let v = n.length;
    for (; v-- > O; ) {
      const R = n[v];
      t.containerState = R[1], R[0].exit.call(t, e);
    }
    n.length = O;
  }
  function w() {
    u.write([null]), a = void 0, u = void 0, t.containerState._closeFlow = void 0;
  }
}
function Vl(e, t, n) {
  return K(
    e,
    e.attempt(this.parser.constructs.document, t, n),
    "linePrefix",
    this.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4
  );
}
function St(e) {
  if (e === null || ne(e) || dt(e))
    return 1;
  if (jn(e))
    return 2;
}
function zr(e, t, n) {
  const r = [];
  let u = -1;
  for (; ++u < e.length; ) {
    const a = e[u].resolveAll;
    a && !r.includes(a) && (t = a(t, n), r.push(a));
  }
  return t;
}
const Ar = {
  name: "attention",
  tokenize: Ql,
  resolveAll: Wl
};
function Wl(e, t) {
  let n = -1, r, u, a, i, o, l, c, d;
  for (; ++n < e.length; )
    if (e[n][0] === "enter" && e[n][1].type === "attentionSequence" && e[n][1]._close) {
      for (r = n; r--; )
        if (e[r][0] === "exit" && e[r][1].type === "attentionSequence" && e[r][1]._open && // If the markers are the same:
        t.sliceSerialize(e[r][1]).charCodeAt(0) === t.sliceSerialize(e[n][1]).charCodeAt(0)) {
          if ((e[r][1]._close || e[n][1]._open) && (e[n][1].end.offset - e[n][1].start.offset) % 3 && !((e[r][1].end.offset - e[r][1].start.offset + e[n][1].end.offset - e[n][1].start.offset) % 3))
            continue;
          l = e[r][1].end.offset - e[r][1].start.offset > 1 && e[n][1].end.offset - e[n][1].start.offset > 1 ? 2 : 1;
          const f = Object.assign({}, e[r][1].end), m = Object.assign({}, e[n][1].start);
          Nu(f, -l), Nu(m, l), i = {
            type: l > 1 ? "strongSequence" : "emphasisSequence",
            start: f,
            end: Object.assign({}, e[r][1].end)
          }, o = {
            type: l > 1 ? "strongSequence" : "emphasisSequence",
            start: Object.assign({}, e[n][1].start),
            end: m
          }, a = {
            type: l > 1 ? "strongText" : "emphasisText",
            start: Object.assign({}, e[r][1].end),
            end: Object.assign({}, e[n][1].start)
          }, u = {
            type: l > 1 ? "strong" : "emphasis",
            start: Object.assign({}, i.start),
            end: Object.assign({}, o.end)
          }, e[r][1].end = Object.assign({}, i.start), e[n][1].start = Object.assign({}, o.end), c = [], e[r][1].end.offset - e[r][1].start.offset && (c = Ne(c, [
            ["enter", e[r][1], t],
            ["exit", e[r][1], t]
          ])), c = Ne(c, [
            ["enter", u, t],
            ["enter", i, t],
            ["exit", i, t],
            ["enter", a, t]
          ]), c = Ne(
            c,
            zr(
              t.parser.constructs.insideSpan.null,
              e.slice(r + 1, n),
              t
            )
          ), c = Ne(c, [
            ["exit", a, t],
            ["enter", o, t],
            ["exit", o, t],
            ["exit", u, t]
          ]), e[n][1].end.offset - e[n][1].start.offset ? (d = 2, c = Ne(c, [
            ["enter", e[n][1], t],
            ["exit", e[n][1], t]
          ])) : d = 0, ve(e, r - 1, n - r + 3, c), n = r + c.length - d - 2;
          break;
        }
    }
  for (n = -1; ++n < e.length; )
    e[n][1].type === "attentionSequence" && (e[n][1].type = "data");
  return e;
}
function Ql(e, t) {
  const n = this.parser.constructs.attentionMarkers.null, r = this.previous, u = St(r);
  let a;
  return i;
  function i(l) {
    return a = l, e.enter("attentionSequence"), o(l);
  }
  function o(l) {
    if (l === a)
      return e.consume(l), o;
    const c = e.exit("attentionSequence"), d = St(l), f = !d || d === 2 && u || n.includes(l), m = !u || u === 2 && d || n.includes(r);
    return c._open = !!(a === 42 ? f : f && (u || !m)), c._close = !!(a === 42 ? m : m && (d || !f)), t(l);
  }
}
function Nu(e, t) {
  e.column += t, e.offset += t, e._bufferIndex += t;
}
const Gl = {
  name: "autolink",
  tokenize: $l
};
function $l(e, t, n) {
  let r = 0;
  return u;
  function u(h) {
    return e.enter("autolink"), e.enter("autolinkMarker"), e.consume(h), e.exit("autolinkMarker"), e.enter("autolinkProtocol"), a;
  }
  function a(h) {
    return Ee(h) ? (e.consume(h), i) : c(h);
  }
  function i(h) {
    return h === 43 || h === 45 || h === 46 || me(h) ? (r = 1, o(h)) : c(h);
  }
  function o(h) {
    return h === 58 ? (e.consume(h), r = 0, l) : (h === 43 || h === 45 || h === 46 || me(h)) && r++ < 32 ? (e.consume(h), o) : (r = 0, c(h));
  }
  function l(h) {
    return h === 62 ? (e.exit("autolinkProtocol"), e.enter("autolinkMarker"), e.consume(h), e.exit("autolinkMarker"), e.exit("autolink"), t) : h === null || h === 32 || h === 60 || kn(h) ? n(h) : (e.consume(h), l);
  }
  function c(h) {
    return h === 64 ? (e.consume(h), d) : vl(h) ? (e.consume(h), c) : n(h);
  }
  function d(h) {
    return me(h) ? f(h) : n(h);
  }
  function f(h) {
    return h === 46 ? (e.consume(h), r = 0, d) : h === 62 ? (e.exit("autolinkProtocol").type = "autolinkEmail", e.enter("autolinkMarker"), e.consume(h), e.exit("autolinkMarker"), e.exit("autolink"), t) : m(h);
  }
  function m(h) {
    if ((h === 45 || me(h)) && r++ < 63) {
      const b = h === 45 ? m : f;
      return e.consume(h), b;
    }
    return n(h);
  }
}
const zn = {
  tokenize: Kl,
  partial: !0
};
function Kl(e, t, n) {
  return r;
  function r(a) {
    return W(a) ? K(e, u, "linePrefix")(a) : u(a);
  }
  function u(a) {
    return a === null || j(a) ? t(a) : n(a);
  }
}
const na = {
  name: "blockQuote",
  tokenize: Xl,
  continuation: {
    tokenize: Zl
  },
  exit: Jl
};
function Xl(e, t, n) {
  const r = this;
  return u;
  function u(i) {
    if (i === 62) {
      const o = r.containerState;
      return o.open || (e.enter("blockQuote", {
        _container: !0
      }), o.open = !0), e.enter("blockQuotePrefix"), e.enter("blockQuoteMarker"), e.consume(i), e.exit("blockQuoteMarker"), a;
    }
    return n(i);
  }
  function a(i) {
    return W(i) ? (e.enter("blockQuotePrefixWhitespace"), e.consume(i), e.exit("blockQuotePrefixWhitespace"), e.exit("blockQuotePrefix"), t) : (e.exit("blockQuotePrefix"), t(i));
  }
}
function Zl(e, t, n) {
  const r = this;
  return u;
  function u(i) {
    return W(i) ? K(
      e,
      a,
      "linePrefix",
      r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4
    )(i) : a(i);
  }
  function a(i) {
    return e.attempt(na, t, n)(i);
  }
}
function Jl(e) {
  e.exit("blockQuote");
}
const ra = {
  name: "characterEscape",
  tokenize: ec
};
function ec(e, t, n) {
  return r;
  function r(a) {
    return e.enter("characterEscape"), e.enter("escapeMarker"), e.consume(a), e.exit("escapeMarker"), u;
  }
  function u(a) {
    return Ul(a) ? (e.enter("characterEscapeValue"), e.consume(a), e.exit("characterEscapeValue"), e.exit("characterEscape"), t) : n(a);
  }
}
const ua = {
  name: "characterReference",
  tokenize: tc
};
function tc(e, t, n) {
  const r = this;
  let u = 0, a, i;
  return o;
  function o(f) {
    return e.enter("characterReference"), e.enter("characterReferenceMarker"), e.consume(f), e.exit("characterReferenceMarker"), l;
  }
  function l(f) {
    return f === 35 ? (e.enter("characterReferenceMarkerNumeric"), e.consume(f), e.exit("characterReferenceMarkerNumeric"), c) : (e.enter("characterReferenceValue"), a = 31, i = me, d(f));
  }
  function c(f) {
    return f === 88 || f === 120 ? (e.enter("characterReferenceMarkerHexadecimal"), e.consume(f), e.exit("characterReferenceMarkerHexadecimal"), e.enter("characterReferenceValue"), a = 6, i = Hl, d) : (e.enter("characterReferenceValue"), a = 7, i = br, d(f));
  }
  function d(f) {
    if (f === 59 && u) {
      const m = e.exit("characterReferenceValue");
      return i === me && !jr(r.sliceSerialize(m)) ? n(f) : (e.enter("characterReferenceMarker"), e.consume(f), e.exit("characterReferenceMarker"), e.exit("characterReference"), t);
    }
    return i(f) && u++ < a ? (e.consume(f), d) : n(f);
  }
}
const ku = {
  tokenize: rc,
  partial: !0
}, yu = {
  name: "codeFenced",
  tokenize: nc,
  concrete: !0
};
function nc(e, t, n) {
  const r = this, u = {
    tokenize: R,
    partial: !0
  };
  let a = 0, i = 0, o;
  return l;
  function l(N) {
    return c(N);
  }
  function c(N) {
    const z = r.events[r.events.length - 1];
    return a = z && z[1].type === "linePrefix" ? z[2].sliceSerialize(z[1], !0).length : 0, o = N, e.enter("codeFenced"), e.enter("codeFencedFence"), e.enter("codeFencedFenceSequence"), d(N);
  }
  function d(N) {
    return N === o ? (i++, e.consume(N), d) : i < 3 ? n(N) : (e.exit("codeFencedFenceSequence"), W(N) ? K(e, f, "whitespace")(N) : f(N));
  }
  function f(N) {
    return N === null || j(N) ? (e.exit("codeFencedFence"), r.interrupt ? t(N) : e.check(ku, I, v)(N)) : (e.enter("codeFencedFenceInfo"), e.enter("chunkString", {
      contentType: "string"
    }), m(N));
  }
  function m(N) {
    return N === null || j(N) ? (e.exit("chunkString"), e.exit("codeFencedFenceInfo"), f(N)) : W(N) ? (e.exit("chunkString"), e.exit("codeFencedFenceInfo"), K(e, h, "whitespace")(N)) : N === 96 && N === o ? n(N) : (e.consume(N), m);
  }
  function h(N) {
    return N === null || j(N) ? f(N) : (e.enter("codeFencedFenceMeta"), e.enter("chunkString", {
      contentType: "string"
    }), b(N));
  }
  function b(N) {
    return N === null || j(N) ? (e.exit("chunkString"), e.exit("codeFencedFenceMeta"), f(N)) : N === 96 && N === o ? n(N) : (e.consume(N), b);
  }
  function I(N) {
    return e.attempt(u, v, y)(N);
  }
  function y(N) {
    return e.enter("lineEnding"), e.consume(N), e.exit("lineEnding"), C;
  }
  function C(N) {
    return a > 0 && W(N) ? K(
      e,
      w,
      "linePrefix",
      a + 1
    )(N) : w(N);
  }
  function w(N) {
    return N === null || j(N) ? e.check(ku, I, v)(N) : (e.enter("codeFlowValue"), O(N));
  }
  function O(N) {
    return N === null || j(N) ? (e.exit("codeFlowValue"), w(N)) : (e.consume(N), O);
  }
  function v(N) {
    return e.exit("codeFenced"), t(N);
  }
  function R(N, z, X) {
    let Q = 0;
    return S;
    function S(G) {
      return N.enter("lineEnding"), N.consume(G), N.exit("lineEnding"), H;
    }
    function H(G) {
      return N.enter("codeFencedFence"), W(G) ? K(
        N,
        F,
        "linePrefix",
        r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4
      )(G) : F(G);
    }
    function F(G) {
      return G === o ? (N.enter("codeFencedFenceSequence"), ee(G)) : X(G);
    }
    function ee(G) {
      return G === o ? (Q++, N.consume(G), ee) : Q >= i ? (N.exit("codeFencedFenceSequence"), W(G) ? K(N, ue, "whitespace")(G) : ue(G)) : X(G);
    }
    function ue(G) {
      return G === null || j(G) ? (N.exit("codeFencedFence"), z(G)) : X(G);
    }
  }
}
function rc(e, t, n) {
  const r = this;
  return u;
  function u(i) {
    return i === null ? n(i) : (e.enter("lineEnding"), e.consume(i), e.exit("lineEnding"), a);
  }
  function a(i) {
    return r.parser.lazy[r.now().line] ? n(i) : t(i);
  }
}
const Jn = {
  name: "codeIndented",
  tokenize: ic
}, uc = {
  tokenize: ac,
  partial: !0
};
function ic(e, t, n) {
  const r = this;
  return u;
  function u(c) {
    return e.enter("codeIndented"), K(e, a, "linePrefix", 5)(c);
  }
  function a(c) {
    const d = r.events[r.events.length - 1];
    return d && d[1].type === "linePrefix" && d[2].sliceSerialize(d[1], !0).length >= 4 ? i(c) : n(c);
  }
  function i(c) {
    return c === null ? l(c) : j(c) ? e.attempt(uc, i, l)(c) : (e.enter("codeFlowValue"), o(c));
  }
  function o(c) {
    return c === null || j(c) ? (e.exit("codeFlowValue"), i(c)) : (e.consume(c), o);
  }
  function l(c) {
    return e.exit("codeIndented"), t(c);
  }
}
function ac(e, t, n) {
  const r = this;
  return u;
  function u(i) {
    return r.parser.lazy[r.now().line] ? n(i) : j(i) ? (e.enter("lineEnding"), e.consume(i), e.exit("lineEnding"), u) : K(e, a, "linePrefix", 5)(i);
  }
  function a(i) {
    const o = r.events[r.events.length - 1];
    return o && o[1].type === "linePrefix" && o[2].sliceSerialize(o[1], !0).length >= 4 ? t(i) : j(i) ? u(i) : n(i);
  }
}
const sc = {
  name: "codeText",
  tokenize: cc,
  resolve: oc,
  previous: lc
};
function oc(e) {
  let t = e.length - 4, n = 3, r, u;
  if ((e[n][1].type === "lineEnding" || e[n][1].type === "space") && (e[t][1].type === "lineEnding" || e[t][1].type === "space")) {
    for (r = n; ++r < t; )
      if (e[r][1].type === "codeTextData") {
        e[n][1].type = "codeTextPadding", e[t][1].type = "codeTextPadding", n += 2, t -= 2;
        break;
      }
  }
  for (r = n - 1, t++; ++r <= t; )
    u === void 0 ? r !== t && e[r][1].type !== "lineEnding" && (u = r) : (r === t || e[r][1].type === "lineEnding") && (e[u][1].type = "codeTextData", r !== u + 2 && (e[u][1].end = e[r - 1][1].end, e.splice(u + 2, r - u - 2), t -= r - u - 2, r = u + 2), u = void 0);
  return e;
}
function lc(e) {
  return e !== 96 || this.events[this.events.length - 1][1].type === "characterEscape";
}
function cc(e, t, n) {
  let r = 0, u, a;
  return i;
  function i(f) {
    return e.enter("codeText"), e.enter("codeTextSequence"), o(f);
  }
  function o(f) {
    return f === 96 ? (e.consume(f), r++, o) : (e.exit("codeTextSequence"), l(f));
  }
  function l(f) {
    return f === null ? n(f) : f === 32 ? (e.enter("space"), e.consume(f), e.exit("space"), l) : f === 96 ? (a = e.enter("codeTextSequence"), u = 0, d(f)) : j(f) ? (e.enter("lineEnding"), e.consume(f), e.exit("lineEnding"), l) : (e.enter("codeTextData"), c(f));
  }
  function c(f) {
    return f === null || f === 32 || f === 96 || j(f) ? (e.exit("codeTextData"), l(f)) : (e.consume(f), c);
  }
  function d(f) {
    return f === 96 ? (e.consume(f), u++, d) : u === r ? (e.exit("codeTextSequence"), e.exit("codeText"), t(f)) : (a.type = "codeTextData", c(f));
  }
}
function ia(e) {
  const t = {};
  let n = -1, r, u, a, i, o, l, c;
  for (; ++n < e.length; ) {
    for (; n in t; )
      n = t[n];
    if (r = e[n], n && r[1].type === "chunkFlow" && e[n - 1][1].type === "listItemPrefix" && (l = r[1]._tokenizer.events, a = 0, a < l.length && l[a][1].type === "lineEndingBlank" && (a += 2), a < l.length && l[a][1].type === "content"))
      for (; ++a < l.length && l[a][1].type !== "content"; )
        l[a][1].type === "chunkText" && (l[a][1]._isInFirstContentOfListItem = !0, a++);
    if (r[0] === "enter")
      r[1].contentType && (Object.assign(t, fc(e, n)), n = t[n], c = !0);
    else if (r[1]._container) {
      for (a = n, u = void 0; a-- && (i = e[a], i[1].type === "lineEnding" || i[1].type === "lineEndingBlank"); )
        i[0] === "enter" && (u && (e[u][1].type = "lineEndingBlank"), i[1].type = "lineEnding", u = a);
      u && (r[1].end = Object.assign({}, e[u][1].start), o = e.slice(u, n), o.unshift(r), ve(e, u, n - u + 1, o));
    }
  }
  return !c;
}
function fc(e, t) {
  const n = e[t][1], r = e[t][2];
  let u = t - 1;
  const a = [], i = n._tokenizer || r.parser[n.contentType](n.start), o = i.events, l = [], c = {};
  let d, f, m = -1, h = n, b = 0, I = 0;
  const y = [I];
  for (; h; ) {
    for (; e[++u][1] !== h; )
      ;
    a.push(u), h._tokenizer || (d = r.sliceStream(h), h.next || d.push(null), f && i.defineSkip(h.start), h._isInFirstContentOfListItem && (i._gfmTasklistFirstContentOfListItem = !0), i.write(d), h._isInFirstContentOfListItem && (i._gfmTasklistFirstContentOfListItem = void 0)), f = h, h = h.next;
  }
  for (h = n; ++m < o.length; )
    // Find a void token that includes a break.
    o[m][0] === "exit" && o[m - 1][0] === "enter" && o[m][1].type === o[m - 1][1].type && o[m][1].start.line !== o[m][1].end.line && (I = m + 1, y.push(I), h._tokenizer = void 0, h.previous = void 0, h = h.next);
  for (i.events = [], h ? (h._tokenizer = void 0, h.previous = void 0) : y.pop(), m = y.length; m--; ) {
    const C = o.slice(y[m], y[m + 1]), w = a.pop();
    l.unshift([w, w + C.length - 1]), ve(e, w, 2, C);
  }
  for (m = -1; ++m < l.length; )
    c[b + l[m][0]] = b + l[m][1], b += l[m][1] - l[m][0] - 1;
  return c;
}
const dc = {
  tokenize: pc,
  resolve: mc
}, hc = {
  tokenize: Ec,
  partial: !0
};
function mc(e) {
  return ia(e), e;
}
function pc(e, t) {
  let n;
  return r;
  function r(o) {
    return e.enter("content"), n = e.enter("chunkContent", {
      contentType: "content"
    }), u(o);
  }
  function u(o) {
    return o === null ? a(o) : j(o) ? e.check(
      hc,
      i,
      a
    )(o) : (e.consume(o), u);
  }
  function a(o) {
    return e.exit("chunkContent"), e.exit("content"), t(o);
  }
  function i(o) {
    return e.consume(o), e.exit("chunkContent"), n.next = e.enter("chunkContent", {
      contentType: "content",
      previous: n
    }), n = n.next, u;
  }
}
function Ec(e, t, n) {
  const r = this;
  return u;
  function u(i) {
    return e.exit("chunkContent"), e.enter("lineEnding"), e.consume(i), e.exit("lineEnding"), K(e, a, "linePrefix");
  }
  function a(i) {
    if (i === null || j(i))
      return n(i);
    const o = r.events[r.events.length - 1];
    return !r.parser.constructs.disable.null.includes("codeIndented") && o && o[1].type === "linePrefix" && o[2].sliceSerialize(o[1], !0).length >= 4 ? t(i) : e.interrupt(r.parser.constructs.flow, n, t)(i);
  }
}
function aa(e, t, n, r, u, a, i, o, l) {
  const c = l || Number.POSITIVE_INFINITY;
  let d = 0;
  return f;
  function f(C) {
    return C === 60 ? (e.enter(r), e.enter(u), e.enter(a), e.consume(C), e.exit(a), m) : C === null || C === 32 || C === 41 || kn(C) ? n(C) : (e.enter(r), e.enter(i), e.enter(o), e.enter("chunkString", {
      contentType: "string"
    }), I(C));
  }
  function m(C) {
    return C === 62 ? (e.enter(a), e.consume(C), e.exit(a), e.exit(u), e.exit(r), t) : (e.enter(o), e.enter("chunkString", {
      contentType: "string"
    }), h(C));
  }
  function h(C) {
    return C === 62 ? (e.exit("chunkString"), e.exit(o), m(C)) : C === null || C === 60 || j(C) ? n(C) : (e.consume(C), C === 92 ? b : h);
  }
  function b(C) {
    return C === 60 || C === 62 || C === 92 ? (e.consume(C), h) : h(C);
  }
  function I(C) {
    return !d && (C === null || C === 41 || ne(C)) ? (e.exit("chunkString"), e.exit(o), e.exit(i), e.exit(r), t(C)) : d < c && C === 40 ? (e.consume(C), d++, I) : C === 41 ? (e.consume(C), d--, I) : C === null || C === 32 || C === 40 || kn(C) ? n(C) : (e.consume(C), C === 92 ? y : I);
  }
  function y(C) {
    return C === 40 || C === 41 || C === 92 ? (e.consume(C), I) : I(C);
  }
}
function sa(e, t, n, r, u, a) {
  const i = this;
  let o = 0, l;
  return c;
  function c(h) {
    return e.enter(r), e.enter(u), e.consume(h), e.exit(u), e.enter(a), d;
  }
  function d(h) {
    return o > 999 || h === null || h === 91 || h === 93 && !l || // To do: remove in the future once we’ve switched from
    // `micromark-extension-footnote` to `micromark-extension-gfm-footnote`,
    // which doesn’t need this.
    // Hidden footnotes hook.
    /* c8 ignore next 3 */
    h === 94 && !o && "_hiddenFootnoteSupport" in i.parser.constructs ? n(h) : h === 93 ? (e.exit(a), e.enter(u), e.consume(h), e.exit(u), e.exit(r), t) : j(h) ? (e.enter("lineEnding"), e.consume(h), e.exit("lineEnding"), d) : (e.enter("chunkString", {
      contentType: "string"
    }), f(h));
  }
  function f(h) {
    return h === null || h === 91 || h === 93 || j(h) || o++ > 999 ? (e.exit("chunkString"), d(h)) : (e.consume(h), l || (l = !W(h)), h === 92 ? m : f);
  }
  function m(h) {
    return h === 91 || h === 92 || h === 93 ? (e.consume(h), o++, f) : f(h);
  }
}
function oa(e, t, n, r, u, a) {
  let i;
  return o;
  function o(m) {
    return m === 34 || m === 39 || m === 40 ? (e.enter(r), e.enter(u), e.consume(m), e.exit(u), i = m === 40 ? 41 : m, l) : n(m);
  }
  function l(m) {
    return m === i ? (e.enter(u), e.consume(m), e.exit(u), e.exit(r), t) : (e.enter(a), c(m));
  }
  function c(m) {
    return m === i ? (e.exit(a), l(i)) : m === null ? n(m) : j(m) ? (e.enter("lineEnding"), e.consume(m), e.exit("lineEnding"), K(e, c, "linePrefix")) : (e.enter("chunkString", {
      contentType: "string"
    }), d(m));
  }
  function d(m) {
    return m === i || m === null || j(m) ? (e.exit("chunkString"), c(m)) : (e.consume(m), m === 92 ? f : d);
  }
  function f(m) {
    return m === i || m === 92 ? (e.consume(m), d) : d(m);
  }
}
function Yt(e, t) {
  let n;
  return r;
  function r(u) {
    return j(u) ? (e.enter("lineEnding"), e.consume(u), e.exit("lineEnding"), n = !0, r) : W(u) ? K(e, r, n ? "linePrefix" : "lineSuffix")(u) : t(u);
  }
}
const gc = {
  name: "definition",
  tokenize: bc
}, Tc = {
  tokenize: Ac,
  partial: !0
};
function bc(e, t, n) {
  const r = this;
  let u;
  return a;
  function a(h) {
    return e.enter("definition"), i(h);
  }
  function i(h) {
    return sa.call(
      r,
      e,
      o,
      // Note: we don’t need to reset the way `markdown-rs` does.
      n,
      "definitionLabel",
      "definitionLabelMarker",
      "definitionLabelString"
    )(h);
  }
  function o(h) {
    return u = Ct(
      r.sliceSerialize(r.events[r.events.length - 1][1]).slice(1, -1)
    ), h === 58 ? (e.enter("definitionMarker"), e.consume(h), e.exit("definitionMarker"), l) : n(h);
  }
  function l(h) {
    return ne(h) ? Yt(e, c)(h) : c(h);
  }
  function c(h) {
    return aa(
      e,
      d,
      // Note: we don’t need to reset the way `markdown-rs` does.
      n,
      "definitionDestination",
      "definitionDestinationLiteral",
      "definitionDestinationLiteralMarker",
      "definitionDestinationRaw",
      "definitionDestinationString"
    )(h);
  }
  function d(h) {
    return e.attempt(Tc, f, f)(h);
  }
  function f(h) {
    return W(h) ? K(e, m, "whitespace")(h) : m(h);
  }
  function m(h) {
    return h === null || j(h) ? (e.exit("definition"), r.parser.defined.push(u), t(h)) : n(h);
  }
}
function Ac(e, t, n) {
  return r;
  function r(o) {
    return ne(o) ? Yt(e, u)(o) : n(o);
  }
  function u(o) {
    return oa(
      e,
      a,
      n,
      "definitionTitle",
      "definitionTitleMarker",
      "definitionTitleString"
    )(o);
  }
  function a(o) {
    return W(o) ? K(e, i, "whitespace")(o) : i(o);
  }
  function i(o) {
    return o === null || j(o) ? t(o) : n(o);
  }
}
const _c = {
  name: "hardBreakEscape",
  tokenize: xc
};
function xc(e, t, n) {
  return r;
  function r(a) {
    return e.enter("hardBreakEscape"), e.consume(a), u;
  }
  function u(a) {
    return j(a) ? (e.exit("hardBreakEscape"), t(a)) : n(a);
  }
}
const Cc = {
  name: "headingAtx",
  tokenize: Sc,
  resolve: Ic
};
function Ic(e, t) {
  let n = e.length - 2, r = 3, u, a;
  return e[r][1].type === "whitespace" && (r += 2), n - 2 > r && e[n][1].type === "whitespace" && (n -= 2), e[n][1].type === "atxHeadingSequence" && (r === n - 1 || n - 4 > r && e[n - 2][1].type === "whitespace") && (n -= r + 1 === n ? 2 : 4), n > r && (u = {
    type: "atxHeadingText",
    start: e[r][1].start,
    end: e[n][1].end
  }, a = {
    type: "chunkText",
    start: e[r][1].start,
    end: e[n][1].end,
    contentType: "text"
  }, ve(e, r, n - r + 1, [
    ["enter", u, t],
    ["enter", a, t],
    ["exit", a, t],
    ["exit", u, t]
  ])), e;
}
function Sc(e, t, n) {
  let r = 0;
  return u;
  function u(d) {
    return e.enter("atxHeading"), a(d);
  }
  function a(d) {
    return e.enter("atxHeadingSequence"), i(d);
  }
  function i(d) {
    return d === 35 && r++ < 6 ? (e.consume(d), i) : d === null || ne(d) ? (e.exit("atxHeadingSequence"), o(d)) : n(d);
  }
  function o(d) {
    return d === 35 ? (e.enter("atxHeadingSequence"), l(d)) : d === null || j(d) ? (e.exit("atxHeading"), t(d)) : W(d) ? K(e, o, "whitespace")(d) : (e.enter("atxHeadingText"), c(d));
  }
  function l(d) {
    return d === 35 ? (e.consume(d), l) : (e.exit("atxHeadingSequence"), o(d));
  }
  function c(d) {
    return d === null || d === 35 || ne(d) ? (e.exit("atxHeadingText"), o(d)) : (e.consume(d), c);
  }
}
const Nc = [
  "address",
  "article",
  "aside",
  "base",
  "basefont",
  "blockquote",
  "body",
  "caption",
  "center",
  "col",
  "colgroup",
  "dd",
  "details",
  "dialog",
  "dir",
  "div",
  "dl",
  "dt",
  "fieldset",
  "figcaption",
  "figure",
  "footer",
  "form",
  "frame",
  "frameset",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "head",
  "header",
  "hr",
  "html",
  "iframe",
  "legend",
  "li",
  "link",
  "main",
  "menu",
  "menuitem",
  "nav",
  "noframes",
  "ol",
  "optgroup",
  "option",
  "p",
  "param",
  "search",
  "section",
  "summary",
  "table",
  "tbody",
  "td",
  "tfoot",
  "th",
  "thead",
  "title",
  "tr",
  "track",
  "ul"
], Ou = ["pre", "script", "style", "textarea"], kc = {
  name: "htmlFlow",
  tokenize: Rc,
  resolveTo: Lc,
  concrete: !0
}, yc = {
  tokenize: Pc,
  partial: !0
}, Oc = {
  tokenize: Dc,
  partial: !0
};
function Lc(e) {
  let t = e.length;
  for (; t-- && !(e[t][0] === "enter" && e[t][1].type === "htmlFlow"); )
    ;
  return t > 1 && e[t - 2][1].type === "linePrefix" && (e[t][1].start = e[t - 2][1].start, e[t + 1][1].start = e[t - 2][1].start, e.splice(t - 2, 2)), e;
}
function Rc(e, t, n) {
  const r = this;
  let u, a, i, o, l;
  return c;
  function c(_) {
    return d(_);
  }
  function d(_) {
    return e.enter("htmlFlow"), e.enter("htmlFlowData"), e.consume(_), f;
  }
  function f(_) {
    return _ === 33 ? (e.consume(_), m) : _ === 47 ? (e.consume(_), a = !0, I) : _ === 63 ? (e.consume(_), u = 3, r.interrupt ? t : A) : Ee(_) ? (e.consume(_), i = String.fromCharCode(_), y) : n(_);
  }
  function m(_) {
    return _ === 45 ? (e.consume(_), u = 2, h) : _ === 91 ? (e.consume(_), u = 5, o = 0, b) : Ee(_) ? (e.consume(_), u = 4, r.interrupt ? t : A) : n(_);
  }
  function h(_) {
    return _ === 45 ? (e.consume(_), r.interrupt ? t : A) : n(_);
  }
  function b(_) {
    const xe = "CDATA[";
    return _ === xe.charCodeAt(o++) ? (e.consume(_), o === xe.length ? r.interrupt ? t : F : b) : n(_);
  }
  function I(_) {
    return Ee(_) ? (e.consume(_), i = String.fromCharCode(_), y) : n(_);
  }
  function y(_) {
    if (_ === null || _ === 47 || _ === 62 || ne(_)) {
      const xe = _ === 47, Ue = i.toLowerCase();
      return !xe && !a && Ou.includes(Ue) ? (u = 1, r.interrupt ? t(_) : F(_)) : Nc.includes(i.toLowerCase()) ? (u = 6, xe ? (e.consume(_), C) : r.interrupt ? t(_) : F(_)) : (u = 7, r.interrupt && !r.parser.lazy[r.now().line] ? n(_) : a ? w(_) : O(_));
    }
    return _ === 45 || me(_) ? (e.consume(_), i += String.fromCharCode(_), y) : n(_);
  }
  function C(_) {
    return _ === 62 ? (e.consume(_), r.interrupt ? t : F) : n(_);
  }
  function w(_) {
    return W(_) ? (e.consume(_), w) : S(_);
  }
  function O(_) {
    return _ === 47 ? (e.consume(_), S) : _ === 58 || _ === 95 || Ee(_) ? (e.consume(_), v) : W(_) ? (e.consume(_), O) : S(_);
  }
  function v(_) {
    return _ === 45 || _ === 46 || _ === 58 || _ === 95 || me(_) ? (e.consume(_), v) : R(_);
  }
  function R(_) {
    return _ === 61 ? (e.consume(_), N) : W(_) ? (e.consume(_), R) : O(_);
  }
  function N(_) {
    return _ === null || _ === 60 || _ === 61 || _ === 62 || _ === 96 ? n(_) : _ === 34 || _ === 39 ? (e.consume(_), l = _, z) : W(_) ? (e.consume(_), N) : X(_);
  }
  function z(_) {
    return _ === l ? (e.consume(_), l = null, Q) : _ === null || j(_) ? n(_) : (e.consume(_), z);
  }
  function X(_) {
    return _ === null || _ === 34 || _ === 39 || _ === 47 || _ === 60 || _ === 61 || _ === 62 || _ === 96 || ne(_) ? R(_) : (e.consume(_), X);
  }
  function Q(_) {
    return _ === 47 || _ === 62 || W(_) ? O(_) : n(_);
  }
  function S(_) {
    return _ === 62 ? (e.consume(_), H) : n(_);
  }
  function H(_) {
    return _ === null || j(_) ? F(_) : W(_) ? (e.consume(_), H) : n(_);
  }
  function F(_) {
    return _ === 45 && u === 2 ? (e.consume(_), fe) : _ === 60 && u === 1 ? (e.consume(_), le) : _ === 62 && u === 4 ? (e.consume(_), _e) : _ === 63 && u === 3 ? (e.consume(_), A) : _ === 93 && u === 5 ? (e.consume(_), Oe) : j(_) && (u === 6 || u === 7) ? (e.exit("htmlFlowData"), e.check(
      yc,
      Le,
      ee
    )(_)) : _ === null || j(_) ? (e.exit("htmlFlowData"), ee(_)) : (e.consume(_), F);
  }
  function ee(_) {
    return e.check(
      Oc,
      ue,
      Le
    )(_);
  }
  function ue(_) {
    return e.enter("lineEnding"), e.consume(_), e.exit("lineEnding"), G;
  }
  function G(_) {
    return _ === null || j(_) ? ee(_) : (e.enter("htmlFlowData"), F(_));
  }
  function fe(_) {
    return _ === 45 ? (e.consume(_), A) : F(_);
  }
  function le(_) {
    return _ === 47 ? (e.consume(_), i = "", Te) : F(_);
  }
  function Te(_) {
    if (_ === 62) {
      const xe = i.toLowerCase();
      return Ou.includes(xe) ? (e.consume(_), _e) : F(_);
    }
    return Ee(_) && i.length < 8 ? (e.consume(_), i += String.fromCharCode(_), Te) : F(_);
  }
  function Oe(_) {
    return _ === 93 ? (e.consume(_), A) : F(_);
  }
  function A(_) {
    return _ === 62 ? (e.consume(_), _e) : _ === 45 && u === 2 ? (e.consume(_), A) : F(_);
  }
  function _e(_) {
    return _ === null || j(_) ? (e.exit("htmlFlowData"), Le(_)) : (e.consume(_), _e);
  }
  function Le(_) {
    return e.exit("htmlFlow"), t(_);
  }
}
function Dc(e, t, n) {
  const r = this;
  return u;
  function u(i) {
    return j(i) ? (e.enter("lineEnding"), e.consume(i), e.exit("lineEnding"), a) : n(i);
  }
  function a(i) {
    return r.parser.lazy[r.now().line] ? n(i) : t(i);
  }
}
function Pc(e, t, n) {
  return r;
  function r(u) {
    return e.enter("lineEnding"), e.consume(u), e.exit("lineEnding"), e.attempt(zn, t, n);
  }
}
const wc = {
  name: "htmlText",
  tokenize: Mc
};
function Mc(e, t, n) {
  const r = this;
  let u, a, i;
  return o;
  function o(A) {
    return e.enter("htmlText"), e.enter("htmlTextData"), e.consume(A), l;
  }
  function l(A) {
    return A === 33 ? (e.consume(A), c) : A === 47 ? (e.consume(A), R) : A === 63 ? (e.consume(A), O) : Ee(A) ? (e.consume(A), X) : n(A);
  }
  function c(A) {
    return A === 45 ? (e.consume(A), d) : A === 91 ? (e.consume(A), a = 0, b) : Ee(A) ? (e.consume(A), w) : n(A);
  }
  function d(A) {
    return A === 45 ? (e.consume(A), h) : n(A);
  }
  function f(A) {
    return A === null ? n(A) : A === 45 ? (e.consume(A), m) : j(A) ? (i = f, le(A)) : (e.consume(A), f);
  }
  function m(A) {
    return A === 45 ? (e.consume(A), h) : f(A);
  }
  function h(A) {
    return A === 62 ? fe(A) : A === 45 ? m(A) : f(A);
  }
  function b(A) {
    const _e = "CDATA[";
    return A === _e.charCodeAt(a++) ? (e.consume(A), a === _e.length ? I : b) : n(A);
  }
  function I(A) {
    return A === null ? n(A) : A === 93 ? (e.consume(A), y) : j(A) ? (i = I, le(A)) : (e.consume(A), I);
  }
  function y(A) {
    return A === 93 ? (e.consume(A), C) : I(A);
  }
  function C(A) {
    return A === 62 ? fe(A) : A === 93 ? (e.consume(A), C) : I(A);
  }
  function w(A) {
    return A === null || A === 62 ? fe(A) : j(A) ? (i = w, le(A)) : (e.consume(A), w);
  }
  function O(A) {
    return A === null ? n(A) : A === 63 ? (e.consume(A), v) : j(A) ? (i = O, le(A)) : (e.consume(A), O);
  }
  function v(A) {
    return A === 62 ? fe(A) : O(A);
  }
  function R(A) {
    return Ee(A) ? (e.consume(A), N) : n(A);
  }
  function N(A) {
    return A === 45 || me(A) ? (e.consume(A), N) : z(A);
  }
  function z(A) {
    return j(A) ? (i = z, le(A)) : W(A) ? (e.consume(A), z) : fe(A);
  }
  function X(A) {
    return A === 45 || me(A) ? (e.consume(A), X) : A === 47 || A === 62 || ne(A) ? Q(A) : n(A);
  }
  function Q(A) {
    return A === 47 ? (e.consume(A), fe) : A === 58 || A === 95 || Ee(A) ? (e.consume(A), S) : j(A) ? (i = Q, le(A)) : W(A) ? (e.consume(A), Q) : fe(A);
  }
  function S(A) {
    return A === 45 || A === 46 || A === 58 || A === 95 || me(A) ? (e.consume(A), S) : H(A);
  }
  function H(A) {
    return A === 61 ? (e.consume(A), F) : j(A) ? (i = H, le(A)) : W(A) ? (e.consume(A), H) : Q(A);
  }
  function F(A) {
    return A === null || A === 60 || A === 61 || A === 62 || A === 96 ? n(A) : A === 34 || A === 39 ? (e.consume(A), u = A, ee) : j(A) ? (i = F, le(A)) : W(A) ? (e.consume(A), F) : (e.consume(A), ue);
  }
  function ee(A) {
    return A === u ? (e.consume(A), u = void 0, G) : A === null ? n(A) : j(A) ? (i = ee, le(A)) : (e.consume(A), ee);
  }
  function ue(A) {
    return A === null || A === 34 || A === 39 || A === 60 || A === 61 || A === 96 ? n(A) : A === 47 || A === 62 || ne(A) ? Q(A) : (e.consume(A), ue);
  }
  function G(A) {
    return A === 47 || A === 62 || ne(A) ? Q(A) : n(A);
  }
  function fe(A) {
    return A === 62 ? (e.consume(A), e.exit("htmlTextData"), e.exit("htmlText"), t) : n(A);
  }
  function le(A) {
    return e.exit("htmlTextData"), e.enter("lineEnding"), e.consume(A), e.exit("lineEnding"), Te;
  }
  function Te(A) {
    return W(A) ? K(
      e,
      Oe,
      "linePrefix",
      r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4
    )(A) : Oe(A);
  }
  function Oe(A) {
    return e.enter("htmlTextData"), i(A);
  }
}
const qr = {
  name: "labelEnd",
  tokenize: jc,
  resolveTo: Uc,
  resolveAll: Hc
}, Bc = {
  tokenize: zc
}, Fc = {
  tokenize: qc
}, vc = {
  tokenize: Yc
};
function Hc(e) {
  let t = -1;
  for (; ++t < e.length; ) {
    const n = e[t][1];
    (n.type === "labelImage" || n.type === "labelLink" || n.type === "labelEnd") && (e.splice(t + 1, n.type === "labelImage" ? 4 : 2), n.type = "data", t++);
  }
  return e;
}
function Uc(e, t) {
  let n = e.length, r = 0, u, a, i, o;
  for (; n--; )
    if (u = e[n][1], a) {
      if (u.type === "link" || u.type === "labelLink" && u._inactive)
        break;
      e[n][0] === "enter" && u.type === "labelLink" && (u._inactive = !0);
    } else if (i) {
      if (e[n][0] === "enter" && (u.type === "labelImage" || u.type === "labelLink") && !u._balanced && (a = n, u.type !== "labelLink")) {
        r = 2;
        break;
      }
    } else u.type === "labelEnd" && (i = n);
  const l = {
    type: e[a][1].type === "labelLink" ? "link" : "image",
    start: Object.assign({}, e[a][1].start),
    end: Object.assign({}, e[e.length - 1][1].end)
  }, c = {
    type: "label",
    start: Object.assign({}, e[a][1].start),
    end: Object.assign({}, e[i][1].end)
  }, d = {
    type: "labelText",
    start: Object.assign({}, e[a + r + 2][1].end),
    end: Object.assign({}, e[i - 2][1].start)
  };
  return o = [
    ["enter", l, t],
    ["enter", c, t]
  ], o = Ne(o, e.slice(a + 1, a + r + 3)), o = Ne(o, [["enter", d, t]]), o = Ne(
    o,
    zr(
      t.parser.constructs.insideSpan.null,
      e.slice(a + r + 4, i - 3),
      t
    )
  ), o = Ne(o, [
    ["exit", d, t],
    e[i - 2],
    e[i - 1],
    ["exit", c, t]
  ]), o = Ne(o, e.slice(i + 1)), o = Ne(o, [["exit", l, t]]), ve(e, a, e.length, o), e;
}
function jc(e, t, n) {
  const r = this;
  let u = r.events.length, a, i;
  for (; u--; )
    if ((r.events[u][1].type === "labelImage" || r.events[u][1].type === "labelLink") && !r.events[u][1]._balanced) {
      a = r.events[u][1];
      break;
    }
  return o;
  function o(m) {
    return a ? a._inactive ? f(m) : (i = r.parser.defined.includes(
      Ct(
        r.sliceSerialize({
          start: a.end,
          end: r.now()
        })
      )
    ), e.enter("labelEnd"), e.enter("labelMarker"), e.consume(m), e.exit("labelMarker"), e.exit("labelEnd"), l) : n(m);
  }
  function l(m) {
    return m === 40 ? e.attempt(
      Bc,
      d,
      i ? d : f
    )(m) : m === 91 ? e.attempt(
      Fc,
      d,
      i ? c : f
    )(m) : i ? d(m) : f(m);
  }
  function c(m) {
    return e.attempt(
      vc,
      d,
      f
    )(m);
  }
  function d(m) {
    return t(m);
  }
  function f(m) {
    return a._balanced = !0, n(m);
  }
}
function zc(e, t, n) {
  return r;
  function r(f) {
    return e.enter("resource"), e.enter("resourceMarker"), e.consume(f), e.exit("resourceMarker"), u;
  }
  function u(f) {
    return ne(f) ? Yt(e, a)(f) : a(f);
  }
  function a(f) {
    return f === 41 ? d(f) : aa(
      e,
      i,
      o,
      "resourceDestination",
      "resourceDestinationLiteral",
      "resourceDestinationLiteralMarker",
      "resourceDestinationRaw",
      "resourceDestinationString",
      32
    )(f);
  }
  function i(f) {
    return ne(f) ? Yt(e, l)(f) : d(f);
  }
  function o(f) {
    return n(f);
  }
  function l(f) {
    return f === 34 || f === 39 || f === 40 ? oa(
      e,
      c,
      n,
      "resourceTitle",
      "resourceTitleMarker",
      "resourceTitleString"
    )(f) : d(f);
  }
  function c(f) {
    return ne(f) ? Yt(e, d)(f) : d(f);
  }
  function d(f) {
    return f === 41 ? (e.enter("resourceMarker"), e.consume(f), e.exit("resourceMarker"), e.exit("resource"), t) : n(f);
  }
}
function qc(e, t, n) {
  const r = this;
  return u;
  function u(o) {
    return sa.call(
      r,
      e,
      a,
      i,
      "reference",
      "referenceMarker",
      "referenceString"
    )(o);
  }
  function a(o) {
    return r.parser.defined.includes(
      Ct(
        r.sliceSerialize(r.events[r.events.length - 1][1]).slice(1, -1)
      )
    ) ? t(o) : n(o);
  }
  function i(o) {
    return n(o);
  }
}
function Yc(e, t, n) {
  return r;
  function r(a) {
    return e.enter("reference"), e.enter("referenceMarker"), e.consume(a), e.exit("referenceMarker"), u;
  }
  function u(a) {
    return a === 93 ? (e.enter("referenceMarker"), e.consume(a), e.exit("referenceMarker"), e.exit("reference"), t) : n(a);
  }
}
const Vc = {
  name: "labelStartImage",
  tokenize: Wc,
  resolveAll: qr.resolveAll
};
function Wc(e, t, n) {
  const r = this;
  return u;
  function u(o) {
    return e.enter("labelImage"), e.enter("labelImageMarker"), e.consume(o), e.exit("labelImageMarker"), a;
  }
  function a(o) {
    return o === 91 ? (e.enter("labelMarker"), e.consume(o), e.exit("labelMarker"), e.exit("labelImage"), i) : n(o);
  }
  function i(o) {
    return o === 94 && "_hiddenFootnoteSupport" in r.parser.constructs ? n(o) : t(o);
  }
}
const Qc = {
  name: "labelStartLink",
  tokenize: Gc,
  resolveAll: qr.resolveAll
};
function Gc(e, t, n) {
  const r = this;
  return u;
  function u(i) {
    return e.enter("labelLink"), e.enter("labelMarker"), e.consume(i), e.exit("labelMarker"), e.exit("labelLink"), a;
  }
  function a(i) {
    return i === 94 && "_hiddenFootnoteSupport" in r.parser.constructs ? n(i) : t(i);
  }
}
const er = {
  name: "lineEnding",
  tokenize: $c
};
function $c(e, t) {
  return n;
  function n(r) {
    return e.enter("lineEnding"), e.consume(r), e.exit("lineEnding"), K(e, t, "linePrefix");
  }
}
const _n = {
  name: "thematicBreak",
  tokenize: Kc
};
function Kc(e, t, n) {
  let r = 0, u;
  return a;
  function a(c) {
    return e.enter("thematicBreak"), i(c);
  }
  function i(c) {
    return u = c, o(c);
  }
  function o(c) {
    return c === u ? (e.enter("thematicBreakSequence"), l(c)) : r >= 3 && (c === null || j(c)) ? (e.exit("thematicBreak"), t(c)) : n(c);
  }
  function l(c) {
    return c === u ? (e.consume(c), r++, l) : (e.exit("thematicBreakSequence"), W(c) ? K(e, o, "whitespace")(c) : o(c));
  }
}
const Ae = {
  name: "list",
  tokenize: Jc,
  continuation: {
    tokenize: e0
  },
  exit: n0
}, Xc = {
  tokenize: r0,
  partial: !0
}, Zc = {
  tokenize: t0,
  partial: !0
};
function Jc(e, t, n) {
  const r = this, u = r.events[r.events.length - 1];
  let a = u && u[1].type === "linePrefix" ? u[2].sliceSerialize(u[1], !0).length : 0, i = 0;
  return o;
  function o(h) {
    const b = r.containerState.type || (h === 42 || h === 43 || h === 45 ? "listUnordered" : "listOrdered");
    if (b === "listUnordered" ? !r.containerState.marker || h === r.containerState.marker : br(h)) {
      if (r.containerState.type || (r.containerState.type = b, e.enter(b, {
        _container: !0
      })), b === "listUnordered")
        return e.enter("listItemPrefix"), h === 42 || h === 45 ? e.check(_n, n, c)(h) : c(h);
      if (!r.interrupt || h === 49)
        return e.enter("listItemPrefix"), e.enter("listItemValue"), l(h);
    }
    return n(h);
  }
  function l(h) {
    return br(h) && ++i < 10 ? (e.consume(h), l) : (!r.interrupt || i < 2) && (r.containerState.marker ? h === r.containerState.marker : h === 41 || h === 46) ? (e.exit("listItemValue"), c(h)) : n(h);
  }
  function c(h) {
    return e.enter("listItemMarker"), e.consume(h), e.exit("listItemMarker"), r.containerState.marker = r.containerState.marker || h, e.check(
      zn,
      // Can’t be empty when interrupting.
      r.interrupt ? n : d,
      e.attempt(
        Xc,
        m,
        f
      )
    );
  }
  function d(h) {
    return r.containerState.initialBlankLine = !0, a++, m(h);
  }
  function f(h) {
    return W(h) ? (e.enter("listItemPrefixWhitespace"), e.consume(h), e.exit("listItemPrefixWhitespace"), m) : n(h);
  }
  function m(h) {
    return r.containerState.size = a + r.sliceSerialize(e.exit("listItemPrefix"), !0).length, t(h);
  }
}
function e0(e, t, n) {
  const r = this;
  return r.containerState._closeFlow = void 0, e.check(zn, u, a);
  function u(o) {
    return r.containerState.furtherBlankLines = r.containerState.furtherBlankLines || r.containerState.initialBlankLine, K(
      e,
      t,
      "listItemIndent",
      r.containerState.size + 1
    )(o);
  }
  function a(o) {
    return r.containerState.furtherBlankLines || !W(o) ? (r.containerState.furtherBlankLines = void 0, r.containerState.initialBlankLine = void 0, i(o)) : (r.containerState.furtherBlankLines = void 0, r.containerState.initialBlankLine = void 0, e.attempt(Zc, t, i)(o));
  }
  function i(o) {
    return r.containerState._closeFlow = !0, r.interrupt = void 0, K(
      e,
      e.attempt(Ae, t, n),
      "linePrefix",
      r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4
    )(o);
  }
}
function t0(e, t, n) {
  const r = this;
  return K(
    e,
    u,
    "listItemIndent",
    r.containerState.size + 1
  );
  function u(a) {
    const i = r.events[r.events.length - 1];
    return i && i[1].type === "listItemIndent" && i[2].sliceSerialize(i[1], !0).length === r.containerState.size ? t(a) : n(a);
  }
}
function n0(e) {
  e.exit(this.containerState.type);
}
function r0(e, t, n) {
  const r = this;
  return K(
    e,
    u,
    "listItemPrefixWhitespace",
    r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 5
  );
  function u(a) {
    const i = r.events[r.events.length - 1];
    return !W(a) && i && i[1].type === "listItemPrefixWhitespace" ? t(a) : n(a);
  }
}
const Lu = {
  name: "setextUnderline",
  tokenize: i0,
  resolveTo: u0
};
function u0(e, t) {
  let n = e.length, r, u, a;
  for (; n--; )
    if (e[n][0] === "enter") {
      if (e[n][1].type === "content") {
        r = n;
        break;
      }
      e[n][1].type === "paragraph" && (u = n);
    } else
      e[n][1].type === "content" && e.splice(n, 1), !a && e[n][1].type === "definition" && (a = n);
  const i = {
    type: "setextHeading",
    start: Object.assign({}, e[u][1].start),
    end: Object.assign({}, e[e.length - 1][1].end)
  };
  return e[u][1].type = "setextHeadingText", a ? (e.splice(u, 0, ["enter", i, t]), e.splice(a + 1, 0, ["exit", e[r][1], t]), e[r][1].end = Object.assign({}, e[a][1].end)) : e[r][1] = i, e.push(["exit", i, t]), e;
}
function i0(e, t, n) {
  const r = this;
  let u;
  return a;
  function a(c) {
    let d = r.events.length, f;
    for (; d--; )
      if (r.events[d][1].type !== "lineEnding" && r.events[d][1].type !== "linePrefix" && r.events[d][1].type !== "content") {
        f = r.events[d][1].type === "paragraph";
        break;
      }
    return !r.parser.lazy[r.now().line] && (r.interrupt || f) ? (e.enter("setextHeadingLine"), u = c, i(c)) : n(c);
  }
  function i(c) {
    return e.enter("setextHeadingLineSequence"), o(c);
  }
  function o(c) {
    return c === u ? (e.consume(c), o) : (e.exit("setextHeadingLineSequence"), W(c) ? K(e, l, "lineSuffix")(c) : l(c));
  }
  function l(c) {
    return c === null || j(c) ? (e.exit("setextHeadingLine"), t(c)) : n(c);
  }
}
const a0 = {
  tokenize: s0
};
function s0(e) {
  const t = this, n = e.attempt(
    // Try to parse a blank line.
    zn,
    r,
    // Try to parse initial flow (essentially, only code).
    e.attempt(
      this.parser.constructs.flowInitial,
      u,
      K(
        e,
        e.attempt(
          this.parser.constructs.flow,
          u,
          e.attempt(dc, u)
        ),
        "linePrefix"
      )
    )
  );
  return n;
  function r(a) {
    if (a === null) {
      e.consume(a);
      return;
    }
    return e.enter("lineEndingBlank"), e.consume(a), e.exit("lineEndingBlank"), t.currentConstruct = void 0, n;
  }
  function u(a) {
    if (a === null) {
      e.consume(a);
      return;
    }
    return e.enter("lineEnding"), e.consume(a), e.exit("lineEnding"), t.currentConstruct = void 0, n;
  }
}
const o0 = {
  resolveAll: ca()
}, l0 = la("string"), c0 = la("text");
function la(e) {
  return {
    tokenize: t,
    resolveAll: ca(
      e === "text" ? f0 : void 0
    )
  };
  function t(n) {
    const r = this, u = this.parser.constructs[e], a = n.attempt(u, i, o);
    return i;
    function i(d) {
      return c(d) ? a(d) : o(d);
    }
    function o(d) {
      if (d === null) {
        n.consume(d);
        return;
      }
      return n.enter("data"), n.consume(d), l;
    }
    function l(d) {
      return c(d) ? (n.exit("data"), a(d)) : (n.consume(d), l);
    }
    function c(d) {
      if (d === null)
        return !0;
      const f = u[d];
      let m = -1;
      if (f)
        for (; ++m < f.length; ) {
          const h = f[m];
          if (!h.previous || h.previous.call(r, r.previous))
            return !0;
        }
      return !1;
    }
  }
}
function ca(e) {
  return t;
  function t(n, r) {
    let u = -1, a;
    for (; ++u <= n.length; )
      a === void 0 ? n[u] && n[u][1].type === "data" && (a = u, u++) : (!n[u] || n[u][1].type !== "data") && (u !== a + 2 && (n[a][1].end = n[u - 1][1].end, n.splice(a + 2, u - a - 2), u = a + 2), a = void 0);
    return e ? e(n, r) : n;
  }
}
function f0(e, t) {
  let n = 0;
  for (; ++n <= e.length; )
    if ((n === e.length || e[n][1].type === "lineEnding") && e[n - 1][1].type === "data") {
      const r = e[n - 1][1], u = t.sliceStream(r);
      let a = u.length, i = -1, o = 0, l;
      for (; a--; ) {
        const c = u[a];
        if (typeof c == "string") {
          for (i = c.length; c.charCodeAt(i - 1) === 32; )
            o++, i--;
          if (i) break;
          i = -1;
        } else if (c === -2)
          l = !0, o++;
        else if (c !== -1) {
          a++;
          break;
        }
      }
      if (o) {
        const c = {
          type: n === e.length || l || o < 2 ? "lineSuffix" : "hardBreakTrailing",
          start: {
            line: r.end.line,
            column: r.end.column - o,
            offset: r.end.offset - o,
            _index: r.start._index + a,
            _bufferIndex: a ? i : r.start._bufferIndex + i
          },
          end: Object.assign({}, r.end)
        };
        r.end = Object.assign({}, c.start), r.start.offset === r.end.offset ? Object.assign(r, c) : (e.splice(
          n,
          0,
          ["enter", c, t],
          ["exit", c, t]
        ), n += 2);
      }
      n++;
    }
  return e;
}
function d0(e, t, n) {
  let r = Object.assign(
    n ? Object.assign({}, n) : {
      line: 1,
      column: 1,
      offset: 0
    },
    {
      _index: 0,
      _bufferIndex: -1
    }
  );
  const u = {}, a = [];
  let i = [], o = [];
  const l = {
    consume: w,
    enter: O,
    exit: v,
    attempt: z(R),
    check: z(N),
    interrupt: z(N, {
      interrupt: !0
    })
  }, c = {
    previous: null,
    code: null,
    containerState: {},
    events: [],
    parser: e,
    sliceStream: h,
    sliceSerialize: m,
    now: b,
    defineSkip: I,
    write: f
  };
  let d = t.tokenize.call(c, l);
  return t.resolveAll && a.push(t), c;
  function f(H) {
    return i = Ne(i, H), y(), i[i.length - 1] !== null ? [] : (X(t, 0), c.events = zr(a, c.events, c), c.events);
  }
  function m(H, F) {
    return m0(h(H), F);
  }
  function h(H) {
    return h0(i, H);
  }
  function b() {
    const { line: H, column: F, offset: ee, _index: ue, _bufferIndex: G } = r;
    return {
      line: H,
      column: F,
      offset: ee,
      _index: ue,
      _bufferIndex: G
    };
  }
  function I(H) {
    u[H.line] = H.column, S();
  }
  function y() {
    let H;
    for (; r._index < i.length; ) {
      const F = i[r._index];
      if (typeof F == "string")
        for (H = r._index, r._bufferIndex < 0 && (r._bufferIndex = 0); r._index === H && r._bufferIndex < F.length; )
          C(F.charCodeAt(r._bufferIndex));
      else
        C(F);
    }
  }
  function C(H) {
    d = d(H);
  }
  function w(H) {
    j(H) ? (r.line++, r.column = 1, r.offset += H === -3 ? 2 : 1, S()) : H !== -1 && (r.column++, r.offset++), r._bufferIndex < 0 ? r._index++ : (r._bufferIndex++, r._bufferIndex === i[r._index].length && (r._bufferIndex = -1, r._index++)), c.previous = H;
  }
  function O(H, F) {
    const ee = F || {};
    return ee.type = H, ee.start = b(), c.events.push(["enter", ee, c]), o.push(ee), ee;
  }
  function v(H) {
    const F = o.pop();
    return F.end = b(), c.events.push(["exit", F, c]), F;
  }
  function R(H, F) {
    X(H, F.from);
  }
  function N(H, F) {
    F.restore();
  }
  function z(H, F) {
    return ee;
    function ee(ue, G, fe) {
      let le, Te, Oe, A;
      return Array.isArray(ue) ? Le(ue) : "tokenize" in ue ? (
        // @ts-expect-error Looks like a construct.
        Le([ue])
      ) : _e(ue);
      function _e(ce) {
        return ut;
        function ut(we) {
          const Qe = we !== null && ce[we], je = we !== null && ce.null, Pt = [
            // To do: add more extension tests.
            /* c8 ignore next 2 */
            ...Array.isArray(Qe) ? Qe : Qe ? [Qe] : [],
            ...Array.isArray(je) ? je : je ? [je] : []
          ];
          return Le(Pt)(we);
        }
      }
      function Le(ce) {
        return le = ce, Te = 0, ce.length === 0 ? fe : _(ce[Te]);
      }
      function _(ce) {
        return ut;
        function ut(we) {
          return A = Q(), Oe = ce, ce.partial || (c.currentConstruct = ce), ce.name && c.parser.constructs.disable.null.includes(ce.name) ? Ue() : ce.tokenize.call(
            // If we do have fields, create an object w/ `context` as its
            // prototype.
            // This allows a “live binding”, which is needed for `interrupt`.
            F ? Object.assign(Object.create(c), F) : c,
            l,
            xe,
            Ue
          )(we);
        }
      }
      function xe(ce) {
        return H(Oe, A), G;
      }
      function Ue(ce) {
        return A.restore(), ++Te < le.length ? _(le[Te]) : fe;
      }
    }
  }
  function X(H, F) {
    H.resolveAll && !a.includes(H) && a.push(H), H.resolve && ve(
      c.events,
      F,
      c.events.length - F,
      H.resolve(c.events.slice(F), c)
    ), H.resolveTo && (c.events = H.resolveTo(c.events, c));
  }
  function Q() {
    const H = b(), F = c.previous, ee = c.currentConstruct, ue = c.events.length, G = Array.from(o);
    return {
      restore: fe,
      from: ue
    };
    function fe() {
      r = H, c.previous = F, c.currentConstruct = ee, c.events.length = ue, o = G, S();
    }
  }
  function S() {
    r.line in u && r.column < 2 && (r.column = u[r.line], r.offset += u[r.line] - 1);
  }
}
function h0(e, t) {
  const n = t.start._index, r = t.start._bufferIndex, u = t.end._index, a = t.end._bufferIndex;
  let i;
  if (n === u)
    i = [e[n].slice(r, a)];
  else {
    if (i = e.slice(n, u), r > -1) {
      const o = i[0];
      typeof o == "string" ? i[0] = o.slice(r) : i.shift();
    }
    a > 0 && i.push(e[u].slice(0, a));
  }
  return i;
}
function m0(e, t) {
  let n = -1;
  const r = [];
  let u;
  for (; ++n < e.length; ) {
    const a = e[n];
    let i;
    if (typeof a == "string")
      i = a;
    else
      switch (a) {
        case -5: {
          i = "\r";
          break;
        }
        case -4: {
          i = `
`;
          break;
        }
        case -3: {
          i = `\r
`;
          break;
        }
        case -2: {
          i = t ? " " : "	";
          break;
        }
        case -1: {
          if (!t && u) continue;
          i = " ";
          break;
        }
        default:
          i = String.fromCharCode(a);
      }
    u = a === -2, r.push(i);
  }
  return r.join("");
}
const p0 = {
  42: Ae,
  43: Ae,
  45: Ae,
  48: Ae,
  49: Ae,
  50: Ae,
  51: Ae,
  52: Ae,
  53: Ae,
  54: Ae,
  55: Ae,
  56: Ae,
  57: Ae,
  62: na
}, E0 = {
  91: gc
}, g0 = {
  [-2]: Jn,
  [-1]: Jn,
  32: Jn
}, T0 = {
  35: Cc,
  42: _n,
  45: [Lu, _n],
  60: kc,
  61: Lu,
  95: _n,
  96: yu,
  126: yu
}, b0 = {
  38: ua,
  92: ra
}, A0 = {
  [-5]: er,
  [-4]: er,
  [-3]: er,
  33: Vc,
  38: ua,
  42: Ar,
  60: [Gl, wc],
  91: Qc,
  92: [_c, ra],
  93: qr,
  95: Ar,
  96: sc
}, _0 = {
  null: [Ar, o0]
}, x0 = {
  null: [42, 95]
}, C0 = {
  null: []
}, I0 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  attentionMarkers: x0,
  contentInitial: E0,
  disable: C0,
  document: p0,
  flow: T0,
  flowInitial: g0,
  insideSpan: _0,
  string: b0,
  text: A0
}, Symbol.toStringTag, { value: "Module" }));
function S0(e) {
  const n = (
    /** @type {FullNormalizedExtension} */
    Ml([I0, ...(e || {}).extensions || []])
  ), r = {
    defined: [],
    lazy: {},
    constructs: n,
    content: u(jl),
    document: u(ql),
    flow: u(a0),
    string: u(l0),
    text: u(c0)
  };
  return r;
  function u(a) {
    return i;
    function i(o) {
      return d0(r, a, o);
    }
  }
}
function N0(e) {
  for (; !ia(e); )
    ;
  return e;
}
const Ru = /[\0\t\n\r]/g;
function k0() {
  let e = 1, t = "", n = !0, r;
  return u;
  function u(a, i, o) {
    const l = [];
    let c, d, f, m, h;
    for (a = t + (typeof a == "string" ? a.toString() : new TextDecoder(i || void 0).decode(a)), f = 0, t = "", n && (a.charCodeAt(0) === 65279 && f++, n = void 0); f < a.length; ) {
      if (Ru.lastIndex = f, c = Ru.exec(a), m = c && c.index !== void 0 ? c.index : a.length, h = a.charCodeAt(m), !c) {
        t = a.slice(f);
        break;
      }
      if (h === 10 && f === m && r)
        l.push(-3), r = void 0;
      else
        switch (r && (l.push(-5), r = void 0), f < m && (l.push(a.slice(f, m)), e += m - f), h) {
          case 0: {
            l.push(65533), e++;
            break;
          }
          case 9: {
            for (d = Math.ceil(e / 4) * 4, l.push(-2); e++ < d; ) l.push(-1);
            break;
          }
          case 10: {
            l.push(-4), e = 1;
            break;
          }
          default:
            r = !0, e = 1;
        }
      f = m + 1;
    }
    return o && (r && l.push(-5), t && l.push(t), l.push(null)), l;
  }
}
const y0 = /\\([!-/:-@[-`{-~])|&(#(?:\d{1,7}|x[\da-f]{1,6})|[\da-z]{1,31});/gi;
function O0(e) {
  return e.replace(y0, L0);
}
function L0(e, t, n) {
  if (t)
    return t;
  if (n.charCodeAt(0) === 35) {
    const u = n.charCodeAt(1), a = u === 120 || u === 88;
    return ta(n.slice(a ? 2 : 1), a ? 16 : 10);
  }
  return jr(n) || e;
}
const fa = {}.hasOwnProperty;
function R0(e, t, n) {
  return typeof t != "string" && (n = t, t = void 0), D0(n)(
    N0(
      S0(n).document().write(k0()(e, t, !0))
    )
  );
}
function D0(e) {
  const t = {
    transforms: [],
    canContainEols: ["emphasis", "fragment", "heading", "paragraph", "strong"],
    enter: {
      autolink: a(hu),
      autolinkProtocol: Q,
      autolinkEmail: Q,
      atxHeading: a(it),
      blockQuote: a(Qe),
      characterEscape: Q,
      characterReference: Q,
      codeFenced: a(je),
      codeFencedFenceInfo: i,
      codeFencedFenceMeta: i,
      codeIndented: a(je, i),
      codeText: a(Pt, i),
      codeTextData: Q,
      data: Q,
      codeFlowValue: Q,
      definition: a(U),
      definitionDestinationString: i,
      definitionLabelString: i,
      definitionTitleString: i,
      emphasis: a(wt),
      hardBreakEscape: a(Mt),
      hardBreakTrailing: a(Mt),
      htmlFlow: a(du, i),
      htmlFlowData: Q,
      htmlText: a(du, i),
      htmlTextData: Q,
      image: a(io),
      label: i,
      link: a(hu),
      listItem: a(ao),
      listItemValue: m,
      listOrdered: a(mu, f),
      listUnordered: a(mu),
      paragraph: a(so),
      reference: _,
      referenceString: i,
      resourceDestinationString: i,
      resourceTitleString: i,
      setextHeading: a(it),
      strong: a(oo),
      thematicBreak: a(co)
    },
    exit: {
      atxHeading: l(),
      atxHeadingSequence: R,
      autolink: l(),
      autolinkEmail: we,
      autolinkProtocol: ut,
      blockQuote: l(),
      characterEscapeValue: S,
      characterReferenceMarkerHexadecimal: Ue,
      characterReferenceMarkerNumeric: Ue,
      characterReferenceValue: ce,
      codeFenced: l(y),
      codeFencedFence: I,
      codeFencedFenceInfo: h,
      codeFencedFenceMeta: b,
      codeFlowValue: S,
      codeIndented: l(C),
      codeText: l(G),
      codeTextData: S,
      data: S,
      definition: l(),
      definitionDestinationString: v,
      definitionLabelString: w,
      definitionTitleString: O,
      emphasis: l(),
      hardBreakEscape: l(F),
      hardBreakTrailing: l(F),
      htmlFlow: l(ee),
      htmlFlowData: S,
      htmlText: l(ue),
      htmlTextData: S,
      image: l(le),
      label: Oe,
      labelText: Te,
      lineEnding: H,
      link: l(fe),
      listItem: l(),
      listOrdered: l(),
      listUnordered: l(),
      paragraph: l(),
      referenceString: xe,
      resourceDestinationString: A,
      resourceTitleString: _e,
      resource: Le,
      setextHeading: l(X),
      setextHeadingLineSequence: z,
      setextHeadingText: N,
      strong: l(),
      thematicBreak: l()
    }
  };
  da(t, (e || {}).mdastExtensions || []);
  const n = {};
  return r;
  function r(L) {
    let B = {
      type: "root",
      children: []
    };
    const q = {
      stack: [B],
      tokenStack: [],
      config: t,
      enter: o,
      exit: c,
      buffer: i,
      resume: d,
      data: n
    }, $ = [];
    let te = -1;
    for (; ++te < L.length; )
      if (L[te][1].type === "listOrdered" || L[te][1].type === "listUnordered")
        if (L[te][0] === "enter")
          $.push(te);
        else {
          const Re = $.pop();
          te = u(L, Re, te);
        }
    for (te = -1; ++te < L.length; ) {
      const Re = t[L[te][0]];
      fa.call(Re, L[te][1].type) && Re[L[te][1].type].call(
        Object.assign(
          {
            sliceSerialize: L[te][2].sliceSerialize
          },
          q
        ),
        L[te][1]
      );
    }
    if (q.tokenStack.length > 0) {
      const Re = q.tokenStack[q.tokenStack.length - 1];
      (Re[1] || Du).call(q, void 0, Re[0]);
    }
    for (B.position = {
      start: Ge(
        L.length > 0 ? L[0][1].start : {
          line: 1,
          column: 1,
          offset: 0
        }
      ),
      end: Ge(
        L.length > 0 ? L[L.length - 2][1].end : {
          line: 1,
          column: 1,
          offset: 0
        }
      )
    }, te = -1; ++te < t.transforms.length; )
      B = t.transforms[te](B) || B;
    return B;
  }
  function u(L, B, q) {
    let $ = B - 1, te = -1, Re = !1, at, ze, Bt, Ft;
    for (; ++$ <= q; ) {
      const Ce = L[$];
      switch (Ce[1].type) {
        case "listUnordered":
        case "listOrdered":
        case "blockQuote": {
          Ce[0] === "enter" ? te++ : te--, Ft = void 0;
          break;
        }
        case "lineEndingBlank": {
          Ce[0] === "enter" && (at && !Ft && !te && !Bt && (Bt = $), Ft = void 0);
          break;
        }
        case "linePrefix":
        case "listItemValue":
        case "listItemMarker":
        case "listItemPrefix":
        case "listItemPrefixWhitespace":
          break;
        default:
          Ft = void 0;
      }
      if (!te && Ce[0] === "enter" && Ce[1].type === "listItemPrefix" || te === -1 && Ce[0] === "exit" && (Ce[1].type === "listUnordered" || Ce[1].type === "listOrdered")) {
        if (at) {
          let Et = $;
          for (ze = void 0; Et--; ) {
            const qe = L[Et];
            if (qe[1].type === "lineEnding" || qe[1].type === "lineEndingBlank") {
              if (qe[0] === "exit") continue;
              ze && (L[ze][1].type = "lineEndingBlank", Re = !0), qe[1].type = "lineEnding", ze = Et;
            } else if (!(qe[1].type === "linePrefix" || qe[1].type === "blockQuotePrefix" || qe[1].type === "blockQuotePrefixWhitespace" || qe[1].type === "blockQuoteMarker" || qe[1].type === "listItemIndent")) break;
          }
          Bt && (!ze || Bt < ze) && (at._spread = !0), at.end = Object.assign(
            {},
            ze ? L[ze][1].start : Ce[1].end
          ), L.splice(ze || $, 0, ["exit", at, Ce[2]]), $++, q++;
        }
        if (Ce[1].type === "listItemPrefix") {
          const Et = {
            type: "listItem",
            _spread: !1,
            start: Object.assign({}, Ce[1].start),
            // @ts-expect-error: we’ll add `end` in a second.
            end: void 0
          };
          at = Et, L.splice($, 0, ["enter", Et, Ce[2]]), $++, q++, Bt = void 0, Ft = !0;
        }
      }
    }
    return L[B][1]._spread = Re, q;
  }
  function a(L, B) {
    return q;
    function q($) {
      o.call(this, L($), $), B && B.call(this, $);
    }
  }
  function i() {
    this.stack.push({
      type: "fragment",
      children: []
    });
  }
  function o(L, B, q) {
    this.stack[this.stack.length - 1].children.push(L), this.stack.push(L), this.tokenStack.push([B, q]), L.position = {
      start: Ge(B.start),
      // @ts-expect-error: `end` will be patched later.
      end: void 0
    };
  }
  function l(L) {
    return B;
    function B(q) {
      L && L.call(this, q), c.call(this, q);
    }
  }
  function c(L, B) {
    const q = this.stack.pop(), $ = this.tokenStack.pop();
    if ($)
      $[0].type !== L.type && (B ? B.call(this, L, $[0]) : ($[1] || Du).call(this, L, $[0]));
    else throw new Error(
      "Cannot close `" + L.type + "` (" + An({
        start: L.start,
        end: L.end
      }) + "): it’s not open"
    );
    q.position.end = Ge(L.end);
  }
  function d() {
    return Ur(this.stack.pop());
  }
  function f() {
    this.data.expectingFirstListItemValue = !0;
  }
  function m(L) {
    if (this.data.expectingFirstListItemValue) {
      const B = this.stack[this.stack.length - 2];
      B.start = Number.parseInt(this.sliceSerialize(L), 10), this.data.expectingFirstListItemValue = void 0;
    }
  }
  function h() {
    const L = this.resume(), B = this.stack[this.stack.length - 1];
    B.lang = L;
  }
  function b() {
    const L = this.resume(), B = this.stack[this.stack.length - 1];
    B.meta = L;
  }
  function I() {
    this.data.flowCodeInside || (this.buffer(), this.data.flowCodeInside = !0);
  }
  function y() {
    const L = this.resume(), B = this.stack[this.stack.length - 1];
    B.value = L.replace(/^(\r?\n|\r)|(\r?\n|\r)$/g, ""), this.data.flowCodeInside = void 0;
  }
  function C() {
    const L = this.resume(), B = this.stack[this.stack.length - 1];
    B.value = L.replace(/(\r?\n|\r)$/g, "");
  }
  function w(L) {
    const B = this.resume(), q = this.stack[this.stack.length - 1];
    q.label = B, q.identifier = Ct(
      this.sliceSerialize(L)
    ).toLowerCase();
  }
  function O() {
    const L = this.resume(), B = this.stack[this.stack.length - 1];
    B.title = L;
  }
  function v() {
    const L = this.resume(), B = this.stack[this.stack.length - 1];
    B.url = L;
  }
  function R(L) {
    const B = this.stack[this.stack.length - 1];
    if (!B.depth) {
      const q = this.sliceSerialize(L).length;
      B.depth = q;
    }
  }
  function N() {
    this.data.setextHeadingSlurpLineEnding = !0;
  }
  function z(L) {
    const B = this.stack[this.stack.length - 1];
    B.depth = this.sliceSerialize(L).codePointAt(0) === 61 ? 1 : 2;
  }
  function X() {
    this.data.setextHeadingSlurpLineEnding = void 0;
  }
  function Q(L) {
    const q = this.stack[this.stack.length - 1].children;
    let $ = q[q.length - 1];
    (!$ || $.type !== "text") && ($ = lo(), $.position = {
      start: Ge(L.start),
      // @ts-expect-error: we’ll add `end` later.
      end: void 0
    }, q.push($)), this.stack.push($);
  }
  function S(L) {
    const B = this.stack.pop();
    B.value += this.sliceSerialize(L), B.position.end = Ge(L.end);
  }
  function H(L) {
    const B = this.stack[this.stack.length - 1];
    if (this.data.atHardBreak) {
      const q = B.children[B.children.length - 1];
      q.position.end = Ge(L.end), this.data.atHardBreak = void 0;
      return;
    }
    !this.data.setextHeadingSlurpLineEnding && t.canContainEols.includes(B.type) && (Q.call(this, L), S.call(this, L));
  }
  function F() {
    this.data.atHardBreak = !0;
  }
  function ee() {
    const L = this.resume(), B = this.stack[this.stack.length - 1];
    B.value = L;
  }
  function ue() {
    const L = this.resume(), B = this.stack[this.stack.length - 1];
    B.value = L;
  }
  function G() {
    const L = this.resume(), B = this.stack[this.stack.length - 1];
    B.value = L;
  }
  function fe() {
    const L = this.stack[this.stack.length - 1];
    if (this.data.inReference) {
      const B = this.data.referenceType || "shortcut";
      L.type += "Reference", L.referenceType = B, delete L.url, delete L.title;
    } else
      delete L.identifier, delete L.label;
    this.data.referenceType = void 0;
  }
  function le() {
    const L = this.stack[this.stack.length - 1];
    if (this.data.inReference) {
      const B = this.data.referenceType || "shortcut";
      L.type += "Reference", L.referenceType = B, delete L.url, delete L.title;
    } else
      delete L.identifier, delete L.label;
    this.data.referenceType = void 0;
  }
  function Te(L) {
    const B = this.sliceSerialize(L), q = this.stack[this.stack.length - 2];
    q.label = O0(B), q.identifier = Ct(B).toLowerCase();
  }
  function Oe() {
    const L = this.stack[this.stack.length - 1], B = this.resume(), q = this.stack[this.stack.length - 1];
    if (this.data.inReference = !0, q.type === "link") {
      const $ = L.children;
      q.children = $;
    } else
      q.alt = B;
  }
  function A() {
    const L = this.resume(), B = this.stack[this.stack.length - 1];
    B.url = L;
  }
  function _e() {
    const L = this.resume(), B = this.stack[this.stack.length - 1];
    B.title = L;
  }
  function Le() {
    this.data.inReference = void 0;
  }
  function _() {
    this.data.referenceType = "collapsed";
  }
  function xe(L) {
    const B = this.resume(), q = this.stack[this.stack.length - 1];
    q.label = B, q.identifier = Ct(
      this.sliceSerialize(L)
    ).toLowerCase(), this.data.referenceType = "full";
  }
  function Ue(L) {
    this.data.characterReferenceType = L.type;
  }
  function ce(L) {
    const B = this.sliceSerialize(L), q = this.data.characterReferenceType;
    let $;
    q ? ($ = ta(
      B,
      q === "characterReferenceMarkerNumeric" ? 10 : 16
    ), this.data.characterReferenceType = void 0) : $ = jr(B);
    const te = this.stack.pop();
    te.value += $, te.position.end = Ge(L.end);
  }
  function ut(L) {
    S.call(this, L);
    const B = this.stack[this.stack.length - 1];
    B.url = this.sliceSerialize(L);
  }
  function we(L) {
    S.call(this, L);
    const B = this.stack[this.stack.length - 1];
    B.url = "mailto:" + this.sliceSerialize(L);
  }
  function Qe() {
    return {
      type: "blockquote",
      children: []
    };
  }
  function je() {
    return {
      type: "code",
      lang: null,
      meta: null,
      value: ""
    };
  }
  function Pt() {
    return {
      type: "inlineCode",
      value: ""
    };
  }
  function U() {
    return {
      type: "definition",
      identifier: "",
      label: null,
      title: null,
      url: ""
    };
  }
  function wt() {
    return {
      type: "emphasis",
      children: []
    };
  }
  function it() {
    return {
      type: "heading",
      // @ts-expect-error `depth` will be set later.
      depth: 0,
      children: []
    };
  }
  function Mt() {
    return {
      type: "break"
    };
  }
  function du() {
    return {
      type: "html",
      value: ""
    };
  }
  function io() {
    return {
      type: "image",
      title: null,
      url: "",
      alt: null
    };
  }
  function hu() {
    return {
      type: "link",
      title: null,
      url: "",
      children: []
    };
  }
  function mu(L) {
    return {
      type: "list",
      ordered: L.type === "listOrdered",
      start: null,
      spread: L._spread,
      children: []
    };
  }
  function ao(L) {
    return {
      type: "listItem",
      spread: L._spread,
      checked: null,
      children: []
    };
  }
  function so() {
    return {
      type: "paragraph",
      children: []
    };
  }
  function oo() {
    return {
      type: "strong",
      children: []
    };
  }
  function lo() {
    return {
      type: "text",
      value: ""
    };
  }
  function co() {
    return {
      type: "thematicBreak"
    };
  }
}
function Ge(e) {
  return {
    line: e.line,
    column: e.column,
    offset: e.offset
  };
}
function da(e, t) {
  let n = -1;
  for (; ++n < t.length; ) {
    const r = t[n];
    Array.isArray(r) ? da(e, r) : P0(e, r);
  }
}
function P0(e, t) {
  let n;
  for (n in t)
    if (fa.call(t, n))
      switch (n) {
        case "canContainEols": {
          const r = t[n];
          r && e[n].push(...r);
          break;
        }
        case "transforms": {
          const r = t[n];
          r && e[n].push(...r);
          break;
        }
        case "enter":
        case "exit": {
          const r = t[n];
          r && Object.assign(e[n], r);
          break;
        }
      }
}
function Du(e, t) {
  throw e ? new Error(
    "Cannot close `" + e.type + "` (" + An({
      start: e.start,
      end: e.end
    }) + "): a different token (`" + t.type + "`, " + An({
      start: t.start,
      end: t.end
    }) + ") is open"
  ) : new Error(
    "Cannot close document, a token (`" + t.type + "`, " + An({
      start: t.start,
      end: t.end
    }) + ") is still open"
  );
}
function w0(e) {
  const t = this;
  t.parser = n;
  function n(r) {
    return R0(r, {
      ...t.data("settings"),
      ...e,
      // Note: these options are not in the readme.
      // The goal is for them to be set by plugins on `data` instead of being
      // passed by users.
      extensions: t.data("micromarkExtensions") || [],
      mdastExtensions: t.data("fromMarkdownExtensions") || []
    });
  }
}
function M0(e, t) {
  const n = {
    type: "element",
    tagName: "blockquote",
    properties: {},
    children: e.wrap(e.all(t), !0)
  };
  return e.patch(t, n), e.applyData(t, n);
}
function B0(e, t) {
  const n = { type: "element", tagName: "br", properties: {}, children: [] };
  return e.patch(t, n), [e.applyData(t, n), { type: "text", value: `
` }];
}
function F0(e, t) {
  const n = t.value ? t.value + `
` : "", r = {};
  t.lang && (r.className = ["language-" + t.lang]);
  let u = {
    type: "element",
    tagName: "code",
    properties: r,
    children: [{ type: "text", value: n }]
  };
  return t.meta && (u.data = { meta: t.meta }), e.patch(t, u), u = e.applyData(t, u), u = { type: "element", tagName: "pre", properties: {}, children: [u] }, e.patch(t, u), u;
}
function v0(e, t) {
  const n = {
    type: "element",
    tagName: "del",
    properties: {},
    children: e.all(t)
  };
  return e.patch(t, n), e.applyData(t, n);
}
function H0(e, t) {
  const n = {
    type: "element",
    tagName: "em",
    properties: {},
    children: e.all(t)
  };
  return e.patch(t, n), e.applyData(t, n);
}
function yt(e) {
  const t = [];
  let n = -1, r = 0, u = 0;
  for (; ++n < e.length; ) {
    const a = e.charCodeAt(n);
    let i = "";
    if (a === 37 && me(e.charCodeAt(n + 1)) && me(e.charCodeAt(n + 2)))
      u = 2;
    else if (a < 128)
      /[!#$&-;=?-Z_a-z~]/.test(String.fromCharCode(a)) || (i = String.fromCharCode(a));
    else if (a > 55295 && a < 57344) {
      const o = e.charCodeAt(n + 1);
      a < 56320 && o > 56319 && o < 57344 ? (i = String.fromCharCode(a, o), u = 1) : i = "�";
    } else
      i = String.fromCharCode(a);
    i && (t.push(e.slice(r, n), encodeURIComponent(i)), r = n + u + 1, i = ""), u && (n += u, u = 0);
  }
  return t.join("") + e.slice(r);
}
function U0(e, t) {
  const n = typeof e.options.clobberPrefix == "string" ? e.options.clobberPrefix : "user-content-", r = String(t.identifier).toUpperCase(), u = yt(r.toLowerCase()), a = e.footnoteOrder.indexOf(r);
  let i, o = e.footnoteCounts.get(r);
  o === void 0 ? (o = 0, e.footnoteOrder.push(r), i = e.footnoteOrder.length) : i = a + 1, o += 1, e.footnoteCounts.set(r, o);
  const l = {
    type: "element",
    tagName: "a",
    properties: {
      href: "#" + n + "fn-" + u,
      id: n + "fnref-" + u + (o > 1 ? "-" + o : ""),
      dataFootnoteRef: !0,
      ariaDescribedBy: ["footnote-label"]
    },
    children: [{ type: "text", value: String(i) }]
  };
  e.patch(t, l);
  const c = {
    type: "element",
    tagName: "sup",
    properties: {},
    children: [l]
  };
  return e.patch(t, c), e.applyData(t, c);
}
function j0(e, t) {
  const n = {
    type: "element",
    tagName: "h" + t.depth,
    properties: {},
    children: e.all(t)
  };
  return e.patch(t, n), e.applyData(t, n);
}
function z0(e, t) {
  if (e.options.allowDangerousHtml) {
    const n = { type: "raw", value: t.value };
    return e.patch(t, n), e.applyData(t, n);
  }
}
function ha(e, t) {
  const n = t.referenceType;
  let r = "]";
  if (n === "collapsed" ? r += "[]" : n === "full" && (r += "[" + (t.label || t.identifier) + "]"), t.type === "imageReference")
    return [{ type: "text", value: "![" + t.alt + r }];
  const u = e.all(t), a = u[0];
  a && a.type === "text" ? a.value = "[" + a.value : u.unshift({ type: "text", value: "[" });
  const i = u[u.length - 1];
  return i && i.type === "text" ? i.value += r : u.push({ type: "text", value: r }), u;
}
function q0(e, t) {
  const n = String(t.identifier).toUpperCase(), r = e.definitionById.get(n);
  if (!r)
    return ha(e, t);
  const u = { src: yt(r.url || ""), alt: t.alt };
  r.title !== null && r.title !== void 0 && (u.title = r.title);
  const a = { type: "element", tagName: "img", properties: u, children: [] };
  return e.patch(t, a), e.applyData(t, a);
}
function Y0(e, t) {
  const n = { src: yt(t.url) };
  t.alt !== null && t.alt !== void 0 && (n.alt = t.alt), t.title !== null && t.title !== void 0 && (n.title = t.title);
  const r = { type: "element", tagName: "img", properties: n, children: [] };
  return e.patch(t, r), e.applyData(t, r);
}
function V0(e, t) {
  const n = { type: "text", value: t.value.replace(/\r?\n|\r/g, " ") };
  e.patch(t, n);
  const r = {
    type: "element",
    tagName: "code",
    properties: {},
    children: [n]
  };
  return e.patch(t, r), e.applyData(t, r);
}
function W0(e, t) {
  const n = String(t.identifier).toUpperCase(), r = e.definitionById.get(n);
  if (!r)
    return ha(e, t);
  const u = { href: yt(r.url || "") };
  r.title !== null && r.title !== void 0 && (u.title = r.title);
  const a = {
    type: "element",
    tagName: "a",
    properties: u,
    children: e.all(t)
  };
  return e.patch(t, a), e.applyData(t, a);
}
function Q0(e, t) {
  const n = { href: yt(t.url) };
  t.title !== null && t.title !== void 0 && (n.title = t.title);
  const r = {
    type: "element",
    tagName: "a",
    properties: n,
    children: e.all(t)
  };
  return e.patch(t, r), e.applyData(t, r);
}
function G0(e, t, n) {
  const r = e.all(t), u = n ? $0(n) : ma(t), a = {}, i = [];
  if (typeof t.checked == "boolean") {
    const d = r[0];
    let f;
    d && d.type === "element" && d.tagName === "p" ? f = d : (f = { type: "element", tagName: "p", properties: {}, children: [] }, r.unshift(f)), f.children.length > 0 && f.children.unshift({ type: "text", value: " " }), f.children.unshift({
      type: "element",
      tagName: "input",
      properties: { type: "checkbox", checked: t.checked, disabled: !0 },
      children: []
    }), a.className = ["task-list-item"];
  }
  let o = -1;
  for (; ++o < r.length; ) {
    const d = r[o];
    (u || o !== 0 || d.type !== "element" || d.tagName !== "p") && i.push({ type: "text", value: `
` }), d.type === "element" && d.tagName === "p" && !u ? i.push(...d.children) : i.push(d);
  }
  const l = r[r.length - 1];
  l && (u || l.type !== "element" || l.tagName !== "p") && i.push({ type: "text", value: `
` });
  const c = { type: "element", tagName: "li", properties: a, children: i };
  return e.patch(t, c), e.applyData(t, c);
}
function $0(e) {
  let t = !1;
  if (e.type === "list") {
    t = e.spread || !1;
    const n = e.children;
    let r = -1;
    for (; !t && ++r < n.length; )
      t = ma(n[r]);
  }
  return t;
}
function ma(e) {
  const t = e.spread;
  return t ?? e.children.length > 1;
}
function K0(e, t) {
  const n = {}, r = e.all(t);
  let u = -1;
  for (typeof t.start == "number" && t.start !== 1 && (n.start = t.start); ++u < r.length; ) {
    const i = r[u];
    if (i.type === "element" && i.tagName === "li" && i.properties && Array.isArray(i.properties.className) && i.properties.className.includes("task-list-item")) {
      n.className = ["contains-task-list"];
      break;
    }
  }
  const a = {
    type: "element",
    tagName: t.ordered ? "ol" : "ul",
    properties: n,
    children: e.wrap(r, !0)
  };
  return e.patch(t, a), e.applyData(t, a);
}
function X0(e, t) {
  const n = {
    type: "element",
    tagName: "p",
    properties: {},
    children: e.all(t)
  };
  return e.patch(t, n), e.applyData(t, n);
}
function Z0(e, t) {
  const n = { type: "root", children: e.wrap(e.all(t)) };
  return e.patch(t, n), e.applyData(t, n);
}
function J0(e, t) {
  const n = {
    type: "element",
    tagName: "strong",
    properties: {},
    children: e.all(t)
  };
  return e.patch(t, n), e.applyData(t, n);
}
function ef(e, t) {
  const n = e.all(t), r = n.shift(), u = [];
  if (r) {
    const i = {
      type: "element",
      tagName: "thead",
      properties: {},
      children: e.wrap([r], !0)
    };
    e.patch(t.children[0], i), u.push(i);
  }
  if (n.length > 0) {
    const i = {
      type: "element",
      tagName: "tbody",
      properties: {},
      children: e.wrap(n, !0)
    }, o = tt(t.children[1]), l = vr(t.children[t.children.length - 1]);
    o && l && (i.position = { start: o, end: l }), u.push(i);
  }
  const a = {
    type: "element",
    tagName: "table",
    properties: {},
    children: e.wrap(u, !0)
  };
  return e.patch(t, a), e.applyData(t, a);
}
function tf(e, t, n) {
  const r = n ? n.children : void 0, a = (r ? r.indexOf(t) : 1) === 0 ? "th" : "td", i = n && n.type === "table" ? n.align : void 0, o = i ? i.length : t.children.length;
  let l = -1;
  const c = [];
  for (; ++l < o; ) {
    const f = t.children[l], m = {}, h = i ? i[l] : void 0;
    h && (m.align = h);
    let b = { type: "element", tagName: a, properties: m, children: [] };
    f && (b.children = e.all(f), e.patch(f, b), b = e.applyData(f, b)), c.push(b);
  }
  const d = {
    type: "element",
    tagName: "tr",
    properties: {},
    children: e.wrap(c, !0)
  };
  return e.patch(t, d), e.applyData(t, d);
}
function nf(e, t) {
  const n = {
    type: "element",
    tagName: "td",
    // Assume body cell.
    properties: {},
    children: e.all(t)
  };
  return e.patch(t, n), e.applyData(t, n);
}
const Pu = 9, wu = 32;
function rf(e) {
  const t = String(e), n = /\r?\n|\r/g;
  let r = n.exec(t), u = 0;
  const a = [];
  for (; r; )
    a.push(
      Mu(t.slice(u, r.index), u > 0, !0),
      r[0]
    ), u = r.index + r[0].length, r = n.exec(t);
  return a.push(Mu(t.slice(u), u > 0, !1)), a.join("");
}
function Mu(e, t, n) {
  let r = 0, u = e.length;
  if (t) {
    let a = e.codePointAt(r);
    for (; a === Pu || a === wu; )
      r++, a = e.codePointAt(r);
  }
  if (n) {
    let a = e.codePointAt(u - 1);
    for (; a === Pu || a === wu; )
      u--, a = e.codePointAt(u - 1);
  }
  return u > r ? e.slice(r, u) : "";
}
function uf(e, t) {
  const n = { type: "text", value: rf(String(t.value)) };
  return e.patch(t, n), e.applyData(t, n);
}
function af(e, t) {
  const n = {
    type: "element",
    tagName: "hr",
    properties: {},
    children: []
  };
  return e.patch(t, n), e.applyData(t, n);
}
const sf = {
  blockquote: M0,
  break: B0,
  code: F0,
  delete: v0,
  emphasis: H0,
  footnoteReference: U0,
  heading: j0,
  html: z0,
  imageReference: q0,
  image: Y0,
  inlineCode: V0,
  linkReference: W0,
  link: Q0,
  listItem: G0,
  list: K0,
  paragraph: X0,
  // @ts-expect-error: root is different, but hard to type.
  root: Z0,
  strong: J0,
  table: ef,
  tableCell: nf,
  tableRow: tf,
  text: uf,
  thematicBreak: af,
  toml: cn,
  yaml: cn,
  definition: cn,
  footnoteDefinition: cn
};
function cn() {
}
const pa = -1, qn = 0, Vt = 1, yn = 2, Yr = 3, Vr = 4, Wr = 5, Qr = 6, Ea = 7, ga = 8, Bu = typeof self == "object" ? self : globalThis, of = (e, t) => {
  const n = (u, a) => (e.set(a, u), u), r = (u) => {
    if (e.has(u))
      return e.get(u);
    const [a, i] = t[u];
    switch (a) {
      case qn:
      case pa:
        return n(i, u);
      case Vt: {
        const o = n([], u);
        for (const l of i)
          o.push(r(l));
        return o;
      }
      case yn: {
        const o = n({}, u);
        for (const [l, c] of i)
          o[r(l)] = r(c);
        return o;
      }
      case Yr:
        return n(new Date(i), u);
      case Vr: {
        const { source: o, flags: l } = i;
        return n(new RegExp(o, l), u);
      }
      case Wr: {
        const o = n(/* @__PURE__ */ new Map(), u);
        for (const [l, c] of i)
          o.set(r(l), r(c));
        return o;
      }
      case Qr: {
        const o = n(/* @__PURE__ */ new Set(), u);
        for (const l of i)
          o.add(r(l));
        return o;
      }
      case Ea: {
        const { name: o, message: l } = i;
        return n(new Bu[o](l), u);
      }
      case ga:
        return n(BigInt(i), u);
      case "BigInt":
        return n(Object(BigInt(i)), u);
      case "ArrayBuffer":
        return n(new Uint8Array(i).buffer, i);
      case "DataView": {
        const { buffer: o } = new Uint8Array(i);
        return n(new DataView(o), i);
      }
    }
    return n(new Bu[a](i), u);
  };
  return r;
}, Fu = (e) => of(/* @__PURE__ */ new Map(), e)(0), gt = "", { toString: lf } = {}, { keys: cf } = Object, vt = (e) => {
  const t = typeof e;
  if (t !== "object" || !e)
    return [qn, t];
  const n = lf.call(e).slice(8, -1);
  switch (n) {
    case "Array":
      return [Vt, gt];
    case "Object":
      return [yn, gt];
    case "Date":
      return [Yr, gt];
    case "RegExp":
      return [Vr, gt];
    case "Map":
      return [Wr, gt];
    case "Set":
      return [Qr, gt];
    case "DataView":
      return [Vt, n];
  }
  return n.includes("Array") ? [Vt, n] : n.includes("Error") ? [Ea, n] : [yn, n];
}, fn = ([e, t]) => e === qn && (t === "function" || t === "symbol"), ff = (e, t, n, r) => {
  const u = (i, o) => {
    const l = r.push(i) - 1;
    return n.set(o, l), l;
  }, a = (i) => {
    if (n.has(i))
      return n.get(i);
    let [o, l] = vt(i);
    switch (o) {
      case qn: {
        let d = i;
        switch (l) {
          case "bigint":
            o = ga, d = i.toString();
            break;
          case "function":
          case "symbol":
            if (e)
              throw new TypeError("unable to serialize " + l);
            d = null;
            break;
          case "undefined":
            return u([pa], i);
        }
        return u([o, d], i);
      }
      case Vt: {
        if (l) {
          let m = i;
          return l === "DataView" ? m = new Uint8Array(i.buffer) : l === "ArrayBuffer" && (m = new Uint8Array(i)), u([l, [...m]], i);
        }
        const d = [], f = u([o, d], i);
        for (const m of i)
          d.push(a(m));
        return f;
      }
      case yn: {
        if (l)
          switch (l) {
            case "BigInt":
              return u([l, i.toString()], i);
            case "Boolean":
            case "Number":
            case "String":
              return u([l, i.valueOf()], i);
          }
        if (t && "toJSON" in i)
          return a(i.toJSON());
        const d = [], f = u([o, d], i);
        for (const m of cf(i))
          (e || !fn(vt(i[m]))) && d.push([a(m), a(i[m])]);
        return f;
      }
      case Yr:
        return u([o, i.toISOString()], i);
      case Vr: {
        const { source: d, flags: f } = i;
        return u([o, { source: d, flags: f }], i);
      }
      case Wr: {
        const d = [], f = u([o, d], i);
        for (const [m, h] of i)
          (e || !(fn(vt(m)) || fn(vt(h)))) && d.push([a(m), a(h)]);
        return f;
      }
      case Qr: {
        const d = [], f = u([o, d], i);
        for (const m of i)
          (e || !fn(vt(m))) && d.push(a(m));
        return f;
      }
    }
    const { message: c } = i;
    return u([o, { name: l, message: c }], i);
  };
  return a;
}, vu = (e, { json: t, lossy: n } = {}) => {
  const r = [];
  return ff(!(t || n), !!t, /* @__PURE__ */ new Map(), r)(e), r;
}, On = typeof structuredClone == "function" ? (
  /* c8 ignore start */
  (e, t) => t && ("json" in t || "lossy" in t) ? Fu(vu(e, t)) : structuredClone(e)
) : (e, t) => Fu(vu(e, t));
function df(e, t) {
  const n = [{ type: "text", value: "↩" }];
  return t > 1 && n.push({
    type: "element",
    tagName: "sup",
    properties: {},
    children: [{ type: "text", value: String(t) }]
  }), n;
}
function hf(e, t) {
  return "Back to reference " + (e + 1) + (t > 1 ? "-" + t : "");
}
function mf(e) {
  const t = typeof e.options.clobberPrefix == "string" ? e.options.clobberPrefix : "user-content-", n = e.options.footnoteBackContent || df, r = e.options.footnoteBackLabel || hf, u = e.options.footnoteLabel || "Footnotes", a = e.options.footnoteLabelTagName || "h2", i = e.options.footnoteLabelProperties || {
    className: ["sr-only"]
  }, o = [];
  let l = -1;
  for (; ++l < e.footnoteOrder.length; ) {
    const c = e.footnoteById.get(
      e.footnoteOrder[l]
    );
    if (!c)
      continue;
    const d = e.all(c), f = String(c.identifier).toUpperCase(), m = yt(f.toLowerCase());
    let h = 0;
    const b = [], I = e.footnoteCounts.get(f);
    for (; I !== void 0 && ++h <= I; ) {
      b.length > 0 && b.push({ type: "text", value: " " });
      let w = typeof n == "string" ? n : n(l, h);
      typeof w == "string" && (w = { type: "text", value: w }), b.push({
        type: "element",
        tagName: "a",
        properties: {
          href: "#" + t + "fnref-" + m + (h > 1 ? "-" + h : ""),
          dataFootnoteBackref: "",
          ariaLabel: typeof r == "string" ? r : r(l, h),
          className: ["data-footnote-backref"]
        },
        children: Array.isArray(w) ? w : [w]
      });
    }
    const y = d[d.length - 1];
    if (y && y.type === "element" && y.tagName === "p") {
      const w = y.children[y.children.length - 1];
      w && w.type === "text" ? w.value += " " : y.children.push({ type: "text", value: " " }), y.children.push(...b);
    } else
      d.push(...b);
    const C = {
      type: "element",
      tagName: "li",
      properties: { id: t + "fn-" + m },
      children: e.wrap(d, !0)
    };
    e.patch(c, C), o.push(C);
  }
  if (o.length !== 0)
    return {
      type: "element",
      tagName: "section",
      properties: { dataFootnotes: !0, className: ["footnotes"] },
      children: [
        {
          type: "element",
          tagName: a,
          properties: {
            ...On(i),
            id: "footnote-label"
          },
          children: [{ type: "text", value: u }]
        },
        { type: "text", value: `
` },
        {
          type: "element",
          tagName: "ol",
          properties: {},
          children: e.wrap(o, !0)
        },
        { type: "text", value: `
` }
      ]
    };
}
const _r = {}.hasOwnProperty, pf = {};
function Ef(e, t) {
  const n = t || pf, r = /* @__PURE__ */ new Map(), u = /* @__PURE__ */ new Map(), a = /* @__PURE__ */ new Map(), i = { ...sf, ...n.handlers }, o = {
    all: c,
    applyData: Tf,
    definitionById: r,
    footnoteById: u,
    footnoteCounts: a,
    footnoteOrder: [],
    handlers: i,
    one: l,
    options: n,
    patch: gf,
    wrap: Af
  };
  return Hn(e, function(d) {
    if (d.type === "definition" || d.type === "footnoteDefinition") {
      const f = d.type === "definition" ? r : u, m = String(d.identifier).toUpperCase();
      f.has(m) || f.set(m, d);
    }
  }), o;
  function l(d, f) {
    const m = d.type, h = o.handlers[m];
    if (_r.call(o.handlers, m) && h)
      return h(o, d, f);
    if (o.options.passThrough && o.options.passThrough.includes(m)) {
      if ("children" in d) {
        const { children: I, ...y } = d, C = On(y);
        return C.children = o.all(d), C;
      }
      return On(d);
    }
    return (o.options.unknownHandler || bf)(o, d, f);
  }
  function c(d) {
    const f = [];
    if ("children" in d) {
      const m = d.children;
      let h = -1;
      for (; ++h < m.length; ) {
        const b = o.one(m[h], d);
        if (b) {
          if (h && m[h - 1].type === "break" && (!Array.isArray(b) && b.type === "text" && (b.value = Hu(b.value)), !Array.isArray(b) && b.type === "element")) {
            const I = b.children[0];
            I && I.type === "text" && (I.value = Hu(I.value));
          }
          Array.isArray(b) ? f.push(...b) : f.push(b);
        }
      }
    }
    return f;
  }
}
function gf(e, t) {
  e.position && (t.position = vo(e));
}
function Tf(e, t) {
  let n = t;
  if (e && e.data) {
    const r = e.data.hName, u = e.data.hChildren, a = e.data.hProperties;
    if (typeof r == "string")
      if (n.type === "element")
        n.tagName = r;
      else {
        const i = "children" in n ? n.children : [n];
        n = { type: "element", tagName: r, properties: {}, children: i };
      }
    n.type === "element" && a && Object.assign(n.properties, On(a)), "children" in n && n.children && u !== null && u !== void 0 && (n.children = u);
  }
  return n;
}
function bf(e, t) {
  const n = t.data || {}, r = "value" in t && !(_r.call(n, "hProperties") || _r.call(n, "hChildren")) ? { type: "text", value: t.value } : {
    type: "element",
    tagName: "div",
    properties: {},
    children: e.all(t)
  };
  return e.patch(t, r), e.applyData(t, r);
}
function Af(e, t) {
  const n = [];
  let r = -1;
  for (t && n.push({ type: "text", value: `
` }); ++r < e.length; )
    r && n.push({ type: "text", value: `
` }), n.push(e[r]);
  return t && e.length > 0 && n.push({ type: "text", value: `
` }), n;
}
function Hu(e) {
  let t = 0, n = e.charCodeAt(t);
  for (; n === 9 || n === 32; )
    t++, n = e.charCodeAt(t);
  return e.slice(t);
}
function Uu(e, t) {
  const n = Ef(e, t), r = n.one(e, void 0), u = mf(n), a = Array.isArray(r) ? { type: "root", children: r } : r || { type: "root", children: [] };
  return u && a.children.push({ type: "text", value: `
` }, u), a;
}
function _f(e, t) {
  return e && "run" in e ? async function(n, r) {
    const u = (
      /** @type {HastRoot} */
      Uu(n, { file: r, ...t })
    );
    await e.run(u, r);
  } : function(n, r) {
    return (
      /** @type {HastRoot} */
      Uu(n, { file: r, ...e || t })
    );
  };
}
function ju(e) {
  if (e)
    throw e;
}
var tr, zu;
function xf() {
  if (zu) return tr;
  zu = 1;
  var e = Object.prototype.hasOwnProperty, t = Object.prototype.toString, n = Object.defineProperty, r = Object.getOwnPropertyDescriptor, u = function(c) {
    return typeof Array.isArray == "function" ? Array.isArray(c) : t.call(c) === "[object Array]";
  }, a = function(c) {
    if (!c || t.call(c) !== "[object Object]")
      return !1;
    var d = e.call(c, "constructor"), f = c.constructor && c.constructor.prototype && e.call(c.constructor.prototype, "isPrototypeOf");
    if (c.constructor && !d && !f)
      return !1;
    var m;
    for (m in c)
      ;
    return typeof m > "u" || e.call(c, m);
  }, i = function(c, d) {
    n && d.name === "__proto__" ? n(c, d.name, {
      enumerable: !0,
      configurable: !0,
      value: d.newValue,
      writable: !0
    }) : c[d.name] = d.newValue;
  }, o = function(c, d) {
    if (d === "__proto__")
      if (e.call(c, d)) {
        if (r)
          return r(c, d).value;
      } else return;
    return c[d];
  };
  return tr = function l() {
    var c, d, f, m, h, b, I = arguments[0], y = 1, C = arguments.length, w = !1;
    for (typeof I == "boolean" && (w = I, I = arguments[1] || {}, y = 2), (I == null || typeof I != "object" && typeof I != "function") && (I = {}); y < C; ++y)
      if (c = arguments[y], c != null)
        for (d in c)
          f = o(I, d), m = o(c, d), I !== m && (w && m && (a(m) || (h = u(m))) ? (h ? (h = !1, b = f && u(f) ? f : []) : b = f && a(f) ? f : {}, i(I, { name: d, newValue: l(w, b, m) })) : typeof m < "u" && i(I, { name: d, newValue: m }));
    return I;
  }, tr;
}
var Cf = xf();
const nr = /* @__PURE__ */ yl(Cf);
function xr(e) {
  if (typeof e != "object" || e === null)
    return !1;
  const t = Object.getPrototypeOf(e);
  return (t === null || t === Object.prototype || Object.getPrototypeOf(t) === null) && !(Symbol.toStringTag in e) && !(Symbol.iterator in e);
}
function If() {
  const e = [], t = { run: n, use: r };
  return t;
  function n(...u) {
    let a = -1;
    const i = u.pop();
    if (typeof i != "function")
      throw new TypeError("Expected function as last argument, not " + i);
    o(null, ...u);
    function o(l, ...c) {
      const d = e[++a];
      let f = -1;
      if (l) {
        i(l);
        return;
      }
      for (; ++f < u.length; )
        (c[f] === null || c[f] === void 0) && (c[f] = u[f]);
      u = c, d ? Sf(d, o)(...c) : i(null, ...c);
    }
  }
  function r(u) {
    if (typeof u != "function")
      throw new TypeError(
        "Expected `middelware` to be a function, not " + u
      );
    return e.push(u), t;
  }
}
function Sf(e, t) {
  let n;
  return r;
  function r(...i) {
    const o = e.length > i.length;
    let l;
    o && i.push(u);
    try {
      l = e.apply(this, i);
    } catch (c) {
      const d = (
        /** @type {Error} */
        c
      );
      if (o && n)
        throw d;
      return u(d);
    }
    o || (l && l.then && typeof l.then == "function" ? l.then(a, u) : l instanceof Error ? u(l) : a(l));
  }
  function u(i, ...o) {
    n || (n = !0, t(i, ...o));
  }
  function a(i) {
    u(null, i);
  }
}
const Me = { basename: Nf, dirname: kf, extname: yf, join: Of, sep: "/" };
function Nf(e, t) {
  if (t !== void 0 && typeof t != "string")
    throw new TypeError('"ext" argument must be a string');
  rn(e);
  let n = 0, r = -1, u = e.length, a;
  if (t === void 0 || t.length === 0 || t.length > e.length) {
    for (; u--; )
      if (e.codePointAt(u) === 47) {
        if (a) {
          n = u + 1;
          break;
        }
      } else r < 0 && (a = !0, r = u + 1);
    return r < 0 ? "" : e.slice(n, r);
  }
  if (t === e)
    return "";
  let i = -1, o = t.length - 1;
  for (; u--; )
    if (e.codePointAt(u) === 47) {
      if (a) {
        n = u + 1;
        break;
      }
    } else
      i < 0 && (a = !0, i = u + 1), o > -1 && (e.codePointAt(u) === t.codePointAt(o--) ? o < 0 && (r = u) : (o = -1, r = i));
  return n === r ? r = i : r < 0 && (r = e.length), e.slice(n, r);
}
function kf(e) {
  if (rn(e), e.length === 0)
    return ".";
  let t = -1, n = e.length, r;
  for (; --n; )
    if (e.codePointAt(n) === 47) {
      if (r) {
        t = n;
        break;
      }
    } else r || (r = !0);
  return t < 0 ? e.codePointAt(0) === 47 ? "/" : "." : t === 1 && e.codePointAt(0) === 47 ? "//" : e.slice(0, t);
}
function yf(e) {
  rn(e);
  let t = e.length, n = -1, r = 0, u = -1, a = 0, i;
  for (; t--; ) {
    const o = e.codePointAt(t);
    if (o === 47) {
      if (i) {
        r = t + 1;
        break;
      }
      continue;
    }
    n < 0 && (i = !0, n = t + 1), o === 46 ? u < 0 ? u = t : a !== 1 && (a = 1) : u > -1 && (a = -1);
  }
  return u < 0 || n < 0 || // We saw a non-dot character immediately before the dot.
  a === 0 || // The (right-most) trimmed path component is exactly `..`.
  a === 1 && u === n - 1 && u === r + 1 ? "" : e.slice(u, n);
}
function Of(...e) {
  let t = -1, n;
  for (; ++t < e.length; )
    rn(e[t]), e[t] && (n = n === void 0 ? e[t] : n + "/" + e[t]);
  return n === void 0 ? "." : Lf(n);
}
function Lf(e) {
  rn(e);
  const t = e.codePointAt(0) === 47;
  let n = Rf(e, !t);
  return n.length === 0 && !t && (n = "."), n.length > 0 && e.codePointAt(e.length - 1) === 47 && (n += "/"), t ? "/" + n : n;
}
function Rf(e, t) {
  let n = "", r = 0, u = -1, a = 0, i = -1, o, l;
  for (; ++i <= e.length; ) {
    if (i < e.length)
      o = e.codePointAt(i);
    else {
      if (o === 47)
        break;
      o = 47;
    }
    if (o === 47) {
      if (!(u === i - 1 || a === 1)) if (u !== i - 1 && a === 2) {
        if (n.length < 2 || r !== 2 || n.codePointAt(n.length - 1) !== 46 || n.codePointAt(n.length - 2) !== 46) {
          if (n.length > 2) {
            if (l = n.lastIndexOf("/"), l !== n.length - 1) {
              l < 0 ? (n = "", r = 0) : (n = n.slice(0, l), r = n.length - 1 - n.lastIndexOf("/")), u = i, a = 0;
              continue;
            }
          } else if (n.length > 0) {
            n = "", r = 0, u = i, a = 0;
            continue;
          }
        }
        t && (n = n.length > 0 ? n + "/.." : "..", r = 2);
      } else
        n.length > 0 ? n += "/" + e.slice(u + 1, i) : n = e.slice(u + 1, i), r = i - u - 1;
      u = i, a = 0;
    } else o === 46 && a > -1 ? a++ : a = -1;
  }
  return n;
}
function rn(e) {
  if (typeof e != "string")
    throw new TypeError(
      "Path must be a string. Received " + JSON.stringify(e)
    );
}
const Df = { cwd: Pf };
function Pf() {
  return "/";
}
function Cr(e) {
  return !!(e !== null && typeof e == "object" && "href" in e && e.href && "protocol" in e && e.protocol && // @ts-expect-error: indexing is fine.
  e.auth === void 0);
}
function wf(e) {
  if (typeof e == "string")
    e = new URL(e);
  else if (!Cr(e)) {
    const t = new TypeError(
      'The "path" argument must be of type string or an instance of URL. Received `' + e + "`"
    );
    throw t.code = "ERR_INVALID_ARG_TYPE", t;
  }
  if (e.protocol !== "file:") {
    const t = new TypeError("The URL must be of scheme file");
    throw t.code = "ERR_INVALID_URL_SCHEME", t;
  }
  return Mf(e);
}
function Mf(e) {
  if (e.hostname !== "") {
    const r = new TypeError(
      'File URL host must be "localhost" or empty on darwin'
    );
    throw r.code = "ERR_INVALID_FILE_URL_HOST", r;
  }
  const t = e.pathname;
  let n = -1;
  for (; ++n < t.length; )
    if (t.codePointAt(n) === 37 && t.codePointAt(n + 1) === 50) {
      const r = t.codePointAt(n + 2);
      if (r === 70 || r === 102) {
        const u = new TypeError(
          "File URL path must not include encoded / characters"
        );
        throw u.code = "ERR_INVALID_FILE_URL_PATH", u;
      }
    }
  return decodeURIComponent(t);
}
const rr = (
  /** @type {const} */
  [
    "history",
    "path",
    "basename",
    "stem",
    "extname",
    "dirname"
  ]
);
class Ta {
  /**
   * Create a new virtual file.
   *
   * `options` is treated as:
   *
   * *   `string` or `Uint8Array` — `{value: options}`
   * *   `URL` — `{path: options}`
   * *   `VFile` — shallow copies its data over to the new file
   * *   `object` — all fields are shallow copied over to the new file
   *
   * Path related fields are set in the following order (least specific to
   * most specific): `history`, `path`, `basename`, `stem`, `extname`,
   * `dirname`.
   *
   * You cannot set `dirname` or `extname` without setting either `history`,
   * `path`, `basename`, or `stem` too.
   *
   * @param {Compatible | null | undefined} [value]
   *   File value.
   * @returns
   *   New instance.
   */
  constructor(t) {
    let n;
    t ? Cr(t) ? n = { path: t } : typeof t == "string" || Bf(t) ? n = { value: t } : n = t : n = {}, this.cwd = "cwd" in n ? "" : Df.cwd(), this.data = {}, this.history = [], this.messages = [], this.value, this.map, this.result, this.stored;
    let r = -1;
    for (; ++r < rr.length; ) {
      const a = rr[r];
      a in n && n[a] !== void 0 && n[a] !== null && (this[a] = a === "history" ? [...n[a]] : n[a]);
    }
    let u;
    for (u in n)
      rr.includes(u) || (this[u] = n[u]);
  }
  /**
   * Get the basename (including extname) (example: `'index.min.js'`).
   *
   * @returns {string | undefined}
   *   Basename.
   */
  get basename() {
    return typeof this.path == "string" ? Me.basename(this.path) : void 0;
  }
  /**
   * Set basename (including extname) (`'index.min.js'`).
   *
   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
   * on windows).
   * Cannot be nullified (use `file.path = file.dirname` instead).
   *
   * @param {string} basename
   *   Basename.
   * @returns {undefined}
   *   Nothing.
   */
  set basename(t) {
    ir(t, "basename"), ur(t, "basename"), this.path = Me.join(this.dirname || "", t);
  }
  /**
   * Get the parent path (example: `'~'`).
   *
   * @returns {string | undefined}
   *   Dirname.
   */
  get dirname() {
    return typeof this.path == "string" ? Me.dirname(this.path) : void 0;
  }
  /**
   * Set the parent path (example: `'~'`).
   *
   * Cannot be set if there’s no `path` yet.
   *
   * @param {string | undefined} dirname
   *   Dirname.
   * @returns {undefined}
   *   Nothing.
   */
  set dirname(t) {
    qu(this.basename, "dirname"), this.path = Me.join(t || "", this.basename);
  }
  /**
   * Get the extname (including dot) (example: `'.js'`).
   *
   * @returns {string | undefined}
   *   Extname.
   */
  get extname() {
    return typeof this.path == "string" ? Me.extname(this.path) : void 0;
  }
  /**
   * Set the extname (including dot) (example: `'.js'`).
   *
   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
   * on windows).
   * Cannot be set if there’s no `path` yet.
   *
   * @param {string | undefined} extname
   *   Extname.
   * @returns {undefined}
   *   Nothing.
   */
  set extname(t) {
    if (ur(t, "extname"), qu(this.dirname, "extname"), t) {
      if (t.codePointAt(0) !== 46)
        throw new Error("`extname` must start with `.`");
      if (t.includes(".", 1))
        throw new Error("`extname` cannot contain multiple dots");
    }
    this.path = Me.join(this.dirname, this.stem + (t || ""));
  }
  /**
   * Get the full path (example: `'~/index.min.js'`).
   *
   * @returns {string}
   *   Path.
   */
  get path() {
    return this.history[this.history.length - 1];
  }
  /**
   * Set the full path (example: `'~/index.min.js'`).
   *
   * Cannot be nullified.
   * You can set a file URL (a `URL` object with a `file:` protocol) which will
   * be turned into a path with `url.fileURLToPath`.
   *
   * @param {URL | string} path
   *   Path.
   * @returns {undefined}
   *   Nothing.
   */
  set path(t) {
    Cr(t) && (t = wf(t)), ir(t, "path"), this.path !== t && this.history.push(t);
  }
  /**
   * Get the stem (basename w/o extname) (example: `'index.min'`).
   *
   * @returns {string | undefined}
   *   Stem.
   */
  get stem() {
    return typeof this.path == "string" ? Me.basename(this.path, this.extname) : void 0;
  }
  /**
   * Set the stem (basename w/o extname) (example: `'index.min'`).
   *
   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
   * on windows).
   * Cannot be nullified (use `file.path = file.dirname` instead).
   *
   * @param {string} stem
   *   Stem.
   * @returns {undefined}
   *   Nothing.
   */
  set stem(t) {
    ir(t, "stem"), ur(t, "stem"), this.path = Me.join(this.dirname || "", t + (this.extname || ""));
  }
  // Normal prototypal methods.
  /**
   * Create a fatal message for `reason` associated with the file.
   *
   * The `fatal` field of the message is set to `true` (error; file not usable)
   * and the `file` field is set to the current file path.
   * The message is added to the `messages` field on `file`.
   *
   * > 🪦 **Note**: also has obsolete signatures.
   *
   * @overload
   * @param {string} reason
   * @param {MessageOptions | null | undefined} [options]
   * @returns {never}
   *
   * @overload
   * @param {string} reason
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {string} reason
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {string} reason
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @param {Error | VFileMessage | string} causeOrReason
   *   Reason for message, should use markdown.
   * @param {Node | NodeLike | MessageOptions | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
   *   Configuration (optional).
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns {never}
   *   Never.
   * @throws {VFileMessage}
   *   Message.
   */
  fail(t, n, r) {
    const u = this.message(t, n, r);
    throw u.fatal = !0, u;
  }
  /**
   * Create an info message for `reason` associated with the file.
   *
   * The `fatal` field of the message is set to `undefined` (info; change
   * likely not needed) and the `file` field is set to the current file path.
   * The message is added to the `messages` field on `file`.
   *
   * > 🪦 **Note**: also has obsolete signatures.
   *
   * @overload
   * @param {string} reason
   * @param {MessageOptions | null | undefined} [options]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @param {Error | VFileMessage | string} causeOrReason
   *   Reason for message, should use markdown.
   * @param {Node | NodeLike | MessageOptions | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
   *   Configuration (optional).
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns {VFileMessage}
   *   Message.
   */
  info(t, n, r) {
    const u = this.message(t, n, r);
    return u.fatal = void 0, u;
  }
  /**
   * Create a message for `reason` associated with the file.
   *
   * The `fatal` field of the message is set to `false` (warning; change may be
   * needed) and the `file` field is set to the current file path.
   * The message is added to the `messages` field on `file`.
   *
   * > 🪦 **Note**: also has obsolete signatures.
   *
   * @overload
   * @param {string} reason
   * @param {MessageOptions | null | undefined} [options]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @param {Error | VFileMessage | string} causeOrReason
   *   Reason for message, should use markdown.
   * @param {Node | NodeLike | MessageOptions | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
   *   Configuration (optional).
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns {VFileMessage}
   *   Message.
   */
  message(t, n, r) {
    const u = new Ho(
      // @ts-expect-error: the overloads are fine.
      t,
      n,
      r
    );
    return this.path && (u.name = this.path + ":" + u.name, u.file = this.path), u.fatal = !1, this.messages.push(u), u;
  }
  /**
   * Serialize the file.
   *
   * > **Note**: which encodings are supported depends on the engine.
   * > For info on Node.js, see:
   * > <https://nodejs.org/api/util.html#whatwg-supported-encodings>.
   *
   * @param {string | null | undefined} [encoding='utf8']
   *   Character encoding to understand `value` as when it’s a `Uint8Array`
   *   (default: `'utf-8'`).
   * @returns {string}
   *   Serialized file.
   */
  toString(t) {
    return this.value === void 0 ? "" : typeof this.value == "string" ? this.value : new TextDecoder(t || void 0).decode(this.value);
  }
}
function ur(e, t) {
  if (e && e.includes(Me.sep))
    throw new Error(
      "`" + t + "` cannot be a path: did not expect `" + Me.sep + "`"
    );
}
function ir(e, t) {
  if (!e)
    throw new Error("`" + t + "` cannot be empty");
}
function qu(e, t) {
  if (!e)
    throw new Error("Setting `" + t + "` requires `path` to be set too");
}
function Bf(e) {
  return !!(e && typeof e == "object" && "byteLength" in e && "byteOffset" in e);
}
const Ff = (
  /**
   * @type {new <Parameters extends Array<unknown>, Result>(property: string | symbol) => (...parameters: Parameters) => Result}
   */
  /** @type {unknown} */
  /**
   * @this {Function}
   * @param {string | symbol} property
   * @returns {(...parameters: Array<unknown>) => unknown}
   */
  (function(e) {
    const r = (
      /** @type {Record<string | symbol, Function>} */
      // Prototypes do exist.
      // type-coverage:ignore-next-line
      this.constructor.prototype
    ), u = r[e], a = function() {
      return u.apply(a, arguments);
    };
    return Object.setPrototypeOf(a, r), a;
  })
), vf = {}.hasOwnProperty;
class Gr extends Ff {
  /**
   * Create a processor.
   */
  constructor() {
    super("copy"), this.Compiler = void 0, this.Parser = void 0, this.attachers = [], this.compiler = void 0, this.freezeIndex = -1, this.frozen = void 0, this.namespace = {}, this.parser = void 0, this.transformers = If();
  }
  /**
   * Copy a processor.
   *
   * @deprecated
   *   This is a private internal method and should not be used.
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *   New *unfrozen* processor ({@linkcode Processor}) that is
   *   configured to work the same as its ancestor.
   *   When the descendant processor is configured in the future it does not
   *   affect the ancestral processor.
   */
  copy() {
    const t = (
      /** @type {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>} */
      new Gr()
    );
    let n = -1;
    for (; ++n < this.attachers.length; ) {
      const r = this.attachers[n];
      t.use(...r);
    }
    return t.data(nr(!0, {}, this.namespace)), t;
  }
  /**
   * Configure the processor with info available to all plugins.
   * Information is stored in an object.
   *
   * Typically, options can be given to a specific plugin, but sometimes it
   * makes sense to have information shared with several plugins.
   * For example, a list of HTML elements that are self-closing, which is
   * needed during all phases.
   *
   * > **Note**: setting information cannot occur on *frozen* processors.
   * > Call the processor first to create a new unfrozen processor.
   *
   * > **Note**: to register custom data in TypeScript, augment the
   * > {@linkcode Data} interface.
   *
   * @example
   *   This example show how to get and set info:
   *
   *   ```js
   *   import {unified} from 'unified'
   *
   *   const processor = unified().data('alpha', 'bravo')
   *
   *   processor.data('alpha') // => 'bravo'
   *
   *   processor.data() // => {alpha: 'bravo'}
   *
   *   processor.data({charlie: 'delta'})
   *
   *   processor.data() // => {charlie: 'delta'}
   *   ```
   *
   * @template {keyof Data} Key
   *
   * @overload
   * @returns {Data}
   *
   * @overload
   * @param {Data} dataset
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *
   * @overload
   * @param {Key} key
   * @returns {Data[Key]}
   *
   * @overload
   * @param {Key} key
   * @param {Data[Key]} value
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *
   * @param {Data | Key} [key]
   *   Key to get or set, or entire dataset to set, or nothing to get the
   *   entire dataset (optional).
   * @param {Data[Key]} [value]
   *   Value to set (optional).
   * @returns {unknown}
   *   The current processor when setting, the value at `key` when getting, or
   *   the entire dataset when getting without key.
   */
  data(t, n) {
    return typeof t == "string" ? arguments.length === 2 ? (or("data", this.frozen), this.namespace[t] = n, this) : vf.call(this.namespace, t) && this.namespace[t] || void 0 : t ? (or("data", this.frozen), this.namespace = t, this) : this.namespace;
  }
  /**
   * Freeze a processor.
   *
   * Frozen processors are meant to be extended and not to be configured
   * directly.
   *
   * When a processor is frozen it cannot be unfrozen.
   * New processors working the same way can be created by calling the
   * processor.
   *
   * It’s possible to freeze processors explicitly by calling `.freeze()`.
   * Processors freeze automatically when `.parse()`, `.run()`, `.runSync()`,
   * `.stringify()`, `.process()`, or `.processSync()` are called.
   *
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *   The current processor.
   */
  freeze() {
    if (this.frozen)
      return this;
    const t = (
      /** @type {Processor} */
      /** @type {unknown} */
      this
    );
    for (; ++this.freezeIndex < this.attachers.length; ) {
      const [n, ...r] = this.attachers[this.freezeIndex];
      if (r[0] === !1)
        continue;
      r[0] === !0 && (r[0] = void 0);
      const u = n.call(t, ...r);
      typeof u == "function" && this.transformers.use(u);
    }
    return this.frozen = !0, this.freezeIndex = Number.POSITIVE_INFINITY, this;
  }
  /**
   * Parse text to a syntax tree.
   *
   * > **Note**: `parse` freezes the processor if not already *frozen*.
   *
   * > **Note**: `parse` performs the parse phase, not the run phase or other
   * > phases.
   *
   * @param {Compatible | undefined} [file]
   *   file to parse (optional); typically `string` or `VFile`; any value
   *   accepted as `x` in `new VFile(x)`.
   * @returns {ParseTree extends undefined ? Node : ParseTree}
   *   Syntax tree representing `file`.
   */
  parse(t) {
    this.freeze();
    const n = dn(t), r = this.parser || this.Parser;
    return ar("parse", r), r(String(n), n);
  }
  /**
   * Process the given file as configured on the processor.
   *
   * > **Note**: `process` freezes the processor if not already *frozen*.
   *
   * > **Note**: `process` performs the parse, run, and stringify phases.
   *
   * @overload
   * @param {Compatible | undefined} file
   * @param {ProcessCallback<VFileWithOutput<CompileResult>>} done
   * @returns {undefined}
   *
   * @overload
   * @param {Compatible | undefined} [file]
   * @returns {Promise<VFileWithOutput<CompileResult>>}
   *
   * @param {Compatible | undefined} [file]
   *   File (optional); typically `string` or `VFile`]; any value accepted as
   *   `x` in `new VFile(x)`.
   * @param {ProcessCallback<VFileWithOutput<CompileResult>> | undefined} [done]
   *   Callback (optional).
   * @returns {Promise<VFile> | undefined}
   *   Nothing if `done` is given.
   *   Otherwise a promise, rejected with a fatal error or resolved with the
   *   processed file.
   *
   *   The parsed, transformed, and compiled value is available at
   *   `file.value` (see note).
   *
   *   > **Note**: unified typically compiles by serializing: most
   *   > compilers return `string` (or `Uint8Array`).
   *   > Some compilers, such as the one configured with
   *   > [`rehype-react`][rehype-react], return other values (in this case, a
   *   > React tree).
   *   > If you’re using a compiler that doesn’t serialize, expect different
   *   > result values.
   *   >
   *   > To register custom results in TypeScript, add them to
   *   > {@linkcode CompileResultMap}.
   *
   *   [rehype-react]: https://github.com/rehypejs/rehype-react
   */
  process(t, n) {
    const r = this;
    return this.freeze(), ar("process", this.parser || this.Parser), sr("process", this.compiler || this.Compiler), n ? u(void 0, n) : new Promise(u);
    function u(a, i) {
      const o = dn(t), l = (
        /** @type {HeadTree extends undefined ? Node : HeadTree} */
        /** @type {unknown} */
        r.parse(o)
      );
      r.run(l, o, function(d, f, m) {
        if (d || !f || !m)
          return c(d);
        const h = (
          /** @type {CompileTree extends undefined ? Node : CompileTree} */
          /** @type {unknown} */
          f
        ), b = r.stringify(h, m);
        jf(b) ? m.value = b : m.result = b, c(
          d,
          /** @type {VFileWithOutput<CompileResult>} */
          m
        );
      });
      function c(d, f) {
        d || !f ? i(d) : a ? a(f) : n(void 0, f);
      }
    }
  }
  /**
   * Process the given file as configured on the processor.
   *
   * An error is thrown if asynchronous transforms are configured.
   *
   * > **Note**: `processSync` freezes the processor if not already *frozen*.
   *
   * > **Note**: `processSync` performs the parse, run, and stringify phases.
   *
   * @param {Compatible | undefined} [file]
   *   File (optional); typically `string` or `VFile`; any value accepted as
   *   `x` in `new VFile(x)`.
   * @returns {VFileWithOutput<CompileResult>}
   *   The processed file.
   *
   *   The parsed, transformed, and compiled value is available at
   *   `file.value` (see note).
   *
   *   > **Note**: unified typically compiles by serializing: most
   *   > compilers return `string` (or `Uint8Array`).
   *   > Some compilers, such as the one configured with
   *   > [`rehype-react`][rehype-react], return other values (in this case, a
   *   > React tree).
   *   > If you’re using a compiler that doesn’t serialize, expect different
   *   > result values.
   *   >
   *   > To register custom results in TypeScript, add them to
   *   > {@linkcode CompileResultMap}.
   *
   *   [rehype-react]: https://github.com/rehypejs/rehype-react
   */
  processSync(t) {
    let n = !1, r;
    return this.freeze(), ar("processSync", this.parser || this.Parser), sr("processSync", this.compiler || this.Compiler), this.process(t, u), Vu("processSync", "process", n), r;
    function u(a, i) {
      n = !0, ju(a), r = i;
    }
  }
  /**
   * Run *transformers* on a syntax tree.
   *
   * > **Note**: `run` freezes the processor if not already *frozen*.
   *
   * > **Note**: `run` performs the run phase, not other phases.
   *
   * @overload
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   * @param {RunCallback<TailTree extends undefined ? Node : TailTree>} done
   * @returns {undefined}
   *
   * @overload
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   * @param {Compatible | undefined} file
   * @param {RunCallback<TailTree extends undefined ? Node : TailTree>} done
   * @returns {undefined}
   *
   * @overload
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   * @param {Compatible | undefined} [file]
   * @returns {Promise<TailTree extends undefined ? Node : TailTree>}
   *
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   *   Tree to transform and inspect.
   * @param {(
   *   RunCallback<TailTree extends undefined ? Node : TailTree> |
   *   Compatible
   * )} [file]
   *   File associated with `node` (optional); any value accepted as `x` in
   *   `new VFile(x)`.
   * @param {RunCallback<TailTree extends undefined ? Node : TailTree>} [done]
   *   Callback (optional).
   * @returns {Promise<TailTree extends undefined ? Node : TailTree> | undefined}
   *   Nothing if `done` is given.
   *   Otherwise, a promise rejected with a fatal error or resolved with the
   *   transformed tree.
   */
  run(t, n, r) {
    Yu(t), this.freeze();
    const u = this.transformers;
    return !r && typeof n == "function" && (r = n, n = void 0), r ? a(void 0, r) : new Promise(a);
    function a(i, o) {
      const l = dn(n);
      u.run(t, l, c);
      function c(d, f, m) {
        const h = (
          /** @type {TailTree extends undefined ? Node : TailTree} */
          f || t
        );
        d ? o(d) : i ? i(h) : r(void 0, h, m);
      }
    }
  }
  /**
   * Run *transformers* on a syntax tree.
   *
   * An error is thrown if asynchronous transforms are configured.
   *
   * > **Note**: `runSync` freezes the processor if not already *frozen*.
   *
   * > **Note**: `runSync` performs the run phase, not other phases.
   *
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   *   Tree to transform and inspect.
   * @param {Compatible | undefined} [file]
   *   File associated with `node` (optional); any value accepted as `x` in
   *   `new VFile(x)`.
   * @returns {TailTree extends undefined ? Node : TailTree}
   *   Transformed tree.
   */
  runSync(t, n) {
    let r = !1, u;
    return this.run(t, n, a), Vu("runSync", "run", r), u;
    function a(i, o) {
      ju(i), u = o, r = !0;
    }
  }
  /**
   * Compile a syntax tree.
   *
   * > **Note**: `stringify` freezes the processor if not already *frozen*.
   *
   * > **Note**: `stringify` performs the stringify phase, not the run phase
   * > or other phases.
   *
   * @param {CompileTree extends undefined ? Node : CompileTree} tree
   *   Tree to compile.
   * @param {Compatible | undefined} [file]
   *   File associated with `node` (optional); any value accepted as `x` in
   *   `new VFile(x)`.
   * @returns {CompileResult extends undefined ? Value : CompileResult}
   *   Textual representation of the tree (see note).
   *
   *   > **Note**: unified typically compiles by serializing: most compilers
   *   > return `string` (or `Uint8Array`).
   *   > Some compilers, such as the one configured with
   *   > [`rehype-react`][rehype-react], return other values (in this case, a
   *   > React tree).
   *   > If you’re using a compiler that doesn’t serialize, expect different
   *   > result values.
   *   >
   *   > To register custom results in TypeScript, add them to
   *   > {@linkcode CompileResultMap}.
   *
   *   [rehype-react]: https://github.com/rehypejs/rehype-react
   */
  stringify(t, n) {
    this.freeze();
    const r = dn(n), u = this.compiler || this.Compiler;
    return sr("stringify", u), Yu(t), u(t, r);
  }
  /**
   * Configure the processor to use a plugin, a list of usable values, or a
   * preset.
   *
   * If the processor is already using a plugin, the previous plugin
   * configuration is changed based on the options that are passed in.
   * In other words, the plugin is not added a second time.
   *
   * > **Note**: `use` cannot be called on *frozen* processors.
   * > Call the processor first to create a new unfrozen processor.
   *
   * @example
   *   There are many ways to pass plugins to `.use()`.
   *   This example gives an overview:
   *
   *   ```js
   *   import {unified} from 'unified'
   *
   *   unified()
   *     // Plugin with options:
   *     .use(pluginA, {x: true, y: true})
   *     // Passing the same plugin again merges configuration (to `{x: true, y: false, z: true}`):
   *     .use(pluginA, {y: false, z: true})
   *     // Plugins:
   *     .use([pluginB, pluginC])
   *     // Two plugins, the second with options:
   *     .use([pluginD, [pluginE, {}]])
   *     // Preset with plugins and settings:
   *     .use({plugins: [pluginF, [pluginG, {}]], settings: {position: false}})
   *     // Settings only:
   *     .use({settings: {position: false}})
   *   ```
   *
   * @template {Array<unknown>} [Parameters=[]]
   * @template {Node | string | undefined} [Input=undefined]
   * @template [Output=Input]
   *
   * @overload
   * @param {Preset | null | undefined} [preset]
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *
   * @overload
   * @param {PluggableList} list
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *
   * @overload
   * @param {Plugin<Parameters, Input, Output>} plugin
   * @param {...(Parameters | [boolean])} parameters
   * @returns {UsePlugin<ParseTree, HeadTree, TailTree, CompileTree, CompileResult, Input, Output>}
   *
   * @param {PluggableList | Plugin | Preset | null | undefined} value
   *   Usable value.
   * @param {...unknown} parameters
   *   Parameters, when a plugin is given as a usable value.
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *   Current processor.
   */
  use(t, ...n) {
    const r = this.attachers, u = this.namespace;
    if (or("use", this.frozen), t != null) if (typeof t == "function")
      l(t, n);
    else if (typeof t == "object")
      Array.isArray(t) ? o(t) : i(t);
    else
      throw new TypeError("Expected usable value, not `" + t + "`");
    return this;
    function a(c) {
      if (typeof c == "function")
        l(c, []);
      else if (typeof c == "object")
        if (Array.isArray(c)) {
          const [d, ...f] = (
            /** @type {PluginTuple<Array<unknown>>} */
            c
          );
          l(d, f);
        } else
          i(c);
      else
        throw new TypeError("Expected usable value, not `" + c + "`");
    }
    function i(c) {
      if (!("plugins" in c) && !("settings" in c))
        throw new Error(
          "Expected usable value but received an empty preset, which is probably a mistake: presets typically come with `plugins` and sometimes with `settings`, but this has neither"
        );
      o(c.plugins), c.settings && (u.settings = nr(!0, u.settings, c.settings));
    }
    function o(c) {
      let d = -1;
      if (c != null) if (Array.isArray(c))
        for (; ++d < c.length; ) {
          const f = c[d];
          a(f);
        }
      else
        throw new TypeError("Expected a list of plugins, not `" + c + "`");
    }
    function l(c, d) {
      let f = -1, m = -1;
      for (; ++f < r.length; )
        if (r[f][0] === c) {
          m = f;
          break;
        }
      if (m === -1)
        r.push([c, ...d]);
      else if (d.length > 0) {
        let [h, ...b] = d;
        const I = r[m][1];
        xr(I) && xr(h) && (h = nr(!0, I, h)), r[m] = [c, h, ...b];
      }
    }
  }
}
const Hf = new Gr().freeze();
function ar(e, t) {
  if (typeof t != "function")
    throw new TypeError("Cannot `" + e + "` without `parser`");
}
function sr(e, t) {
  if (typeof t != "function")
    throw new TypeError("Cannot `" + e + "` without `compiler`");
}
function or(e, t) {
  if (t)
    throw new Error(
      "Cannot call `" + e + "` on a frozen processor.\nCreate a new processor first, by calling it: use `processor()` instead of `processor`."
    );
}
function Yu(e) {
  if (!xr(e) || typeof e.type != "string")
    throw new TypeError("Expected node, got `" + e + "`");
}
function Vu(e, t, n) {
  if (!n)
    throw new Error(
      "`" + e + "` finished async. Use `" + t + "` instead"
    );
}
function dn(e) {
  return Uf(e) ? e : new Ta(e);
}
function Uf(e) {
  return !!(e && typeof e == "object" && "message" in e && "messages" in e);
}
function jf(e) {
  return typeof e == "string" || zf(e);
}
function zf(e) {
  return !!(e && typeof e == "object" && "byteLength" in e && "byteOffset" in e);
}
const qf = "https://github.com/remarkjs/react-markdown/blob/main/changelog.md", Wu = [], Qu = { allowDangerousHtml: !0 }, Yf = /^(https?|ircs?|mailto|xmpp)$/i, Vf = [
  { from: "astPlugins", id: "remove-buggy-html-in-markdown-parser" },
  { from: "allowDangerousHtml", id: "remove-buggy-html-in-markdown-parser" },
  {
    from: "allowNode",
    id: "replace-allownode-allowedtypes-and-disallowedtypes",
    to: "allowElement"
  },
  {
    from: "allowedTypes",
    id: "replace-allownode-allowedtypes-and-disallowedtypes",
    to: "allowedElements"
  },
  { from: "className", id: "remove-classname" },
  {
    from: "disallowedTypes",
    id: "replace-allownode-allowedtypes-and-disallowedtypes",
    to: "disallowedElements"
  },
  { from: "escapeHtml", id: "remove-buggy-html-in-markdown-parser" },
  { from: "includeElementIndex", id: "#remove-includeelementindex" },
  {
    from: "includeNodeIndex",
    id: "change-includenodeindex-to-includeelementindex"
  },
  { from: "linkTarget", id: "remove-linktarget" },
  { from: "plugins", id: "change-plugins-to-remarkplugins", to: "remarkPlugins" },
  { from: "rawSourcePos", id: "#remove-rawsourcepos" },
  { from: "renderers", id: "change-renderers-to-components", to: "components" },
  { from: "source", id: "change-source-to-children", to: "children" },
  { from: "sourcePos", id: "#remove-sourcepos" },
  { from: "transformImageUri", id: "#add-urltransform", to: "urlTransform" },
  { from: "transformLinkUri", id: "#add-urltransform", to: "urlTransform" }
];
function Wf(e) {
  const t = Qf(e), n = Gf(e);
  return $f(t.runSync(t.parse(n), n), e);
}
function Qf(e) {
  const t = e.rehypePlugins || Wu, n = e.remarkPlugins || Wu, r = e.remarkRehypeOptions ? { ...e.remarkRehypeOptions, ...Qu } : Qu;
  return Hf().use(w0).use(n).use(_f, r).use(t);
}
function Gf(e) {
  const t = e.children || "", n = new Ta();
  return typeof t == "string" && (n.value = t), n;
}
function $f(e, t) {
  const n = t.allowedElements, r = t.allowElement, u = t.components, a = t.disallowedElements, i = t.skipHtml, o = t.unwrapDisallowed, l = t.urlTransform || Kf;
  for (const d of Vf)
    Object.hasOwn(t, d.from) && Uo(
      "Unexpected `" + d.from + "` prop, " + (d.to ? "use `" + d.to + "` instead" : "remove it") + " (see <" + qf + "#" + d.id + "> for more info)"
    );
  return Hn(e, c), jo(e, {
    Fragment: g.Fragment,
    components: u,
    ignoreInvalidStyle: !0,
    jsx: g.jsx,
    jsxs: g.jsxs,
    passKeys: !0,
    passNode: !0
  });
  function c(d, f, m) {
    if (d.type === "raw" && m && typeof f == "number")
      return i ? m.children.splice(f, 1) : m.children[f] = { type: "text", value: d.value }, f;
    if (d.type === "element") {
      let h;
      for (h in Zn)
        if (Object.hasOwn(Zn, h) && Object.hasOwn(d.properties, h)) {
          const b = d.properties[h], I = Zn[h];
          (I === null || I.includes(d.tagName)) && (d.properties[h] = l(String(b || ""), h, d));
        }
    }
    if (d.type === "element") {
      let h = n ? !n.includes(d.tagName) : a ? a.includes(d.tagName) : !1;
      if (!h && r && typeof f == "number" && (h = !r(d, f, m)), h && m && typeof f == "number")
        return o && d.children ? m.children.splice(f, 1, ...d.children) : m.children.splice(f, 1), f;
    }
  }
}
function Kf(e) {
  const t = e.indexOf(":"), n = e.indexOf("?"), r = e.indexOf("#"), u = e.indexOf("/");
  return (
    // If there is no protocol, it’s relative.
    t === -1 || // If the first colon is after a `?`, `#`, or `/`, it’s not a protocol.
    u !== -1 && t > u || n !== -1 && t > n || r !== -1 && t > r || // It is a protocol, it should be allowed.
    Yf.test(e.slice(0, t)) ? e : ""
  );
}
const ba = -1, Yn = 0, Ln = 1, Rn = 2, $r = 3, Kr = 4, Xr = 5, Zr = 6, Aa = 7, _a = 8, Gu = typeof self == "object" ? self : globalThis, Xf = (e, t) => {
  const n = (u, a) => (e.set(a, u), u), r = (u) => {
    if (e.has(u))
      return e.get(u);
    const [a, i] = t[u];
    switch (a) {
      case Yn:
      case ba:
        return n(i, u);
      case Ln: {
        const o = n([], u);
        for (const l of i)
          o.push(r(l));
        return o;
      }
      case Rn: {
        const o = n({}, u);
        for (const [l, c] of i)
          o[r(l)] = r(c);
        return o;
      }
      case $r:
        return n(new Date(i), u);
      case Kr: {
        const { source: o, flags: l } = i;
        return n(new RegExp(o, l), u);
      }
      case Xr: {
        const o = n(/* @__PURE__ */ new Map(), u);
        for (const [l, c] of i)
          o.set(r(l), r(c));
        return o;
      }
      case Zr: {
        const o = n(/* @__PURE__ */ new Set(), u);
        for (const l of i)
          o.add(r(l));
        return o;
      }
      case Aa: {
        const { name: o, message: l } = i;
        return n(new Gu[o](l), u);
      }
      case _a:
        return n(BigInt(i), u);
      case "BigInt":
        return n(Object(BigInt(i)), u);
    }
    return n(new Gu[a](i), u);
  };
  return r;
}, $u = (e) => Xf(/* @__PURE__ */ new Map(), e)(0), Tt = "", { toString: Zf } = {}, { keys: Jf } = Object, Ht = (e) => {
  const t = typeof e;
  if (t !== "object" || !e)
    return [Yn, t];
  const n = Zf.call(e).slice(8, -1);
  switch (n) {
    case "Array":
      return [Ln, Tt];
    case "Object":
      return [Rn, Tt];
    case "Date":
      return [$r, Tt];
    case "RegExp":
      return [Kr, Tt];
    case "Map":
      return [Xr, Tt];
    case "Set":
      return [Zr, Tt];
  }
  return n.includes("Array") ? [Ln, n] : n.includes("Error") ? [Aa, n] : [Rn, n];
}, hn = ([e, t]) => e === Yn && (t === "function" || t === "symbol"), ed = (e, t, n, r) => {
  const u = (i, o) => {
    const l = r.push(i) - 1;
    return n.set(o, l), l;
  }, a = (i) => {
    if (n.has(i))
      return n.get(i);
    let [o, l] = Ht(i);
    switch (o) {
      case Yn: {
        let d = i;
        switch (l) {
          case "bigint":
            o = _a, d = i.toString();
            break;
          case "function":
          case "symbol":
            if (e)
              throw new TypeError("unable to serialize " + l);
            d = null;
            break;
          case "undefined":
            return u([ba], i);
        }
        return u([o, d], i);
      }
      case Ln: {
        if (l)
          return u([l, [...i]], i);
        const d = [], f = u([o, d], i);
        for (const m of i)
          d.push(a(m));
        return f;
      }
      case Rn: {
        if (l)
          switch (l) {
            case "BigInt":
              return u([l, i.toString()], i);
            case "Boolean":
            case "Number":
            case "String":
              return u([l, i.valueOf()], i);
          }
        if (t && "toJSON" in i)
          return a(i.toJSON());
        const d = [], f = u([o, d], i);
        for (const m of Jf(i))
          (e || !hn(Ht(i[m]))) && d.push([a(m), a(i[m])]);
        return f;
      }
      case $r:
        return u([o, i.toISOString()], i);
      case Kr: {
        const { source: d, flags: f } = i;
        return u([o, { source: d, flags: f }], i);
      }
      case Xr: {
        const d = [], f = u([o, d], i);
        for (const [m, h] of i)
          (e || !(hn(Ht(m)) || hn(Ht(h)))) && d.push([a(m), a(h)]);
        return f;
      }
      case Zr: {
        const d = [], f = u([o, d], i);
        for (const m of i)
          (e || !hn(Ht(m))) && d.push(a(m));
        return f;
      }
    }
    const { message: c } = i;
    return u([o, { name: l, message: c }], i);
  };
  return a;
}, Ku = (e, { json: t, lossy: n } = {}) => {
  const r = [];
  return ed(!(t || n), !!t, /* @__PURE__ */ new Map(), r)(e), r;
}, Xu = typeof structuredClone == "function" ? (
  /* c8 ignore start */
  (e, t) => t && ("json" in t || "lossy" in t) ? $u(Ku(e, t)) : structuredClone(e)
) : (e, t) => $u(Ku(e, t));
class un {
  /**
   * @constructor
   * @param {Properties} property
   * @param {Normal} normal
   * @param {string} [space]
   */
  constructor(t, n, r) {
    this.property = t, this.normal = n, r && (this.space = r);
  }
}
un.prototype.property = {};
un.prototype.normal = {};
un.prototype.space = null;
function xa(e, t) {
  const n = {}, r = {};
  let u = -1;
  for (; ++u < e.length; )
    Object.assign(n, e[u].property), Object.assign(r, e[u].normal);
  return new un(n, r, t);
}
function Jt(e) {
  return e.toLowerCase();
}
class ye {
  /**
   * @constructor
   * @param {string} property
   * @param {string} attribute
   */
  constructor(t, n) {
    this.property = t, this.attribute = n;
  }
}
ye.prototype.space = null;
ye.prototype.boolean = !1;
ye.prototype.booleanish = !1;
ye.prototype.overloadedBoolean = !1;
ye.prototype.number = !1;
ye.prototype.commaSeparated = !1;
ye.prototype.spaceSeparated = !1;
ye.prototype.commaOrSpaceSeparated = !1;
ye.prototype.mustUseProperty = !1;
ye.prototype.defined = !1;
let td = 0;
const Y = ht(), oe = ht(), Ca = ht(), M = ht(), re = ht(), It = ht(), Ie = ht();
function ht() {
  return 2 ** ++td;
}
const Ir = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  boolean: Y,
  booleanish: oe,
  commaOrSpaceSeparated: Ie,
  commaSeparated: It,
  number: M,
  overloadedBoolean: Ca,
  spaceSeparated: re
}, Symbol.toStringTag, { value: "Module" })), lr = Object.keys(Ir);
class Jr extends ye {
  /**
   * @constructor
   * @param {string} property
   * @param {string} attribute
   * @param {number|null} [mask]
   * @param {string} [space]
   */
  constructor(t, n, r, u) {
    let a = -1;
    if (super(t, n), Zu(this, "space", u), typeof r == "number")
      for (; ++a < lr.length; ) {
        const i = lr[a];
        Zu(this, lr[a], (r & Ir[i]) === Ir[i]);
      }
  }
}
Jr.prototype.defined = !0;
function Zu(e, t, n) {
  n && (e[t] = n);
}
const nd = {}.hasOwnProperty;
function Ot(e) {
  const t = {}, n = {};
  let r;
  for (r in e.properties)
    if (nd.call(e.properties, r)) {
      const u = e.properties[r], a = new Jr(
        r,
        e.transform(e.attributes || {}, r),
        u,
        e.space
      );
      e.mustUseProperty && e.mustUseProperty.includes(r) && (a.mustUseProperty = !0), t[r] = a, n[Jt(r)] = r, n[Jt(a.attribute)] = r;
    }
  return new un(t, n, e.space);
}
const Ia = Ot({
  space: "xlink",
  transform(e, t) {
    return "xlink:" + t.slice(5).toLowerCase();
  },
  properties: {
    xLinkActuate: null,
    xLinkArcRole: null,
    xLinkHref: null,
    xLinkRole: null,
    xLinkShow: null,
    xLinkTitle: null,
    xLinkType: null
  }
}), Sa = Ot({
  space: "xml",
  transform(e, t) {
    return "xml:" + t.slice(3).toLowerCase();
  },
  properties: { xmlLang: null, xmlBase: null, xmlSpace: null }
});
function Na(e, t) {
  return t in e ? e[t] : t;
}
function ka(e, t) {
  return Na(e, t.toLowerCase());
}
const ya = Ot({
  space: "xmlns",
  attributes: { xmlnsxlink: "xmlns:xlink" },
  transform: ka,
  properties: { xmlns: null, xmlnsXLink: null }
}), Oa = Ot({
  transform(e, t) {
    return t === "role" ? t : "aria-" + t.slice(4).toLowerCase();
  },
  properties: {
    ariaActiveDescendant: null,
    ariaAtomic: oe,
    ariaAutoComplete: null,
    ariaBusy: oe,
    ariaChecked: oe,
    ariaColCount: M,
    ariaColIndex: M,
    ariaColSpan: M,
    ariaControls: re,
    ariaCurrent: null,
    ariaDescribedBy: re,
    ariaDetails: null,
    ariaDisabled: oe,
    ariaDropEffect: re,
    ariaErrorMessage: null,
    ariaExpanded: oe,
    ariaFlowTo: re,
    ariaGrabbed: oe,
    ariaHasPopup: null,
    ariaHidden: oe,
    ariaInvalid: null,
    ariaKeyShortcuts: null,
    ariaLabel: null,
    ariaLabelledBy: re,
    ariaLevel: M,
    ariaLive: null,
    ariaModal: oe,
    ariaMultiLine: oe,
    ariaMultiSelectable: oe,
    ariaOrientation: null,
    ariaOwns: re,
    ariaPlaceholder: null,
    ariaPosInSet: M,
    ariaPressed: oe,
    ariaReadOnly: oe,
    ariaRelevant: null,
    ariaRequired: oe,
    ariaRoleDescription: re,
    ariaRowCount: M,
    ariaRowIndex: M,
    ariaRowSpan: M,
    ariaSelected: oe,
    ariaSetSize: M,
    ariaSort: null,
    ariaValueMax: M,
    ariaValueMin: M,
    ariaValueNow: M,
    ariaValueText: null,
    role: null
  }
}), rd = Ot({
  space: "html",
  attributes: {
    acceptcharset: "accept-charset",
    classname: "class",
    htmlfor: "for",
    httpequiv: "http-equiv"
  },
  transform: ka,
  mustUseProperty: ["checked", "multiple", "muted", "selected"],
  properties: {
    // Standard Properties.
    abbr: null,
    accept: It,
    acceptCharset: re,
    accessKey: re,
    action: null,
    allow: null,
    allowFullScreen: Y,
    allowPaymentRequest: Y,
    allowUserMedia: Y,
    alt: null,
    as: null,
    async: Y,
    autoCapitalize: null,
    autoComplete: re,
    autoFocus: Y,
    autoPlay: Y,
    blocking: re,
    capture: null,
    charSet: null,
    checked: Y,
    cite: null,
    className: re,
    cols: M,
    colSpan: null,
    content: null,
    contentEditable: oe,
    controls: Y,
    controlsList: re,
    coords: M | It,
    crossOrigin: null,
    data: null,
    dateTime: null,
    decoding: null,
    default: Y,
    defer: Y,
    dir: null,
    dirName: null,
    disabled: Y,
    download: Ca,
    draggable: oe,
    encType: null,
    enterKeyHint: null,
    fetchPriority: null,
    form: null,
    formAction: null,
    formEncType: null,
    formMethod: null,
    formNoValidate: Y,
    formTarget: null,
    headers: re,
    height: M,
    hidden: Y,
    high: M,
    href: null,
    hrefLang: null,
    htmlFor: re,
    httpEquiv: re,
    id: null,
    imageSizes: null,
    imageSrcSet: null,
    inert: Y,
    inputMode: null,
    integrity: null,
    is: null,
    isMap: Y,
    itemId: null,
    itemProp: re,
    itemRef: re,
    itemScope: Y,
    itemType: re,
    kind: null,
    label: null,
    lang: null,
    language: null,
    list: null,
    loading: null,
    loop: Y,
    low: M,
    manifest: null,
    max: null,
    maxLength: M,
    media: null,
    method: null,
    min: null,
    minLength: M,
    multiple: Y,
    muted: Y,
    name: null,
    nonce: null,
    noModule: Y,
    noValidate: Y,
    onAbort: null,
    onAfterPrint: null,
    onAuxClick: null,
    onBeforeMatch: null,
    onBeforePrint: null,
    onBeforeToggle: null,
    onBeforeUnload: null,
    onBlur: null,
    onCancel: null,
    onCanPlay: null,
    onCanPlayThrough: null,
    onChange: null,
    onClick: null,
    onClose: null,
    onContextLost: null,
    onContextMenu: null,
    onContextRestored: null,
    onCopy: null,
    onCueChange: null,
    onCut: null,
    onDblClick: null,
    onDrag: null,
    onDragEnd: null,
    onDragEnter: null,
    onDragExit: null,
    onDragLeave: null,
    onDragOver: null,
    onDragStart: null,
    onDrop: null,
    onDurationChange: null,
    onEmptied: null,
    onEnded: null,
    onError: null,
    onFocus: null,
    onFormData: null,
    onHashChange: null,
    onInput: null,
    onInvalid: null,
    onKeyDown: null,
    onKeyPress: null,
    onKeyUp: null,
    onLanguageChange: null,
    onLoad: null,
    onLoadedData: null,
    onLoadedMetadata: null,
    onLoadEnd: null,
    onLoadStart: null,
    onMessage: null,
    onMessageError: null,
    onMouseDown: null,
    onMouseEnter: null,
    onMouseLeave: null,
    onMouseMove: null,
    onMouseOut: null,
    onMouseOver: null,
    onMouseUp: null,
    onOffline: null,
    onOnline: null,
    onPageHide: null,
    onPageShow: null,
    onPaste: null,
    onPause: null,
    onPlay: null,
    onPlaying: null,
    onPopState: null,
    onProgress: null,
    onRateChange: null,
    onRejectionHandled: null,
    onReset: null,
    onResize: null,
    onScroll: null,
    onScrollEnd: null,
    onSecurityPolicyViolation: null,
    onSeeked: null,
    onSeeking: null,
    onSelect: null,
    onSlotChange: null,
    onStalled: null,
    onStorage: null,
    onSubmit: null,
    onSuspend: null,
    onTimeUpdate: null,
    onToggle: null,
    onUnhandledRejection: null,
    onUnload: null,
    onVolumeChange: null,
    onWaiting: null,
    onWheel: null,
    open: Y,
    optimum: M,
    pattern: null,
    ping: re,
    placeholder: null,
    playsInline: Y,
    popover: null,
    popoverTarget: null,
    popoverTargetAction: null,
    poster: null,
    preload: null,
    readOnly: Y,
    referrerPolicy: null,
    rel: re,
    required: Y,
    reversed: Y,
    rows: M,
    rowSpan: M,
    sandbox: re,
    scope: null,
    scoped: Y,
    seamless: Y,
    selected: Y,
    shadowRootClonable: Y,
    shadowRootDelegatesFocus: Y,
    shadowRootMode: null,
    shape: null,
    size: M,
    sizes: null,
    slot: null,
    span: M,
    spellCheck: oe,
    src: null,
    srcDoc: null,
    srcLang: null,
    srcSet: null,
    start: M,
    step: null,
    style: null,
    tabIndex: M,
    target: null,
    title: null,
    translate: null,
    type: null,
    typeMustMatch: Y,
    useMap: null,
    value: oe,
    width: M,
    wrap: null,
    writingSuggestions: null,
    // Legacy.
    // See: https://html.spec.whatwg.org/#other-elements,-attributes-and-apis
    align: null,
    // Several. Use CSS `text-align` instead,
    aLink: null,
    // `<body>`. Use CSS `a:active {color}` instead
    archive: re,
    // `<object>`. List of URIs to archives
    axis: null,
    // `<td>` and `<th>`. Use `scope` on `<th>`
    background: null,
    // `<body>`. Use CSS `background-image` instead
    bgColor: null,
    // `<body>` and table elements. Use CSS `background-color` instead
    border: M,
    // `<table>`. Use CSS `border-width` instead,
    borderColor: null,
    // `<table>`. Use CSS `border-color` instead,
    bottomMargin: M,
    // `<body>`
    cellPadding: null,
    // `<table>`
    cellSpacing: null,
    // `<table>`
    char: null,
    // Several table elements. When `align=char`, sets the character to align on
    charOff: null,
    // Several table elements. When `char`, offsets the alignment
    classId: null,
    // `<object>`
    clear: null,
    // `<br>`. Use CSS `clear` instead
    code: null,
    // `<object>`
    codeBase: null,
    // `<object>`
    codeType: null,
    // `<object>`
    color: null,
    // `<font>` and `<hr>`. Use CSS instead
    compact: Y,
    // Lists. Use CSS to reduce space between items instead
    declare: Y,
    // `<object>`
    event: null,
    // `<script>`
    face: null,
    // `<font>`. Use CSS instead
    frame: null,
    // `<table>`
    frameBorder: null,
    // `<iframe>`. Use CSS `border` instead
    hSpace: M,
    // `<img>` and `<object>`
    leftMargin: M,
    // `<body>`
    link: null,
    // `<body>`. Use CSS `a:link {color: *}` instead
    longDesc: null,
    // `<frame>`, `<iframe>`, and `<img>`. Use an `<a>`
    lowSrc: null,
    // `<img>`. Use a `<picture>`
    marginHeight: M,
    // `<body>`
    marginWidth: M,
    // `<body>`
    noResize: Y,
    // `<frame>`
    noHref: Y,
    // `<area>`. Use no href instead of an explicit `nohref`
    noShade: Y,
    // `<hr>`. Use background-color and height instead of borders
    noWrap: Y,
    // `<td>` and `<th>`
    object: null,
    // `<applet>`
    profile: null,
    // `<head>`
    prompt: null,
    // `<isindex>`
    rev: null,
    // `<link>`
    rightMargin: M,
    // `<body>`
    rules: null,
    // `<table>`
    scheme: null,
    // `<meta>`
    scrolling: oe,
    // `<frame>`. Use overflow in the child context
    standby: null,
    // `<object>`
    summary: null,
    // `<table>`
    text: null,
    // `<body>`. Use CSS `color` instead
    topMargin: M,
    // `<body>`
    valueType: null,
    // `<param>`
    version: null,
    // `<html>`. Use a doctype.
    vAlign: null,
    // Several. Use CSS `vertical-align` instead
    vLink: null,
    // `<body>`. Use CSS `a:visited {color}` instead
    vSpace: M,
    // `<img>` and `<object>`
    // Non-standard Properties.
    allowTransparency: null,
    autoCorrect: null,
    autoSave: null,
    disablePictureInPicture: Y,
    disableRemotePlayback: Y,
    prefix: null,
    property: null,
    results: M,
    security: null,
    unselectable: null
  }
}), ud = Ot({
  space: "svg",
  attributes: {
    accentHeight: "accent-height",
    alignmentBaseline: "alignment-baseline",
    arabicForm: "arabic-form",
    baselineShift: "baseline-shift",
    capHeight: "cap-height",
    className: "class",
    clipPath: "clip-path",
    clipRule: "clip-rule",
    colorInterpolation: "color-interpolation",
    colorInterpolationFilters: "color-interpolation-filters",
    colorProfile: "color-profile",
    colorRendering: "color-rendering",
    crossOrigin: "crossorigin",
    dataType: "datatype",
    dominantBaseline: "dominant-baseline",
    enableBackground: "enable-background",
    fillOpacity: "fill-opacity",
    fillRule: "fill-rule",
    floodColor: "flood-color",
    floodOpacity: "flood-opacity",
    fontFamily: "font-family",
    fontSize: "font-size",
    fontSizeAdjust: "font-size-adjust",
    fontStretch: "font-stretch",
    fontStyle: "font-style",
    fontVariant: "font-variant",
    fontWeight: "font-weight",
    glyphName: "glyph-name",
    glyphOrientationHorizontal: "glyph-orientation-horizontal",
    glyphOrientationVertical: "glyph-orientation-vertical",
    hrefLang: "hreflang",
    horizAdvX: "horiz-adv-x",
    horizOriginX: "horiz-origin-x",
    horizOriginY: "horiz-origin-y",
    imageRendering: "image-rendering",
    letterSpacing: "letter-spacing",
    lightingColor: "lighting-color",
    markerEnd: "marker-end",
    markerMid: "marker-mid",
    markerStart: "marker-start",
    navDown: "nav-down",
    navDownLeft: "nav-down-left",
    navDownRight: "nav-down-right",
    navLeft: "nav-left",
    navNext: "nav-next",
    navPrev: "nav-prev",
    navRight: "nav-right",
    navUp: "nav-up",
    navUpLeft: "nav-up-left",
    navUpRight: "nav-up-right",
    onAbort: "onabort",
    onActivate: "onactivate",
    onAfterPrint: "onafterprint",
    onBeforePrint: "onbeforeprint",
    onBegin: "onbegin",
    onCancel: "oncancel",
    onCanPlay: "oncanplay",
    onCanPlayThrough: "oncanplaythrough",
    onChange: "onchange",
    onClick: "onclick",
    onClose: "onclose",
    onCopy: "oncopy",
    onCueChange: "oncuechange",
    onCut: "oncut",
    onDblClick: "ondblclick",
    onDrag: "ondrag",
    onDragEnd: "ondragend",
    onDragEnter: "ondragenter",
    onDragExit: "ondragexit",
    onDragLeave: "ondragleave",
    onDragOver: "ondragover",
    onDragStart: "ondragstart",
    onDrop: "ondrop",
    onDurationChange: "ondurationchange",
    onEmptied: "onemptied",
    onEnd: "onend",
    onEnded: "onended",
    onError: "onerror",
    onFocus: "onfocus",
    onFocusIn: "onfocusin",
    onFocusOut: "onfocusout",
    onHashChange: "onhashchange",
    onInput: "oninput",
    onInvalid: "oninvalid",
    onKeyDown: "onkeydown",
    onKeyPress: "onkeypress",
    onKeyUp: "onkeyup",
    onLoad: "onload",
    onLoadedData: "onloadeddata",
    onLoadedMetadata: "onloadedmetadata",
    onLoadStart: "onloadstart",
    onMessage: "onmessage",
    onMouseDown: "onmousedown",
    onMouseEnter: "onmouseenter",
    onMouseLeave: "onmouseleave",
    onMouseMove: "onmousemove",
    onMouseOut: "onmouseout",
    onMouseOver: "onmouseover",
    onMouseUp: "onmouseup",
    onMouseWheel: "onmousewheel",
    onOffline: "onoffline",
    onOnline: "ononline",
    onPageHide: "onpagehide",
    onPageShow: "onpageshow",
    onPaste: "onpaste",
    onPause: "onpause",
    onPlay: "onplay",
    onPlaying: "onplaying",
    onPopState: "onpopstate",
    onProgress: "onprogress",
    onRateChange: "onratechange",
    onRepeat: "onrepeat",
    onReset: "onreset",
    onResize: "onresize",
    onScroll: "onscroll",
    onSeeked: "onseeked",
    onSeeking: "onseeking",
    onSelect: "onselect",
    onShow: "onshow",
    onStalled: "onstalled",
    onStorage: "onstorage",
    onSubmit: "onsubmit",
    onSuspend: "onsuspend",
    onTimeUpdate: "ontimeupdate",
    onToggle: "ontoggle",
    onUnload: "onunload",
    onVolumeChange: "onvolumechange",
    onWaiting: "onwaiting",
    onZoom: "onzoom",
    overlinePosition: "overline-position",
    overlineThickness: "overline-thickness",
    paintOrder: "paint-order",
    panose1: "panose-1",
    pointerEvents: "pointer-events",
    referrerPolicy: "referrerpolicy",
    renderingIntent: "rendering-intent",
    shapeRendering: "shape-rendering",
    stopColor: "stop-color",
    stopOpacity: "stop-opacity",
    strikethroughPosition: "strikethrough-position",
    strikethroughThickness: "strikethrough-thickness",
    strokeDashArray: "stroke-dasharray",
    strokeDashOffset: "stroke-dashoffset",
    strokeLineCap: "stroke-linecap",
    strokeLineJoin: "stroke-linejoin",
    strokeMiterLimit: "stroke-miterlimit",
    strokeOpacity: "stroke-opacity",
    strokeWidth: "stroke-width",
    tabIndex: "tabindex",
    textAnchor: "text-anchor",
    textDecoration: "text-decoration",
    textRendering: "text-rendering",
    transformOrigin: "transform-origin",
    typeOf: "typeof",
    underlinePosition: "underline-position",
    underlineThickness: "underline-thickness",
    unicodeBidi: "unicode-bidi",
    unicodeRange: "unicode-range",
    unitsPerEm: "units-per-em",
    vAlphabetic: "v-alphabetic",
    vHanging: "v-hanging",
    vIdeographic: "v-ideographic",
    vMathematical: "v-mathematical",
    vectorEffect: "vector-effect",
    vertAdvY: "vert-adv-y",
    vertOriginX: "vert-origin-x",
    vertOriginY: "vert-origin-y",
    wordSpacing: "word-spacing",
    writingMode: "writing-mode",
    xHeight: "x-height",
    // These were camelcased in Tiny. Now lowercased in SVG 2
    playbackOrder: "playbackorder",
    timelineBegin: "timelinebegin"
  },
  transform: Na,
  properties: {
    about: Ie,
    accentHeight: M,
    accumulate: null,
    additive: null,
    alignmentBaseline: null,
    alphabetic: M,
    amplitude: M,
    arabicForm: null,
    ascent: M,
    attributeName: null,
    attributeType: null,
    azimuth: M,
    bandwidth: null,
    baselineShift: null,
    baseFrequency: null,
    baseProfile: null,
    bbox: null,
    begin: null,
    bias: M,
    by: null,
    calcMode: null,
    capHeight: M,
    className: re,
    clip: null,
    clipPath: null,
    clipPathUnits: null,
    clipRule: null,
    color: null,
    colorInterpolation: null,
    colorInterpolationFilters: null,
    colorProfile: null,
    colorRendering: null,
    content: null,
    contentScriptType: null,
    contentStyleType: null,
    crossOrigin: null,
    cursor: null,
    cx: null,
    cy: null,
    d: null,
    dataType: null,
    defaultAction: null,
    descent: M,
    diffuseConstant: M,
    direction: null,
    display: null,
    dur: null,
    divisor: M,
    dominantBaseline: null,
    download: Y,
    dx: null,
    dy: null,
    edgeMode: null,
    editable: null,
    elevation: M,
    enableBackground: null,
    end: null,
    event: null,
    exponent: M,
    externalResourcesRequired: null,
    fill: null,
    fillOpacity: M,
    fillRule: null,
    filter: null,
    filterRes: null,
    filterUnits: null,
    floodColor: null,
    floodOpacity: null,
    focusable: null,
    focusHighlight: null,
    fontFamily: null,
    fontSize: null,
    fontSizeAdjust: null,
    fontStretch: null,
    fontStyle: null,
    fontVariant: null,
    fontWeight: null,
    format: null,
    fr: null,
    from: null,
    fx: null,
    fy: null,
    g1: It,
    g2: It,
    glyphName: It,
    glyphOrientationHorizontal: null,
    glyphOrientationVertical: null,
    glyphRef: null,
    gradientTransform: null,
    gradientUnits: null,
    handler: null,
    hanging: M,
    hatchContentUnits: null,
    hatchUnits: null,
    height: null,
    href: null,
    hrefLang: null,
    horizAdvX: M,
    horizOriginX: M,
    horizOriginY: M,
    id: null,
    ideographic: M,
    imageRendering: null,
    initialVisibility: null,
    in: null,
    in2: null,
    intercept: M,
    k: M,
    k1: M,
    k2: M,
    k3: M,
    k4: M,
    kernelMatrix: Ie,
    kernelUnitLength: null,
    keyPoints: null,
    // SEMI_COLON_SEPARATED
    keySplines: null,
    // SEMI_COLON_SEPARATED
    keyTimes: null,
    // SEMI_COLON_SEPARATED
    kerning: null,
    lang: null,
    lengthAdjust: null,
    letterSpacing: null,
    lightingColor: null,
    limitingConeAngle: M,
    local: null,
    markerEnd: null,
    markerMid: null,
    markerStart: null,
    markerHeight: null,
    markerUnits: null,
    markerWidth: null,
    mask: null,
    maskContentUnits: null,
    maskUnits: null,
    mathematical: null,
    max: null,
    media: null,
    mediaCharacterEncoding: null,
    mediaContentEncodings: null,
    mediaSize: M,
    mediaTime: null,
    method: null,
    min: null,
    mode: null,
    name: null,
    navDown: null,
    navDownLeft: null,
    navDownRight: null,
    navLeft: null,
    navNext: null,
    navPrev: null,
    navRight: null,
    navUp: null,
    navUpLeft: null,
    navUpRight: null,
    numOctaves: null,
    observer: null,
    offset: null,
    onAbort: null,
    onActivate: null,
    onAfterPrint: null,
    onBeforePrint: null,
    onBegin: null,
    onCancel: null,
    onCanPlay: null,
    onCanPlayThrough: null,
    onChange: null,
    onClick: null,
    onClose: null,
    onCopy: null,
    onCueChange: null,
    onCut: null,
    onDblClick: null,
    onDrag: null,
    onDragEnd: null,
    onDragEnter: null,
    onDragExit: null,
    onDragLeave: null,
    onDragOver: null,
    onDragStart: null,
    onDrop: null,
    onDurationChange: null,
    onEmptied: null,
    onEnd: null,
    onEnded: null,
    onError: null,
    onFocus: null,
    onFocusIn: null,
    onFocusOut: null,
    onHashChange: null,
    onInput: null,
    onInvalid: null,
    onKeyDown: null,
    onKeyPress: null,
    onKeyUp: null,
    onLoad: null,
    onLoadedData: null,
    onLoadedMetadata: null,
    onLoadStart: null,
    onMessage: null,
    onMouseDown: null,
    onMouseEnter: null,
    onMouseLeave: null,
    onMouseMove: null,
    onMouseOut: null,
    onMouseOver: null,
    onMouseUp: null,
    onMouseWheel: null,
    onOffline: null,
    onOnline: null,
    onPageHide: null,
    onPageShow: null,
    onPaste: null,
    onPause: null,
    onPlay: null,
    onPlaying: null,
    onPopState: null,
    onProgress: null,
    onRateChange: null,
    onRepeat: null,
    onReset: null,
    onResize: null,
    onScroll: null,
    onSeeked: null,
    onSeeking: null,
    onSelect: null,
    onShow: null,
    onStalled: null,
    onStorage: null,
    onSubmit: null,
    onSuspend: null,
    onTimeUpdate: null,
    onToggle: null,
    onUnload: null,
    onVolumeChange: null,
    onWaiting: null,
    onZoom: null,
    opacity: null,
    operator: null,
    order: null,
    orient: null,
    orientation: null,
    origin: null,
    overflow: null,
    overlay: null,
    overlinePosition: M,
    overlineThickness: M,
    paintOrder: null,
    panose1: null,
    path: null,
    pathLength: M,
    patternContentUnits: null,
    patternTransform: null,
    patternUnits: null,
    phase: null,
    ping: re,
    pitch: null,
    playbackOrder: null,
    pointerEvents: null,
    points: null,
    pointsAtX: M,
    pointsAtY: M,
    pointsAtZ: M,
    preserveAlpha: null,
    preserveAspectRatio: null,
    primitiveUnits: null,
    propagate: null,
    property: Ie,
    r: null,
    radius: null,
    referrerPolicy: null,
    refX: null,
    refY: null,
    rel: Ie,
    rev: Ie,
    renderingIntent: null,
    repeatCount: null,
    repeatDur: null,
    requiredExtensions: Ie,
    requiredFeatures: Ie,
    requiredFonts: Ie,
    requiredFormats: Ie,
    resource: null,
    restart: null,
    result: null,
    rotate: null,
    rx: null,
    ry: null,
    scale: null,
    seed: null,
    shapeRendering: null,
    side: null,
    slope: null,
    snapshotTime: null,
    specularConstant: M,
    specularExponent: M,
    spreadMethod: null,
    spacing: null,
    startOffset: null,
    stdDeviation: null,
    stemh: null,
    stemv: null,
    stitchTiles: null,
    stopColor: null,
    stopOpacity: null,
    strikethroughPosition: M,
    strikethroughThickness: M,
    string: null,
    stroke: null,
    strokeDashArray: Ie,
    strokeDashOffset: null,
    strokeLineCap: null,
    strokeLineJoin: null,
    strokeMiterLimit: M,
    strokeOpacity: M,
    strokeWidth: null,
    style: null,
    surfaceScale: M,
    syncBehavior: null,
    syncBehaviorDefault: null,
    syncMaster: null,
    syncTolerance: null,
    syncToleranceDefault: null,
    systemLanguage: Ie,
    tabIndex: M,
    tableValues: null,
    target: null,
    targetX: M,
    targetY: M,
    textAnchor: null,
    textDecoration: null,
    textRendering: null,
    textLength: null,
    timelineBegin: null,
    title: null,
    transformBehavior: null,
    type: null,
    typeOf: Ie,
    to: null,
    transform: null,
    transformOrigin: null,
    u1: null,
    u2: null,
    underlinePosition: M,
    underlineThickness: M,
    unicode: null,
    unicodeBidi: null,
    unicodeRange: null,
    unitsPerEm: M,
    values: null,
    vAlphabetic: M,
    vMathematical: M,
    vectorEffect: null,
    vHanging: M,
    vIdeographic: M,
    version: null,
    vertAdvY: M,
    vertOriginX: M,
    vertOriginY: M,
    viewBox: null,
    viewTarget: null,
    visibility: null,
    width: null,
    widths: null,
    wordSpacing: null,
    writingMode: null,
    x: null,
    x1: null,
    x2: null,
    xChannelSelector: null,
    xHeight: M,
    y: null,
    y1: null,
    y2: null,
    yChannelSelector: null,
    z: null,
    zoomAndPan: null
  }
}), id = /^data[-\w.:]+$/i, Ju = /-[a-z]/g, ad = /[A-Z]/g;
function eu(e, t) {
  const n = Jt(t);
  let r = t, u = ye;
  if (n in e.normal)
    return e.property[e.normal[n]];
  if (n.length > 4 && n.slice(0, 4) === "data" && id.test(t)) {
    if (t.charAt(4) === "-") {
      const a = t.slice(5).replace(Ju, od);
      r = "data" + a.charAt(0).toUpperCase() + a.slice(1);
    } else {
      const a = t.slice(4);
      if (!Ju.test(a)) {
        let i = a.replace(ad, sd);
        i.charAt(0) !== "-" && (i = "-" + i), t = "data" + i;
      }
    }
    u = Jr;
  }
  return new u(r, t);
}
function sd(e) {
  return "-" + e.toLowerCase();
}
function od(e) {
  return e.charAt(1).toUpperCase();
}
const Vn = xa([Sa, Ia, ya, Oa, rd], "html"), an = xa([Sa, Ia, ya, Oa, ud], "svg"), ei = /[#.]/g;
function ld(e, t) {
  const n = e || "", r = {};
  let u = 0, a, i;
  for (; u < n.length; ) {
    ei.lastIndex = u;
    const o = ei.exec(n), l = n.slice(u, o ? o.index : n.length);
    l && (a ? a === "#" ? r.id = l : Array.isArray(r.className) ? r.className.push(l) : r.className = [l] : i = l, u += l.length), o && (a = o[0], u++);
  }
  return {
    type: "element",
    // @ts-expect-error: tag name is parsed.
    tagName: i || t || "div",
    properties: r,
    children: []
  };
}
const Sr = {}.hasOwnProperty;
function La(e, t, n) {
  const r = n && hd(n);
  function u(a, i, ...o) {
    let l = -1, c;
    if (a == null) {
      c = { type: "root", children: [] };
      const d = (
        /** @type {Child} */
        i
      );
      o.unshift(d);
    } else if (c = ld(a, t), c.tagName = c.tagName.toLowerCase(), r && Sr.call(r, c.tagName) && (c.tagName = r[c.tagName]), cd(i))
      o.unshift(i);
    else {
      let d;
      for (d in i)
        Sr.call(i, d) && fd(e, c.properties, d, i[d]);
    }
    for (; ++l < o.length; )
      Nr(c.children, o[l]);
    return c.type === "element" && c.tagName === "template" && (c.content = { type: "root", children: c.children }, c.children = []), c;
  }
  return u;
}
function cd(e) {
  if (e === null || typeof e != "object" || Array.isArray(e))
    return !0;
  if (typeof e.type != "string") return !1;
  const t = (
    /** @type {Record<string, unknown>} */
    e
  ), n = Object.keys(e);
  for (const r of n) {
    const u = t[r];
    if (u && typeof u == "object") {
      if (!Array.isArray(u)) return !0;
      const a = (
        /** @type {Array<unknown>} */
        u
      );
      for (const i of a)
        if (typeof i != "number" && typeof i != "string")
          return !0;
    }
  }
  return !!("children" in e && Array.isArray(e.children));
}
function fd(e, t, n, r) {
  const u = eu(e, n);
  let a = -1, i;
  if (r != null) {
    if (typeof r == "number") {
      if (Number.isNaN(r)) return;
      i = r;
    } else typeof r == "boolean" ? i = r : typeof r == "string" ? u.spaceSeparated ? i = Tu(r) : u.commaSeparated ? i = bu(r) : u.commaOrSpaceSeparated ? i = Tu(bu(r).join(" ")) : i = ti(u, u.property, r) : Array.isArray(r) ? i = r.concat() : i = u.property === "style" ? dd(r) : String(r);
    if (Array.isArray(i)) {
      const o = [];
      for (; ++a < i.length; ) {
        const l = (
          /** @type {number | string} */
          ti(u, u.property, i[a])
        );
        o[a] = l;
      }
      i = o;
    }
    if (u.property === "className" && Array.isArray(t.className)) {
      const o = (
        /** @type {number | string} */
        i
      );
      i = t.className.concat(o);
    }
    t[u.property] = i;
  }
}
function Nr(e, t) {
  let n = -1;
  if (t != null) if (typeof t == "string" || typeof t == "number")
    e.push({ type: "text", value: String(t) });
  else if (Array.isArray(t))
    for (; ++n < t.length; )
      Nr(e, t[n]);
  else if (typeof t == "object" && "type" in t)
    t.type === "root" ? Nr(e, t.children) : e.push(t);
  else
    throw new Error("Expected node, nodes, or string, got `" + t + "`");
}
function ti(e, t, n) {
  if (typeof n == "string") {
    if (e.number && n && !Number.isNaN(Number(n)))
      return Number(n);
    if ((e.boolean || e.overloadedBoolean) && (n === "" || Jt(n) === Jt(t)))
      return !0;
  }
  return n;
}
function dd(e) {
  const t = [];
  let n;
  for (n in e)
    Sr.call(e, n) && t.push([n, e[n]].join(": "));
  return t.join("; ");
}
function hd(e) {
  const t = {};
  let n = -1;
  for (; ++n < e.length; )
    t[e[n].toLowerCase()] = e[n];
  return t;
}
const md = [
  "altGlyph",
  "altGlyphDef",
  "altGlyphItem",
  "animateColor",
  "animateMotion",
  "animateTransform",
  "clipPath",
  "feBlend",
  "feColorMatrix",
  "feComponentTransfer",
  "feComposite",
  "feConvolveMatrix",
  "feDiffuseLighting",
  "feDisplacementMap",
  "feDistantLight",
  "feDropShadow",
  "feFlood",
  "feFuncA",
  "feFuncB",
  "feFuncG",
  "feFuncR",
  "feGaussianBlur",
  "feImage",
  "feMerge",
  "feMergeNode",
  "feMorphology",
  "feOffset",
  "fePointLight",
  "feSpecularLighting",
  "feSpotLight",
  "feTile",
  "feTurbulence",
  "foreignObject",
  "glyphRef",
  "linearGradient",
  "radialGradient",
  "solidColor",
  "textArea",
  "textPath"
], pd = La(Vn, "div"), Ed = La(an, "g", md);
function gd(e) {
  const t = String(e), n = [];
  return { toOffset: u, toPoint: r };
  function r(a) {
    if (typeof a == "number" && a > -1 && a <= t.length) {
      let i = 0;
      for (; ; ) {
        let o = n[i];
        if (o === void 0) {
          const l = ni(t, n[i - 1]);
          o = l === -1 ? t.length + 1 : l + 1, n[i] = o;
        }
        if (o > a)
          return {
            line: i + 1,
            column: a - (i > 0 ? n[i - 1] : 0) + 1,
            offset: a
          };
        i++;
      }
    }
  }
  function u(a) {
    if (a && typeof a.line == "number" && typeof a.column == "number" && !Number.isNaN(a.line) && !Number.isNaN(a.column)) {
      for (; n.length < a.line; ) {
        const o = n[n.length - 1], l = ni(t, o), c = l === -1 ? t.length + 1 : l + 1;
        if (o === c) break;
        n.push(c);
      }
      const i = (a.line > 1 ? n[a.line - 2] : 0) + a.column - 1;
      if (i < n[a.line - 1]) return i;
    }
  }
}
function ni(e, t) {
  const n = e.indexOf("\r", t), r = e.indexOf(`
`, t);
  return r === -1 ? n : n === -1 || n + 1 === r ? r : n < r ? n : r;
}
const lt = {
  html: "http://www.w3.org/1999/xhtml",
  mathml: "http://www.w3.org/1998/Math/MathML",
  svg: "http://www.w3.org/2000/svg",
  xlink: "http://www.w3.org/1999/xlink",
  xml: "http://www.w3.org/XML/1998/namespace",
  xmlns: "http://www.w3.org/2000/xmlns/"
}, Ra = {}.hasOwnProperty, Td = Object.prototype;
function bd(e, t) {
  const n = t || {};
  return tu(
    {
      file: n.file || void 0,
      location: !1,
      schema: n.space === "svg" ? an : Vn,
      verbose: n.verbose || !1
    },
    e
  );
}
function tu(e, t) {
  let n;
  switch (t.nodeName) {
    case "#comment": {
      const r = (
        /** @type {DefaultTreeAdapterMap['commentNode']} */
        t
      );
      return n = { type: "comment", value: r.data }, xn(e, r, n), n;
    }
    case "#document":
    case "#document-fragment": {
      const r = (
        /** @type {DefaultTreeAdapterMap['document'] | DefaultTreeAdapterMap['documentFragment']} */
        t
      ), u = "mode" in r ? r.mode === "quirks" || r.mode === "limited-quirks" : !1;
      if (n = {
        type: "root",
        children: Da(e, t.childNodes),
        data: { quirksMode: u }
      }, e.file && e.location) {
        const a = String(e.file), i = gd(a), o = i.toPoint(0), l = i.toPoint(a.length);
        n.position = { start: o, end: l };
      }
      return n;
    }
    case "#documentType": {
      const r = (
        /** @type {DefaultTreeAdapterMap['documentType']} */
        t
      );
      return n = { type: "doctype" }, xn(e, r, n), n;
    }
    case "#text": {
      const r = (
        /** @type {DefaultTreeAdapterMap['textNode']} */
        t
      );
      return n = { type: "text", value: r.value }, xn(e, r, n), n;
    }
    // Element.
    default:
      return n = Ad(
        e,
        /** @type {DefaultTreeAdapterMap['element']} */
        t
      ), n;
  }
}
function Da(e, t) {
  let n = -1;
  const r = [];
  for (; ++n < t.length; ) {
    const u = (
      /** @type {RootContent} */
      tu(e, t[n])
    );
    r.push(u);
  }
  return r;
}
function Ad(e, t) {
  const n = e.schema;
  e.schema = t.namespaceURI === lt.svg ? an : Vn;
  let r = -1;
  const u = {};
  for (; ++r < t.attrs.length; ) {
    const o = t.attrs[r], l = (o.prefix ? o.prefix + ":" : "") + o.name;
    Ra.call(Td, l) || (u[l] = o.value);
  }
  const i = (e.schema.space === "svg" ? Ed : pd)(t.tagName, u, Da(e, t.childNodes));
  if (xn(e, t, i), i.tagName === "template") {
    const o = (
      /** @type {DefaultTreeAdapterMap['template']} */
      t
    ), l = o.sourceCodeLocation, c = l && l.startTag && At(l.startTag), d = l && l.endTag && At(l.endTag), f = (
      /** @type {Root} */
      tu(e, o.content)
    );
    c && d && e.file && (f.position = { start: c.end, end: d.start }), i.content = f;
  }
  return e.schema = n, i;
}
function xn(e, t, n) {
  if ("sourceCodeLocation" in t && t.sourceCodeLocation && e.file) {
    const r = _d(e, n, t.sourceCodeLocation);
    r && (e.location = !0, n.position = r);
  }
}
function _d(e, t, n) {
  const r = At(n);
  if (t.type === "element") {
    const u = t.children[t.children.length - 1];
    if (r && !n.endTag && u && u.position && u.position.end && (r.end = Object.assign({}, u.position.end)), e.verbose) {
      const a = {};
      let i;
      if (n.attrs)
        for (i in n.attrs)
          Ra.call(n.attrs, i) && (a[eu(e.schema, i).property] = At(
            n.attrs[i]
          ));
      Ve(n.startTag);
      const o = At(n.startTag), l = n.endTag ? At(n.endTag) : void 0, c = { opening: o };
      l && (c.closing = l), c.properties = a, t.data = { position: c };
    }
  }
  return r;
}
function At(e) {
  const t = ri({
    line: e.startLine,
    column: e.startCol,
    offset: e.startOffset
  }), n = ri({
    line: e.endLine,
    column: e.endCol,
    offset: e.endOffset
  });
  return t || n ? { start: t, end: n } : void 0;
}
function ri(e) {
  return e.line && e.column ? e : void 0;
}
const xd = {}, Cd = {}.hasOwnProperty, Pa = Gi("type", { handlers: { root: Sd, element: Ld, text: yd, comment: Od, doctype: kd } });
function Id(e, t) {
  const r = (t || xd).space;
  return Pa(e, r === "svg" ? an : Vn);
}
function Sd(e, t) {
  const n = {
    nodeName: "#document",
    // @ts-expect-error: `parse5` uses enums, which are actually strings.
    mode: (e.data || {}).quirksMode ? "quirks" : "no-quirks",
    childNodes: []
  };
  return n.childNodes = nu(e.children, n, t), Lt(e, n), n;
}
function Nd(e, t) {
  const n = { nodeName: "#document-fragment", childNodes: [] };
  return n.childNodes = nu(e.children, n, t), Lt(e, n), n;
}
function kd(e) {
  const t = {
    nodeName: "#documentType",
    name: "html",
    publicId: "",
    systemId: "",
    parentNode: null
  };
  return Lt(e, t), t;
}
function yd(e) {
  const t = {
    nodeName: "#text",
    value: e.value,
    parentNode: null
  };
  return Lt(e, t), t;
}
function Od(e) {
  const t = {
    nodeName: "#comment",
    data: e.value,
    parentNode: null
  };
  return Lt(e, t), t;
}
function Ld(e, t) {
  const n = t;
  let r = n;
  e.type === "element" && e.tagName.toLowerCase() === "svg" && n.space === "html" && (r = an);
  const u = [];
  let a;
  if (e.properties) {
    for (a in e.properties)
      if (a !== "children" && Cd.call(e.properties, a)) {
        const l = Rd(
          r,
          a,
          e.properties[a]
        );
        l && u.push(l);
      }
  }
  const i = r.space, o = {
    nodeName: e.tagName,
    tagName: e.tagName,
    attrs: u,
    // @ts-expect-error: `parse5` types are wrong.
    namespaceURI: lt[i],
    childNodes: [],
    parentNode: null
  };
  return o.childNodes = nu(e.children, o, r), Lt(e, o), e.tagName === "template" && e.content && (o.content = Nd(e.content, r)), o;
}
function Rd(e, t, n) {
  const r = eu(e, t);
  if (n === !1 || n === null || n === void 0 || typeof n == "number" && Number.isNaN(n) || !n && r.boolean)
    return;
  Array.isArray(n) && (n = r.commaSeparated ? zo(n) : qo(n));
  const u = {
    name: r.attribute,
    value: n === !0 ? "" : String(n)
  };
  if (r.space && r.space !== "html" && r.space !== "svg") {
    const a = u.name.indexOf(":");
    a < 0 ? u.prefix = "" : (u.name = u.name.slice(a + 1), u.prefix = r.attribute.slice(0, a)), u.namespace = lt[r.space];
  }
  return u;
}
function nu(e, t, n) {
  let r = -1;
  const u = [];
  if (e)
    for (; ++r < e.length; ) {
      const a = Pa(e[r], n);
      a.parentNode = t, u.push(a);
    }
  return u;
}
function Lt(e, t) {
  const n = e.position;
  n && n.start && n.end && (Ve(typeof n.start.offset == "number"), Ve(typeof n.end.offset == "number"), t.sourceCodeLocation = {
    startLine: n.start.line,
    startCol: n.start.column,
    startOffset: n.start.offset,
    endLine: n.end.line,
    endCol: n.end.column,
    endOffset: n.end.offset
  });
}
const Dd = /* @__PURE__ */ new Set([
  65534,
  65535,
  131070,
  131071,
  196606,
  196607,
  262142,
  262143,
  327678,
  327679,
  393214,
  393215,
  458750,
  458751,
  524286,
  524287,
  589822,
  589823,
  655358,
  655359,
  720894,
  720895,
  786430,
  786431,
  851966,
  851967,
  917502,
  917503,
  983038,
  983039,
  1048574,
  1048575,
  1114110,
  1114111
]), ae = "�";
var p;
(function(e) {
  e[e.EOF = -1] = "EOF", e[e.NULL = 0] = "NULL", e[e.TABULATION = 9] = "TABULATION", e[e.CARRIAGE_RETURN = 13] = "CARRIAGE_RETURN", e[e.LINE_FEED = 10] = "LINE_FEED", e[e.FORM_FEED = 12] = "FORM_FEED", e[e.SPACE = 32] = "SPACE", e[e.EXCLAMATION_MARK = 33] = "EXCLAMATION_MARK", e[e.QUOTATION_MARK = 34] = "QUOTATION_MARK", e[e.AMPERSAND = 38] = "AMPERSAND", e[e.APOSTROPHE = 39] = "APOSTROPHE", e[e.HYPHEN_MINUS = 45] = "HYPHEN_MINUS", e[e.SOLIDUS = 47] = "SOLIDUS", e[e.DIGIT_0 = 48] = "DIGIT_0", e[e.DIGIT_9 = 57] = "DIGIT_9", e[e.SEMICOLON = 59] = "SEMICOLON", e[e.LESS_THAN_SIGN = 60] = "LESS_THAN_SIGN", e[e.EQUALS_SIGN = 61] = "EQUALS_SIGN", e[e.GREATER_THAN_SIGN = 62] = "GREATER_THAN_SIGN", e[e.QUESTION_MARK = 63] = "QUESTION_MARK", e[e.LATIN_CAPITAL_A = 65] = "LATIN_CAPITAL_A", e[e.LATIN_CAPITAL_Z = 90] = "LATIN_CAPITAL_Z", e[e.RIGHT_SQUARE_BRACKET = 93] = "RIGHT_SQUARE_BRACKET", e[e.GRAVE_ACCENT = 96] = "GRAVE_ACCENT", e[e.LATIN_SMALL_A = 97] = "LATIN_SMALL_A", e[e.LATIN_SMALL_Z = 122] = "LATIN_SMALL_Z";
})(p || (p = {}));
const be = {
  DASH_DASH: "--",
  CDATA_START: "[CDATA[",
  DOCTYPE: "doctype",
  SCRIPT: "script",
  PUBLIC: "public",
  SYSTEM: "system"
};
function wa(e) {
  return e >= 55296 && e <= 57343;
}
function Pd(e) {
  return e >= 56320 && e <= 57343;
}
function wd(e, t) {
  return (e - 55296) * 1024 + 9216 + t;
}
function Ma(e) {
  return e !== 32 && e !== 10 && e !== 13 && e !== 9 && e !== 12 && e >= 1 && e <= 31 || e >= 127 && e <= 159;
}
function Ba(e) {
  return e >= 64976 && e <= 65007 || Dd.has(e);
}
var k;
(function(e) {
  e.controlCharacterInInputStream = "control-character-in-input-stream", e.noncharacterInInputStream = "noncharacter-in-input-stream", e.surrogateInInputStream = "surrogate-in-input-stream", e.nonVoidHtmlElementStartTagWithTrailingSolidus = "non-void-html-element-start-tag-with-trailing-solidus", e.endTagWithAttributes = "end-tag-with-attributes", e.endTagWithTrailingSolidus = "end-tag-with-trailing-solidus", e.unexpectedSolidusInTag = "unexpected-solidus-in-tag", e.unexpectedNullCharacter = "unexpected-null-character", e.unexpectedQuestionMarkInsteadOfTagName = "unexpected-question-mark-instead-of-tag-name", e.invalidFirstCharacterOfTagName = "invalid-first-character-of-tag-name", e.unexpectedEqualsSignBeforeAttributeName = "unexpected-equals-sign-before-attribute-name", e.missingEndTagName = "missing-end-tag-name", e.unexpectedCharacterInAttributeName = "unexpected-character-in-attribute-name", e.unknownNamedCharacterReference = "unknown-named-character-reference", e.missingSemicolonAfterCharacterReference = "missing-semicolon-after-character-reference", e.unexpectedCharacterAfterDoctypeSystemIdentifier = "unexpected-character-after-doctype-system-identifier", e.unexpectedCharacterInUnquotedAttributeValue = "unexpected-character-in-unquoted-attribute-value", e.eofBeforeTagName = "eof-before-tag-name", e.eofInTag = "eof-in-tag", e.missingAttributeValue = "missing-attribute-value", e.missingWhitespaceBetweenAttributes = "missing-whitespace-between-attributes", e.missingWhitespaceAfterDoctypePublicKeyword = "missing-whitespace-after-doctype-public-keyword", e.missingWhitespaceBetweenDoctypePublicAndSystemIdentifiers = "missing-whitespace-between-doctype-public-and-system-identifiers", e.missingWhitespaceAfterDoctypeSystemKeyword = "missing-whitespace-after-doctype-system-keyword", e.missingQuoteBeforeDoctypePublicIdentifier = "missing-quote-before-doctype-public-identifier", e.missingQuoteBeforeDoctypeSystemIdentifier = "missing-quote-before-doctype-system-identifier", e.missingDoctypePublicIdentifier = "missing-doctype-public-identifier", e.missingDoctypeSystemIdentifier = "missing-doctype-system-identifier", e.abruptDoctypePublicIdentifier = "abrupt-doctype-public-identifier", e.abruptDoctypeSystemIdentifier = "abrupt-doctype-system-identifier", e.cdataInHtmlContent = "cdata-in-html-content", e.incorrectlyOpenedComment = "incorrectly-opened-comment", e.eofInScriptHtmlCommentLikeText = "eof-in-script-html-comment-like-text", e.eofInDoctype = "eof-in-doctype", e.nestedComment = "nested-comment", e.abruptClosingOfEmptyComment = "abrupt-closing-of-empty-comment", e.eofInComment = "eof-in-comment", e.incorrectlyClosedComment = "incorrectly-closed-comment", e.eofInCdata = "eof-in-cdata", e.absenceOfDigitsInNumericCharacterReference = "absence-of-digits-in-numeric-character-reference", e.nullCharacterReference = "null-character-reference", e.surrogateCharacterReference = "surrogate-character-reference", e.characterReferenceOutsideUnicodeRange = "character-reference-outside-unicode-range", e.controlCharacterReference = "control-character-reference", e.noncharacterCharacterReference = "noncharacter-character-reference", e.missingWhitespaceBeforeDoctypeName = "missing-whitespace-before-doctype-name", e.missingDoctypeName = "missing-doctype-name", e.invalidCharacterSequenceAfterDoctypeName = "invalid-character-sequence-after-doctype-name", e.duplicateAttribute = "duplicate-attribute", e.nonConformingDoctype = "non-conforming-doctype", e.missingDoctype = "missing-doctype", e.misplacedDoctype = "misplaced-doctype", e.endTagWithoutMatchingOpenElement = "end-tag-without-matching-open-element", e.closingOfElementWithOpenChildElements = "closing-of-element-with-open-child-elements", e.disallowedContentInNoscriptInHead = "disallowed-content-in-noscript-in-head", e.openElementsLeftAfterEof = "open-elements-left-after-eof", e.abandonedHeadElementChild = "abandoned-head-element-child", e.misplacedStartTagForHeadElement = "misplaced-start-tag-for-head-element", e.nestedNoscriptInHead = "nested-noscript-in-head", e.eofInElementThatCanContainOnlyText = "eof-in-element-that-can-contain-only-text";
})(k || (k = {}));
const Md = 65536;
class Bd {
  constructor(t) {
    this.handler = t, this.html = "", this.pos = -1, this.lastGapPos = -2, this.gapStack = [], this.skipNextNewLine = !1, this.lastChunkWritten = !1, this.endOfChunkHit = !1, this.bufferWaterline = Md, this.isEol = !1, this.lineStartPos = 0, this.droppedBufferSize = 0, this.line = 1, this.lastErrOffset = -1;
  }
  /** The column on the current line. If we just saw a gap (eg. a surrogate pair), return the index before. */
  get col() {
    return this.pos - this.lineStartPos + +(this.lastGapPos !== this.pos);
  }
  get offset() {
    return this.droppedBufferSize + this.pos;
  }
  getError(t, n) {
    const { line: r, col: u, offset: a } = this, i = u + n, o = a + n;
    return {
      code: t,
      startLine: r,
      endLine: r,
      startCol: i,
      endCol: i,
      startOffset: o,
      endOffset: o
    };
  }
  _err(t) {
    this.handler.onParseError && this.lastErrOffset !== this.offset && (this.lastErrOffset = this.offset, this.handler.onParseError(this.getError(t, 0)));
  }
  _addGap() {
    this.gapStack.push(this.lastGapPos), this.lastGapPos = this.pos;
  }
  _processSurrogate(t) {
    if (this.pos !== this.html.length - 1) {
      const n = this.html.charCodeAt(this.pos + 1);
      if (Pd(n))
        return this.pos++, this._addGap(), wd(t, n);
    } else if (!this.lastChunkWritten)
      return this.endOfChunkHit = !0, p.EOF;
    return this._err(k.surrogateInInputStream), t;
  }
  willDropParsedChunk() {
    return this.pos > this.bufferWaterline;
  }
  dropParsedChunk() {
    this.willDropParsedChunk() && (this.html = this.html.substring(this.pos), this.lineStartPos -= this.pos, this.droppedBufferSize += this.pos, this.pos = 0, this.lastGapPos = -2, this.gapStack.length = 0);
  }
  write(t, n) {
    this.html.length > 0 ? this.html += t : this.html = t, this.endOfChunkHit = !1, this.lastChunkWritten = n;
  }
  insertHtmlAtCurrentPos(t) {
    this.html = this.html.substring(0, this.pos + 1) + t + this.html.substring(this.pos + 1), this.endOfChunkHit = !1;
  }
  startsWith(t, n) {
    if (this.pos + t.length > this.html.length)
      return this.endOfChunkHit = !this.lastChunkWritten, !1;
    if (n)
      return this.html.startsWith(t, this.pos);
    for (let r = 0; r < t.length; r++)
      if ((this.html.charCodeAt(this.pos + r) | 32) !== t.charCodeAt(r))
        return !1;
    return !0;
  }
  peek(t) {
    const n = this.pos + t;
    if (n >= this.html.length)
      return this.endOfChunkHit = !this.lastChunkWritten, p.EOF;
    const r = this.html.charCodeAt(n);
    return r === p.CARRIAGE_RETURN ? p.LINE_FEED : r;
  }
  advance() {
    if (this.pos++, this.isEol && (this.isEol = !1, this.line++, this.lineStartPos = this.pos), this.pos >= this.html.length)
      return this.endOfChunkHit = !this.lastChunkWritten, p.EOF;
    let t = this.html.charCodeAt(this.pos);
    return t === p.CARRIAGE_RETURN ? (this.isEol = !0, this.skipNextNewLine = !0, p.LINE_FEED) : t === p.LINE_FEED && (this.isEol = !0, this.skipNextNewLine) ? (this.line--, this.skipNextNewLine = !1, this._addGap(), this.advance()) : (this.skipNextNewLine = !1, wa(t) && (t = this._processSurrogate(t)), this.handler.onParseError === null || t > 31 && t < 127 || t === p.LINE_FEED || t === p.CARRIAGE_RETURN || t > 159 && t < 64976 || this._checkForProblematicCharacters(t), t);
  }
  _checkForProblematicCharacters(t) {
    Ma(t) ? this._err(k.controlCharacterInInputStream) : Ba(t) && this._err(k.noncharacterInInputStream);
  }
  retreat(t) {
    for (this.pos -= t; this.pos < this.lastGapPos; )
      this.lastGapPos = this.gapStack.pop(), this.pos--;
    this.isEol = !1;
  }
}
var V;
(function(e) {
  e[e.CHARACTER = 0] = "CHARACTER", e[e.NULL_CHARACTER = 1] = "NULL_CHARACTER", e[e.WHITESPACE_CHARACTER = 2] = "WHITESPACE_CHARACTER", e[e.START_TAG = 3] = "START_TAG", e[e.END_TAG = 4] = "END_TAG", e[e.COMMENT = 5] = "COMMENT", e[e.DOCTYPE = 6] = "DOCTYPE", e[e.EOF = 7] = "EOF", e[e.HIBERNATION = 8] = "HIBERNATION";
})(V || (V = {}));
function Fa(e, t) {
  for (let n = e.attrs.length - 1; n >= 0; n--)
    if (e.attrs[n].name === t)
      return e.attrs[n].value;
  return null;
}
const va = new Uint16Array(
  // prettier-ignore
  'ᵁ<Õıʊҝջאٵ۞ޢߖࠏ੊ઑඡ๭༉༦჊ረዡᐕᒝᓃᓟᔥ\0\0\0\0\0\0ᕫᛍᦍᰒᷝ὾⁠↰⊍⏀⏻⑂⠤⤒ⴈ⹈⿎〖㊺㘹㞬㣾㨨㩱㫠㬮ࠀEMabcfglmnoprstu\\bfms¦³¹ÈÏlig耻Æ䃆P耻&䀦cute耻Á䃁reve;䄂Āiyx}rc耻Â䃂;䐐r;쀀𝔄rave耻À䃀pha;䎑acr;䄀d;橓Āgp¡on;䄄f;쀀𝔸plyFunction;恡ing耻Å䃅Ācs¾Ãr;쀀𝒜ign;扔ilde耻Ã䃃ml耻Ä䃄ЀaceforsuåûþėĜĢħĪĀcrêòkslash;或Ŷöø;櫧ed;挆y;䐑ƀcrtąċĔause;戵noullis;愬a;䎒r;쀀𝔅pf;쀀𝔹eve;䋘còēmpeq;扎܀HOacdefhilorsuōőŖƀƞƢƵƷƺǜȕɳɸɾcy;䐧PY耻©䂩ƀcpyŝŢźute;䄆Ā;iŧŨ拒talDifferentialD;慅leys;愭ȀaeioƉƎƔƘron;䄌dil耻Ç䃇rc;䄈nint;戰ot;䄊ĀdnƧƭilla;䂸terDot;䂷òſi;䎧rcleȀDMPTǇǋǑǖot;抙inus;抖lus;投imes;抗oĀcsǢǸkwiseContourIntegral;戲eCurlyĀDQȃȏoubleQuote;思uote;怙ȀlnpuȞȨɇɕonĀ;eȥȦ户;橴ƀgitȯȶȺruent;扡nt;戯ourIntegral;戮ĀfrɌɎ;愂oduct;成nterClockwiseContourIntegral;戳oss;樯cr;쀀𝒞pĀ;Cʄʅ拓ap;才րDJSZacefiosʠʬʰʴʸˋ˗ˡ˦̳ҍĀ;oŹʥtrahd;椑cy;䐂cy;䐅cy;䐏ƀgrsʿ˄ˇger;怡r;憡hv;櫤Āayː˕ron;䄎;䐔lĀ;t˝˞戇a;䎔r;쀀𝔇Āaf˫̧Ācm˰̢riticalȀADGT̖̜̀̆cute;䂴oŴ̋̍;䋙bleAcute;䋝rave;䁠ilde;䋜ond;拄ferentialD;慆Ѱ̽\0\0\0͔͂\0Ѕf;쀀𝔻ƀ;DE͈͉͍䂨ot;惜qual;扐blèCDLRUVͣͲ΂ϏϢϸontourIntegraìȹoɴ͹\0\0ͻ»͉nArrow;懓Āeo·ΤftƀARTΐΖΡrrow;懐ightArrow;懔eåˊngĀLRΫτeftĀARγιrrow;柸ightArrow;柺ightArrow;柹ightĀATϘϞrrow;懒ee;抨pɁϩ\0\0ϯrrow;懑ownArrow;懕erticalBar;戥ǹABLRTaВЪаўѿͼrrowƀ;BUНОТ憓ar;椓pArrow;懵reve;䌑eft˒к\0ц\0ѐightVector;楐eeVector;楞ectorĀ;Bљњ憽ar;楖ightǔѧ\0ѱeeVector;楟ectorĀ;BѺѻ懁ar;楗eeĀ;A҆҇护rrow;憧ĀctҒҗr;쀀𝒟rok;䄐ࠀNTacdfglmopqstuxҽӀӄӋӞӢӧӮӵԡԯԶՒ՝ՠեG;䅊H耻Ð䃐cute耻É䃉ƀaiyӒӗӜron;䄚rc耻Ê䃊;䐭ot;䄖r;쀀𝔈rave耻È䃈ement;戈ĀapӺӾcr;䄒tyɓԆ\0\0ԒmallSquare;旻erySmallSquare;斫ĀgpԦԪon;䄘f;쀀𝔼silon;䎕uĀaiԼՉlĀ;TՂՃ橵ilde;扂librium;懌Āci՗՚r;愰m;橳a;䎗ml耻Ë䃋Āipժկsts;戃onentialE;慇ʀcfiosօֈ֍ֲ׌y;䐤r;쀀𝔉lledɓ֗\0\0֣mallSquare;旼erySmallSquare;斪Ͱֺ\0ֿ\0\0ׄf;쀀𝔽All;戀riertrf;愱cò׋؀JTabcdfgorstר׬ׯ׺؀ؒؖ؛؝أ٬ٲcy;䐃耻>䀾mmaĀ;d׷׸䎓;䏜reve;䄞ƀeiy؇،ؐdil;䄢rc;䄜;䐓ot;䄠r;쀀𝔊;拙pf;쀀𝔾eater̀EFGLSTصلَٖٛ٦qualĀ;Lؾؿ扥ess;招ullEqual;执reater;檢ess;扷lantEqual;橾ilde;扳cr;쀀𝒢;扫ЀAacfiosuڅڋږڛڞڪھۊRDcy;䐪Āctڐڔek;䋇;䁞irc;䄤r;愌lbertSpace;愋ǰگ\0ڲf;愍izontalLine;攀Āctۃۅòکrok;䄦mpńېۘownHumðįqual;扏܀EJOacdfgmnostuۺ۾܃܇܎ܚܞܡܨ݄ݸދޏޕcy;䐕lig;䄲cy;䐁cute耻Í䃍Āiyܓܘrc耻Î䃎;䐘ot;䄰r;愑rave耻Ì䃌ƀ;apܠܯܿĀcgܴܷr;䄪inaryI;慈lieóϝǴ݉\0ݢĀ;eݍݎ戬Āgrݓݘral;戫section;拂isibleĀCTݬݲomma;恣imes;恢ƀgptݿރވon;䄮f;쀀𝕀a;䎙cr;愐ilde;䄨ǫޚ\0ޞcy;䐆l耻Ï䃏ʀcfosuެ޷޼߂ߐĀiyޱ޵rc;䄴;䐙r;쀀𝔍pf;쀀𝕁ǣ߇\0ߌr;쀀𝒥rcy;䐈kcy;䐄΀HJacfosߤߨ߽߬߱ࠂࠈcy;䐥cy;䐌ppa;䎚Āey߶߻dil;䄶;䐚r;쀀𝔎pf;쀀𝕂cr;쀀𝒦րJTaceflmostࠥࠩࠬࡐࡣ঳সে্਷ੇcy;䐉耻<䀼ʀcmnpr࠷࠼ࡁࡄࡍute;䄹bda;䎛g;柪lacetrf;愒r;憞ƀaeyࡗ࡜ࡡron;䄽dil;䄻;䐛Āfsࡨ॰tԀACDFRTUVarࡾࢩࢱࣦ࣠ࣼयज़ΐ४Ānrࢃ࢏gleBracket;柨rowƀ;BR࢙࢚࢞憐ar;懤ightArrow;懆eiling;挈oǵࢷ\0ࣃbleBracket;柦nǔࣈ\0࣒eeVector;楡ectorĀ;Bࣛࣜ懃ar;楙loor;挊ightĀAV࣯ࣵrrow;憔ector;楎Āerँगeƀ;AVउऊऐ抣rrow;憤ector;楚iangleƀ;BEतथऩ抲ar;槏qual;抴pƀDTVषूौownVector;楑eeVector;楠ectorĀ;Bॖॗ憿ar;楘ectorĀ;B॥०憼ar;楒ightáΜs̀EFGLSTॾঋকঝঢভqualGreater;拚ullEqual;扦reater;扶ess;檡lantEqual;橽ilde;扲r;쀀𝔏Ā;eঽা拘ftarrow;懚idot;䄿ƀnpw৔ਖਛgȀLRlr৞৷ਂਐeftĀAR০৬rrow;柵ightArrow;柷ightArrow;柶eftĀarγਊightáοightáϊf;쀀𝕃erĀLRਢਬeftArrow;憙ightArrow;憘ƀchtਾੀੂòࡌ;憰rok;䅁;扪Ѐacefiosuਗ਼੝੠੷੼અઋ઎p;椅y;䐜Ādl੥੯iumSpace;恟lintrf;愳r;쀀𝔐nusPlus;戓pf;쀀𝕄cò੶;䎜ҀJacefostuણધભીଔଙඑ඗ඞcy;䐊cute;䅃ƀaey઴હાron;䅇dil;䅅;䐝ƀgswે૰଎ativeƀMTV૓૟૨ediumSpace;怋hiĀcn૦૘ë૙eryThiî૙tedĀGL૸ଆreaterGreateòٳessLesóੈLine;䀊r;쀀𝔑ȀBnptଢନଷ଺reak;恠BreakingSpace;䂠f;愕ڀ;CDEGHLNPRSTV୕ୖ୪୼஡௫ఄ౞಄ದ೘ൡඅ櫬Āou୛୤ngruent;扢pCap;扭oubleVerticalBar;戦ƀlqxஃஊ஛ement;戉ualĀ;Tஒஓ扠ilde;쀀≂̸ists;戄reater΀;EFGLSTஶஷ஽௉௓௘௥扯qual;扱ullEqual;쀀≧̸reater;쀀≫̸ess;批lantEqual;쀀⩾̸ilde;扵umpń௲௽ownHump;쀀≎̸qual;쀀≏̸eĀfsఊధtTriangleƀ;BEచఛడ拪ar;쀀⧏̸qual;括s̀;EGLSTవశ఼ౄోౘ扮qual;扰reater;扸ess;쀀≪̸lantEqual;쀀⩽̸ilde;扴estedĀGL౨౹reaterGreater;쀀⪢̸essLess;쀀⪡̸recedesƀ;ESಒಓಛ技qual;쀀⪯̸lantEqual;拠ĀeiಫಹverseElement;戌ghtTriangleƀ;BEೋೌ೒拫ar;쀀⧐̸qual;拭ĀquೝഌuareSuĀbp೨೹setĀ;E೰ೳ쀀⊏̸qual;拢ersetĀ;Eഃആ쀀⊐̸qual;拣ƀbcpഓതൎsetĀ;Eഛഞ쀀⊂⃒qual;抈ceedsȀ;ESTലള഻െ抁qual;쀀⪰̸lantEqual;拡ilde;쀀≿̸ersetĀ;E൘൛쀀⊃⃒qual;抉ildeȀ;EFT൮൯൵ൿ扁qual;扄ullEqual;扇ilde;扉erticalBar;戤cr;쀀𝒩ilde耻Ñ䃑;䎝܀Eacdfgmoprstuvලෂ෉෕ෛ෠෧෼ขภยา฿ไlig;䅒cute耻Ó䃓Āiy෎ීrc耻Ô䃔;䐞blac;䅐r;쀀𝔒rave耻Ò䃒ƀaei෮ෲ෶cr;䅌ga;䎩cron;䎟pf;쀀𝕆enCurlyĀDQฎบoubleQuote;怜uote;怘;橔Āclวฬr;쀀𝒪ash耻Ø䃘iŬื฼de耻Õ䃕es;樷ml耻Ö䃖erĀBP๋๠Āar๐๓r;怾acĀek๚๜;揞et;掴arenthesis;揜Ҁacfhilors๿ງຊຏຒດຝະ໼rtialD;戂y;䐟r;쀀𝔓i;䎦;䎠usMinus;䂱Āipຢອncareplanåڝf;愙Ȁ;eio຺ູ໠໤檻cedesȀ;EST່້໏໚扺qual;檯lantEqual;扼ilde;找me;怳Ādp໩໮uct;戏ortionĀ;aȥ໹l;戝Āci༁༆r;쀀𝒫;䎨ȀUfos༑༖༛༟OT耻"䀢r;쀀𝔔pf;愚cr;쀀𝒬؀BEacefhiorsu༾གྷཇའཱིྦྷྪྭ႖ႩႴႾarr;椐G耻®䂮ƀcnrཎནབute;䅔g;柫rĀ;tཛྷཝ憠l;椖ƀaeyཧཬཱron;䅘dil;䅖;䐠Ā;vླྀཹ愜erseĀEUྂྙĀlq྇ྎement;戋uilibrium;懋pEquilibrium;楯r»ཹo;䎡ghtЀACDFTUVa࿁࿫࿳ဢဨၛႇϘĀnr࿆࿒gleBracket;柩rowƀ;BL࿜࿝࿡憒ar;懥eftArrow;懄eiling;按oǵ࿹\0စbleBracket;柧nǔည\0နeeVector;楝ectorĀ;Bဝသ懂ar;楕loor;挋Āerိ၃eƀ;AVဵံြ抢rrow;憦ector;楛iangleƀ;BEၐၑၕ抳ar;槐qual;抵pƀDTVၣၮၸownVector;楏eeVector;楜ectorĀ;Bႂႃ憾ar;楔ectorĀ;B႑႒懀ar;楓Āpuႛ႞f;愝ndImplies;楰ightarrow;懛ĀchႹႼr;愛;憱leDelayed;槴ڀHOacfhimoqstuფჱჷჽᄙᄞᅑᅖᅡᅧᆵᆻᆿĀCcჩხHcy;䐩y;䐨FTcy;䐬cute;䅚ʀ;aeiyᄈᄉᄎᄓᄗ檼ron;䅠dil;䅞rc;䅜;䐡r;쀀𝔖ortȀDLRUᄪᄴᄾᅉownArrow»ОeftArrow»࢚ightArrow»࿝pArrow;憑gma;䎣allCircle;战pf;쀀𝕊ɲᅭ\0\0ᅰt;戚areȀ;ISUᅻᅼᆉᆯ斡ntersection;抓uĀbpᆏᆞsetĀ;Eᆗᆘ抏qual;抑ersetĀ;Eᆨᆩ抐qual;抒nion;抔cr;쀀𝒮ar;拆ȀbcmpᇈᇛሉላĀ;sᇍᇎ拐etĀ;Eᇍᇕqual;抆ĀchᇠህeedsȀ;ESTᇭᇮᇴᇿ扻qual;檰lantEqual;扽ilde;承Tháྌ;我ƀ;esሒሓሣ拑rsetĀ;Eሜም抃qual;抇et»ሓրHRSacfhiorsሾቄ቉ቕ቞ቱቶኟዂወዑORN耻Þ䃞ADE;愢ĀHc቎ቒcy;䐋y;䐦Ābuቚቜ;䀉;䎤ƀaeyብቪቯron;䅤dil;䅢;䐢r;쀀𝔗Āeiቻ኉ǲኀ\0ኇefore;戴a;䎘Ācn኎ኘkSpace;쀀  Space;怉ldeȀ;EFTካኬኲኼ戼qual;扃ullEqual;扅ilde;扈pf;쀀𝕋ipleDot;惛Āctዖዛr;쀀𝒯rok;䅦ૡዷጎጚጦ\0ጬጱ\0\0\0\0\0ጸጽ፷ᎅ\0᏿ᐄᐊᐐĀcrዻጁute耻Ú䃚rĀ;oጇገ憟cir;楉rǣጓ\0጖y;䐎ve;䅬Āiyጞጣrc耻Û䃛;䐣blac;䅰r;쀀𝔘rave耻Ù䃙acr;䅪Ādiፁ፩erĀBPፈ፝Āarፍፐr;䁟acĀekፗፙ;揟et;掵arenthesis;揝onĀ;P፰፱拃lus;抎Āgp፻፿on;䅲f;쀀𝕌ЀADETadps᎕ᎮᎸᏄϨᏒᏗᏳrrowƀ;BDᅐᎠᎤar;椒ownArrow;懅ownArrow;憕quilibrium;楮eeĀ;AᏋᏌ报rrow;憥ownáϳerĀLRᏞᏨeftArrow;憖ightArrow;憗iĀ;lᏹᏺ䏒on;䎥ing;䅮cr;쀀𝒰ilde;䅨ml耻Ü䃜ҀDbcdefosvᐧᐬᐰᐳᐾᒅᒊᒐᒖash;披ar;櫫y;䐒ashĀ;lᐻᐼ抩;櫦Āerᑃᑅ;拁ƀbtyᑌᑐᑺar;怖Ā;iᑏᑕcalȀBLSTᑡᑥᑪᑴar;戣ine;䁼eparator;杘ilde;所ThinSpace;怊r;쀀𝔙pf;쀀𝕍cr;쀀𝒱dash;抪ʀcefosᒧᒬᒱᒶᒼirc;䅴dge;拀r;쀀𝔚pf;쀀𝕎cr;쀀𝒲Ȁfiosᓋᓐᓒᓘr;쀀𝔛;䎞pf;쀀𝕏cr;쀀𝒳ҀAIUacfosuᓱᓵᓹᓽᔄᔏᔔᔚᔠcy;䐯cy;䐇cy;䐮cute耻Ý䃝Āiyᔉᔍrc;䅶;䐫r;쀀𝔜pf;쀀𝕐cr;쀀𝒴ml;䅸ЀHacdefosᔵᔹᔿᕋᕏᕝᕠᕤcy;䐖cute;䅹Āayᕄᕉron;䅽;䐗ot;䅻ǲᕔ\0ᕛoWidtè૙a;䎖r;愨pf;愤cr;쀀𝒵௡ᖃᖊᖐ\0ᖰᖶᖿ\0\0\0\0ᗆᗛᗫᙟ᙭\0ᚕ᚛ᚲᚹ\0ᚾcute耻á䃡reve;䄃̀;Ediuyᖜᖝᖡᖣᖨᖭ戾;쀀∾̳;房rc耻â䃢te肻´̆;䐰lig耻æ䃦Ā;r²ᖺ;쀀𝔞rave耻à䃠ĀepᗊᗖĀfpᗏᗔsym;愵èᗓha;䎱ĀapᗟcĀclᗤᗧr;䄁g;樿ɤᗰ\0\0ᘊʀ;adsvᗺᗻᗿᘁᘇ戧nd;橕;橜lope;橘;橚΀;elmrszᘘᘙᘛᘞᘿᙏᙙ戠;榤e»ᘙsdĀ;aᘥᘦ戡ѡᘰᘲᘴᘶᘸᘺᘼᘾ;榨;榩;榪;榫;榬;榭;榮;榯tĀ;vᙅᙆ戟bĀ;dᙌᙍ抾;榝Āptᙔᙗh;戢»¹arr;捼Āgpᙣᙧon;䄅f;쀀𝕒΀;Eaeiop዁ᙻᙽᚂᚄᚇᚊ;橰cir;橯;扊d;手s;䀧roxĀ;e዁ᚒñᚃing耻å䃥ƀctyᚡᚦᚨr;쀀𝒶;䀪mpĀ;e዁ᚯñʈilde耻ã䃣ml耻ä䃤Āciᛂᛈoninôɲnt;樑ࠀNabcdefiklnoprsu᛭ᛱᜰ᜼ᝃᝈ᝸᝽០៦ᠹᡐᜍ᤽᥈ᥰot;櫭Ācrᛶ᜞kȀcepsᜀᜅᜍᜓong;扌psilon;䏶rime;怵imĀ;e᜚᜛戽q;拍Ŷᜢᜦee;抽edĀ;gᜬᜭ挅e»ᜭrkĀ;t፜᜷brk;掶Āoyᜁᝁ;䐱quo;怞ʀcmprtᝓ᝛ᝡᝤᝨausĀ;eĊĉptyv;榰séᜌnoõēƀahwᝯ᝱ᝳ;䎲;愶een;扬r;쀀𝔟g΀costuvwឍឝឳេ៕៛៞ƀaiuបពរðݠrc;旯p»፱ƀdptឤឨឭot;樀lus;樁imes;樂ɱឹ\0\0ើcup;樆ar;昅riangleĀdu៍្own;施p;斳plus;樄eåᑄåᒭarow;植ƀako៭ᠦᠵĀcn៲ᠣkƀlst៺֫᠂ozenge;槫riangleȀ;dlr᠒᠓᠘᠝斴own;斾eft;旂ight;斸k;搣Ʊᠫ\0ᠳƲᠯ\0ᠱ;斒;斑4;斓ck;斈ĀeoᠾᡍĀ;qᡃᡆ쀀=⃥uiv;쀀≡⃥t;挐Ȁptwxᡙᡞᡧᡬf;쀀𝕓Ā;tᏋᡣom»Ꮜtie;拈؀DHUVbdhmptuvᢅᢖᢪᢻᣗᣛᣬ᣿ᤅᤊᤐᤡȀLRlrᢎᢐᢒᢔ;敗;敔;敖;敓ʀ;DUduᢡᢢᢤᢦᢨ敐;敦;敩;敤;敧ȀLRlrᢳᢵᢷᢹ;敝;敚;敜;教΀;HLRhlrᣊᣋᣍᣏᣑᣓᣕ救;敬;散;敠;敫;敢;敟ox;槉ȀLRlrᣤᣦᣨᣪ;敕;敒;攐;攌ʀ;DUduڽ᣷᣹᣻᣽;敥;敨;攬;攴inus;抟lus;択imes;抠ȀLRlrᤙᤛᤝ᤟;敛;敘;攘;攔΀;HLRhlrᤰᤱᤳᤵᤷ᤻᤹攂;敪;敡;敞;攼;攤;攜Āevģ᥂bar耻¦䂦Ȁceioᥑᥖᥚᥠr;쀀𝒷mi;恏mĀ;e᜚᜜lƀ;bhᥨᥩᥫ䁜;槅sub;柈Ŭᥴ᥾lĀ;e᥹᥺怢t»᥺pƀ;Eeįᦅᦇ;檮Ā;qۜۛೡᦧ\0᧨ᨑᨕᨲ\0ᨷᩐ\0\0᪴\0\0᫁\0\0ᬡᬮ᭍᭒\0᯽\0ᰌƀcpr᦭ᦲ᧝ute;䄇̀;abcdsᦿᧀᧄ᧊᧕᧙戩nd;橄rcup;橉Āau᧏᧒p;橋p;橇ot;橀;쀀∩︀Āeo᧢᧥t;恁îړȀaeiu᧰᧻ᨁᨅǰ᧵\0᧸s;橍on;䄍dil耻ç䃧rc;䄉psĀ;sᨌᨍ橌m;橐ot;䄋ƀdmnᨛᨠᨦil肻¸ƭptyv;榲t脀¢;eᨭᨮ䂢räƲr;쀀𝔠ƀceiᨽᩀᩍy;䑇ckĀ;mᩇᩈ朓ark»ᩈ;䏇r΀;Ecefms᩟᩠ᩢᩫ᪤᪪᪮旋;槃ƀ;elᩩᩪᩭ䋆q;扗eɡᩴ\0\0᪈rrowĀlr᩼᪁eft;憺ight;憻ʀRSacd᪒᪔᪖᪚᪟»ཇ;擈st;抛irc;抚ash;抝nint;樐id;櫯cir;槂ubsĀ;u᪻᪼晣it»᪼ˬ᫇᫔᫺\0ᬊonĀ;eᫍᫎ䀺Ā;qÇÆɭ᫙\0\0᫢aĀ;t᫞᫟䀬;䁀ƀ;fl᫨᫩᫫戁îᅠeĀmx᫱᫶ent»᫩eóɍǧ᫾\0ᬇĀ;dኻᬂot;橭nôɆƀfryᬐᬔᬗ;쀀𝕔oäɔ脀©;sŕᬝr;愗Āaoᬥᬩrr;憵ss;朗Ācuᬲᬷr;쀀𝒸Ābpᬼ᭄Ā;eᭁᭂ櫏;櫑Ā;eᭉᭊ櫐;櫒dot;拯΀delprvw᭠᭬᭷ᮂᮬᯔ᯹arrĀlr᭨᭪;椸;椵ɰ᭲\0\0᭵r;拞c;拟arrĀ;p᭿ᮀ憶;椽̀;bcdosᮏᮐᮖᮡᮥᮨ截rcap;橈Āauᮛᮞp;橆p;橊ot;抍r;橅;쀀∪︀Ȁalrv᮵ᮿᯞᯣrrĀ;mᮼᮽ憷;椼yƀevwᯇᯔᯘqɰᯎ\0\0ᯒreã᭳uã᭵ee;拎edge;拏en耻¤䂤earrowĀlrᯮ᯳eft»ᮀight»ᮽeäᯝĀciᰁᰇoninôǷnt;戱lcty;挭ঀAHabcdefhijlorstuwz᰸᰻᰿ᱝᱩᱵᲊᲞᲬᲷ᳻᳿ᴍᵻᶑᶫᶻ᷆᷍rò΁ar;楥Ȁglrs᱈ᱍ᱒᱔ger;怠eth;愸òᄳhĀ;vᱚᱛ怐»ऊūᱡᱧarow;椏aã̕Āayᱮᱳron;䄏;䐴ƀ;ao̲ᱼᲄĀgrʿᲁr;懊tseq;橷ƀglmᲑᲔᲘ耻°䂰ta;䎴ptyv;榱ĀirᲣᲨsht;楿;쀀𝔡arĀlrᲳᲵ»ࣜ»သʀaegsv᳂͸᳖᳜᳠mƀ;oș᳊᳔ndĀ;ș᳑uit;晦amma;䏝in;拲ƀ;io᳧᳨᳸䃷de脀÷;o᳧ᳰntimes;拇nø᳷cy;䑒cɯᴆ\0\0ᴊrn;挞op;挍ʀlptuwᴘᴝᴢᵉᵕlar;䀤f;쀀𝕕ʀ;emps̋ᴭᴷᴽᵂqĀ;d͒ᴳot;扑inus;戸lus;戔quare;抡blebarwedgåúnƀadhᄮᵝᵧownarrowóᲃarpoonĀlrᵲᵶefôᲴighôᲶŢᵿᶅkaro÷གɯᶊ\0\0ᶎrn;挟op;挌ƀcotᶘᶣᶦĀryᶝᶡ;쀀𝒹;䑕l;槶rok;䄑Ādrᶰᶴot;拱iĀ;fᶺ᠖斿Āah᷀᷃ròЩaòྦangle;榦Āci᷒ᷕy;䑟grarr;柿ऀDacdefglmnopqrstuxḁḉḙḸոḼṉṡṾấắẽỡἪἷὄ὎὚ĀDoḆᴴoôᲉĀcsḎḔute耻é䃩ter;橮ȀaioyḢḧḱḶron;䄛rĀ;cḭḮ扖耻ê䃪lon;払;䑍ot;䄗ĀDrṁṅot;扒;쀀𝔢ƀ;rsṐṑṗ檚ave耻è䃨Ā;dṜṝ檖ot;檘Ȁ;ilsṪṫṲṴ檙nters;揧;愓Ā;dṹṺ檕ot;檗ƀapsẅẉẗcr;䄓tyƀ;svẒẓẕ戅et»ẓpĀ1;ẝẤĳạả;怄;怅怃ĀgsẪẬ;䅋p;怂ĀgpẴẸon;䄙f;쀀𝕖ƀalsỄỎỒrĀ;sỊị拕l;槣us;橱iƀ;lvỚớở䎵on»ớ;䏵ȀcsuvỪỳἋἣĀioữḱrc»Ḯɩỹ\0\0ỻíՈantĀglἂἆtr»ṝess»Ṻƀaeiἒ἖Ἒls;䀽st;扟vĀ;DȵἠD;橸parsl;槥ĀDaἯἳot;打rr;楱ƀcdiἾὁỸr;愯oô͒ĀahὉὋ;䎷耻ð䃰Āmrὓὗl耻ë䃫o;悬ƀcipὡὤὧl;䀡sôծĀeoὬὴctatioîՙnentialåչৡᾒ\0ᾞ\0ᾡᾧ\0\0ῆῌ\0ΐ\0ῦῪ \0 ⁚llingdotseñṄy;䑄male;晀ƀilrᾭᾳ῁lig;耀ﬃɩᾹ\0\0᾽g;耀ﬀig;耀ﬄ;쀀𝔣lig;耀ﬁlig;쀀fjƀaltῙ῜ῡt;晭ig;耀ﬂns;斱of;䆒ǰ΅\0ῳf;쀀𝕗ĀakֿῷĀ;vῼ´拔;櫙artint;樍Āao‌⁕Ācs‑⁒α‚‰‸⁅⁈\0⁐β•‥‧‪‬\0‮耻½䂽;慓耻¼䂼;慕;慙;慛Ƴ‴\0‶;慔;慖ʴ‾⁁\0\0⁃耻¾䂾;慗;慜5;慘ƶ⁌\0⁎;慚;慝8;慞l;恄wn;挢cr;쀀𝒻ࢀEabcdefgijlnorstv₂₉₟₥₰₴⃰⃵⃺⃿℃ℒℸ̗ℾ⅒↞Ā;lٍ₇;檌ƀcmpₐₕ₝ute;䇵maĀ;dₜ᳚䎳;檆reve;䄟Āiy₪₮rc;䄝;䐳ot;䄡Ȁ;lqsؾق₽⃉ƀ;qsؾٌ⃄lanô٥Ȁ;cdl٥⃒⃥⃕c;檩otĀ;o⃜⃝檀Ā;l⃢⃣檂;檄Ā;e⃪⃭쀀⋛︀s;檔r;쀀𝔤Ā;gٳ؛mel;愷cy;䑓Ȁ;Eajٚℌℎℐ;檒;檥;檤ȀEaesℛℝ℩ℴ;扩pĀ;p℣ℤ檊rox»ℤĀ;q℮ℯ檈Ā;q℮ℛim;拧pf;쀀𝕘Āci⅃ⅆr;愊mƀ;el٫ⅎ⅐;檎;檐茀>;cdlqr׮ⅠⅪⅮⅳⅹĀciⅥⅧ;檧r;橺ot;拗Par;榕uest;橼ʀadelsↄⅪ←ٖ↛ǰ↉\0↎proø₞r;楸qĀlqؿ↖lesó₈ií٫Āen↣↭rtneqq;쀀≩︀Å↪ԀAabcefkosy⇄⇇⇱⇵⇺∘∝∯≨≽ròΠȀilmr⇐⇔⇗⇛rsðᒄf»․ilôکĀdr⇠⇤cy;䑊ƀ;cwࣴ⇫⇯ir;楈;憭ar;意irc;䄥ƀalr∁∎∓rtsĀ;u∉∊晥it»∊lip;怦con;抹r;쀀𝔥sĀew∣∩arow;椥arow;椦ʀamopr∺∾≃≞≣rr;懿tht;戻kĀlr≉≓eftarrow;憩ightarrow;憪f;쀀𝕙bar;怕ƀclt≯≴≸r;쀀𝒽asè⇴rok;䄧Ābp⊂⊇ull;恃hen»ᱛૡ⊣\0⊪\0⊸⋅⋎\0⋕⋳\0\0⋸⌢⍧⍢⍿\0⎆⎪⎴cute耻í䃭ƀ;iyݱ⊰⊵rc耻î䃮;䐸Ācx⊼⊿y;䐵cl耻¡䂡ĀfrΟ⋉;쀀𝔦rave耻ì䃬Ȁ;inoܾ⋝⋩⋮Āin⋢⋦nt;樌t;戭fin;槜ta;愩lig;䄳ƀaop⋾⌚⌝ƀcgt⌅⌈⌗r;䄫ƀelpܟ⌏⌓inåގarôܠh;䄱f;抷ed;䆵ʀ;cfotӴ⌬⌱⌽⍁are;愅inĀ;t⌸⌹戞ie;槝doô⌙ʀ;celpݗ⍌⍐⍛⍡al;抺Āgr⍕⍙eróᕣã⍍arhk;樗rod;樼Ȁcgpt⍯⍲⍶⍻y;䑑on;䄯f;쀀𝕚a;䎹uest耻¿䂿Āci⎊⎏r;쀀𝒾nʀ;EdsvӴ⎛⎝⎡ӳ;拹ot;拵Ā;v⎦⎧拴;拳Ā;iݷ⎮lde;䄩ǫ⎸\0⎼cy;䑖l耻ï䃯̀cfmosu⏌⏗⏜⏡⏧⏵Āiy⏑⏕rc;䄵;䐹r;쀀𝔧ath;䈷pf;쀀𝕛ǣ⏬\0⏱r;쀀𝒿rcy;䑘kcy;䑔Ѐacfghjos␋␖␢␧␭␱␵␻ppaĀ;v␓␔䎺;䏰Āey␛␠dil;䄷;䐺r;쀀𝔨reen;䄸cy;䑅cy;䑜pf;쀀𝕜cr;쀀𝓀஀ABEHabcdefghjlmnoprstuv⑰⒁⒆⒍⒑┎┽╚▀♎♞♥♹♽⚚⚲⛘❝❨➋⟀⠁⠒ƀart⑷⑺⑼rò৆òΕail;椛arr;椎Ā;gঔ⒋;檋ar;楢ॣ⒥\0⒪\0⒱\0\0\0\0\0⒵Ⓔ\0ⓆⓈⓍ\0⓹ute;䄺mptyv;榴raîࡌbda;䎻gƀ;dlࢎⓁⓃ;榑åࢎ;檅uo耻«䂫rЀ;bfhlpst࢙ⓞⓦⓩ⓫⓮⓱⓵Ā;f࢝ⓣs;椟s;椝ë≒p;憫l;椹im;楳l;憢ƀ;ae⓿─┄檫il;椙Ā;s┉┊檭;쀀⪭︀ƀabr┕┙┝rr;椌rk;杲Āak┢┬cĀek┨┪;䁻;䁛Āes┱┳;榋lĀdu┹┻;榏;榍Ȁaeuy╆╋╖╘ron;䄾Ādi═╔il;䄼ìࢰâ┩;䐻Ȁcqrs╣╦╭╽a;椶uoĀ;rนᝆĀdu╲╷har;楧shar;楋h;憲ʀ;fgqs▋▌উ◳◿扤tʀahlrt▘▤▷◂◨rrowĀ;t࢙□aé⓶arpoonĀdu▯▴own»њp»०eftarrows;懇ightƀahs◍◖◞rrowĀ;sࣴࢧarpoonó྘quigarro÷⇰hreetimes;拋ƀ;qs▋ও◺lanôবʀ;cdgsব☊☍☝☨c;檨otĀ;o☔☕橿Ā;r☚☛檁;檃Ā;e☢☥쀀⋚︀s;檓ʀadegs☳☹☽♉♋pproøⓆot;拖qĀgq♃♅ôউgtò⒌ôছiíলƀilr♕࣡♚sht;楼;쀀𝔩Ā;Eজ♣;檑š♩♶rĀdu▲♮Ā;l॥♳;楪lk;斄cy;䑙ʀ;achtੈ⚈⚋⚑⚖rò◁orneòᴈard;楫ri;旺Āio⚟⚤dot;䅀ustĀ;a⚬⚭掰che»⚭ȀEaes⚻⚽⛉⛔;扨pĀ;p⛃⛄檉rox»⛄Ā;q⛎⛏檇Ā;q⛎⚻im;拦Ѐabnoptwz⛩⛴⛷✚✯❁❇❐Ānr⛮⛱g;柬r;懽rëࣁgƀlmr⛿✍✔eftĀar০✇ightá৲apsto;柼ightá৽parrowĀlr✥✩efô⓭ight;憬ƀafl✶✹✽r;榅;쀀𝕝us;樭imes;樴š❋❏st;戗áፎƀ;ef❗❘᠀旊nge»❘arĀ;l❤❥䀨t;榓ʀachmt❳❶❼➅➇ròࢨorneòᶌarĀ;d྘➃;業;怎ri;抿̀achiqt➘➝ੀ➢➮➻quo;怹r;쀀𝓁mƀ;egল➪➬;檍;檏Ābu┪➳oĀ;rฟ➹;怚rok;䅂萀<;cdhilqrࠫ⟒☹⟜⟠⟥⟪⟰Āci⟗⟙;檦r;橹reå◲mes;拉arr;楶uest;橻ĀPi⟵⟹ar;榖ƀ;ef⠀भ᠛旃rĀdu⠇⠍shar;楊har;楦Āen⠗⠡rtneqq;쀀≨︀Å⠞܀Dacdefhilnopsu⡀⡅⢂⢎⢓⢠⢥⢨⣚⣢⣤ઃ⣳⤂Dot;戺Ȁclpr⡎⡒⡣⡽r耻¯䂯Āet⡗⡙;時Ā;e⡞⡟朠se»⡟Ā;sျ⡨toȀ;dluျ⡳⡷⡻owîҌefôएðᏑker;斮Āoy⢇⢌mma;権;䐼ash;怔asuredangle»ᘦr;쀀𝔪o;愧ƀcdn⢯⢴⣉ro耻µ䂵Ȁ;acdᑤ⢽⣀⣄sôᚧir;櫰ot肻·Ƶusƀ;bd⣒ᤃ⣓戒Ā;uᴼ⣘;横ţ⣞⣡p;櫛ò−ðઁĀdp⣩⣮els;抧f;쀀𝕞Āct⣸⣽r;쀀𝓂pos»ᖝƀ;lm⤉⤊⤍䎼timap;抸ఀGLRVabcdefghijlmoprstuvw⥂⥓⥾⦉⦘⧚⧩⨕⨚⩘⩝⪃⪕⪤⪨⬄⬇⭄⭿⮮ⰴⱧⱼ⳩Āgt⥇⥋;쀀⋙̸Ā;v⥐௏쀀≫⃒ƀelt⥚⥲⥶ftĀar⥡⥧rrow;懍ightarrow;懎;쀀⋘̸Ā;v⥻ే쀀≪⃒ightarrow;懏ĀDd⦎⦓ash;抯ash;抮ʀbcnpt⦣⦧⦬⦱⧌la»˞ute;䅄g;쀀∠⃒ʀ;Eiop඄⦼⧀⧅⧈;쀀⩰̸d;쀀≋̸s;䅉roø඄urĀ;a⧓⧔普lĀ;s⧓ସǳ⧟\0⧣p肻 ଷmpĀ;e௹ఀʀaeouy⧴⧾⨃⨐⨓ǰ⧹\0⧻;橃on;䅈dil;䅆ngĀ;dൾ⨊ot;쀀⩭̸p;橂;䐽ash;怓΀;Aadqsxஒ⨩⨭⨻⩁⩅⩐rr;懗rĀhr⨳⨶k;椤Ā;oᏲᏰot;쀀≐̸uiöୣĀei⩊⩎ar;椨í஘istĀ;s஠டr;쀀𝔫ȀEest௅⩦⩹⩼ƀ;qs஼⩭௡ƀ;qs஼௅⩴lanô௢ií௪Ā;rஶ⪁»ஷƀAap⪊⪍⪑rò⥱rr;憮ar;櫲ƀ;svྍ⪜ྌĀ;d⪡⪢拼;拺cy;䑚΀AEadest⪷⪺⪾⫂⫅⫶⫹rò⥦;쀀≦̸rr;憚r;急Ȁ;fqs఻⫎⫣⫯tĀar⫔⫙rro÷⫁ightarro÷⪐ƀ;qs఻⪺⫪lanôౕĀ;sౕ⫴»శiíౝĀ;rవ⫾iĀ;eచథiäඐĀpt⬌⬑f;쀀𝕟膀¬;in⬙⬚⬶䂬nȀ;Edvஉ⬤⬨⬮;쀀⋹̸ot;쀀⋵̸ǡஉ⬳⬵;拷;拶iĀ;vಸ⬼ǡಸ⭁⭃;拾;拽ƀaor⭋⭣⭩rȀ;ast୻⭕⭚⭟lleì୻l;쀀⫽⃥;쀀∂̸lint;樔ƀ;ceಒ⭰⭳uåಥĀ;cಘ⭸Ā;eಒ⭽ñಘȀAait⮈⮋⮝⮧rò⦈rrƀ;cw⮔⮕⮙憛;쀀⤳̸;쀀↝̸ghtarrow»⮕riĀ;eೋೖ΀chimpqu⮽⯍⯙⬄୸⯤⯯Ȁ;cerല⯆ഷ⯉uå൅;쀀𝓃ortɭ⬅\0\0⯖ará⭖mĀ;e൮⯟Ā;q൴൳suĀbp⯫⯭å೸åഋƀbcp⯶ⰑⰙȀ;Ees⯿ⰀഢⰄ抄;쀀⫅̸etĀ;eഛⰋqĀ;qണⰀcĀ;eലⰗñസȀ;EesⰢⰣൟⰧ抅;쀀⫆̸etĀ;e൘ⰮqĀ;qൠⰣȀgilrⰽⰿⱅⱇìௗlde耻ñ䃱çృiangleĀlrⱒⱜeftĀ;eచⱚñదightĀ;eೋⱥñ೗Ā;mⱬⱭ䎽ƀ;esⱴⱵⱹ䀣ro;愖p;怇ҀDHadgilrsⲏⲔⲙⲞⲣⲰⲶⳓⳣash;抭arr;椄p;쀀≍⃒ash;抬ĀetⲨⲬ;쀀≥⃒;쀀>⃒nfin;槞ƀAetⲽⳁⳅrr;椂;쀀≤⃒Ā;rⳊⳍ쀀<⃒ie;쀀⊴⃒ĀAtⳘⳜrr;椃rie;쀀⊵⃒im;쀀∼⃒ƀAan⳰⳴ⴂrr;懖rĀhr⳺⳽k;椣Ā;oᏧᏥear;椧ቓ᪕\0\0\0\0\0\0\0\0\0\0\0\0\0ⴭ\0ⴸⵈⵠⵥ⵲ⶄᬇ\0\0ⶍⶫ\0ⷈⷎ\0ⷜ⸙⸫⸾⹃Ācsⴱ᪗ute耻ó䃳ĀiyⴼⵅrĀ;c᪞ⵂ耻ô䃴;䐾ʀabios᪠ⵒⵗǈⵚlac;䅑v;樸old;榼lig;䅓Ācr⵩⵭ir;榿;쀀𝔬ͯ⵹\0\0⵼\0ⶂn;䋛ave耻ò䃲;槁Ābmⶈ෴ar;榵Ȁacitⶕ⶘ⶥⶨrò᪀Āir⶝ⶠr;榾oss;榻nå๒;槀ƀaeiⶱⶵⶹcr;䅍ga;䏉ƀcdnⷀⷅǍron;䎿;榶pf;쀀𝕠ƀaelⷔ⷗ǒr;榷rp;榹΀;adiosvⷪⷫⷮ⸈⸍⸐⸖戨rò᪆Ȁ;efmⷷⷸ⸂⸅橝rĀ;oⷾⷿ愴f»ⷿ耻ª䂪耻º䂺gof;抶r;橖lope;橗;橛ƀclo⸟⸡⸧ò⸁ash耻ø䃸l;折iŬⸯ⸴de耻õ䃵esĀ;aǛ⸺s;樶ml耻ö䃶bar;挽ૡ⹞\0⹽\0⺀⺝\0⺢⺹\0\0⻋ຜ\0⼓\0\0⼫⾼\0⿈rȀ;astЃ⹧⹲຅脀¶;l⹭⹮䂶leìЃɩ⹸\0\0⹻m;櫳;櫽y;䐿rʀcimpt⺋⺏⺓ᡥ⺗nt;䀥od;䀮il;怰enk;怱r;쀀𝔭ƀimo⺨⺰⺴Ā;v⺭⺮䏆;䏕maô੶ne;明ƀ;tv⺿⻀⻈䏀chfork»´;䏖Āau⻏⻟nĀck⻕⻝kĀ;h⇴⻛;愎ö⇴sҀ;abcdemst⻳⻴ᤈ⻹⻽⼄⼆⼊⼎䀫cir;樣ir;樢Āouᵀ⼂;樥;橲n肻±ຝim;樦wo;樧ƀipu⼙⼠⼥ntint;樕f;쀀𝕡nd耻£䂣Ԁ;Eaceinosu່⼿⽁⽄⽇⾁⾉⾒⽾⾶;檳p;檷uå໙Ā;c໎⽌̀;acens່⽙⽟⽦⽨⽾pproø⽃urlyeñ໙ñ໎ƀaes⽯⽶⽺pprox;檹qq;檵im;拨iíໟmeĀ;s⾈ຮ怲ƀEas⽸⾐⽺ð⽵ƀdfp໬⾙⾯ƀals⾠⾥⾪lar;挮ine;挒urf;挓Ā;t໻⾴ï໻rel;抰Āci⿀⿅r;쀀𝓅;䏈ncsp;怈̀fiopsu⿚⋢⿟⿥⿫⿱r;쀀𝔮pf;쀀𝕢rime;恗cr;쀀𝓆ƀaeo⿸〉〓tĀei⿾々rnionóڰnt;樖stĀ;e【】䀿ñἙô༔઀ABHabcdefhilmnoprstux぀けさすムㄎㄫㅇㅢㅲㆎ㈆㈕㈤㈩㉘㉮㉲㊐㊰㊷ƀartぇおがròႳòϝail;検aròᱥar;楤΀cdenqrtとふへみわゔヌĀeuねぱ;쀀∽̱te;䅕iãᅮmptyv;榳gȀ;del࿑らるろ;榒;榥å࿑uo耻»䂻rր;abcfhlpstw࿜ガクシスゼゾダッデナp;極Ā;f࿠ゴs;椠;椳s;椞ë≝ð✮l;楅im;楴l;憣;憝Āaiパフil;椚oĀ;nホボ戶aló༞ƀabrョリヮrò៥rk;杳ĀakンヽcĀekヹ・;䁽;䁝Āes㄂㄄;榌lĀduㄊㄌ;榎;榐Ȁaeuyㄗㄜㄧㄩron;䅙Ādiㄡㄥil;䅗ì࿲âヺ;䑀Ȁclqsㄴㄷㄽㅄa;椷dhar;楩uoĀ;rȎȍh;憳ƀacgㅎㅟངlȀ;ipsླྀㅘㅛႜnåႻarôྩt;断ƀilrㅩဣㅮsht;楽;쀀𝔯ĀaoㅷㆆrĀduㅽㅿ»ѻĀ;l႑ㆄ;楬Ā;vㆋㆌ䏁;䏱ƀgns㆕ㇹㇼht̀ahlrstㆤㆰ㇂㇘㇤㇮rrowĀ;t࿜ㆭaéトarpoonĀduㆻㆿowîㅾp»႒eftĀah㇊㇐rrowó࿪arpoonóՑightarrows;應quigarro÷ニhreetimes;拌g;䋚ingdotseñἲƀahm㈍㈐㈓rò࿪aòՑ;怏oustĀ;a㈞㈟掱che»㈟mid;櫮Ȁabpt㈲㈽㉀㉒Ānr㈷㈺g;柭r;懾rëဃƀafl㉇㉊㉎r;榆;쀀𝕣us;樮imes;樵Āap㉝㉧rĀ;g㉣㉤䀩t;榔olint;樒arò㇣Ȁachq㉻㊀Ⴜ㊅quo;怺r;쀀𝓇Ābu・㊊oĀ;rȔȓƀhir㊗㊛㊠reåㇸmes;拊iȀ;efl㊪ၙᠡ㊫方tri;槎luhar;楨;愞ൡ㋕㋛㋟㌬㌸㍱\0㍺㎤\0\0㏬㏰\0㐨㑈㑚㒭㒱㓊㓱\0㘖\0\0㘳cute;䅛quï➺Ԁ;Eaceinpsyᇭ㋳㋵㋿㌂㌋㌏㌟㌦㌩;檴ǰ㋺\0㋼;檸on;䅡uåᇾĀ;dᇳ㌇il;䅟rc;䅝ƀEas㌖㌘㌛;檶p;檺im;择olint;樓iíሄ;䑁otƀ;be㌴ᵇ㌵担;橦΀Aacmstx㍆㍊㍗㍛㍞㍣㍭rr;懘rĀhr㍐㍒ë∨Ā;oਸ਼਴t耻§䂧i;䀻war;椩mĀin㍩ðnuóñt;朶rĀ;o㍶⁕쀀𝔰Ȁacoy㎂㎆㎑㎠rp;景Āhy㎋㎏cy;䑉;䑈rtɭ㎙\0\0㎜iäᑤaraì⹯耻­䂭Āgm㎨㎴maƀ;fv㎱㎲㎲䏃;䏂Ѐ;deglnprካ㏅㏉㏎㏖㏞㏡㏦ot;橪Ā;q኱ኰĀ;E㏓㏔檞;檠Ā;E㏛㏜檝;檟e;扆lus;樤arr;楲aròᄽȀaeit㏸㐈㐏㐗Āls㏽㐄lsetmé㍪hp;樳parsl;槤Ādlᑣ㐔e;挣Ā;e㐜㐝檪Ā;s㐢㐣檬;쀀⪬︀ƀflp㐮㐳㑂tcy;䑌Ā;b㐸㐹䀯Ā;a㐾㐿槄r;挿f;쀀𝕤aĀdr㑍ЂesĀ;u㑔㑕晠it»㑕ƀcsu㑠㑹㒟Āau㑥㑯pĀ;sᆈ㑫;쀀⊓︀pĀ;sᆴ㑵;쀀⊔︀uĀbp㑿㒏ƀ;esᆗᆜ㒆etĀ;eᆗ㒍ñᆝƀ;esᆨᆭ㒖etĀ;eᆨ㒝ñᆮƀ;afᅻ㒦ְrť㒫ֱ»ᅼaròᅈȀcemt㒹㒾㓂㓅r;쀀𝓈tmîñiì㐕aræᆾĀar㓎㓕rĀ;f㓔ឿ昆Āan㓚㓭ightĀep㓣㓪psiloîỠhé⺯s»⡒ʀbcmnp㓻㕞ሉ㖋㖎Ҁ;Edemnprs㔎㔏㔑㔕㔞㔣㔬㔱㔶抂;櫅ot;檽Ā;dᇚ㔚ot;櫃ult;櫁ĀEe㔨㔪;櫋;把lus;檿arr;楹ƀeiu㔽㕒㕕tƀ;en㔎㕅㕋qĀ;qᇚ㔏eqĀ;q㔫㔨m;櫇Ābp㕚㕜;櫕;櫓c̀;acensᇭ㕬㕲㕹㕻㌦pproø㋺urlyeñᇾñᇳƀaes㖂㖈㌛pproø㌚qñ㌗g;晪ڀ123;Edehlmnps㖩㖬㖯ሜ㖲㖴㗀㗉㗕㗚㗟㗨㗭耻¹䂹耻²䂲耻³䂳;櫆Āos㖹㖼t;檾ub;櫘Ā;dሢ㗅ot;櫄sĀou㗏㗒l;柉b;櫗arr;楻ult;櫂ĀEe㗤㗦;櫌;抋lus;櫀ƀeiu㗴㘉㘌tƀ;enሜ㗼㘂qĀ;qሢ㖲eqĀ;q㗧㗤m;櫈Ābp㘑㘓;櫔;櫖ƀAan㘜㘠㘭rr;懙rĀhr㘦㘨ë∮Ā;oਫ਩war;椪lig耻ß䃟௡㙑㙝㙠ዎ㙳㙹\0㙾㛂\0\0\0\0\0㛛㜃\0㜉㝬\0\0\0㞇ɲ㙖\0\0㙛get;挖;䏄rë๟ƀaey㙦㙫㙰ron;䅥dil;䅣;䑂lrec;挕r;쀀𝔱Ȁeiko㚆㚝㚵㚼ǲ㚋\0㚑eĀ4fኄኁaƀ;sv㚘㚙㚛䎸ym;䏑Ācn㚢㚲kĀas㚨㚮pproø዁im»ኬsðኞĀas㚺㚮ð዁rn耻þ䃾Ǭ̟㛆⋧es膀×;bd㛏㛐㛘䃗Ā;aᤏ㛕r;樱;樰ƀeps㛡㛣㜀á⩍Ȁ;bcf҆㛬㛰㛴ot;挶ir;櫱Ā;o㛹㛼쀀𝕥rk;櫚á㍢rime;怴ƀaip㜏㜒㝤dåቈ΀adempst㜡㝍㝀㝑㝗㝜㝟ngleʀ;dlqr㜰㜱㜶㝀㝂斵own»ᶻeftĀ;e⠀㜾ñम;扜ightĀ;e㊪㝋ñၚot;旬inus;樺lus;樹b;槍ime;樻ezium;揢ƀcht㝲㝽㞁Āry㝷㝻;쀀𝓉;䑆cy;䑛rok;䅧Āio㞋㞎xô᝷headĀlr㞗㞠eftarro÷ࡏightarrow»ཝऀAHabcdfghlmoprstuw㟐㟓㟗㟤㟰㟼㠎㠜㠣㠴㡑㡝㡫㢩㣌㣒㣪㣶ròϭar;楣Ācr㟜㟢ute耻ú䃺òᅐrǣ㟪\0㟭y;䑞ve;䅭Āiy㟵㟺rc耻û䃻;䑃ƀabh㠃㠆㠋ròᎭlac;䅱aòᏃĀir㠓㠘sht;楾;쀀𝔲rave耻ù䃹š㠧㠱rĀlr㠬㠮»ॗ»ႃlk;斀Āct㠹㡍ɯ㠿\0\0㡊rnĀ;e㡅㡆挜r»㡆op;挏ri;旸Āal㡖㡚cr;䅫肻¨͉Āgp㡢㡦on;䅳f;쀀𝕦̀adhlsuᅋ㡸㡽፲㢑㢠ownáᎳarpoonĀlr㢈㢌efô㠭ighô㠯iƀ;hl㢙㢚㢜䏅»ᏺon»㢚parrows;懈ƀcit㢰㣄㣈ɯ㢶\0\0㣁rnĀ;e㢼㢽挝r»㢽op;挎ng;䅯ri;旹cr;쀀𝓊ƀdir㣙㣝㣢ot;拰lde;䅩iĀ;f㜰㣨»᠓Āam㣯㣲rò㢨l耻ü䃼angle;榧ހABDacdeflnoprsz㤜㤟㤩㤭㦵㦸㦽㧟㧤㧨㧳㧹㧽㨁㨠ròϷarĀ;v㤦㤧櫨;櫩asèϡĀnr㤲㤷grt;榜΀eknprst㓣㥆㥋㥒㥝㥤㦖appá␕othinçẖƀhir㓫⻈㥙opô⾵Ā;hᎷ㥢ïㆍĀiu㥩㥭gmá㎳Ābp㥲㦄setneqĀ;q㥽㦀쀀⊊︀;쀀⫋︀setneqĀ;q㦏㦒쀀⊋︀;쀀⫌︀Āhr㦛㦟etá㚜iangleĀlr㦪㦯eft»थight»ၑy;䐲ash»ံƀelr㧄㧒㧗ƀ;beⷪ㧋㧏ar;抻q;扚lip;拮Ābt㧜ᑨaòᑩr;쀀𝔳tré㦮suĀbp㧯㧱»ജ»൙pf;쀀𝕧roð໻tré㦴Ācu㨆㨋r;쀀𝓋Ābp㨐㨘nĀEe㦀㨖»㥾nĀEe㦒㨞»㦐igzag;榚΀cefoprs㨶㨻㩖㩛㩔㩡㩪irc;䅵Ādi㩀㩑Ābg㩅㩉ar;機eĀ;qᗺ㩏;扙erp;愘r;쀀𝔴pf;쀀𝕨Ā;eᑹ㩦atèᑹcr;쀀𝓌ૣណ㪇\0㪋\0㪐㪛\0\0㪝㪨㪫㪯\0\0㫃㫎\0㫘ៜ៟tré៑r;쀀𝔵ĀAa㪔㪗ròσrò৶;䎾ĀAa㪡㪤ròθrò৫að✓is;拻ƀdptឤ㪵㪾Āfl㪺ឩ;쀀𝕩imåឲĀAa㫇㫊ròώròਁĀcq㫒ីr;쀀𝓍Āpt៖㫜ré។Ѐacefiosu㫰㫽㬈㬌㬑㬕㬛㬡cĀuy㫶㫻te耻ý䃽;䑏Āiy㬂㬆rc;䅷;䑋n耻¥䂥r;쀀𝔶cy;䑗pf;쀀𝕪cr;쀀𝓎Ācm㬦㬩y;䑎l耻ÿ䃿Ԁacdefhiosw㭂㭈㭔㭘㭤㭩㭭㭴㭺㮀cute;䅺Āay㭍㭒ron;䅾;䐷ot;䅼Āet㭝㭡træᕟa;䎶r;쀀𝔷cy;䐶grarr;懝pf;쀀𝕫cr;쀀𝓏Ājn㮅㮇;怍j;怌'.split("").map((e) => e.charCodeAt(0))
), Fd = new Uint16Array(
  // prettier-ignore
  "Ȁaglq	\x1Bɭ\0\0p;䀦os;䀧t;䀾t;䀼uot;䀢".split("").map((e) => e.charCodeAt(0))
);
var cr;
const vd = /* @__PURE__ */ new Map([
  [0, 65533],
  // C1 Unicode control character reference replacements
  [128, 8364],
  [130, 8218],
  [131, 402],
  [132, 8222],
  [133, 8230],
  [134, 8224],
  [135, 8225],
  [136, 710],
  [137, 8240],
  [138, 352],
  [139, 8249],
  [140, 338],
  [142, 381],
  [145, 8216],
  [146, 8217],
  [147, 8220],
  [148, 8221],
  [149, 8226],
  [150, 8211],
  [151, 8212],
  [152, 732],
  [153, 8482],
  [154, 353],
  [155, 8250],
  [156, 339],
  [158, 382],
  [159, 376]
]), Hd = (
  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition, node/no-unsupported-features/es-builtins
  (cr = String.fromCodePoint) !== null && cr !== void 0 ? cr : function(e) {
    let t = "";
    return e > 65535 && (e -= 65536, t += String.fromCharCode(e >>> 10 & 1023 | 55296), e = 56320 | e & 1023), t += String.fromCharCode(e), t;
  }
);
function Ud(e) {
  var t;
  return e >= 55296 && e <= 57343 || e > 1114111 ? 65533 : (t = vd.get(e)) !== null && t !== void 0 ? t : e;
}
var he;
(function(e) {
  e[e.NUM = 35] = "NUM", e[e.SEMI = 59] = "SEMI", e[e.EQUALS = 61] = "EQUALS", e[e.ZERO = 48] = "ZERO", e[e.NINE = 57] = "NINE", e[e.LOWER_A = 97] = "LOWER_A", e[e.LOWER_F = 102] = "LOWER_F", e[e.LOWER_X = 120] = "LOWER_X", e[e.LOWER_Z = 122] = "LOWER_Z", e[e.UPPER_A = 65] = "UPPER_A", e[e.UPPER_F = 70] = "UPPER_F", e[e.UPPER_Z = 90] = "UPPER_Z";
})(he || (he = {}));
const jd = 32;
var Ze;
(function(e) {
  e[e.VALUE_LENGTH = 49152] = "VALUE_LENGTH", e[e.BRANCH_LENGTH = 16256] = "BRANCH_LENGTH", e[e.JUMP_TABLE = 127] = "JUMP_TABLE";
})(Ze || (Ze = {}));
function kr(e) {
  return e >= he.ZERO && e <= he.NINE;
}
function zd(e) {
  return e >= he.UPPER_A && e <= he.UPPER_F || e >= he.LOWER_A && e <= he.LOWER_F;
}
function qd(e) {
  return e >= he.UPPER_A && e <= he.UPPER_Z || e >= he.LOWER_A && e <= he.LOWER_Z || kr(e);
}
function Yd(e) {
  return e === he.EQUALS || qd(e);
}
var de;
(function(e) {
  e[e.EntityStart = 0] = "EntityStart", e[e.NumericStart = 1] = "NumericStart", e[e.NumericDecimal = 2] = "NumericDecimal", e[e.NumericHex = 3] = "NumericHex", e[e.NamedEntity = 4] = "NamedEntity";
})(de || (de = {}));
var Ye;
(function(e) {
  e[e.Legacy = 0] = "Legacy", e[e.Strict = 1] = "Strict", e[e.Attribute = 2] = "Attribute";
})(Ye || (Ye = {}));
class Ha {
  constructor(t, n, r) {
    this.decodeTree = t, this.emitCodePoint = n, this.errors = r, this.state = de.EntityStart, this.consumed = 1, this.result = 0, this.treeIndex = 0, this.excess = 1, this.decodeMode = Ye.Strict;
  }
  /** Resets the instance to make it reusable. */
  startEntity(t) {
    this.decodeMode = t, this.state = de.EntityStart, this.result = 0, this.treeIndex = 0, this.excess = 1, this.consumed = 1;
  }
  /**
   * Write an entity to the decoder. This can be called multiple times with partial entities.
   * If the entity is incomplete, the decoder will return -1.
   *
   * Mirrors the implementation of `getDecoder`, but with the ability to stop decoding if the
   * entity is incomplete, and resume when the next string is written.
   *
   * @param string The string containing the entity (or a continuation of the entity).
   * @param offset The offset at which the entity begins. Should be 0 if this is not the first call.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  write(t, n) {
    switch (this.state) {
      case de.EntityStart:
        return t.charCodeAt(n) === he.NUM ? (this.state = de.NumericStart, this.consumed += 1, this.stateNumericStart(t, n + 1)) : (this.state = de.NamedEntity, this.stateNamedEntity(t, n));
      case de.NumericStart:
        return this.stateNumericStart(t, n);
      case de.NumericDecimal:
        return this.stateNumericDecimal(t, n);
      case de.NumericHex:
        return this.stateNumericHex(t, n);
      case de.NamedEntity:
        return this.stateNamedEntity(t, n);
    }
  }
  /**
   * Switches between the numeric decimal and hexadecimal states.
   *
   * Equivalent to the `Numeric character reference state` in the HTML spec.
   *
   * @param str The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  stateNumericStart(t, n) {
    return n >= t.length ? -1 : (t.charCodeAt(n) | jd) === he.LOWER_X ? (this.state = de.NumericHex, this.consumed += 1, this.stateNumericHex(t, n + 1)) : (this.state = de.NumericDecimal, this.stateNumericDecimal(t, n));
  }
  addToNumericResult(t, n, r, u) {
    if (n !== r) {
      const a = r - n;
      this.result = this.result * Math.pow(u, a) + parseInt(t.substr(n, a), u), this.consumed += a;
    }
  }
  /**
   * Parses a hexadecimal numeric entity.
   *
   * Equivalent to the `Hexademical character reference state` in the HTML spec.
   *
   * @param str The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  stateNumericHex(t, n) {
    const r = n;
    for (; n < t.length; ) {
      const u = t.charCodeAt(n);
      if (kr(u) || zd(u))
        n += 1;
      else
        return this.addToNumericResult(t, r, n, 16), this.emitNumericEntity(u, 3);
    }
    return this.addToNumericResult(t, r, n, 16), -1;
  }
  /**
   * Parses a decimal numeric entity.
   *
   * Equivalent to the `Decimal character reference state` in the HTML spec.
   *
   * @param str The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  stateNumericDecimal(t, n) {
    const r = n;
    for (; n < t.length; ) {
      const u = t.charCodeAt(n);
      if (kr(u))
        n += 1;
      else
        return this.addToNumericResult(t, r, n, 10), this.emitNumericEntity(u, 2);
    }
    return this.addToNumericResult(t, r, n, 10), -1;
  }
  /**
   * Validate and emit a numeric entity.
   *
   * Implements the logic from the `Hexademical character reference start
   * state` and `Numeric character reference end state` in the HTML spec.
   *
   * @param lastCp The last code point of the entity. Used to see if the
   *               entity was terminated with a semicolon.
   * @param expectedLength The minimum number of characters that should be
   *                       consumed. Used to validate that at least one digit
   *                       was consumed.
   * @returns The number of characters that were consumed.
   */
  emitNumericEntity(t, n) {
    var r;
    if (this.consumed <= n)
      return (r = this.errors) === null || r === void 0 || r.absenceOfDigitsInNumericCharacterReference(this.consumed), 0;
    if (t === he.SEMI)
      this.consumed += 1;
    else if (this.decodeMode === Ye.Strict)
      return 0;
    return this.emitCodePoint(Ud(this.result), this.consumed), this.errors && (t !== he.SEMI && this.errors.missingSemicolonAfterCharacterReference(), this.errors.validateNumericCharacterReference(this.result)), this.consumed;
  }
  /**
   * Parses a named entity.
   *
   * Equivalent to the `Named character reference state` in the HTML spec.
   *
   * @param str The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  stateNamedEntity(t, n) {
    const { decodeTree: r } = this;
    let u = r[this.treeIndex], a = (u & Ze.VALUE_LENGTH) >> 14;
    for (; n < t.length; n++, this.excess++) {
      const i = t.charCodeAt(n);
      if (this.treeIndex = Vd(r, u, this.treeIndex + Math.max(1, a), i), this.treeIndex < 0)
        return this.result === 0 || // If we are parsing an attribute
        this.decodeMode === Ye.Attribute && // We shouldn't have consumed any characters after the entity,
        (a === 0 || // And there should be no invalid characters.
        Yd(i)) ? 0 : this.emitNotTerminatedNamedEntity();
      if (u = r[this.treeIndex], a = (u & Ze.VALUE_LENGTH) >> 14, a !== 0) {
        if (i === he.SEMI)
          return this.emitNamedEntityData(this.treeIndex, a, this.consumed + this.excess);
        this.decodeMode !== Ye.Strict && (this.result = this.treeIndex, this.consumed += this.excess, this.excess = 0);
      }
    }
    return -1;
  }
  /**
   * Emit a named entity that was not terminated with a semicolon.
   *
   * @returns The number of characters consumed.
   */
  emitNotTerminatedNamedEntity() {
    var t;
    const { result: n, decodeTree: r } = this, u = (r[n] & Ze.VALUE_LENGTH) >> 14;
    return this.emitNamedEntityData(n, u, this.consumed), (t = this.errors) === null || t === void 0 || t.missingSemicolonAfterCharacterReference(), this.consumed;
  }
  /**
   * Emit a named entity.
   *
   * @param result The index of the entity in the decode tree.
   * @param valueLength The number of bytes in the entity.
   * @param consumed The number of characters consumed.
   *
   * @returns The number of characters consumed.
   */
  emitNamedEntityData(t, n, r) {
    const { decodeTree: u } = this;
    return this.emitCodePoint(n === 1 ? u[t] & ~Ze.VALUE_LENGTH : u[t + 1], r), n === 3 && this.emitCodePoint(u[t + 2], r), r;
  }
  /**
   * Signal to the parser that the end of the input was reached.
   *
   * Remaining data will be emitted and relevant errors will be produced.
   *
   * @returns The number of characters consumed.
   */
  end() {
    var t;
    switch (this.state) {
      case de.NamedEntity:
        return this.result !== 0 && (this.decodeMode !== Ye.Attribute || this.result === this.treeIndex) ? this.emitNotTerminatedNamedEntity() : 0;
      // Otherwise, emit a numeric entity if we have one.
      case de.NumericDecimal:
        return this.emitNumericEntity(0, 2);
      case de.NumericHex:
        return this.emitNumericEntity(0, 3);
      case de.NumericStart:
        return (t = this.errors) === null || t === void 0 || t.absenceOfDigitsInNumericCharacterReference(this.consumed), 0;
      case de.EntityStart:
        return 0;
    }
  }
}
function Ua(e) {
  let t = "";
  const n = new Ha(e, (r) => t += Hd(r));
  return function(u, a) {
    let i = 0, o = 0;
    for (; (o = u.indexOf("&", o)) >= 0; ) {
      t += u.slice(i, o), n.startEntity(a);
      const c = n.write(
        u,
        // Skip the "&"
        o + 1
      );
      if (c < 0) {
        i = o + n.end();
        break;
      }
      i = o + c, o = c === 0 ? i + 1 : i;
    }
    const l = t + u.slice(i);
    return t = "", l;
  };
}
function Vd(e, t, n, r) {
  const u = (t & Ze.BRANCH_LENGTH) >> 7, a = t & Ze.JUMP_TABLE;
  if (u === 0)
    return a !== 0 && r === a ? n : -1;
  if (a) {
    const l = r - a;
    return l < 0 || l >= u ? -1 : e[n + l] - 1;
  }
  let i = n, o = i + u - 1;
  for (; i <= o; ) {
    const l = i + o >>> 1, c = e[l];
    if (c < r)
      i = l + 1;
    else if (c > r)
      o = l - 1;
    else
      return e[l + u];
  }
  return -1;
}
Ua(va);
Ua(Fd);
var D;
(function(e) {
  e.HTML = "http://www.w3.org/1999/xhtml", e.MATHML = "http://www.w3.org/1998/Math/MathML", e.SVG = "http://www.w3.org/2000/svg", e.XLINK = "http://www.w3.org/1999/xlink", e.XML = "http://www.w3.org/XML/1998/namespace", e.XMLNS = "http://www.w3.org/2000/xmlns/";
})(D || (D = {}));
var ct;
(function(e) {
  e.TYPE = "type", e.ACTION = "action", e.ENCODING = "encoding", e.PROMPT = "prompt", e.NAME = "name", e.COLOR = "color", e.FACE = "face", e.SIZE = "size";
})(ct || (ct = {}));
var ke;
(function(e) {
  e.NO_QUIRKS = "no-quirks", e.QUIRKS = "quirks", e.LIMITED_QUIRKS = "limited-quirks";
})(ke || (ke = {}));
var x;
(function(e) {
  e.A = "a", e.ADDRESS = "address", e.ANNOTATION_XML = "annotation-xml", e.APPLET = "applet", e.AREA = "area", e.ARTICLE = "article", e.ASIDE = "aside", e.B = "b", e.BASE = "base", e.BASEFONT = "basefont", e.BGSOUND = "bgsound", e.BIG = "big", e.BLOCKQUOTE = "blockquote", e.BODY = "body", e.BR = "br", e.BUTTON = "button", e.CAPTION = "caption", e.CENTER = "center", e.CODE = "code", e.COL = "col", e.COLGROUP = "colgroup", e.DD = "dd", e.DESC = "desc", e.DETAILS = "details", e.DIALOG = "dialog", e.DIR = "dir", e.DIV = "div", e.DL = "dl", e.DT = "dt", e.EM = "em", e.EMBED = "embed", e.FIELDSET = "fieldset", e.FIGCAPTION = "figcaption", e.FIGURE = "figure", e.FONT = "font", e.FOOTER = "footer", e.FOREIGN_OBJECT = "foreignObject", e.FORM = "form", e.FRAME = "frame", e.FRAMESET = "frameset", e.H1 = "h1", e.H2 = "h2", e.H3 = "h3", e.H4 = "h4", e.H5 = "h5", e.H6 = "h6", e.HEAD = "head", e.HEADER = "header", e.HGROUP = "hgroup", e.HR = "hr", e.HTML = "html", e.I = "i", e.IMG = "img", e.IMAGE = "image", e.INPUT = "input", e.IFRAME = "iframe", e.KEYGEN = "keygen", e.LABEL = "label", e.LI = "li", e.LINK = "link", e.LISTING = "listing", e.MAIN = "main", e.MALIGNMARK = "malignmark", e.MARQUEE = "marquee", e.MATH = "math", e.MENU = "menu", e.META = "meta", e.MGLYPH = "mglyph", e.MI = "mi", e.MO = "mo", e.MN = "mn", e.MS = "ms", e.MTEXT = "mtext", e.NAV = "nav", e.NOBR = "nobr", e.NOFRAMES = "noframes", e.NOEMBED = "noembed", e.NOSCRIPT = "noscript", e.OBJECT = "object", e.OL = "ol", e.OPTGROUP = "optgroup", e.OPTION = "option", e.P = "p", e.PARAM = "param", e.PLAINTEXT = "plaintext", e.PRE = "pre", e.RB = "rb", e.RP = "rp", e.RT = "rt", e.RTC = "rtc", e.RUBY = "ruby", e.S = "s", e.SCRIPT = "script", e.SEARCH = "search", e.SECTION = "section", e.SELECT = "select", e.SOURCE = "source", e.SMALL = "small", e.SPAN = "span", e.STRIKE = "strike", e.STRONG = "strong", e.STYLE = "style", e.SUB = "sub", e.SUMMARY = "summary", e.SUP = "sup", e.TABLE = "table", e.TBODY = "tbody", e.TEMPLATE = "template", e.TEXTAREA = "textarea", e.TFOOT = "tfoot", e.TD = "td", e.TH = "th", e.THEAD = "thead", e.TITLE = "title", e.TR = "tr", e.TRACK = "track", e.TT = "tt", e.U = "u", e.UL = "ul", e.SVG = "svg", e.VAR = "var", e.WBR = "wbr", e.XMP = "xmp";
})(x || (x = {}));
var s;
(function(e) {
  e[e.UNKNOWN = 0] = "UNKNOWN", e[e.A = 1] = "A", e[e.ADDRESS = 2] = "ADDRESS", e[e.ANNOTATION_XML = 3] = "ANNOTATION_XML", e[e.APPLET = 4] = "APPLET", e[e.AREA = 5] = "AREA", e[e.ARTICLE = 6] = "ARTICLE", e[e.ASIDE = 7] = "ASIDE", e[e.B = 8] = "B", e[e.BASE = 9] = "BASE", e[e.BASEFONT = 10] = "BASEFONT", e[e.BGSOUND = 11] = "BGSOUND", e[e.BIG = 12] = "BIG", e[e.BLOCKQUOTE = 13] = "BLOCKQUOTE", e[e.BODY = 14] = "BODY", e[e.BR = 15] = "BR", e[e.BUTTON = 16] = "BUTTON", e[e.CAPTION = 17] = "CAPTION", e[e.CENTER = 18] = "CENTER", e[e.CODE = 19] = "CODE", e[e.COL = 20] = "COL", e[e.COLGROUP = 21] = "COLGROUP", e[e.DD = 22] = "DD", e[e.DESC = 23] = "DESC", e[e.DETAILS = 24] = "DETAILS", e[e.DIALOG = 25] = "DIALOG", e[e.DIR = 26] = "DIR", e[e.DIV = 27] = "DIV", e[e.DL = 28] = "DL", e[e.DT = 29] = "DT", e[e.EM = 30] = "EM", e[e.EMBED = 31] = "EMBED", e[e.FIELDSET = 32] = "FIELDSET", e[e.FIGCAPTION = 33] = "FIGCAPTION", e[e.FIGURE = 34] = "FIGURE", e[e.FONT = 35] = "FONT", e[e.FOOTER = 36] = "FOOTER", e[e.FOREIGN_OBJECT = 37] = "FOREIGN_OBJECT", e[e.FORM = 38] = "FORM", e[e.FRAME = 39] = "FRAME", e[e.FRAMESET = 40] = "FRAMESET", e[e.H1 = 41] = "H1", e[e.H2 = 42] = "H2", e[e.H3 = 43] = "H3", e[e.H4 = 44] = "H4", e[e.H5 = 45] = "H5", e[e.H6 = 46] = "H6", e[e.HEAD = 47] = "HEAD", e[e.HEADER = 48] = "HEADER", e[e.HGROUP = 49] = "HGROUP", e[e.HR = 50] = "HR", e[e.HTML = 51] = "HTML", e[e.I = 52] = "I", e[e.IMG = 53] = "IMG", e[e.IMAGE = 54] = "IMAGE", e[e.INPUT = 55] = "INPUT", e[e.IFRAME = 56] = "IFRAME", e[e.KEYGEN = 57] = "KEYGEN", e[e.LABEL = 58] = "LABEL", e[e.LI = 59] = "LI", e[e.LINK = 60] = "LINK", e[e.LISTING = 61] = "LISTING", e[e.MAIN = 62] = "MAIN", e[e.MALIGNMARK = 63] = "MALIGNMARK", e[e.MARQUEE = 64] = "MARQUEE", e[e.MATH = 65] = "MATH", e[e.MENU = 66] = "MENU", e[e.META = 67] = "META", e[e.MGLYPH = 68] = "MGLYPH", e[e.MI = 69] = "MI", e[e.MO = 70] = "MO", e[e.MN = 71] = "MN", e[e.MS = 72] = "MS", e[e.MTEXT = 73] = "MTEXT", e[e.NAV = 74] = "NAV", e[e.NOBR = 75] = "NOBR", e[e.NOFRAMES = 76] = "NOFRAMES", e[e.NOEMBED = 77] = "NOEMBED", e[e.NOSCRIPT = 78] = "NOSCRIPT", e[e.OBJECT = 79] = "OBJECT", e[e.OL = 80] = "OL", e[e.OPTGROUP = 81] = "OPTGROUP", e[e.OPTION = 82] = "OPTION", e[e.P = 83] = "P", e[e.PARAM = 84] = "PARAM", e[e.PLAINTEXT = 85] = "PLAINTEXT", e[e.PRE = 86] = "PRE", e[e.RB = 87] = "RB", e[e.RP = 88] = "RP", e[e.RT = 89] = "RT", e[e.RTC = 90] = "RTC", e[e.RUBY = 91] = "RUBY", e[e.S = 92] = "S", e[e.SCRIPT = 93] = "SCRIPT", e[e.SEARCH = 94] = "SEARCH", e[e.SECTION = 95] = "SECTION", e[e.SELECT = 96] = "SELECT", e[e.SOURCE = 97] = "SOURCE", e[e.SMALL = 98] = "SMALL", e[e.SPAN = 99] = "SPAN", e[e.STRIKE = 100] = "STRIKE", e[e.STRONG = 101] = "STRONG", e[e.STYLE = 102] = "STYLE", e[e.SUB = 103] = "SUB", e[e.SUMMARY = 104] = "SUMMARY", e[e.SUP = 105] = "SUP", e[e.TABLE = 106] = "TABLE", e[e.TBODY = 107] = "TBODY", e[e.TEMPLATE = 108] = "TEMPLATE", e[e.TEXTAREA = 109] = "TEXTAREA", e[e.TFOOT = 110] = "TFOOT", e[e.TD = 111] = "TD", e[e.TH = 112] = "TH", e[e.THEAD = 113] = "THEAD", e[e.TITLE = 114] = "TITLE", e[e.TR = 115] = "TR", e[e.TRACK = 116] = "TRACK", e[e.TT = 117] = "TT", e[e.U = 118] = "U", e[e.UL = 119] = "UL", e[e.SVG = 120] = "SVG", e[e.VAR = 121] = "VAR", e[e.WBR = 122] = "WBR", e[e.XMP = 123] = "XMP";
})(s || (s = {}));
const Wd = /* @__PURE__ */ new Map([
  [x.A, s.A],
  [x.ADDRESS, s.ADDRESS],
  [x.ANNOTATION_XML, s.ANNOTATION_XML],
  [x.APPLET, s.APPLET],
  [x.AREA, s.AREA],
  [x.ARTICLE, s.ARTICLE],
  [x.ASIDE, s.ASIDE],
  [x.B, s.B],
  [x.BASE, s.BASE],
  [x.BASEFONT, s.BASEFONT],
  [x.BGSOUND, s.BGSOUND],
  [x.BIG, s.BIG],
  [x.BLOCKQUOTE, s.BLOCKQUOTE],
  [x.BODY, s.BODY],
  [x.BR, s.BR],
  [x.BUTTON, s.BUTTON],
  [x.CAPTION, s.CAPTION],
  [x.CENTER, s.CENTER],
  [x.CODE, s.CODE],
  [x.COL, s.COL],
  [x.COLGROUP, s.COLGROUP],
  [x.DD, s.DD],
  [x.DESC, s.DESC],
  [x.DETAILS, s.DETAILS],
  [x.DIALOG, s.DIALOG],
  [x.DIR, s.DIR],
  [x.DIV, s.DIV],
  [x.DL, s.DL],
  [x.DT, s.DT],
  [x.EM, s.EM],
  [x.EMBED, s.EMBED],
  [x.FIELDSET, s.FIELDSET],
  [x.FIGCAPTION, s.FIGCAPTION],
  [x.FIGURE, s.FIGURE],
  [x.FONT, s.FONT],
  [x.FOOTER, s.FOOTER],
  [x.FOREIGN_OBJECT, s.FOREIGN_OBJECT],
  [x.FORM, s.FORM],
  [x.FRAME, s.FRAME],
  [x.FRAMESET, s.FRAMESET],
  [x.H1, s.H1],
  [x.H2, s.H2],
  [x.H3, s.H3],
  [x.H4, s.H4],
  [x.H5, s.H5],
  [x.H6, s.H6],
  [x.HEAD, s.HEAD],
  [x.HEADER, s.HEADER],
  [x.HGROUP, s.HGROUP],
  [x.HR, s.HR],
  [x.HTML, s.HTML],
  [x.I, s.I],
  [x.IMG, s.IMG],
  [x.IMAGE, s.IMAGE],
  [x.INPUT, s.INPUT],
  [x.IFRAME, s.IFRAME],
  [x.KEYGEN, s.KEYGEN],
  [x.LABEL, s.LABEL],
  [x.LI, s.LI],
  [x.LINK, s.LINK],
  [x.LISTING, s.LISTING],
  [x.MAIN, s.MAIN],
  [x.MALIGNMARK, s.MALIGNMARK],
  [x.MARQUEE, s.MARQUEE],
  [x.MATH, s.MATH],
  [x.MENU, s.MENU],
  [x.META, s.META],
  [x.MGLYPH, s.MGLYPH],
  [x.MI, s.MI],
  [x.MO, s.MO],
  [x.MN, s.MN],
  [x.MS, s.MS],
  [x.MTEXT, s.MTEXT],
  [x.NAV, s.NAV],
  [x.NOBR, s.NOBR],
  [x.NOFRAMES, s.NOFRAMES],
  [x.NOEMBED, s.NOEMBED],
  [x.NOSCRIPT, s.NOSCRIPT],
  [x.OBJECT, s.OBJECT],
  [x.OL, s.OL],
  [x.OPTGROUP, s.OPTGROUP],
  [x.OPTION, s.OPTION],
  [x.P, s.P],
  [x.PARAM, s.PARAM],
  [x.PLAINTEXT, s.PLAINTEXT],
  [x.PRE, s.PRE],
  [x.RB, s.RB],
  [x.RP, s.RP],
  [x.RT, s.RT],
  [x.RTC, s.RTC],
  [x.RUBY, s.RUBY],
  [x.S, s.S],
  [x.SCRIPT, s.SCRIPT],
  [x.SEARCH, s.SEARCH],
  [x.SECTION, s.SECTION],
  [x.SELECT, s.SELECT],
  [x.SOURCE, s.SOURCE],
  [x.SMALL, s.SMALL],
  [x.SPAN, s.SPAN],
  [x.STRIKE, s.STRIKE],
  [x.STRONG, s.STRONG],
  [x.STYLE, s.STYLE],
  [x.SUB, s.SUB],
  [x.SUMMARY, s.SUMMARY],
  [x.SUP, s.SUP],
  [x.TABLE, s.TABLE],
  [x.TBODY, s.TBODY],
  [x.TEMPLATE, s.TEMPLATE],
  [x.TEXTAREA, s.TEXTAREA],
  [x.TFOOT, s.TFOOT],
  [x.TD, s.TD],
  [x.TH, s.TH],
  [x.THEAD, s.THEAD],
  [x.TITLE, s.TITLE],
  [x.TR, s.TR],
  [x.TRACK, s.TRACK],
  [x.TT, s.TT],
  [x.U, s.U],
  [x.UL, s.UL],
  [x.SVG, s.SVG],
  [x.VAR, s.VAR],
  [x.WBR, s.WBR],
  [x.XMP, s.XMP]
]);
function Rt(e) {
  var t;
  return (t = Wd.get(e)) !== null && t !== void 0 ? t : s.UNKNOWN;
}
const P = s, Qd = {
  [D.HTML]: /* @__PURE__ */ new Set([
    P.ADDRESS,
    P.APPLET,
    P.AREA,
    P.ARTICLE,
    P.ASIDE,
    P.BASE,
    P.BASEFONT,
    P.BGSOUND,
    P.BLOCKQUOTE,
    P.BODY,
    P.BR,
    P.BUTTON,
    P.CAPTION,
    P.CENTER,
    P.COL,
    P.COLGROUP,
    P.DD,
    P.DETAILS,
    P.DIR,
    P.DIV,
    P.DL,
    P.DT,
    P.EMBED,
    P.FIELDSET,
    P.FIGCAPTION,
    P.FIGURE,
    P.FOOTER,
    P.FORM,
    P.FRAME,
    P.FRAMESET,
    P.H1,
    P.H2,
    P.H3,
    P.H4,
    P.H5,
    P.H6,
    P.HEAD,
    P.HEADER,
    P.HGROUP,
    P.HR,
    P.HTML,
    P.IFRAME,
    P.IMG,
    P.INPUT,
    P.LI,
    P.LINK,
    P.LISTING,
    P.MAIN,
    P.MARQUEE,
    P.MENU,
    P.META,
    P.NAV,
    P.NOEMBED,
    P.NOFRAMES,
    P.NOSCRIPT,
    P.OBJECT,
    P.OL,
    P.P,
    P.PARAM,
    P.PLAINTEXT,
    P.PRE,
    P.SCRIPT,
    P.SECTION,
    P.SELECT,
    P.SOURCE,
    P.STYLE,
    P.SUMMARY,
    P.TABLE,
    P.TBODY,
    P.TD,
    P.TEMPLATE,
    P.TEXTAREA,
    P.TFOOT,
    P.TH,
    P.THEAD,
    P.TITLE,
    P.TR,
    P.TRACK,
    P.UL,
    P.WBR,
    P.XMP
  ]),
  [D.MATHML]: /* @__PURE__ */ new Set([P.MI, P.MO, P.MN, P.MS, P.MTEXT, P.ANNOTATION_XML]),
  [D.SVG]: /* @__PURE__ */ new Set([P.TITLE, P.FOREIGN_OBJECT, P.DESC]),
  [D.XLINK]: /* @__PURE__ */ new Set(),
  [D.XML]: /* @__PURE__ */ new Set(),
  [D.XMLNS]: /* @__PURE__ */ new Set()
}, yr = /* @__PURE__ */ new Set([P.H1, P.H2, P.H3, P.H4, P.H5, P.H6]);
x.STYLE, x.SCRIPT, x.XMP, x.IFRAME, x.NOEMBED, x.NOFRAMES, x.PLAINTEXT;
var E;
(function(e) {
  e[e.DATA = 0] = "DATA", e[e.RCDATA = 1] = "RCDATA", e[e.RAWTEXT = 2] = "RAWTEXT", e[e.SCRIPT_DATA = 3] = "SCRIPT_DATA", e[e.PLAINTEXT = 4] = "PLAINTEXT", e[e.TAG_OPEN = 5] = "TAG_OPEN", e[e.END_TAG_OPEN = 6] = "END_TAG_OPEN", e[e.TAG_NAME = 7] = "TAG_NAME", e[e.RCDATA_LESS_THAN_SIGN = 8] = "RCDATA_LESS_THAN_SIGN", e[e.RCDATA_END_TAG_OPEN = 9] = "RCDATA_END_TAG_OPEN", e[e.RCDATA_END_TAG_NAME = 10] = "RCDATA_END_TAG_NAME", e[e.RAWTEXT_LESS_THAN_SIGN = 11] = "RAWTEXT_LESS_THAN_SIGN", e[e.RAWTEXT_END_TAG_OPEN = 12] = "RAWTEXT_END_TAG_OPEN", e[e.RAWTEXT_END_TAG_NAME = 13] = "RAWTEXT_END_TAG_NAME", e[e.SCRIPT_DATA_LESS_THAN_SIGN = 14] = "SCRIPT_DATA_LESS_THAN_SIGN", e[e.SCRIPT_DATA_END_TAG_OPEN = 15] = "SCRIPT_DATA_END_TAG_OPEN", e[e.SCRIPT_DATA_END_TAG_NAME = 16] = "SCRIPT_DATA_END_TAG_NAME", e[e.SCRIPT_DATA_ESCAPE_START = 17] = "SCRIPT_DATA_ESCAPE_START", e[e.SCRIPT_DATA_ESCAPE_START_DASH = 18] = "SCRIPT_DATA_ESCAPE_START_DASH", e[e.SCRIPT_DATA_ESCAPED = 19] = "SCRIPT_DATA_ESCAPED", e[e.SCRIPT_DATA_ESCAPED_DASH = 20] = "SCRIPT_DATA_ESCAPED_DASH", e[e.SCRIPT_DATA_ESCAPED_DASH_DASH = 21] = "SCRIPT_DATA_ESCAPED_DASH_DASH", e[e.SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN = 22] = "SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN", e[e.SCRIPT_DATA_ESCAPED_END_TAG_OPEN = 23] = "SCRIPT_DATA_ESCAPED_END_TAG_OPEN", e[e.SCRIPT_DATA_ESCAPED_END_TAG_NAME = 24] = "SCRIPT_DATA_ESCAPED_END_TAG_NAME", e[e.SCRIPT_DATA_DOUBLE_ESCAPE_START = 25] = "SCRIPT_DATA_DOUBLE_ESCAPE_START", e[e.SCRIPT_DATA_DOUBLE_ESCAPED = 26] = "SCRIPT_DATA_DOUBLE_ESCAPED", e[e.SCRIPT_DATA_DOUBLE_ESCAPED_DASH = 27] = "SCRIPT_DATA_DOUBLE_ESCAPED_DASH", e[e.SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH = 28] = "SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH", e[e.SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN = 29] = "SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN", e[e.SCRIPT_DATA_DOUBLE_ESCAPE_END = 30] = "SCRIPT_DATA_DOUBLE_ESCAPE_END", e[e.BEFORE_ATTRIBUTE_NAME = 31] = "BEFORE_ATTRIBUTE_NAME", e[e.ATTRIBUTE_NAME = 32] = "ATTRIBUTE_NAME", e[e.AFTER_ATTRIBUTE_NAME = 33] = "AFTER_ATTRIBUTE_NAME", e[e.BEFORE_ATTRIBUTE_VALUE = 34] = "BEFORE_ATTRIBUTE_VALUE", e[e.ATTRIBUTE_VALUE_DOUBLE_QUOTED = 35] = "ATTRIBUTE_VALUE_DOUBLE_QUOTED", e[e.ATTRIBUTE_VALUE_SINGLE_QUOTED = 36] = "ATTRIBUTE_VALUE_SINGLE_QUOTED", e[e.ATTRIBUTE_VALUE_UNQUOTED = 37] = "ATTRIBUTE_VALUE_UNQUOTED", e[e.AFTER_ATTRIBUTE_VALUE_QUOTED = 38] = "AFTER_ATTRIBUTE_VALUE_QUOTED", e[e.SELF_CLOSING_START_TAG = 39] = "SELF_CLOSING_START_TAG", e[e.BOGUS_COMMENT = 40] = "BOGUS_COMMENT", e[e.MARKUP_DECLARATION_OPEN = 41] = "MARKUP_DECLARATION_OPEN", e[e.COMMENT_START = 42] = "COMMENT_START", e[e.COMMENT_START_DASH = 43] = "COMMENT_START_DASH", e[e.COMMENT = 44] = "COMMENT", e[e.COMMENT_LESS_THAN_SIGN = 45] = "COMMENT_LESS_THAN_SIGN", e[e.COMMENT_LESS_THAN_SIGN_BANG = 46] = "COMMENT_LESS_THAN_SIGN_BANG", e[e.COMMENT_LESS_THAN_SIGN_BANG_DASH = 47] = "COMMENT_LESS_THAN_SIGN_BANG_DASH", e[e.COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH = 48] = "COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH", e[e.COMMENT_END_DASH = 49] = "COMMENT_END_DASH", e[e.COMMENT_END = 50] = "COMMENT_END", e[e.COMMENT_END_BANG = 51] = "COMMENT_END_BANG", e[e.DOCTYPE = 52] = "DOCTYPE", e[e.BEFORE_DOCTYPE_NAME = 53] = "BEFORE_DOCTYPE_NAME", e[e.DOCTYPE_NAME = 54] = "DOCTYPE_NAME", e[e.AFTER_DOCTYPE_NAME = 55] = "AFTER_DOCTYPE_NAME", e[e.AFTER_DOCTYPE_PUBLIC_KEYWORD = 56] = "AFTER_DOCTYPE_PUBLIC_KEYWORD", e[e.BEFORE_DOCTYPE_PUBLIC_IDENTIFIER = 57] = "BEFORE_DOCTYPE_PUBLIC_IDENTIFIER", e[e.DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED = 58] = "DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED", e[e.DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED = 59] = "DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED", e[e.AFTER_DOCTYPE_PUBLIC_IDENTIFIER = 60] = "AFTER_DOCTYPE_PUBLIC_IDENTIFIER", e[e.BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS = 61] = "BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS", e[e.AFTER_DOCTYPE_SYSTEM_KEYWORD = 62] = "AFTER_DOCTYPE_SYSTEM_KEYWORD", e[e.BEFORE_DOCTYPE_SYSTEM_IDENTIFIER = 63] = "BEFORE_DOCTYPE_SYSTEM_IDENTIFIER", e[e.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED = 64] = "DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED", e[e.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED = 65] = "DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED", e[e.AFTER_DOCTYPE_SYSTEM_IDENTIFIER = 66] = "AFTER_DOCTYPE_SYSTEM_IDENTIFIER", e[e.BOGUS_DOCTYPE = 67] = "BOGUS_DOCTYPE", e[e.CDATA_SECTION = 68] = "CDATA_SECTION", e[e.CDATA_SECTION_BRACKET = 69] = "CDATA_SECTION_BRACKET", e[e.CDATA_SECTION_END = 70] = "CDATA_SECTION_END", e[e.CHARACTER_REFERENCE = 71] = "CHARACTER_REFERENCE", e[e.AMBIGUOUS_AMPERSAND = 72] = "AMBIGUOUS_AMPERSAND";
})(E || (E = {}));
const se = {
  DATA: E.DATA,
  RCDATA: E.RCDATA,
  RAWTEXT: E.RAWTEXT,
  SCRIPT_DATA: E.SCRIPT_DATA,
  PLAINTEXT: E.PLAINTEXT,
  CDATA_SECTION: E.CDATA_SECTION
};
function Gd(e) {
  return e >= p.DIGIT_0 && e <= p.DIGIT_9;
}
function qt(e) {
  return e >= p.LATIN_CAPITAL_A && e <= p.LATIN_CAPITAL_Z;
}
function $d(e) {
  return e >= p.LATIN_SMALL_A && e <= p.LATIN_SMALL_Z;
}
function Ke(e) {
  return $d(e) || qt(e);
}
function ui(e) {
  return Ke(e) || Gd(e);
}
function mn(e) {
  return e + 32;
}
function ja(e) {
  return e === p.SPACE || e === p.LINE_FEED || e === p.TABULATION || e === p.FORM_FEED;
}
function ii(e) {
  return ja(e) || e === p.SOLIDUS || e === p.GREATER_THAN_SIGN;
}
function Kd(e) {
  return e === p.NULL ? k.nullCharacterReference : e > 1114111 ? k.characterReferenceOutsideUnicodeRange : wa(e) ? k.surrogateCharacterReference : Ba(e) ? k.noncharacterCharacterReference : Ma(e) || e === p.CARRIAGE_RETURN ? k.controlCharacterReference : null;
}
class Xd {
  constructor(t, n) {
    this.options = t, this.handler = n, this.paused = !1, this.inLoop = !1, this.inForeignNode = !1, this.lastStartTagName = "", this.active = !1, this.state = E.DATA, this.returnState = E.DATA, this.entityStartPos = 0, this.consumedAfterSnapshot = -1, this.currentCharacterToken = null, this.currentToken = null, this.currentAttr = { name: "", value: "" }, this.preprocessor = new Bd(n), this.currentLocation = this.getCurrentLocation(-1), this.entityDecoder = new Ha(va, (r, u) => {
      this.preprocessor.pos = this.entityStartPos + u - 1, this._flushCodePointConsumedAsCharacterReference(r);
    }, n.onParseError ? {
      missingSemicolonAfterCharacterReference: () => {
        this._err(k.missingSemicolonAfterCharacterReference, 1);
      },
      absenceOfDigitsInNumericCharacterReference: (r) => {
        this._err(k.absenceOfDigitsInNumericCharacterReference, this.entityStartPos - this.preprocessor.pos + r);
      },
      validateNumericCharacterReference: (r) => {
        const u = Kd(r);
        u && this._err(u, 1);
      }
    } : void 0);
  }
  //Errors
  _err(t, n = 0) {
    var r, u;
    (u = (r = this.handler).onParseError) === null || u === void 0 || u.call(r, this.preprocessor.getError(t, n));
  }
  // NOTE: `offset` may never run across line boundaries.
  getCurrentLocation(t) {
    return this.options.sourceCodeLocationInfo ? {
      startLine: this.preprocessor.line,
      startCol: this.preprocessor.col - t,
      startOffset: this.preprocessor.offset - t,
      endLine: -1,
      endCol: -1,
      endOffset: -1
    } : null;
  }
  _runParsingLoop() {
    if (!this.inLoop) {
      for (this.inLoop = !0; this.active && !this.paused; ) {
        this.consumedAfterSnapshot = 0;
        const t = this._consume();
        this._ensureHibernation() || this._callState(t);
      }
      this.inLoop = !1;
    }
  }
  //API
  pause() {
    this.paused = !0;
  }
  resume(t) {
    if (!this.paused)
      throw new Error("Parser was already resumed");
    this.paused = !1, !this.inLoop && (this._runParsingLoop(), this.paused || t?.());
  }
  write(t, n, r) {
    this.active = !0, this.preprocessor.write(t, n), this._runParsingLoop(), this.paused || r?.();
  }
  insertHtmlAtCurrentPos(t) {
    this.active = !0, this.preprocessor.insertHtmlAtCurrentPos(t), this._runParsingLoop();
  }
  //Hibernation
  _ensureHibernation() {
    return this.preprocessor.endOfChunkHit ? (this.preprocessor.retreat(this.consumedAfterSnapshot), this.consumedAfterSnapshot = 0, this.active = !1, !0) : !1;
  }
  //Consumption
  _consume() {
    return this.consumedAfterSnapshot++, this.preprocessor.advance();
  }
  _advanceBy(t) {
    this.consumedAfterSnapshot += t;
    for (let n = 0; n < t; n++)
      this.preprocessor.advance();
  }
  _consumeSequenceIfMatch(t, n) {
    return this.preprocessor.startsWith(t, n) ? (this._advanceBy(t.length - 1), !0) : !1;
  }
  //Token creation
  _createStartTagToken() {
    this.currentToken = {
      type: V.START_TAG,
      tagName: "",
      tagID: s.UNKNOWN,
      selfClosing: !1,
      ackSelfClosing: !1,
      attrs: [],
      location: this.getCurrentLocation(1)
    };
  }
  _createEndTagToken() {
    this.currentToken = {
      type: V.END_TAG,
      tagName: "",
      tagID: s.UNKNOWN,
      selfClosing: !1,
      ackSelfClosing: !1,
      attrs: [],
      location: this.getCurrentLocation(2)
    };
  }
  _createCommentToken(t) {
    this.currentToken = {
      type: V.COMMENT,
      data: "",
      location: this.getCurrentLocation(t)
    };
  }
  _createDoctypeToken(t) {
    this.currentToken = {
      type: V.DOCTYPE,
      name: t,
      forceQuirks: !1,
      publicId: null,
      systemId: null,
      location: this.currentLocation
    };
  }
  _createCharacterToken(t, n) {
    this.currentCharacterToken = {
      type: t,
      chars: n,
      location: this.currentLocation
    };
  }
  //Tag attributes
  _createAttr(t) {
    this.currentAttr = {
      name: t,
      value: ""
    }, this.currentLocation = this.getCurrentLocation(0);
  }
  _leaveAttrName() {
    var t, n;
    const r = this.currentToken;
    if (Fa(r, this.currentAttr.name) === null) {
      if (r.attrs.push(this.currentAttr), r.location && this.currentLocation) {
        const u = (t = (n = r.location).attrs) !== null && t !== void 0 ? t : n.attrs = /* @__PURE__ */ Object.create(null);
        u[this.currentAttr.name] = this.currentLocation, this._leaveAttrValue();
      }
    } else
      this._err(k.duplicateAttribute);
  }
  _leaveAttrValue() {
    this.currentLocation && (this.currentLocation.endLine = this.preprocessor.line, this.currentLocation.endCol = this.preprocessor.col, this.currentLocation.endOffset = this.preprocessor.offset);
  }
  //Token emission
  prepareToken(t) {
    this._emitCurrentCharacterToken(t.location), this.currentToken = null, t.location && (t.location.endLine = this.preprocessor.line, t.location.endCol = this.preprocessor.col + 1, t.location.endOffset = this.preprocessor.offset + 1), this.currentLocation = this.getCurrentLocation(-1);
  }
  emitCurrentTagToken() {
    const t = this.currentToken;
    this.prepareToken(t), t.tagID = Rt(t.tagName), t.type === V.START_TAG ? (this.lastStartTagName = t.tagName, this.handler.onStartTag(t)) : (t.attrs.length > 0 && this._err(k.endTagWithAttributes), t.selfClosing && this._err(k.endTagWithTrailingSolidus), this.handler.onEndTag(t)), this.preprocessor.dropParsedChunk();
  }
  emitCurrentComment(t) {
    this.prepareToken(t), this.handler.onComment(t), this.preprocessor.dropParsedChunk();
  }
  emitCurrentDoctype(t) {
    this.prepareToken(t), this.handler.onDoctype(t), this.preprocessor.dropParsedChunk();
  }
  _emitCurrentCharacterToken(t) {
    if (this.currentCharacterToken) {
      switch (t && this.currentCharacterToken.location && (this.currentCharacterToken.location.endLine = t.startLine, this.currentCharacterToken.location.endCol = t.startCol, this.currentCharacterToken.location.endOffset = t.startOffset), this.currentCharacterToken.type) {
        case V.CHARACTER: {
          this.handler.onCharacter(this.currentCharacterToken);
          break;
        }
        case V.NULL_CHARACTER: {
          this.handler.onNullCharacter(this.currentCharacterToken);
          break;
        }
        case V.WHITESPACE_CHARACTER: {
          this.handler.onWhitespaceCharacter(this.currentCharacterToken);
          break;
        }
      }
      this.currentCharacterToken = null;
    }
  }
  _emitEOFToken() {
    const t = this.getCurrentLocation(0);
    t && (t.endLine = t.startLine, t.endCol = t.startCol, t.endOffset = t.startOffset), this._emitCurrentCharacterToken(t), this.handler.onEof({ type: V.EOF, location: t }), this.active = !1;
  }
  //Characters emission
  //OPTIMIZATION: The specification uses only one type of character token (one token per character).
  //This causes a huge memory overhead and a lot of unnecessary parser loops. parse5 uses 3 groups of characters.
  //If we have a sequence of characters that belong to the same group, the parser can process it
  //as a single solid character token.
  //So, there are 3 types of character tokens in parse5:
  //1)TokenType.NULL_CHARACTER - \u0000-character sequences (e.g. '\u0000\u0000\u0000')
  //2)TokenType.WHITESPACE_CHARACTER - any whitespace/new-line character sequences (e.g. '\n  \r\t   \f')
  //3)TokenType.CHARACTER - any character sequence which don't belong to groups 1 and 2 (e.g. 'abcdef1234@@#$%^')
  _appendCharToCurrentCharacterToken(t, n) {
    if (this.currentCharacterToken)
      if (this.currentCharacterToken.type === t) {
        this.currentCharacterToken.chars += n;
        return;
      } else
        this.currentLocation = this.getCurrentLocation(0), this._emitCurrentCharacterToken(this.currentLocation), this.preprocessor.dropParsedChunk();
    this._createCharacterToken(t, n);
  }
  _emitCodePoint(t) {
    const n = ja(t) ? V.WHITESPACE_CHARACTER : t === p.NULL ? V.NULL_CHARACTER : V.CHARACTER;
    this._appendCharToCurrentCharacterToken(n, String.fromCodePoint(t));
  }
  //NOTE: used when we emit characters explicitly.
  //This is always for non-whitespace and non-null characters, which allows us to avoid additional checks.
  _emitChars(t) {
    this._appendCharToCurrentCharacterToken(V.CHARACTER, t);
  }
  // Character reference helpers
  _startCharacterReference() {
    this.returnState = this.state, this.state = E.CHARACTER_REFERENCE, this.entityStartPos = this.preprocessor.pos, this.entityDecoder.startEntity(this._isCharacterReferenceInAttribute() ? Ye.Attribute : Ye.Legacy);
  }
  _isCharacterReferenceInAttribute() {
    return this.returnState === E.ATTRIBUTE_VALUE_DOUBLE_QUOTED || this.returnState === E.ATTRIBUTE_VALUE_SINGLE_QUOTED || this.returnState === E.ATTRIBUTE_VALUE_UNQUOTED;
  }
  _flushCodePointConsumedAsCharacterReference(t) {
    this._isCharacterReferenceInAttribute() ? this.currentAttr.value += String.fromCodePoint(t) : this._emitCodePoint(t);
  }
  // Calling states this way turns out to be much faster than any other approach.
  _callState(t) {
    switch (this.state) {
      case E.DATA: {
        this._stateData(t);
        break;
      }
      case E.RCDATA: {
        this._stateRcdata(t);
        break;
      }
      case E.RAWTEXT: {
        this._stateRawtext(t);
        break;
      }
      case E.SCRIPT_DATA: {
        this._stateScriptData(t);
        break;
      }
      case E.PLAINTEXT: {
        this._statePlaintext(t);
        break;
      }
      case E.TAG_OPEN: {
        this._stateTagOpen(t);
        break;
      }
      case E.END_TAG_OPEN: {
        this._stateEndTagOpen(t);
        break;
      }
      case E.TAG_NAME: {
        this._stateTagName(t);
        break;
      }
      case E.RCDATA_LESS_THAN_SIGN: {
        this._stateRcdataLessThanSign(t);
        break;
      }
      case E.RCDATA_END_TAG_OPEN: {
        this._stateRcdataEndTagOpen(t);
        break;
      }
      case E.RCDATA_END_TAG_NAME: {
        this._stateRcdataEndTagName(t);
        break;
      }
      case E.RAWTEXT_LESS_THAN_SIGN: {
        this._stateRawtextLessThanSign(t);
        break;
      }
      case E.RAWTEXT_END_TAG_OPEN: {
        this._stateRawtextEndTagOpen(t);
        break;
      }
      case E.RAWTEXT_END_TAG_NAME: {
        this._stateRawtextEndTagName(t);
        break;
      }
      case E.SCRIPT_DATA_LESS_THAN_SIGN: {
        this._stateScriptDataLessThanSign(t);
        break;
      }
      case E.SCRIPT_DATA_END_TAG_OPEN: {
        this._stateScriptDataEndTagOpen(t);
        break;
      }
      case E.SCRIPT_DATA_END_TAG_NAME: {
        this._stateScriptDataEndTagName(t);
        break;
      }
      case E.SCRIPT_DATA_ESCAPE_START: {
        this._stateScriptDataEscapeStart(t);
        break;
      }
      case E.SCRIPT_DATA_ESCAPE_START_DASH: {
        this._stateScriptDataEscapeStartDash(t);
        break;
      }
      case E.SCRIPT_DATA_ESCAPED: {
        this._stateScriptDataEscaped(t);
        break;
      }
      case E.SCRIPT_DATA_ESCAPED_DASH: {
        this._stateScriptDataEscapedDash(t);
        break;
      }
      case E.SCRIPT_DATA_ESCAPED_DASH_DASH: {
        this._stateScriptDataEscapedDashDash(t);
        break;
      }
      case E.SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN: {
        this._stateScriptDataEscapedLessThanSign(t);
        break;
      }
      case E.SCRIPT_DATA_ESCAPED_END_TAG_OPEN: {
        this._stateScriptDataEscapedEndTagOpen(t);
        break;
      }
      case E.SCRIPT_DATA_ESCAPED_END_TAG_NAME: {
        this._stateScriptDataEscapedEndTagName(t);
        break;
      }
      case E.SCRIPT_DATA_DOUBLE_ESCAPE_START: {
        this._stateScriptDataDoubleEscapeStart(t);
        break;
      }
      case E.SCRIPT_DATA_DOUBLE_ESCAPED: {
        this._stateScriptDataDoubleEscaped(t);
        break;
      }
      case E.SCRIPT_DATA_DOUBLE_ESCAPED_DASH: {
        this._stateScriptDataDoubleEscapedDash(t);
        break;
      }
      case E.SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH: {
        this._stateScriptDataDoubleEscapedDashDash(t);
        break;
      }
      case E.SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN: {
        this._stateScriptDataDoubleEscapedLessThanSign(t);
        break;
      }
      case E.SCRIPT_DATA_DOUBLE_ESCAPE_END: {
        this._stateScriptDataDoubleEscapeEnd(t);
        break;
      }
      case E.BEFORE_ATTRIBUTE_NAME: {
        this._stateBeforeAttributeName(t);
        break;
      }
      case E.ATTRIBUTE_NAME: {
        this._stateAttributeName(t);
        break;
      }
      case E.AFTER_ATTRIBUTE_NAME: {
        this._stateAfterAttributeName(t);
        break;
      }
      case E.BEFORE_ATTRIBUTE_VALUE: {
        this._stateBeforeAttributeValue(t);
        break;
      }
      case E.ATTRIBUTE_VALUE_DOUBLE_QUOTED: {
        this._stateAttributeValueDoubleQuoted(t);
        break;
      }
      case E.ATTRIBUTE_VALUE_SINGLE_QUOTED: {
        this._stateAttributeValueSingleQuoted(t);
        break;
      }
      case E.ATTRIBUTE_VALUE_UNQUOTED: {
        this._stateAttributeValueUnquoted(t);
        break;
      }
      case E.AFTER_ATTRIBUTE_VALUE_QUOTED: {
        this._stateAfterAttributeValueQuoted(t);
        break;
      }
      case E.SELF_CLOSING_START_TAG: {
        this._stateSelfClosingStartTag(t);
        break;
      }
      case E.BOGUS_COMMENT: {
        this._stateBogusComment(t);
        break;
      }
      case E.MARKUP_DECLARATION_OPEN: {
        this._stateMarkupDeclarationOpen(t);
        break;
      }
      case E.COMMENT_START: {
        this._stateCommentStart(t);
        break;
      }
      case E.COMMENT_START_DASH: {
        this._stateCommentStartDash(t);
        break;
      }
      case E.COMMENT: {
        this._stateComment(t);
        break;
      }
      case E.COMMENT_LESS_THAN_SIGN: {
        this._stateCommentLessThanSign(t);
        break;
      }
      case E.COMMENT_LESS_THAN_SIGN_BANG: {
        this._stateCommentLessThanSignBang(t);
        break;
      }
      case E.COMMENT_LESS_THAN_SIGN_BANG_DASH: {
        this._stateCommentLessThanSignBangDash(t);
        break;
      }
      case E.COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH: {
        this._stateCommentLessThanSignBangDashDash(t);
        break;
      }
      case E.COMMENT_END_DASH: {
        this._stateCommentEndDash(t);
        break;
      }
      case E.COMMENT_END: {
        this._stateCommentEnd(t);
        break;
      }
      case E.COMMENT_END_BANG: {
        this._stateCommentEndBang(t);
        break;
      }
      case E.DOCTYPE: {
        this._stateDoctype(t);
        break;
      }
      case E.BEFORE_DOCTYPE_NAME: {
        this._stateBeforeDoctypeName(t);
        break;
      }
      case E.DOCTYPE_NAME: {
        this._stateDoctypeName(t);
        break;
      }
      case E.AFTER_DOCTYPE_NAME: {
        this._stateAfterDoctypeName(t);
        break;
      }
      case E.AFTER_DOCTYPE_PUBLIC_KEYWORD: {
        this._stateAfterDoctypePublicKeyword(t);
        break;
      }
      case E.BEFORE_DOCTYPE_PUBLIC_IDENTIFIER: {
        this._stateBeforeDoctypePublicIdentifier(t);
        break;
      }
      case E.DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED: {
        this._stateDoctypePublicIdentifierDoubleQuoted(t);
        break;
      }
      case E.DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED: {
        this._stateDoctypePublicIdentifierSingleQuoted(t);
        break;
      }
      case E.AFTER_DOCTYPE_PUBLIC_IDENTIFIER: {
        this._stateAfterDoctypePublicIdentifier(t);
        break;
      }
      case E.BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS: {
        this._stateBetweenDoctypePublicAndSystemIdentifiers(t);
        break;
      }
      case E.AFTER_DOCTYPE_SYSTEM_KEYWORD: {
        this._stateAfterDoctypeSystemKeyword(t);
        break;
      }
      case E.BEFORE_DOCTYPE_SYSTEM_IDENTIFIER: {
        this._stateBeforeDoctypeSystemIdentifier(t);
        break;
      }
      case E.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED: {
        this._stateDoctypeSystemIdentifierDoubleQuoted(t);
        break;
      }
      case E.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED: {
        this._stateDoctypeSystemIdentifierSingleQuoted(t);
        break;
      }
      case E.AFTER_DOCTYPE_SYSTEM_IDENTIFIER: {
        this._stateAfterDoctypeSystemIdentifier(t);
        break;
      }
      case E.BOGUS_DOCTYPE: {
        this._stateBogusDoctype(t);
        break;
      }
      case E.CDATA_SECTION: {
        this._stateCdataSection(t);
        break;
      }
      case E.CDATA_SECTION_BRACKET: {
        this._stateCdataSectionBracket(t);
        break;
      }
      case E.CDATA_SECTION_END: {
        this._stateCdataSectionEnd(t);
        break;
      }
      case E.CHARACTER_REFERENCE: {
        this._stateCharacterReference();
        break;
      }
      case E.AMBIGUOUS_AMPERSAND: {
        this._stateAmbiguousAmpersand(t);
        break;
      }
      default:
        throw new Error("Unknown state");
    }
  }
  // State machine
  // Data state
  //------------------------------------------------------------------
  _stateData(t) {
    switch (t) {
      case p.LESS_THAN_SIGN: {
        this.state = E.TAG_OPEN;
        break;
      }
      case p.AMPERSAND: {
        this._startCharacterReference();
        break;
      }
      case p.NULL: {
        this._err(k.unexpectedNullCharacter), this._emitCodePoint(t);
        break;
      }
      case p.EOF: {
        this._emitEOFToken();
        break;
      }
      default:
        this._emitCodePoint(t);
    }
  }
  //  RCDATA state
  //------------------------------------------------------------------
  _stateRcdata(t) {
    switch (t) {
      case p.AMPERSAND: {
        this._startCharacterReference();
        break;
      }
      case p.LESS_THAN_SIGN: {
        this.state = E.RCDATA_LESS_THAN_SIGN;
        break;
      }
      case p.NULL: {
        this._err(k.unexpectedNullCharacter), this._emitChars(ae);
        break;
      }
      case p.EOF: {
        this._emitEOFToken();
        break;
      }
      default:
        this._emitCodePoint(t);
    }
  }
  // RAWTEXT state
  //------------------------------------------------------------------
  _stateRawtext(t) {
    switch (t) {
      case p.LESS_THAN_SIGN: {
        this.state = E.RAWTEXT_LESS_THAN_SIGN;
        break;
      }
      case p.NULL: {
        this._err(k.unexpectedNullCharacter), this._emitChars(ae);
        break;
      }
      case p.EOF: {
        this._emitEOFToken();
        break;
      }
      default:
        this._emitCodePoint(t);
    }
  }
  // Script data state
  //------------------------------------------------------------------
  _stateScriptData(t) {
    switch (t) {
      case p.LESS_THAN_SIGN: {
        this.state = E.SCRIPT_DATA_LESS_THAN_SIGN;
        break;
      }
      case p.NULL: {
        this._err(k.unexpectedNullCharacter), this._emitChars(ae);
        break;
      }
      case p.EOF: {
        this._emitEOFToken();
        break;
      }
      default:
        this._emitCodePoint(t);
    }
  }
  // PLAINTEXT state
  //------------------------------------------------------------------
  _statePlaintext(t) {
    switch (t) {
      case p.NULL: {
        this._err(k.unexpectedNullCharacter), this._emitChars(ae);
        break;
      }
      case p.EOF: {
        this._emitEOFToken();
        break;
      }
      default:
        this._emitCodePoint(t);
    }
  }
  // Tag open state
  //------------------------------------------------------------------
  _stateTagOpen(t) {
    if (Ke(t))
      this._createStartTagToken(), this.state = E.TAG_NAME, this._stateTagName(t);
    else
      switch (t) {
        case p.EXCLAMATION_MARK: {
          this.state = E.MARKUP_DECLARATION_OPEN;
          break;
        }
        case p.SOLIDUS: {
          this.state = E.END_TAG_OPEN;
          break;
        }
        case p.QUESTION_MARK: {
          this._err(k.unexpectedQuestionMarkInsteadOfTagName), this._createCommentToken(1), this.state = E.BOGUS_COMMENT, this._stateBogusComment(t);
          break;
        }
        case p.EOF: {
          this._err(k.eofBeforeTagName), this._emitChars("<"), this._emitEOFToken();
          break;
        }
        default:
          this._err(k.invalidFirstCharacterOfTagName), this._emitChars("<"), this.state = E.DATA, this._stateData(t);
      }
  }
  // End tag open state
  //------------------------------------------------------------------
  _stateEndTagOpen(t) {
    if (Ke(t))
      this._createEndTagToken(), this.state = E.TAG_NAME, this._stateTagName(t);
    else
      switch (t) {
        case p.GREATER_THAN_SIGN: {
          this._err(k.missingEndTagName), this.state = E.DATA;
          break;
        }
        case p.EOF: {
          this._err(k.eofBeforeTagName), this._emitChars("</"), this._emitEOFToken();
          break;
        }
        default:
          this._err(k.invalidFirstCharacterOfTagName), this._createCommentToken(2), this.state = E.BOGUS_COMMENT, this._stateBogusComment(t);
      }
  }
  // Tag name state
  //------------------------------------------------------------------
  _stateTagName(t) {
    const n = this.currentToken;
    switch (t) {
      case p.SPACE:
      case p.LINE_FEED:
      case p.TABULATION:
      case p.FORM_FEED: {
        this.state = E.BEFORE_ATTRIBUTE_NAME;
        break;
      }
      case p.SOLIDUS: {
        this.state = E.SELF_CLOSING_START_TAG;
        break;
      }
      case p.GREATER_THAN_SIGN: {
        this.state = E.DATA, this.emitCurrentTagToken();
        break;
      }
      case p.NULL: {
        this._err(k.unexpectedNullCharacter), n.tagName += ae;
        break;
      }
      case p.EOF: {
        this._err(k.eofInTag), this._emitEOFToken();
        break;
      }
      default:
        n.tagName += String.fromCodePoint(qt(t) ? mn(t) : t);
    }
  }
  // RCDATA less-than sign state
  //------------------------------------------------------------------
  _stateRcdataLessThanSign(t) {
    t === p.SOLIDUS ? this.state = E.RCDATA_END_TAG_OPEN : (this._emitChars("<"), this.state = E.RCDATA, this._stateRcdata(t));
  }
  // RCDATA end tag open state
  //------------------------------------------------------------------
  _stateRcdataEndTagOpen(t) {
    Ke(t) ? (this.state = E.RCDATA_END_TAG_NAME, this._stateRcdataEndTagName(t)) : (this._emitChars("</"), this.state = E.RCDATA, this._stateRcdata(t));
  }
  handleSpecialEndTag(t) {
    if (!this.preprocessor.startsWith(this.lastStartTagName, !1))
      return !this._ensureHibernation();
    this._createEndTagToken();
    const n = this.currentToken;
    switch (n.tagName = this.lastStartTagName, this.preprocessor.peek(this.lastStartTagName.length)) {
      case p.SPACE:
      case p.LINE_FEED:
      case p.TABULATION:
      case p.FORM_FEED:
        return this._advanceBy(this.lastStartTagName.length), this.state = E.BEFORE_ATTRIBUTE_NAME, !1;
      case p.SOLIDUS:
        return this._advanceBy(this.lastStartTagName.length), this.state = E.SELF_CLOSING_START_TAG, !1;
      case p.GREATER_THAN_SIGN:
        return this._advanceBy(this.lastStartTagName.length), this.emitCurrentTagToken(), this.state = E.DATA, !1;
      default:
        return !this._ensureHibernation();
    }
  }
  // RCDATA end tag name state
  //------------------------------------------------------------------
  _stateRcdataEndTagName(t) {
    this.handleSpecialEndTag(t) && (this._emitChars("</"), this.state = E.RCDATA, this._stateRcdata(t));
  }
  // RAWTEXT less-than sign state
  //------------------------------------------------------------------
  _stateRawtextLessThanSign(t) {
    t === p.SOLIDUS ? this.state = E.RAWTEXT_END_TAG_OPEN : (this._emitChars("<"), this.state = E.RAWTEXT, this._stateRawtext(t));
  }
  // RAWTEXT end tag open state
  //------------------------------------------------------------------
  _stateRawtextEndTagOpen(t) {
    Ke(t) ? (this.state = E.RAWTEXT_END_TAG_NAME, this._stateRawtextEndTagName(t)) : (this._emitChars("</"), this.state = E.RAWTEXT, this._stateRawtext(t));
  }
  // RAWTEXT end tag name state
  //------------------------------------------------------------------
  _stateRawtextEndTagName(t) {
    this.handleSpecialEndTag(t) && (this._emitChars("</"), this.state = E.RAWTEXT, this._stateRawtext(t));
  }
  // Script data less-than sign state
  //------------------------------------------------------------------
  _stateScriptDataLessThanSign(t) {
    switch (t) {
      case p.SOLIDUS: {
        this.state = E.SCRIPT_DATA_END_TAG_OPEN;
        break;
      }
      case p.EXCLAMATION_MARK: {
        this.state = E.SCRIPT_DATA_ESCAPE_START, this._emitChars("<!");
        break;
      }
      default:
        this._emitChars("<"), this.state = E.SCRIPT_DATA, this._stateScriptData(t);
    }
  }
  // Script data end tag open state
  //------------------------------------------------------------------
  _stateScriptDataEndTagOpen(t) {
    Ke(t) ? (this.state = E.SCRIPT_DATA_END_TAG_NAME, this._stateScriptDataEndTagName(t)) : (this._emitChars("</"), this.state = E.SCRIPT_DATA, this._stateScriptData(t));
  }
  // Script data end tag name state
  //------------------------------------------------------------------
  _stateScriptDataEndTagName(t) {
    this.handleSpecialEndTag(t) && (this._emitChars("</"), this.state = E.SCRIPT_DATA, this._stateScriptData(t));
  }
  // Script data escape start state
  //------------------------------------------------------------------
  _stateScriptDataEscapeStart(t) {
    t === p.HYPHEN_MINUS ? (this.state = E.SCRIPT_DATA_ESCAPE_START_DASH, this._emitChars("-")) : (this.state = E.SCRIPT_DATA, this._stateScriptData(t));
  }
  // Script data escape start dash state
  //------------------------------------------------------------------
  _stateScriptDataEscapeStartDash(t) {
    t === p.HYPHEN_MINUS ? (this.state = E.SCRIPT_DATA_ESCAPED_DASH_DASH, this._emitChars("-")) : (this.state = E.SCRIPT_DATA, this._stateScriptData(t));
  }
  // Script data escaped state
  //------------------------------------------------------------------
  _stateScriptDataEscaped(t) {
    switch (t) {
      case p.HYPHEN_MINUS: {
        this.state = E.SCRIPT_DATA_ESCAPED_DASH, this._emitChars("-");
        break;
      }
      case p.LESS_THAN_SIGN: {
        this.state = E.SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN;
        break;
      }
      case p.NULL: {
        this._err(k.unexpectedNullCharacter), this._emitChars(ae);
        break;
      }
      case p.EOF: {
        this._err(k.eofInScriptHtmlCommentLikeText), this._emitEOFToken();
        break;
      }
      default:
        this._emitCodePoint(t);
    }
  }
  // Script data escaped dash state
  //------------------------------------------------------------------
  _stateScriptDataEscapedDash(t) {
    switch (t) {
      case p.HYPHEN_MINUS: {
        this.state = E.SCRIPT_DATA_ESCAPED_DASH_DASH, this._emitChars("-");
        break;
      }
      case p.LESS_THAN_SIGN: {
        this.state = E.SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN;
        break;
      }
      case p.NULL: {
        this._err(k.unexpectedNullCharacter), this.state = E.SCRIPT_DATA_ESCAPED, this._emitChars(ae);
        break;
      }
      case p.EOF: {
        this._err(k.eofInScriptHtmlCommentLikeText), this._emitEOFToken();
        break;
      }
      default:
        this.state = E.SCRIPT_DATA_ESCAPED, this._emitCodePoint(t);
    }
  }
  // Script data escaped dash dash state
  //------------------------------------------------------------------
  _stateScriptDataEscapedDashDash(t) {
    switch (t) {
      case p.HYPHEN_MINUS: {
        this._emitChars("-");
        break;
      }
      case p.LESS_THAN_SIGN: {
        this.state = E.SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN;
        break;
      }
      case p.GREATER_THAN_SIGN: {
        this.state = E.SCRIPT_DATA, this._emitChars(">");
        break;
      }
      case p.NULL: {
        this._err(k.unexpectedNullCharacter), this.state = E.SCRIPT_DATA_ESCAPED, this._emitChars(ae);
        break;
      }
      case p.EOF: {
        this._err(k.eofInScriptHtmlCommentLikeText), this._emitEOFToken();
        break;
      }
      default:
        this.state = E.SCRIPT_DATA_ESCAPED, this._emitCodePoint(t);
    }
  }
  // Script data escaped less-than sign state
  //------------------------------------------------------------------
  _stateScriptDataEscapedLessThanSign(t) {
    t === p.SOLIDUS ? this.state = E.SCRIPT_DATA_ESCAPED_END_TAG_OPEN : Ke(t) ? (this._emitChars("<"), this.state = E.SCRIPT_DATA_DOUBLE_ESCAPE_START, this._stateScriptDataDoubleEscapeStart(t)) : (this._emitChars("<"), this.state = E.SCRIPT_DATA_ESCAPED, this._stateScriptDataEscaped(t));
  }
  // Script data escaped end tag open state
  //------------------------------------------------------------------
  _stateScriptDataEscapedEndTagOpen(t) {
    Ke(t) ? (this.state = E.SCRIPT_DATA_ESCAPED_END_TAG_NAME, this._stateScriptDataEscapedEndTagName(t)) : (this._emitChars("</"), this.state = E.SCRIPT_DATA_ESCAPED, this._stateScriptDataEscaped(t));
  }
  // Script data escaped end tag name state
  //------------------------------------------------------------------
  _stateScriptDataEscapedEndTagName(t) {
    this.handleSpecialEndTag(t) && (this._emitChars("</"), this.state = E.SCRIPT_DATA_ESCAPED, this._stateScriptDataEscaped(t));
  }
  // Script data double escape start state
  //------------------------------------------------------------------
  _stateScriptDataDoubleEscapeStart(t) {
    if (this.preprocessor.startsWith(be.SCRIPT, !1) && ii(this.preprocessor.peek(be.SCRIPT.length))) {
      this._emitCodePoint(t);
      for (let n = 0; n < be.SCRIPT.length; n++)
        this._emitCodePoint(this._consume());
      this.state = E.SCRIPT_DATA_DOUBLE_ESCAPED;
    } else this._ensureHibernation() || (this.state = E.SCRIPT_DATA_ESCAPED, this._stateScriptDataEscaped(t));
  }
  // Script data double escaped state
  //------------------------------------------------------------------
  _stateScriptDataDoubleEscaped(t) {
    switch (t) {
      case p.HYPHEN_MINUS: {
        this.state = E.SCRIPT_DATA_DOUBLE_ESCAPED_DASH, this._emitChars("-");
        break;
      }
      case p.LESS_THAN_SIGN: {
        this.state = E.SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN, this._emitChars("<");
        break;
      }
      case p.NULL: {
        this._err(k.unexpectedNullCharacter), this._emitChars(ae);
        break;
      }
      case p.EOF: {
        this._err(k.eofInScriptHtmlCommentLikeText), this._emitEOFToken();
        break;
      }
      default:
        this._emitCodePoint(t);
    }
  }
  // Script data double escaped dash state
  //------------------------------------------------------------------
  _stateScriptDataDoubleEscapedDash(t) {
    switch (t) {
      case p.HYPHEN_MINUS: {
        this.state = E.SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH, this._emitChars("-");
        break;
      }
      case p.LESS_THAN_SIGN: {
        this.state = E.SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN, this._emitChars("<");
        break;
      }
      case p.NULL: {
        this._err(k.unexpectedNullCharacter), this.state = E.SCRIPT_DATA_DOUBLE_ESCAPED, this._emitChars(ae);
        break;
      }
      case p.EOF: {
        this._err(k.eofInScriptHtmlCommentLikeText), this._emitEOFToken();
        break;
      }
      default:
        this.state = E.SCRIPT_DATA_DOUBLE_ESCAPED, this._emitCodePoint(t);
    }
  }
  // Script data double escaped dash dash state
  //------------------------------------------------------------------
  _stateScriptDataDoubleEscapedDashDash(t) {
    switch (t) {
      case p.HYPHEN_MINUS: {
        this._emitChars("-");
        break;
      }
      case p.LESS_THAN_SIGN: {
        this.state = E.SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN, this._emitChars("<");
        break;
      }
      case p.GREATER_THAN_SIGN: {
        this.state = E.SCRIPT_DATA, this._emitChars(">");
        break;
      }
      case p.NULL: {
        this._err(k.unexpectedNullCharacter), this.state = E.SCRIPT_DATA_DOUBLE_ESCAPED, this._emitChars(ae);
        break;
      }
      case p.EOF: {
        this._err(k.eofInScriptHtmlCommentLikeText), this._emitEOFToken();
        break;
      }
      default:
        this.state = E.SCRIPT_DATA_DOUBLE_ESCAPED, this._emitCodePoint(t);
    }
  }
  // Script data double escaped less-than sign state
  //------------------------------------------------------------------
  _stateScriptDataDoubleEscapedLessThanSign(t) {
    t === p.SOLIDUS ? (this.state = E.SCRIPT_DATA_DOUBLE_ESCAPE_END, this._emitChars("/")) : (this.state = E.SCRIPT_DATA_DOUBLE_ESCAPED, this._stateScriptDataDoubleEscaped(t));
  }
  // Script data double escape end state
  //------------------------------------------------------------------
  _stateScriptDataDoubleEscapeEnd(t) {
    if (this.preprocessor.startsWith(be.SCRIPT, !1) && ii(this.preprocessor.peek(be.SCRIPT.length))) {
      this._emitCodePoint(t);
      for (let n = 0; n < be.SCRIPT.length; n++)
        this._emitCodePoint(this._consume());
      this.state = E.SCRIPT_DATA_ESCAPED;
    } else this._ensureHibernation() || (this.state = E.SCRIPT_DATA_DOUBLE_ESCAPED, this._stateScriptDataDoubleEscaped(t));
  }
  // Before attribute name state
  //------------------------------------------------------------------
  _stateBeforeAttributeName(t) {
    switch (t) {
      case p.SPACE:
      case p.LINE_FEED:
      case p.TABULATION:
      case p.FORM_FEED:
        break;
      case p.SOLIDUS:
      case p.GREATER_THAN_SIGN:
      case p.EOF: {
        this.state = E.AFTER_ATTRIBUTE_NAME, this._stateAfterAttributeName(t);
        break;
      }
      case p.EQUALS_SIGN: {
        this._err(k.unexpectedEqualsSignBeforeAttributeName), this._createAttr("="), this.state = E.ATTRIBUTE_NAME;
        break;
      }
      default:
        this._createAttr(""), this.state = E.ATTRIBUTE_NAME, this._stateAttributeName(t);
    }
  }
  // Attribute name state
  //------------------------------------------------------------------
  _stateAttributeName(t) {
    switch (t) {
      case p.SPACE:
      case p.LINE_FEED:
      case p.TABULATION:
      case p.FORM_FEED:
      case p.SOLIDUS:
      case p.GREATER_THAN_SIGN:
      case p.EOF: {
        this._leaveAttrName(), this.state = E.AFTER_ATTRIBUTE_NAME, this._stateAfterAttributeName(t);
        break;
      }
      case p.EQUALS_SIGN: {
        this._leaveAttrName(), this.state = E.BEFORE_ATTRIBUTE_VALUE;
        break;
      }
      case p.QUOTATION_MARK:
      case p.APOSTROPHE:
      case p.LESS_THAN_SIGN: {
        this._err(k.unexpectedCharacterInAttributeName), this.currentAttr.name += String.fromCodePoint(t);
        break;
      }
      case p.NULL: {
        this._err(k.unexpectedNullCharacter), this.currentAttr.name += ae;
        break;
      }
      default:
        this.currentAttr.name += String.fromCodePoint(qt(t) ? mn(t) : t);
    }
  }
  // After attribute name state
  //------------------------------------------------------------------
  _stateAfterAttributeName(t) {
    switch (t) {
      case p.SPACE:
      case p.LINE_FEED:
      case p.TABULATION:
      case p.FORM_FEED:
        break;
      case p.SOLIDUS: {
        this.state = E.SELF_CLOSING_START_TAG;
        break;
      }
      case p.EQUALS_SIGN: {
        this.state = E.BEFORE_ATTRIBUTE_VALUE;
        break;
      }
      case p.GREATER_THAN_SIGN: {
        this.state = E.DATA, this.emitCurrentTagToken();
        break;
      }
      case p.EOF: {
        this._err(k.eofInTag), this._emitEOFToken();
        break;
      }
      default:
        this._createAttr(""), this.state = E.ATTRIBUTE_NAME, this._stateAttributeName(t);
    }
  }
  // Before attribute value state
  //------------------------------------------------------------------
  _stateBeforeAttributeValue(t) {
    switch (t) {
      case p.SPACE:
      case p.LINE_FEED:
      case p.TABULATION:
      case p.FORM_FEED:
        break;
      case p.QUOTATION_MARK: {
        this.state = E.ATTRIBUTE_VALUE_DOUBLE_QUOTED;
        break;
      }
      case p.APOSTROPHE: {
        this.state = E.ATTRIBUTE_VALUE_SINGLE_QUOTED;
        break;
      }
      case p.GREATER_THAN_SIGN: {
        this._err(k.missingAttributeValue), this.state = E.DATA, this.emitCurrentTagToken();
        break;
      }
      default:
        this.state = E.ATTRIBUTE_VALUE_UNQUOTED, this._stateAttributeValueUnquoted(t);
    }
  }
  // Attribute value (double-quoted) state
  //------------------------------------------------------------------
  _stateAttributeValueDoubleQuoted(t) {
    switch (t) {
      case p.QUOTATION_MARK: {
        this.state = E.AFTER_ATTRIBUTE_VALUE_QUOTED;
        break;
      }
      case p.AMPERSAND: {
        this._startCharacterReference();
        break;
      }
      case p.NULL: {
        this._err(k.unexpectedNullCharacter), this.currentAttr.value += ae;
        break;
      }
      case p.EOF: {
        this._err(k.eofInTag), this._emitEOFToken();
        break;
      }
      default:
        this.currentAttr.value += String.fromCodePoint(t);
    }
  }
  // Attribute value (single-quoted) state
  //------------------------------------------------------------------
  _stateAttributeValueSingleQuoted(t) {
    switch (t) {
      case p.APOSTROPHE: {
        this.state = E.AFTER_ATTRIBUTE_VALUE_QUOTED;
        break;
      }
      case p.AMPERSAND: {
        this._startCharacterReference();
        break;
      }
      case p.NULL: {
        this._err(k.unexpectedNullCharacter), this.currentAttr.value += ae;
        break;
      }
      case p.EOF: {
        this._err(k.eofInTag), this._emitEOFToken();
        break;
      }
      default:
        this.currentAttr.value += String.fromCodePoint(t);
    }
  }
  // Attribute value (unquoted) state
  //------------------------------------------------------------------
  _stateAttributeValueUnquoted(t) {
    switch (t) {
      case p.SPACE:
      case p.LINE_FEED:
      case p.TABULATION:
      case p.FORM_FEED: {
        this._leaveAttrValue(), this.state = E.BEFORE_ATTRIBUTE_NAME;
        break;
      }
      case p.AMPERSAND: {
        this._startCharacterReference();
        break;
      }
      case p.GREATER_THAN_SIGN: {
        this._leaveAttrValue(), this.state = E.DATA, this.emitCurrentTagToken();
        break;
      }
      case p.NULL: {
        this._err(k.unexpectedNullCharacter), this.currentAttr.value += ae;
        break;
      }
      case p.QUOTATION_MARK:
      case p.APOSTROPHE:
      case p.LESS_THAN_SIGN:
      case p.EQUALS_SIGN:
      case p.GRAVE_ACCENT: {
        this._err(k.unexpectedCharacterInUnquotedAttributeValue), this.currentAttr.value += String.fromCodePoint(t);
        break;
      }
      case p.EOF: {
        this._err(k.eofInTag), this._emitEOFToken();
        break;
      }
      default:
        this.currentAttr.value += String.fromCodePoint(t);
    }
  }
  // After attribute value (quoted) state
  //------------------------------------------------------------------
  _stateAfterAttributeValueQuoted(t) {
    switch (t) {
      case p.SPACE:
      case p.LINE_FEED:
      case p.TABULATION:
      case p.FORM_FEED: {
        this._leaveAttrValue(), this.state = E.BEFORE_ATTRIBUTE_NAME;
        break;
      }
      case p.SOLIDUS: {
        this._leaveAttrValue(), this.state = E.SELF_CLOSING_START_TAG;
        break;
      }
      case p.GREATER_THAN_SIGN: {
        this._leaveAttrValue(), this.state = E.DATA, this.emitCurrentTagToken();
        break;
      }
      case p.EOF: {
        this._err(k.eofInTag), this._emitEOFToken();
        break;
      }
      default:
        this._err(k.missingWhitespaceBetweenAttributes), this.state = E.BEFORE_ATTRIBUTE_NAME, this._stateBeforeAttributeName(t);
    }
  }
  // Self-closing start tag state
  //------------------------------------------------------------------
  _stateSelfClosingStartTag(t) {
    switch (t) {
      case p.GREATER_THAN_SIGN: {
        const n = this.currentToken;
        n.selfClosing = !0, this.state = E.DATA, this.emitCurrentTagToken();
        break;
      }
      case p.EOF: {
        this._err(k.eofInTag), this._emitEOFToken();
        break;
      }
      default:
        this._err(k.unexpectedSolidusInTag), this.state = E.BEFORE_ATTRIBUTE_NAME, this._stateBeforeAttributeName(t);
    }
  }
  // Bogus comment state
  //------------------------------------------------------------------
  _stateBogusComment(t) {
    const n = this.currentToken;
    switch (t) {
      case p.GREATER_THAN_SIGN: {
        this.state = E.DATA, this.emitCurrentComment(n);
        break;
      }
      case p.EOF: {
        this.emitCurrentComment(n), this._emitEOFToken();
        break;
      }
      case p.NULL: {
        this._err(k.unexpectedNullCharacter), n.data += ae;
        break;
      }
      default:
        n.data += String.fromCodePoint(t);
    }
  }
  // Markup declaration open state
  //------------------------------------------------------------------
  _stateMarkupDeclarationOpen(t) {
    this._consumeSequenceIfMatch(be.DASH_DASH, !0) ? (this._createCommentToken(be.DASH_DASH.length + 1), this.state = E.COMMENT_START) : this._consumeSequenceIfMatch(be.DOCTYPE, !1) ? (this.currentLocation = this.getCurrentLocation(be.DOCTYPE.length + 1), this.state = E.DOCTYPE) : this._consumeSequenceIfMatch(be.CDATA_START, !0) ? this.inForeignNode ? this.state = E.CDATA_SECTION : (this._err(k.cdataInHtmlContent), this._createCommentToken(be.CDATA_START.length + 1), this.currentToken.data = "[CDATA[", this.state = E.BOGUS_COMMENT) : this._ensureHibernation() || (this._err(k.incorrectlyOpenedComment), this._createCommentToken(2), this.state = E.BOGUS_COMMENT, this._stateBogusComment(t));
  }
  // Comment start state
  //------------------------------------------------------------------
  _stateCommentStart(t) {
    switch (t) {
      case p.HYPHEN_MINUS: {
        this.state = E.COMMENT_START_DASH;
        break;
      }
      case p.GREATER_THAN_SIGN: {
        this._err(k.abruptClosingOfEmptyComment), this.state = E.DATA;
        const n = this.currentToken;
        this.emitCurrentComment(n);
        break;
      }
      default:
        this.state = E.COMMENT, this._stateComment(t);
    }
  }
  // Comment start dash state
  //------------------------------------------------------------------
  _stateCommentStartDash(t) {
    const n = this.currentToken;
    switch (t) {
      case p.HYPHEN_MINUS: {
        this.state = E.COMMENT_END;
        break;
      }
      case p.GREATER_THAN_SIGN: {
        this._err(k.abruptClosingOfEmptyComment), this.state = E.DATA, this.emitCurrentComment(n);
        break;
      }
      case p.EOF: {
        this._err(k.eofInComment), this.emitCurrentComment(n), this._emitEOFToken();
        break;
      }
      default:
        n.data += "-", this.state = E.COMMENT, this._stateComment(t);
    }
  }
  // Comment state
  //------------------------------------------------------------------
  _stateComment(t) {
    const n = this.currentToken;
    switch (t) {
      case p.HYPHEN_MINUS: {
        this.state = E.COMMENT_END_DASH;
        break;
      }
      case p.LESS_THAN_SIGN: {
        n.data += "<", this.state = E.COMMENT_LESS_THAN_SIGN;
        break;
      }
      case p.NULL: {
        this._err(k.unexpectedNullCharacter), n.data += ae;
        break;
      }
      case p.EOF: {
        this._err(k.eofInComment), this.emitCurrentComment(n), this._emitEOFToken();
        break;
      }
      default:
        n.data += String.fromCodePoint(t);
    }
  }
  // Comment less-than sign state
  //------------------------------------------------------------------
  _stateCommentLessThanSign(t) {
    const n = this.currentToken;
    switch (t) {
      case p.EXCLAMATION_MARK: {
        n.data += "!", this.state = E.COMMENT_LESS_THAN_SIGN_BANG;
        break;
      }
      case p.LESS_THAN_SIGN: {
        n.data += "<";
        break;
      }
      default:
        this.state = E.COMMENT, this._stateComment(t);
    }
  }
  // Comment less-than sign bang state
  //------------------------------------------------------------------
  _stateCommentLessThanSignBang(t) {
    t === p.HYPHEN_MINUS ? this.state = E.COMMENT_LESS_THAN_SIGN_BANG_DASH : (this.state = E.COMMENT, this._stateComment(t));
  }
  // Comment less-than sign bang dash state
  //------------------------------------------------------------------
  _stateCommentLessThanSignBangDash(t) {
    t === p.HYPHEN_MINUS ? this.state = E.COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH : (this.state = E.COMMENT_END_DASH, this._stateCommentEndDash(t));
  }
  // Comment less-than sign bang dash dash state
  //------------------------------------------------------------------
  _stateCommentLessThanSignBangDashDash(t) {
    t !== p.GREATER_THAN_SIGN && t !== p.EOF && this._err(k.nestedComment), this.state = E.COMMENT_END, this._stateCommentEnd(t);
  }
  // Comment end dash state
  //------------------------------------------------------------------
  _stateCommentEndDash(t) {
    const n = this.currentToken;
    switch (t) {
      case p.HYPHEN_MINUS: {
        this.state = E.COMMENT_END;
        break;
      }
      case p.EOF: {
        this._err(k.eofInComment), this.emitCurrentComment(n), this._emitEOFToken();
        break;
      }
      default:
        n.data += "-", this.state = E.COMMENT, this._stateComment(t);
    }
  }
  // Comment end state
  //------------------------------------------------------------------
  _stateCommentEnd(t) {
    const n = this.currentToken;
    switch (t) {
      case p.GREATER_THAN_SIGN: {
        this.state = E.DATA, this.emitCurrentComment(n);
        break;
      }
      case p.EXCLAMATION_MARK: {
        this.state = E.COMMENT_END_BANG;
        break;
      }
      case p.HYPHEN_MINUS: {
        n.data += "-";
        break;
      }
      case p.EOF: {
        this._err(k.eofInComment), this.emitCurrentComment(n), this._emitEOFToken();
        break;
      }
      default:
        n.data += "--", this.state = E.COMMENT, this._stateComment(t);
    }
  }
  // Comment end bang state
  //------------------------------------------------------------------
  _stateCommentEndBang(t) {
    const n = this.currentToken;
    switch (t) {
      case p.HYPHEN_MINUS: {
        n.data += "--!", this.state = E.COMMENT_END_DASH;
        break;
      }
      case p.GREATER_THAN_SIGN: {
        this._err(k.incorrectlyClosedComment), this.state = E.DATA, this.emitCurrentComment(n);
        break;
      }
      case p.EOF: {
        this._err(k.eofInComment), this.emitCurrentComment(n), this._emitEOFToken();
        break;
      }
      default:
        n.data += "--!", this.state = E.COMMENT, this._stateComment(t);
    }
  }
  // DOCTYPE state
  //------------------------------------------------------------------
  _stateDoctype(t) {
    switch (t) {
      case p.SPACE:
      case p.LINE_FEED:
      case p.TABULATION:
      case p.FORM_FEED: {
        this.state = E.BEFORE_DOCTYPE_NAME;
        break;
      }
      case p.GREATER_THAN_SIGN: {
        this.state = E.BEFORE_DOCTYPE_NAME, this._stateBeforeDoctypeName(t);
        break;
      }
      case p.EOF: {
        this._err(k.eofInDoctype), this._createDoctypeToken(null);
        const n = this.currentToken;
        n.forceQuirks = !0, this.emitCurrentDoctype(n), this._emitEOFToken();
        break;
      }
      default:
        this._err(k.missingWhitespaceBeforeDoctypeName), this.state = E.BEFORE_DOCTYPE_NAME, this._stateBeforeDoctypeName(t);
    }
  }
  // Before DOCTYPE name state
  //------------------------------------------------------------------
  _stateBeforeDoctypeName(t) {
    if (qt(t))
      this._createDoctypeToken(String.fromCharCode(mn(t))), this.state = E.DOCTYPE_NAME;
    else
      switch (t) {
        case p.SPACE:
        case p.LINE_FEED:
        case p.TABULATION:
        case p.FORM_FEED:
          break;
        case p.NULL: {
          this._err(k.unexpectedNullCharacter), this._createDoctypeToken(ae), this.state = E.DOCTYPE_NAME;
          break;
        }
        case p.GREATER_THAN_SIGN: {
          this._err(k.missingDoctypeName), this._createDoctypeToken(null);
          const n = this.currentToken;
          n.forceQuirks = !0, this.emitCurrentDoctype(n), this.state = E.DATA;
          break;
        }
        case p.EOF: {
          this._err(k.eofInDoctype), this._createDoctypeToken(null);
          const n = this.currentToken;
          n.forceQuirks = !0, this.emitCurrentDoctype(n), this._emitEOFToken();
          break;
        }
        default:
          this._createDoctypeToken(String.fromCodePoint(t)), this.state = E.DOCTYPE_NAME;
      }
  }
  // DOCTYPE name state
  //------------------------------------------------------------------
  _stateDoctypeName(t) {
    const n = this.currentToken;
    switch (t) {
      case p.SPACE:
      case p.LINE_FEED:
      case p.TABULATION:
      case p.FORM_FEED: {
        this.state = E.AFTER_DOCTYPE_NAME;
        break;
      }
      case p.GREATER_THAN_SIGN: {
        this.state = E.DATA, this.emitCurrentDoctype(n);
        break;
      }
      case p.NULL: {
        this._err(k.unexpectedNullCharacter), n.name += ae;
        break;
      }
      case p.EOF: {
        this._err(k.eofInDoctype), n.forceQuirks = !0, this.emitCurrentDoctype(n), this._emitEOFToken();
        break;
      }
      default:
        n.name += String.fromCodePoint(qt(t) ? mn(t) : t);
    }
  }
  // After DOCTYPE name state
  //------------------------------------------------------------------
  _stateAfterDoctypeName(t) {
    const n = this.currentToken;
    switch (t) {
      case p.SPACE:
      case p.LINE_FEED:
      case p.TABULATION:
      case p.FORM_FEED:
        break;
      case p.GREATER_THAN_SIGN: {
        this.state = E.DATA, this.emitCurrentDoctype(n);
        break;
      }
      case p.EOF: {
        this._err(k.eofInDoctype), n.forceQuirks = !0, this.emitCurrentDoctype(n), this._emitEOFToken();
        break;
      }
      default:
        this._consumeSequenceIfMatch(be.PUBLIC, !1) ? this.state = E.AFTER_DOCTYPE_PUBLIC_KEYWORD : this._consumeSequenceIfMatch(be.SYSTEM, !1) ? this.state = E.AFTER_DOCTYPE_SYSTEM_KEYWORD : this._ensureHibernation() || (this._err(k.invalidCharacterSequenceAfterDoctypeName), n.forceQuirks = !0, this.state = E.BOGUS_DOCTYPE, this._stateBogusDoctype(t));
    }
  }
  // After DOCTYPE public keyword state
  //------------------------------------------------------------------
  _stateAfterDoctypePublicKeyword(t) {
    const n = this.currentToken;
    switch (t) {
      case p.SPACE:
      case p.LINE_FEED:
      case p.TABULATION:
      case p.FORM_FEED: {
        this.state = E.BEFORE_DOCTYPE_PUBLIC_IDENTIFIER;
        break;
      }
      case p.QUOTATION_MARK: {
        this._err(k.missingWhitespaceAfterDoctypePublicKeyword), n.publicId = "", this.state = E.DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED;
        break;
      }
      case p.APOSTROPHE: {
        this._err(k.missingWhitespaceAfterDoctypePublicKeyword), n.publicId = "", this.state = E.DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED;
        break;
      }
      case p.GREATER_THAN_SIGN: {
        this._err(k.missingDoctypePublicIdentifier), n.forceQuirks = !0, this.state = E.DATA, this.emitCurrentDoctype(n);
        break;
      }
      case p.EOF: {
        this._err(k.eofInDoctype), n.forceQuirks = !0, this.emitCurrentDoctype(n), this._emitEOFToken();
        break;
      }
      default:
        this._err(k.missingQuoteBeforeDoctypePublicIdentifier), n.forceQuirks = !0, this.state = E.BOGUS_DOCTYPE, this._stateBogusDoctype(t);
    }
  }
  // Before DOCTYPE public identifier state
  //------------------------------------------------------------------
  _stateBeforeDoctypePublicIdentifier(t) {
    const n = this.currentToken;
    switch (t) {
      case p.SPACE:
      case p.LINE_FEED:
      case p.TABULATION:
      case p.FORM_FEED:
        break;
      case p.QUOTATION_MARK: {
        n.publicId = "", this.state = E.DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED;
        break;
      }
      case p.APOSTROPHE: {
        n.publicId = "", this.state = E.DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED;
        break;
      }
      case p.GREATER_THAN_SIGN: {
        this._err(k.missingDoctypePublicIdentifier), n.forceQuirks = !0, this.state = E.DATA, this.emitCurrentDoctype(n);
        break;
      }
      case p.EOF: {
        this._err(k.eofInDoctype), n.forceQuirks = !0, this.emitCurrentDoctype(n), this._emitEOFToken();
        break;
      }
      default:
        this._err(k.missingQuoteBeforeDoctypePublicIdentifier), n.forceQuirks = !0, this.state = E.BOGUS_DOCTYPE, this._stateBogusDoctype(t);
    }
  }
  // DOCTYPE public identifier (double-quoted) state
  //------------------------------------------------------------------
  _stateDoctypePublicIdentifierDoubleQuoted(t) {
    const n = this.currentToken;
    switch (t) {
      case p.QUOTATION_MARK: {
        this.state = E.AFTER_DOCTYPE_PUBLIC_IDENTIFIER;
        break;
      }
      case p.NULL: {
        this._err(k.unexpectedNullCharacter), n.publicId += ae;
        break;
      }
      case p.GREATER_THAN_SIGN: {
        this._err(k.abruptDoctypePublicIdentifier), n.forceQuirks = !0, this.emitCurrentDoctype(n), this.state = E.DATA;
        break;
      }
      case p.EOF: {
        this._err(k.eofInDoctype), n.forceQuirks = !0, this.emitCurrentDoctype(n), this._emitEOFToken();
        break;
      }
      default:
        n.publicId += String.fromCodePoint(t);
    }
  }
  // DOCTYPE public identifier (single-quoted) state
  //------------------------------------------------------------------
  _stateDoctypePublicIdentifierSingleQuoted(t) {
    const n = this.currentToken;
    switch (t) {
      case p.APOSTROPHE: {
        this.state = E.AFTER_DOCTYPE_PUBLIC_IDENTIFIER;
        break;
      }
      case p.NULL: {
        this._err(k.unexpectedNullCharacter), n.publicId += ae;
        break;
      }
      case p.GREATER_THAN_SIGN: {
        this._err(k.abruptDoctypePublicIdentifier), n.forceQuirks = !0, this.emitCurrentDoctype(n), this.state = E.DATA;
        break;
      }
      case p.EOF: {
        this._err(k.eofInDoctype), n.forceQuirks = !0, this.emitCurrentDoctype(n), this._emitEOFToken();
        break;
      }
      default:
        n.publicId += String.fromCodePoint(t);
    }
  }
  // After DOCTYPE public identifier state
  //------------------------------------------------------------------
  _stateAfterDoctypePublicIdentifier(t) {
    const n = this.currentToken;
    switch (t) {
      case p.SPACE:
      case p.LINE_FEED:
      case p.TABULATION:
      case p.FORM_FEED: {
        this.state = E.BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS;
        break;
      }
      case p.GREATER_THAN_SIGN: {
        this.state = E.DATA, this.emitCurrentDoctype(n);
        break;
      }
      case p.QUOTATION_MARK: {
        this._err(k.missingWhitespaceBetweenDoctypePublicAndSystemIdentifiers), n.systemId = "", this.state = E.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED;
        break;
      }
      case p.APOSTROPHE: {
        this._err(k.missingWhitespaceBetweenDoctypePublicAndSystemIdentifiers), n.systemId = "", this.state = E.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED;
        break;
      }
      case p.EOF: {
        this._err(k.eofInDoctype), n.forceQuirks = !0, this.emitCurrentDoctype(n), this._emitEOFToken();
        break;
      }
      default:
        this._err(k.missingQuoteBeforeDoctypeSystemIdentifier), n.forceQuirks = !0, this.state = E.BOGUS_DOCTYPE, this._stateBogusDoctype(t);
    }
  }
  // Between DOCTYPE public and system identifiers state
  //------------------------------------------------------------------
  _stateBetweenDoctypePublicAndSystemIdentifiers(t) {
    const n = this.currentToken;
    switch (t) {
      case p.SPACE:
      case p.LINE_FEED:
      case p.TABULATION:
      case p.FORM_FEED:
        break;
      case p.GREATER_THAN_SIGN: {
        this.emitCurrentDoctype(n), this.state = E.DATA;
        break;
      }
      case p.QUOTATION_MARK: {
        n.systemId = "", this.state = E.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED;
        break;
      }
      case p.APOSTROPHE: {
        n.systemId = "", this.state = E.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED;
        break;
      }
      case p.EOF: {
        this._err(k.eofInDoctype), n.forceQuirks = !0, this.emitCurrentDoctype(n), this._emitEOFToken();
        break;
      }
      default:
        this._err(k.missingQuoteBeforeDoctypeSystemIdentifier), n.forceQuirks = !0, this.state = E.BOGUS_DOCTYPE, this._stateBogusDoctype(t);
    }
  }
  // After DOCTYPE system keyword state
  //------------------------------------------------------------------
  _stateAfterDoctypeSystemKeyword(t) {
    const n = this.currentToken;
    switch (t) {
      case p.SPACE:
      case p.LINE_FEED:
      case p.TABULATION:
      case p.FORM_FEED: {
        this.state = E.BEFORE_DOCTYPE_SYSTEM_IDENTIFIER;
        break;
      }
      case p.QUOTATION_MARK: {
        this._err(k.missingWhitespaceAfterDoctypeSystemKeyword), n.systemId = "", this.state = E.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED;
        break;
      }
      case p.APOSTROPHE: {
        this._err(k.missingWhitespaceAfterDoctypeSystemKeyword), n.systemId = "", this.state = E.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED;
        break;
      }
      case p.GREATER_THAN_SIGN: {
        this._err(k.missingDoctypeSystemIdentifier), n.forceQuirks = !0, this.state = E.DATA, this.emitCurrentDoctype(n);
        break;
      }
      case p.EOF: {
        this._err(k.eofInDoctype), n.forceQuirks = !0, this.emitCurrentDoctype(n), this._emitEOFToken();
        break;
      }
      default:
        this._err(k.missingQuoteBeforeDoctypeSystemIdentifier), n.forceQuirks = !0, this.state = E.BOGUS_DOCTYPE, this._stateBogusDoctype(t);
    }
  }
  // Before DOCTYPE system identifier state
  //------------------------------------------------------------------
  _stateBeforeDoctypeSystemIdentifier(t) {
    const n = this.currentToken;
    switch (t) {
      case p.SPACE:
      case p.LINE_FEED:
      case p.TABULATION:
      case p.FORM_FEED:
        break;
      case p.QUOTATION_MARK: {
        n.systemId = "", this.state = E.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED;
        break;
      }
      case p.APOSTROPHE: {
        n.systemId = "", this.state = E.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED;
        break;
      }
      case p.GREATER_THAN_SIGN: {
        this._err(k.missingDoctypeSystemIdentifier), n.forceQuirks = !0, this.state = E.DATA, this.emitCurrentDoctype(n);
        break;
      }
      case p.EOF: {
        this._err(k.eofInDoctype), n.forceQuirks = !0, this.emitCurrentDoctype(n), this._emitEOFToken();
        break;
      }
      default:
        this._err(k.missingQuoteBeforeDoctypeSystemIdentifier), n.forceQuirks = !0, this.state = E.BOGUS_DOCTYPE, this._stateBogusDoctype(t);
    }
  }
  // DOCTYPE system identifier (double-quoted) state
  //------------------------------------------------------------------
  _stateDoctypeSystemIdentifierDoubleQuoted(t) {
    const n = this.currentToken;
    switch (t) {
      case p.QUOTATION_MARK: {
        this.state = E.AFTER_DOCTYPE_SYSTEM_IDENTIFIER;
        break;
      }
      case p.NULL: {
        this._err(k.unexpectedNullCharacter), n.systemId += ae;
        break;
      }
      case p.GREATER_THAN_SIGN: {
        this._err(k.abruptDoctypeSystemIdentifier), n.forceQuirks = !0, this.emitCurrentDoctype(n), this.state = E.DATA;
        break;
      }
      case p.EOF: {
        this._err(k.eofInDoctype), n.forceQuirks = !0, this.emitCurrentDoctype(n), this._emitEOFToken();
        break;
      }
      default:
        n.systemId += String.fromCodePoint(t);
    }
  }
  // DOCTYPE system identifier (single-quoted) state
  //------------------------------------------------------------------
  _stateDoctypeSystemIdentifierSingleQuoted(t) {
    const n = this.currentToken;
    switch (t) {
      case p.APOSTROPHE: {
        this.state = E.AFTER_DOCTYPE_SYSTEM_IDENTIFIER;
        break;
      }
      case p.NULL: {
        this._err(k.unexpectedNullCharacter), n.systemId += ae;
        break;
      }
      case p.GREATER_THAN_SIGN: {
        this._err(k.abruptDoctypeSystemIdentifier), n.forceQuirks = !0, this.emitCurrentDoctype(n), this.state = E.DATA;
        break;
      }
      case p.EOF: {
        this._err(k.eofInDoctype), n.forceQuirks = !0, this.emitCurrentDoctype(n), this._emitEOFToken();
        break;
      }
      default:
        n.systemId += String.fromCodePoint(t);
    }
  }
  // After DOCTYPE system identifier state
  //------------------------------------------------------------------
  _stateAfterDoctypeSystemIdentifier(t) {
    const n = this.currentToken;
    switch (t) {
      case p.SPACE:
      case p.LINE_FEED:
      case p.TABULATION:
      case p.FORM_FEED:
        break;
      case p.GREATER_THAN_SIGN: {
        this.emitCurrentDoctype(n), this.state = E.DATA;
        break;
      }
      case p.EOF: {
        this._err(k.eofInDoctype), n.forceQuirks = !0, this.emitCurrentDoctype(n), this._emitEOFToken();
        break;
      }
      default:
        this._err(k.unexpectedCharacterAfterDoctypeSystemIdentifier), this.state = E.BOGUS_DOCTYPE, this._stateBogusDoctype(t);
    }
  }
  // Bogus DOCTYPE state
  //------------------------------------------------------------------
  _stateBogusDoctype(t) {
    const n = this.currentToken;
    switch (t) {
      case p.GREATER_THAN_SIGN: {
        this.emitCurrentDoctype(n), this.state = E.DATA;
        break;
      }
      case p.NULL: {
        this._err(k.unexpectedNullCharacter);
        break;
      }
      case p.EOF: {
        this.emitCurrentDoctype(n), this._emitEOFToken();
        break;
      }
    }
  }
  // CDATA section state
  //------------------------------------------------------------------
  _stateCdataSection(t) {
    switch (t) {
      case p.RIGHT_SQUARE_BRACKET: {
        this.state = E.CDATA_SECTION_BRACKET;
        break;
      }
      case p.EOF: {
        this._err(k.eofInCdata), this._emitEOFToken();
        break;
      }
      default:
        this._emitCodePoint(t);
    }
  }
  // CDATA section bracket state
  //------------------------------------------------------------------
  _stateCdataSectionBracket(t) {
    t === p.RIGHT_SQUARE_BRACKET ? this.state = E.CDATA_SECTION_END : (this._emitChars("]"), this.state = E.CDATA_SECTION, this._stateCdataSection(t));
  }
  // CDATA section end state
  //------------------------------------------------------------------
  _stateCdataSectionEnd(t) {
    switch (t) {
      case p.GREATER_THAN_SIGN: {
        this.state = E.DATA;
        break;
      }
      case p.RIGHT_SQUARE_BRACKET: {
        this._emitChars("]");
        break;
      }
      default:
        this._emitChars("]]"), this.state = E.CDATA_SECTION, this._stateCdataSection(t);
    }
  }
  // Character reference state
  //------------------------------------------------------------------
  _stateCharacterReference() {
    let t = this.entityDecoder.write(this.preprocessor.html, this.preprocessor.pos);
    if (t < 0)
      if (this.preprocessor.lastChunkWritten)
        t = this.entityDecoder.end();
      else {
        this.active = !1, this.preprocessor.pos = this.preprocessor.html.length - 1, this.consumedAfterSnapshot = 0, this.preprocessor.endOfChunkHit = !0;
        return;
      }
    t === 0 ? (this.preprocessor.pos = this.entityStartPos, this._flushCodePointConsumedAsCharacterReference(p.AMPERSAND), this.state = !this._isCharacterReferenceInAttribute() && ui(this.preprocessor.peek(1)) ? E.AMBIGUOUS_AMPERSAND : this.returnState) : this.state = this.returnState;
  }
  // Ambiguos ampersand state
  //------------------------------------------------------------------
  _stateAmbiguousAmpersand(t) {
    ui(t) ? this._flushCodePointConsumedAsCharacterReference(t) : (t === p.SEMICOLON && this._err(k.unknownNamedCharacterReference), this.state = this.returnState, this._callState(t));
  }
}
const za = /* @__PURE__ */ new Set([s.DD, s.DT, s.LI, s.OPTGROUP, s.OPTION, s.P, s.RB, s.RP, s.RT, s.RTC]), ai = /* @__PURE__ */ new Set([
  ...za,
  s.CAPTION,
  s.COLGROUP,
  s.TBODY,
  s.TD,
  s.TFOOT,
  s.TH,
  s.THEAD,
  s.TR
]), Dn = /* @__PURE__ */ new Set([
  s.APPLET,
  s.CAPTION,
  s.HTML,
  s.MARQUEE,
  s.OBJECT,
  s.TABLE,
  s.TD,
  s.TEMPLATE,
  s.TH
]), Zd = /* @__PURE__ */ new Set([...Dn, s.OL, s.UL]), Jd = /* @__PURE__ */ new Set([...Dn, s.BUTTON]), si = /* @__PURE__ */ new Set([s.ANNOTATION_XML, s.MI, s.MN, s.MO, s.MS, s.MTEXT]), oi = /* @__PURE__ */ new Set([s.DESC, s.FOREIGN_OBJECT, s.TITLE]), eh = /* @__PURE__ */ new Set([s.TR, s.TEMPLATE, s.HTML]), th = /* @__PURE__ */ new Set([s.TBODY, s.TFOOT, s.THEAD, s.TEMPLATE, s.HTML]), nh = /* @__PURE__ */ new Set([s.TABLE, s.TEMPLATE, s.HTML]), rh = /* @__PURE__ */ new Set([s.TD, s.TH]);
class uh {
  get currentTmplContentOrNode() {
    return this._isInTemplate() ? this.treeAdapter.getTemplateContent(this.current) : this.current;
  }
  constructor(t, n, r) {
    this.treeAdapter = n, this.handler = r, this.items = [], this.tagIDs = [], this.stackTop = -1, this.tmplCount = 0, this.currentTagId = s.UNKNOWN, this.current = t;
  }
  //Index of element
  _indexOf(t) {
    return this.items.lastIndexOf(t, this.stackTop);
  }
  //Update current element
  _isInTemplate() {
    return this.currentTagId === s.TEMPLATE && this.treeAdapter.getNamespaceURI(this.current) === D.HTML;
  }
  _updateCurrentElement() {
    this.current = this.items[this.stackTop], this.currentTagId = this.tagIDs[this.stackTop];
  }
  //Mutations
  push(t, n) {
    this.stackTop++, this.items[this.stackTop] = t, this.current = t, this.tagIDs[this.stackTop] = n, this.currentTagId = n, this._isInTemplate() && this.tmplCount++, this.handler.onItemPush(t, n, !0);
  }
  pop() {
    const t = this.current;
    this.tmplCount > 0 && this._isInTemplate() && this.tmplCount--, this.stackTop--, this._updateCurrentElement(), this.handler.onItemPop(t, !0);
  }
  replace(t, n) {
    const r = this._indexOf(t);
    this.items[r] = n, r === this.stackTop && (this.current = n);
  }
  insertAfter(t, n, r) {
    const u = this._indexOf(t) + 1;
    this.items.splice(u, 0, n), this.tagIDs.splice(u, 0, r), this.stackTop++, u === this.stackTop && this._updateCurrentElement(), this.handler.onItemPush(this.current, this.currentTagId, u === this.stackTop);
  }
  popUntilTagNamePopped(t) {
    let n = this.stackTop + 1;
    do
      n = this.tagIDs.lastIndexOf(t, n - 1);
    while (n > 0 && this.treeAdapter.getNamespaceURI(this.items[n]) !== D.HTML);
    this.shortenToLength(n < 0 ? 0 : n);
  }
  shortenToLength(t) {
    for (; this.stackTop >= t; ) {
      const n = this.current;
      this.tmplCount > 0 && this._isInTemplate() && (this.tmplCount -= 1), this.stackTop--, this._updateCurrentElement(), this.handler.onItemPop(n, this.stackTop < t);
    }
  }
  popUntilElementPopped(t) {
    const n = this._indexOf(t);
    this.shortenToLength(n < 0 ? 0 : n);
  }
  popUntilPopped(t, n) {
    const r = this._indexOfTagNames(t, n);
    this.shortenToLength(r < 0 ? 0 : r);
  }
  popUntilNumberedHeaderPopped() {
    this.popUntilPopped(yr, D.HTML);
  }
  popUntilTableCellPopped() {
    this.popUntilPopped(rh, D.HTML);
  }
  popAllUpToHtmlElement() {
    this.tmplCount = 0, this.shortenToLength(1);
  }
  _indexOfTagNames(t, n) {
    for (let r = this.stackTop; r >= 0; r--)
      if (t.has(this.tagIDs[r]) && this.treeAdapter.getNamespaceURI(this.items[r]) === n)
        return r;
    return -1;
  }
  clearBackTo(t, n) {
    const r = this._indexOfTagNames(t, n);
    this.shortenToLength(r + 1);
  }
  clearBackToTableContext() {
    this.clearBackTo(nh, D.HTML);
  }
  clearBackToTableBodyContext() {
    this.clearBackTo(th, D.HTML);
  }
  clearBackToTableRowContext() {
    this.clearBackTo(eh, D.HTML);
  }
  remove(t) {
    const n = this._indexOf(t);
    n >= 0 && (n === this.stackTop ? this.pop() : (this.items.splice(n, 1), this.tagIDs.splice(n, 1), this.stackTop--, this._updateCurrentElement(), this.handler.onItemPop(t, !1)));
  }
  //Search
  tryPeekProperlyNestedBodyElement() {
    return this.stackTop >= 1 && this.tagIDs[1] === s.BODY ? this.items[1] : null;
  }
  contains(t) {
    return this._indexOf(t) > -1;
  }
  getCommonAncestor(t) {
    const n = this._indexOf(t) - 1;
    return n >= 0 ? this.items[n] : null;
  }
  isRootHtmlElementCurrent() {
    return this.stackTop === 0 && this.tagIDs[0] === s.HTML;
  }
  //Element in scope
  hasInDynamicScope(t, n) {
    for (let r = this.stackTop; r >= 0; r--) {
      const u = this.tagIDs[r];
      switch (this.treeAdapter.getNamespaceURI(this.items[r])) {
        case D.HTML: {
          if (u === t)
            return !0;
          if (n.has(u))
            return !1;
          break;
        }
        case D.SVG: {
          if (oi.has(u))
            return !1;
          break;
        }
        case D.MATHML: {
          if (si.has(u))
            return !1;
          break;
        }
      }
    }
    return !0;
  }
  hasInScope(t) {
    return this.hasInDynamicScope(t, Dn);
  }
  hasInListItemScope(t) {
    return this.hasInDynamicScope(t, Zd);
  }
  hasInButtonScope(t) {
    return this.hasInDynamicScope(t, Jd);
  }
  hasNumberedHeaderInScope() {
    for (let t = this.stackTop; t >= 0; t--) {
      const n = this.tagIDs[t];
      switch (this.treeAdapter.getNamespaceURI(this.items[t])) {
        case D.HTML: {
          if (yr.has(n))
            return !0;
          if (Dn.has(n))
            return !1;
          break;
        }
        case D.SVG: {
          if (oi.has(n))
            return !1;
          break;
        }
        case D.MATHML: {
          if (si.has(n))
            return !1;
          break;
        }
      }
    }
    return !0;
  }
  hasInTableScope(t) {
    for (let n = this.stackTop; n >= 0; n--)
      if (this.treeAdapter.getNamespaceURI(this.items[n]) === D.HTML)
        switch (this.tagIDs[n]) {
          case t:
            return !0;
          case s.TABLE:
          case s.HTML:
            return !1;
        }
    return !0;
  }
  hasTableBodyContextInTableScope() {
    for (let t = this.stackTop; t >= 0; t--)
      if (this.treeAdapter.getNamespaceURI(this.items[t]) === D.HTML)
        switch (this.tagIDs[t]) {
          case s.TBODY:
          case s.THEAD:
          case s.TFOOT:
            return !0;
          case s.TABLE:
          case s.HTML:
            return !1;
        }
    return !0;
  }
  hasInSelectScope(t) {
    for (let n = this.stackTop; n >= 0; n--)
      if (this.treeAdapter.getNamespaceURI(this.items[n]) === D.HTML)
        switch (this.tagIDs[n]) {
          case t:
            return !0;
          case s.OPTION:
          case s.OPTGROUP:
            break;
          default:
            return !1;
        }
    return !0;
  }
  //Implied end tags
  generateImpliedEndTags() {
    for (; za.has(this.currentTagId); )
      this.pop();
  }
  generateImpliedEndTagsThoroughly() {
    for (; ai.has(this.currentTagId); )
      this.pop();
  }
  generateImpliedEndTagsWithExclusion(t) {
    for (; this.currentTagId !== t && ai.has(this.currentTagId); )
      this.pop();
  }
}
const fr = 3;
var Be;
(function(e) {
  e[e.Marker = 0] = "Marker", e[e.Element = 1] = "Element";
})(Be || (Be = {}));
const li = { type: Be.Marker };
class ih {
  constructor(t) {
    this.treeAdapter = t, this.entries = [], this.bookmark = null;
  }
  //Noah Ark's condition
  //OPTIMIZATION: at first we try to find possible candidates for exclusion using
  //lightweight heuristics without thorough attributes check.
  _getNoahArkConditionCandidates(t, n) {
    const r = [], u = n.length, a = this.treeAdapter.getTagName(t), i = this.treeAdapter.getNamespaceURI(t);
    for (let o = 0; o < this.entries.length; o++) {
      const l = this.entries[o];
      if (l.type === Be.Marker)
        break;
      const { element: c } = l;
      if (this.treeAdapter.getTagName(c) === a && this.treeAdapter.getNamespaceURI(c) === i) {
        const d = this.treeAdapter.getAttrList(c);
        d.length === u && r.push({ idx: o, attrs: d });
      }
    }
    return r;
  }
  _ensureNoahArkCondition(t) {
    if (this.entries.length < fr)
      return;
    const n = this.treeAdapter.getAttrList(t), r = this._getNoahArkConditionCandidates(t, n);
    if (r.length < fr)
      return;
    const u = new Map(n.map((i) => [i.name, i.value]));
    let a = 0;
    for (let i = 0; i < r.length; i++) {
      const o = r[i];
      o.attrs.every((l) => u.get(l.name) === l.value) && (a += 1, a >= fr && this.entries.splice(o.idx, 1));
    }
  }
  //Mutations
  insertMarker() {
    this.entries.unshift(li);
  }
  pushElement(t, n) {
    this._ensureNoahArkCondition(t), this.entries.unshift({
      type: Be.Element,
      element: t,
      token: n
    });
  }
  insertElementAfterBookmark(t, n) {
    const r = this.entries.indexOf(this.bookmark);
    this.entries.splice(r, 0, {
      type: Be.Element,
      element: t,
      token: n
    });
  }
  removeEntry(t) {
    const n = this.entries.indexOf(t);
    n >= 0 && this.entries.splice(n, 1);
  }
  /**
   * Clears the list of formatting elements up to the last marker.
   *
   * @see https://html.spec.whatwg.org/multipage/parsing.html#clear-the-list-of-active-formatting-elements-up-to-the-last-marker
   */
  clearToLastMarker() {
    const t = this.entries.indexOf(li);
    t >= 0 ? this.entries.splice(0, t + 1) : this.entries.length = 0;
  }
  //Search
  getElementEntryInScopeWithTagName(t) {
    const n = this.entries.find((r) => r.type === Be.Marker || this.treeAdapter.getTagName(r.element) === t);
    return n && n.type === Be.Element ? n : null;
  }
  getElementEntry(t) {
    return this.entries.find((n) => n.type === Be.Element && n.element === t);
  }
}
const Xe = {
  //Node construction
  createDocument() {
    return {
      nodeName: "#document",
      mode: ke.NO_QUIRKS,
      childNodes: []
    };
  },
  createDocumentFragment() {
    return {
      nodeName: "#document-fragment",
      childNodes: []
    };
  },
  createElement(e, t, n) {
    return {
      nodeName: e,
      tagName: e,
      attrs: n,
      namespaceURI: t,
      childNodes: [],
      parentNode: null
    };
  },
  createCommentNode(e) {
    return {
      nodeName: "#comment",
      data: e,
      parentNode: null
    };
  },
  createTextNode(e) {
    return {
      nodeName: "#text",
      value: e,
      parentNode: null
    };
  },
  //Tree mutation
  appendChild(e, t) {
    e.childNodes.push(t), t.parentNode = e;
  },
  insertBefore(e, t, n) {
    const r = e.childNodes.indexOf(n);
    e.childNodes.splice(r, 0, t), t.parentNode = e;
  },
  setTemplateContent(e, t) {
    e.content = t;
  },
  getTemplateContent(e) {
    return e.content;
  },
  setDocumentType(e, t, n, r) {
    const u = e.childNodes.find((a) => a.nodeName === "#documentType");
    if (u)
      u.name = t, u.publicId = n, u.systemId = r;
    else {
      const a = {
        nodeName: "#documentType",
        name: t,
        publicId: n,
        systemId: r,
        parentNode: null
      };
      Xe.appendChild(e, a);
    }
  },
  setDocumentMode(e, t) {
    e.mode = t;
  },
  getDocumentMode(e) {
    return e.mode;
  },
  detachNode(e) {
    if (e.parentNode) {
      const t = e.parentNode.childNodes.indexOf(e);
      e.parentNode.childNodes.splice(t, 1), e.parentNode = null;
    }
  },
  insertText(e, t) {
    if (e.childNodes.length > 0) {
      const n = e.childNodes[e.childNodes.length - 1];
      if (Xe.isTextNode(n)) {
        n.value += t;
        return;
      }
    }
    Xe.appendChild(e, Xe.createTextNode(t));
  },
  insertTextBefore(e, t, n) {
    const r = e.childNodes[e.childNodes.indexOf(n) - 1];
    r && Xe.isTextNode(r) ? r.value += t : Xe.insertBefore(e, Xe.createTextNode(t), n);
  },
  adoptAttributes(e, t) {
    const n = new Set(e.attrs.map((r) => r.name));
    for (let r = 0; r < t.length; r++)
      n.has(t[r].name) || e.attrs.push(t[r]);
  },
  //Tree traversing
  getFirstChild(e) {
    return e.childNodes[0];
  },
  getChildNodes(e) {
    return e.childNodes;
  },
  getParentNode(e) {
    return e.parentNode;
  },
  getAttrList(e) {
    return e.attrs;
  },
  //Node data
  getTagName(e) {
    return e.tagName;
  },
  getNamespaceURI(e) {
    return e.namespaceURI;
  },
  getTextNodeContent(e) {
    return e.value;
  },
  getCommentNodeContent(e) {
    return e.data;
  },
  getDocumentTypeNodeName(e) {
    return e.name;
  },
  getDocumentTypeNodePublicId(e) {
    return e.publicId;
  },
  getDocumentTypeNodeSystemId(e) {
    return e.systemId;
  },
  //Node types
  isTextNode(e) {
    return e.nodeName === "#text";
  },
  isCommentNode(e) {
    return e.nodeName === "#comment";
  },
  isDocumentTypeNode(e) {
    return e.nodeName === "#documentType";
  },
  isElementNode(e) {
    return Object.prototype.hasOwnProperty.call(e, "tagName");
  },
  // Source code location
  setNodeSourceCodeLocation(e, t) {
    e.sourceCodeLocation = t;
  },
  getNodeSourceCodeLocation(e) {
    return e.sourceCodeLocation;
  },
  updateNodeSourceCodeLocation(e, t) {
    e.sourceCodeLocation = { ...e.sourceCodeLocation, ...t };
  }
}, qa = "html", ah = "about:legacy-compat", sh = "http://www.ibm.com/data/dtd/v11/ibmxhtml1-transitional.dtd", Ya = [
  "+//silmaril//dtd html pro v0r11 19970101//",
  "-//as//dtd html 3.0 aswedit + extensions//",
  "-//advasoft ltd//dtd html 3.0 aswedit + extensions//",
  "-//ietf//dtd html 2.0 level 1//",
  "-//ietf//dtd html 2.0 level 2//",
  "-//ietf//dtd html 2.0 strict level 1//",
  "-//ietf//dtd html 2.0 strict level 2//",
  "-//ietf//dtd html 2.0 strict//",
  "-//ietf//dtd html 2.0//",
  "-//ietf//dtd html 2.1e//",
  "-//ietf//dtd html 3.0//",
  "-//ietf//dtd html 3.2 final//",
  "-//ietf//dtd html 3.2//",
  "-//ietf//dtd html 3//",
  "-//ietf//dtd html level 0//",
  "-//ietf//dtd html level 1//",
  "-//ietf//dtd html level 2//",
  "-//ietf//dtd html level 3//",
  "-//ietf//dtd html strict level 0//",
  "-//ietf//dtd html strict level 1//",
  "-//ietf//dtd html strict level 2//",
  "-//ietf//dtd html strict level 3//",
  "-//ietf//dtd html strict//",
  "-//ietf//dtd html//",
  "-//metrius//dtd metrius presentational//",
  "-//microsoft//dtd internet explorer 2.0 html strict//",
  "-//microsoft//dtd internet explorer 2.0 html//",
  "-//microsoft//dtd internet explorer 2.0 tables//",
  "-//microsoft//dtd internet explorer 3.0 html strict//",
  "-//microsoft//dtd internet explorer 3.0 html//",
  "-//microsoft//dtd internet explorer 3.0 tables//",
  "-//netscape comm. corp.//dtd html//",
  "-//netscape comm. corp.//dtd strict html//",
  "-//o'reilly and associates//dtd html 2.0//",
  "-//o'reilly and associates//dtd html extended 1.0//",
  "-//o'reilly and associates//dtd html extended relaxed 1.0//",
  "-//sq//dtd html 2.0 hotmetal + extensions//",
  "-//softquad software//dtd hotmetal pro 6.0::19990601::extensions to html 4.0//",
  "-//softquad//dtd hotmetal pro 4.0::19971010::extensions to html 4.0//",
  "-//spyglass//dtd html 2.0 extended//",
  "-//sun microsystems corp.//dtd hotjava html//",
  "-//sun microsystems corp.//dtd hotjava strict html//",
  "-//w3c//dtd html 3 1995-03-24//",
  "-//w3c//dtd html 3.2 draft//",
  "-//w3c//dtd html 3.2 final//",
  "-//w3c//dtd html 3.2//",
  "-//w3c//dtd html 3.2s draft//",
  "-//w3c//dtd html 4.0 frameset//",
  "-//w3c//dtd html 4.0 transitional//",
  "-//w3c//dtd html experimental 19960712//",
  "-//w3c//dtd html experimental 970421//",
  "-//w3c//dtd w3 html//",
  "-//w3o//dtd w3 html 3.0//",
  "-//webtechs//dtd mozilla html 2.0//",
  "-//webtechs//dtd mozilla html//"
], oh = [
  ...Ya,
  "-//w3c//dtd html 4.01 frameset//",
  "-//w3c//dtd html 4.01 transitional//"
], lh = /* @__PURE__ */ new Set([
  "-//w3o//dtd w3 html strict 3.0//en//",
  "-/w3c/dtd html 4.0 transitional/en",
  "html"
]), Va = ["-//w3c//dtd xhtml 1.0 frameset//", "-//w3c//dtd xhtml 1.0 transitional//"], ch = [
  ...Va,
  "-//w3c//dtd html 4.01 frameset//",
  "-//w3c//dtd html 4.01 transitional//"
];
function ci(e, t) {
  return t.some((n) => e.startsWith(n));
}
function fh(e) {
  return e.name === qa && e.publicId === null && (e.systemId === null || e.systemId === ah);
}
function dh(e) {
  if (e.name !== qa)
    return ke.QUIRKS;
  const { systemId: t } = e;
  if (t && t.toLowerCase() === sh)
    return ke.QUIRKS;
  let { publicId: n } = e;
  if (n !== null) {
    if (n = n.toLowerCase(), lh.has(n))
      return ke.QUIRKS;
    let r = t === null ? oh : Ya;
    if (ci(n, r))
      return ke.QUIRKS;
    if (r = t === null ? Va : ch, ci(n, r))
      return ke.LIMITED_QUIRKS;
  }
  return ke.NO_QUIRKS;
}
const fi = {
  TEXT_HTML: "text/html",
  APPLICATION_XML: "application/xhtml+xml"
}, hh = "definitionurl", mh = "definitionURL", ph = new Map([
  "attributeName",
  "attributeType",
  "baseFrequency",
  "baseProfile",
  "calcMode",
  "clipPathUnits",
  "diffuseConstant",
  "edgeMode",
  "filterUnits",
  "glyphRef",
  "gradientTransform",
  "gradientUnits",
  "kernelMatrix",
  "kernelUnitLength",
  "keyPoints",
  "keySplines",
  "keyTimes",
  "lengthAdjust",
  "limitingConeAngle",
  "markerHeight",
  "markerUnits",
  "markerWidth",
  "maskContentUnits",
  "maskUnits",
  "numOctaves",
  "pathLength",
  "patternContentUnits",
  "patternTransform",
  "patternUnits",
  "pointsAtX",
  "pointsAtY",
  "pointsAtZ",
  "preserveAlpha",
  "preserveAspectRatio",
  "primitiveUnits",
  "refX",
  "refY",
  "repeatCount",
  "repeatDur",
  "requiredExtensions",
  "requiredFeatures",
  "specularConstant",
  "specularExponent",
  "spreadMethod",
  "startOffset",
  "stdDeviation",
  "stitchTiles",
  "surfaceScale",
  "systemLanguage",
  "tableValues",
  "targetX",
  "targetY",
  "textLength",
  "viewBox",
  "viewTarget",
  "xChannelSelector",
  "yChannelSelector",
  "zoomAndPan"
].map((e) => [e.toLowerCase(), e])), Eh = /* @__PURE__ */ new Map([
  ["xlink:actuate", { prefix: "xlink", name: "actuate", namespace: D.XLINK }],
  ["xlink:arcrole", { prefix: "xlink", name: "arcrole", namespace: D.XLINK }],
  ["xlink:href", { prefix: "xlink", name: "href", namespace: D.XLINK }],
  ["xlink:role", { prefix: "xlink", name: "role", namespace: D.XLINK }],
  ["xlink:show", { prefix: "xlink", name: "show", namespace: D.XLINK }],
  ["xlink:title", { prefix: "xlink", name: "title", namespace: D.XLINK }],
  ["xlink:type", { prefix: "xlink", name: "type", namespace: D.XLINK }],
  ["xml:lang", { prefix: "xml", name: "lang", namespace: D.XML }],
  ["xml:space", { prefix: "xml", name: "space", namespace: D.XML }],
  ["xmlns", { prefix: "", name: "xmlns", namespace: D.XMLNS }],
  ["xmlns:xlink", { prefix: "xmlns", name: "xlink", namespace: D.XMLNS }]
]), gh = new Map([
  "altGlyph",
  "altGlyphDef",
  "altGlyphItem",
  "animateColor",
  "animateMotion",
  "animateTransform",
  "clipPath",
  "feBlend",
  "feColorMatrix",
  "feComponentTransfer",
  "feComposite",
  "feConvolveMatrix",
  "feDiffuseLighting",
  "feDisplacementMap",
  "feDistantLight",
  "feFlood",
  "feFuncA",
  "feFuncB",
  "feFuncG",
  "feFuncR",
  "feGaussianBlur",
  "feImage",
  "feMerge",
  "feMergeNode",
  "feMorphology",
  "feOffset",
  "fePointLight",
  "feSpecularLighting",
  "feSpotLight",
  "feTile",
  "feTurbulence",
  "foreignObject",
  "glyphRef",
  "linearGradient",
  "radialGradient",
  "textPath"
].map((e) => [e.toLowerCase(), e])), Th = /* @__PURE__ */ new Set([
  s.B,
  s.BIG,
  s.BLOCKQUOTE,
  s.BODY,
  s.BR,
  s.CENTER,
  s.CODE,
  s.DD,
  s.DIV,
  s.DL,
  s.DT,
  s.EM,
  s.EMBED,
  s.H1,
  s.H2,
  s.H3,
  s.H4,
  s.H5,
  s.H6,
  s.HEAD,
  s.HR,
  s.I,
  s.IMG,
  s.LI,
  s.LISTING,
  s.MENU,
  s.META,
  s.NOBR,
  s.OL,
  s.P,
  s.PRE,
  s.RUBY,
  s.S,
  s.SMALL,
  s.SPAN,
  s.STRONG,
  s.STRIKE,
  s.SUB,
  s.SUP,
  s.TABLE,
  s.TT,
  s.U,
  s.UL,
  s.VAR
]);
function bh(e) {
  const t = e.tagID;
  return t === s.FONT && e.attrs.some(({ name: r }) => r === ct.COLOR || r === ct.SIZE || r === ct.FACE) || Th.has(t);
}
function Wa(e) {
  for (let t = 0; t < e.attrs.length; t++)
    if (e.attrs[t].name === hh) {
      e.attrs[t].name = mh;
      break;
    }
}
function Qa(e) {
  for (let t = 0; t < e.attrs.length; t++) {
    const n = ph.get(e.attrs[t].name);
    n != null && (e.attrs[t].name = n);
  }
}
function ru(e) {
  for (let t = 0; t < e.attrs.length; t++) {
    const n = Eh.get(e.attrs[t].name);
    n && (e.attrs[t].prefix = n.prefix, e.attrs[t].name = n.name, e.attrs[t].namespace = n.namespace);
  }
}
function Ah(e) {
  const t = gh.get(e.tagName);
  t != null && (e.tagName = t, e.tagID = Rt(e.tagName));
}
function _h(e, t) {
  return t === D.MATHML && (e === s.MI || e === s.MO || e === s.MN || e === s.MS || e === s.MTEXT);
}
function xh(e, t, n) {
  if (t === D.MATHML && e === s.ANNOTATION_XML) {
    for (let r = 0; r < n.length; r++)
      if (n[r].name === ct.ENCODING) {
        const u = n[r].value.toLowerCase();
        return u === fi.TEXT_HTML || u === fi.APPLICATION_XML;
      }
  }
  return t === D.SVG && (e === s.FOREIGN_OBJECT || e === s.DESC || e === s.TITLE);
}
function Ch(e, t, n, r) {
  return (!r || r === D.HTML) && xh(e, t, n) || (!r || r === D.MATHML) && _h(e, t);
}
const Ih = "hidden", Sh = 8, Nh = 3;
var T;
(function(e) {
  e[e.INITIAL = 0] = "INITIAL", e[e.BEFORE_HTML = 1] = "BEFORE_HTML", e[e.BEFORE_HEAD = 2] = "BEFORE_HEAD", e[e.IN_HEAD = 3] = "IN_HEAD", e[e.IN_HEAD_NO_SCRIPT = 4] = "IN_HEAD_NO_SCRIPT", e[e.AFTER_HEAD = 5] = "AFTER_HEAD", e[e.IN_BODY = 6] = "IN_BODY", e[e.TEXT = 7] = "TEXT", e[e.IN_TABLE = 8] = "IN_TABLE", e[e.IN_TABLE_TEXT = 9] = "IN_TABLE_TEXT", e[e.IN_CAPTION = 10] = "IN_CAPTION", e[e.IN_COLUMN_GROUP = 11] = "IN_COLUMN_GROUP", e[e.IN_TABLE_BODY = 12] = "IN_TABLE_BODY", e[e.IN_ROW = 13] = "IN_ROW", e[e.IN_CELL = 14] = "IN_CELL", e[e.IN_SELECT = 15] = "IN_SELECT", e[e.IN_SELECT_IN_TABLE = 16] = "IN_SELECT_IN_TABLE", e[e.IN_TEMPLATE = 17] = "IN_TEMPLATE", e[e.AFTER_BODY = 18] = "AFTER_BODY", e[e.IN_FRAMESET = 19] = "IN_FRAMESET", e[e.AFTER_FRAMESET = 20] = "AFTER_FRAMESET", e[e.AFTER_AFTER_BODY = 21] = "AFTER_AFTER_BODY", e[e.AFTER_AFTER_FRAMESET = 22] = "AFTER_AFTER_FRAMESET";
})(T || (T = {}));
const kh = {
  startLine: -1,
  startCol: -1,
  startOffset: -1,
  endLine: -1,
  endCol: -1,
  endOffset: -1
}, Ga = /* @__PURE__ */ new Set([s.TABLE, s.TBODY, s.TFOOT, s.THEAD, s.TR]), di = {
  scriptingEnabled: !0,
  sourceCodeLocationInfo: !1,
  treeAdapter: Xe,
  onParseError: null
};
class hi {
  constructor(t, n, r = null, u = null) {
    this.fragmentContext = r, this.scriptHandler = u, this.currentToken = null, this.stopped = !1, this.insertionMode = T.INITIAL, this.originalInsertionMode = T.INITIAL, this.headElement = null, this.formElement = null, this.currentNotInHTML = !1, this.tmplInsertionModeStack = [], this.pendingCharacterTokens = [], this.hasNonWhitespacePendingCharacterToken = !1, this.framesetOk = !0, this.skipNextNewLine = !1, this.fosterParentingEnabled = !1, this.options = {
      ...di,
      ...t
    }, this.treeAdapter = this.options.treeAdapter, this.onParseError = this.options.onParseError, this.onParseError && (this.options.sourceCodeLocationInfo = !0), this.document = n ?? this.treeAdapter.createDocument(), this.tokenizer = new Xd(this.options, this), this.activeFormattingElements = new ih(this.treeAdapter), this.fragmentContextID = r ? Rt(this.treeAdapter.getTagName(r)) : s.UNKNOWN, this._setContextModes(r ?? this.document, this.fragmentContextID), this.openElements = new uh(this.document, this.treeAdapter, this);
  }
  // API
  static parse(t, n) {
    const r = new this(n);
    return r.tokenizer.write(t, !0), r.document;
  }
  static getFragmentParser(t, n) {
    const r = {
      ...di,
      ...n
    };
    t ?? (t = r.treeAdapter.createElement(x.TEMPLATE, D.HTML, []));
    const u = r.treeAdapter.createElement("documentmock", D.HTML, []), a = new this(r, u, t);
    return a.fragmentContextID === s.TEMPLATE && a.tmplInsertionModeStack.unshift(T.IN_TEMPLATE), a._initTokenizerForFragmentParsing(), a._insertFakeRootElement(), a._resetInsertionMode(), a._findFormInFragmentContext(), a;
  }
  getFragment() {
    const t = this.treeAdapter.getFirstChild(this.document), n = this.treeAdapter.createDocumentFragment();
    return this._adoptNodes(t, n), n;
  }
  //Errors
  /** @internal */
  _err(t, n, r) {
    var u;
    if (!this.onParseError)
      return;
    const a = (u = t.location) !== null && u !== void 0 ? u : kh, i = {
      code: n,
      startLine: a.startLine,
      startCol: a.startCol,
      startOffset: a.startOffset,
      endLine: r ? a.startLine : a.endLine,
      endCol: r ? a.startCol : a.endCol,
      endOffset: r ? a.startOffset : a.endOffset
    };
    this.onParseError(i);
  }
  //Stack events
  /** @internal */
  onItemPush(t, n, r) {
    var u, a;
    (a = (u = this.treeAdapter).onItemPush) === null || a === void 0 || a.call(u, t), r && this.openElements.stackTop > 0 && this._setContextModes(t, n);
  }
  /** @internal */
  onItemPop(t, n) {
    var r, u;
    if (this.options.sourceCodeLocationInfo && this._setEndLocation(t, this.currentToken), (u = (r = this.treeAdapter).onItemPop) === null || u === void 0 || u.call(r, t, this.openElements.current), n) {
      let a, i;
      this.openElements.stackTop === 0 && this.fragmentContext ? (a = this.fragmentContext, i = this.fragmentContextID) : { current: a, currentTagId: i } = this.openElements, this._setContextModes(a, i);
    }
  }
  _setContextModes(t, n) {
    const r = t === this.document || this.treeAdapter.getNamespaceURI(t) === D.HTML;
    this.currentNotInHTML = !r, this.tokenizer.inForeignNode = !r && !this._isIntegrationPoint(n, t);
  }
  /** @protected */
  _switchToTextParsing(t, n) {
    this._insertElement(t, D.HTML), this.tokenizer.state = n, this.originalInsertionMode = this.insertionMode, this.insertionMode = T.TEXT;
  }
  switchToPlaintextParsing() {
    this.insertionMode = T.TEXT, this.originalInsertionMode = T.IN_BODY, this.tokenizer.state = se.PLAINTEXT;
  }
  //Fragment parsing
  /** @protected */
  _getAdjustedCurrentElement() {
    return this.openElements.stackTop === 0 && this.fragmentContext ? this.fragmentContext : this.openElements.current;
  }
  /** @protected */
  _findFormInFragmentContext() {
    let t = this.fragmentContext;
    for (; t; ) {
      if (this.treeAdapter.getTagName(t) === x.FORM) {
        this.formElement = t;
        break;
      }
      t = this.treeAdapter.getParentNode(t);
    }
  }
  _initTokenizerForFragmentParsing() {
    if (!(!this.fragmentContext || this.treeAdapter.getNamespaceURI(this.fragmentContext) !== D.HTML))
      switch (this.fragmentContextID) {
        case s.TITLE:
        case s.TEXTAREA: {
          this.tokenizer.state = se.RCDATA;
          break;
        }
        case s.STYLE:
        case s.XMP:
        case s.IFRAME:
        case s.NOEMBED:
        case s.NOFRAMES:
        case s.NOSCRIPT: {
          this.tokenizer.state = se.RAWTEXT;
          break;
        }
        case s.SCRIPT: {
          this.tokenizer.state = se.SCRIPT_DATA;
          break;
        }
        case s.PLAINTEXT: {
          this.tokenizer.state = se.PLAINTEXT;
          break;
        }
      }
  }
  //Tree mutation
  /** @protected */
  _setDocumentType(t) {
    const n = t.name || "", r = t.publicId || "", u = t.systemId || "";
    if (this.treeAdapter.setDocumentType(this.document, n, r, u), t.location) {
      const i = this.treeAdapter.getChildNodes(this.document).find((o) => this.treeAdapter.isDocumentTypeNode(o));
      i && this.treeAdapter.setNodeSourceCodeLocation(i, t.location);
    }
  }
  /** @protected */
  _attachElementToTree(t, n) {
    if (this.options.sourceCodeLocationInfo) {
      const r = n && {
        ...n,
        startTag: n
      };
      this.treeAdapter.setNodeSourceCodeLocation(t, r);
    }
    if (this._shouldFosterParentOnInsertion())
      this._fosterParentElement(t);
    else {
      const r = this.openElements.currentTmplContentOrNode;
      this.treeAdapter.appendChild(r, t);
    }
  }
  /**
   * For self-closing tags. Add an element to the tree, but skip adding it
   * to the stack.
   */
  /** @protected */
  _appendElement(t, n) {
    const r = this.treeAdapter.createElement(t.tagName, n, t.attrs);
    this._attachElementToTree(r, t.location);
  }
  /** @protected */
  _insertElement(t, n) {
    const r = this.treeAdapter.createElement(t.tagName, n, t.attrs);
    this._attachElementToTree(r, t.location), this.openElements.push(r, t.tagID);
  }
  /** @protected */
  _insertFakeElement(t, n) {
    const r = this.treeAdapter.createElement(t, D.HTML, []);
    this._attachElementToTree(r, null), this.openElements.push(r, n);
  }
  /** @protected */
  _insertTemplate(t) {
    const n = this.treeAdapter.createElement(t.tagName, D.HTML, t.attrs), r = this.treeAdapter.createDocumentFragment();
    this.treeAdapter.setTemplateContent(n, r), this._attachElementToTree(n, t.location), this.openElements.push(n, t.tagID), this.options.sourceCodeLocationInfo && this.treeAdapter.setNodeSourceCodeLocation(r, null);
  }
  /** @protected */
  _insertFakeRootElement() {
    const t = this.treeAdapter.createElement(x.HTML, D.HTML, []);
    this.options.sourceCodeLocationInfo && this.treeAdapter.setNodeSourceCodeLocation(t, null), this.treeAdapter.appendChild(this.openElements.current, t), this.openElements.push(t, s.HTML);
  }
  /** @protected */
  _appendCommentNode(t, n) {
    const r = this.treeAdapter.createCommentNode(t.data);
    this.treeAdapter.appendChild(n, r), this.options.sourceCodeLocationInfo && this.treeAdapter.setNodeSourceCodeLocation(r, t.location);
  }
  /** @protected */
  _insertCharacters(t) {
    let n, r;
    if (this._shouldFosterParentOnInsertion() ? ({ parent: n, beforeElement: r } = this._findFosterParentingLocation(), r ? this.treeAdapter.insertTextBefore(n, t.chars, r) : this.treeAdapter.insertText(n, t.chars)) : (n = this.openElements.currentTmplContentOrNode, this.treeAdapter.insertText(n, t.chars)), !t.location)
      return;
    const u = this.treeAdapter.getChildNodes(n), a = r ? u.lastIndexOf(r) : u.length, i = u[a - 1];
    if (this.treeAdapter.getNodeSourceCodeLocation(i)) {
      const { endLine: l, endCol: c, endOffset: d } = t.location;
      this.treeAdapter.updateNodeSourceCodeLocation(i, { endLine: l, endCol: c, endOffset: d });
    } else this.options.sourceCodeLocationInfo && this.treeAdapter.setNodeSourceCodeLocation(i, t.location);
  }
  /** @protected */
  _adoptNodes(t, n) {
    for (let r = this.treeAdapter.getFirstChild(t); r; r = this.treeAdapter.getFirstChild(t))
      this.treeAdapter.detachNode(r), this.treeAdapter.appendChild(n, r);
  }
  /** @protected */
  _setEndLocation(t, n) {
    if (this.treeAdapter.getNodeSourceCodeLocation(t) && n.location) {
      const r = n.location, u = this.treeAdapter.getTagName(t), a = (
        // NOTE: For cases like <p> <p> </p> - First 'p' closes without a closing
        // tag and for cases like <td> <p> </td> - 'p' closes without a closing tag.
        n.type === V.END_TAG && u === n.tagName ? {
          endTag: { ...r },
          endLine: r.endLine,
          endCol: r.endCol,
          endOffset: r.endOffset
        } : {
          endLine: r.startLine,
          endCol: r.startCol,
          endOffset: r.startOffset
        }
      );
      this.treeAdapter.updateNodeSourceCodeLocation(t, a);
    }
  }
  //Token processing
  shouldProcessStartTagTokenInForeignContent(t) {
    if (!this.currentNotInHTML)
      return !1;
    let n, r;
    return this.openElements.stackTop === 0 && this.fragmentContext ? (n = this.fragmentContext, r = this.fragmentContextID) : { current: n, currentTagId: r } = this.openElements, t.tagID === s.SVG && this.treeAdapter.getTagName(n) === x.ANNOTATION_XML && this.treeAdapter.getNamespaceURI(n) === D.MATHML ? !1 : (
      // Check that `current` is not an integration point for HTML or MathML elements.
      this.tokenizer.inForeignNode || // If it _is_ an integration point, then we might have to check that it is not an HTML
      // integration point.
      (t.tagID === s.MGLYPH || t.tagID === s.MALIGNMARK) && !this._isIntegrationPoint(r, n, D.HTML)
    );
  }
  /** @protected */
  _processToken(t) {
    switch (t.type) {
      case V.CHARACTER: {
        this.onCharacter(t);
        break;
      }
      case V.NULL_CHARACTER: {
        this.onNullCharacter(t);
        break;
      }
      case V.COMMENT: {
        this.onComment(t);
        break;
      }
      case V.DOCTYPE: {
        this.onDoctype(t);
        break;
      }
      case V.START_TAG: {
        this._processStartTag(t);
        break;
      }
      case V.END_TAG: {
        this.onEndTag(t);
        break;
      }
      case V.EOF: {
        this.onEof(t);
        break;
      }
      case V.WHITESPACE_CHARACTER: {
        this.onWhitespaceCharacter(t);
        break;
      }
    }
  }
  //Integration points
  /** @protected */
  _isIntegrationPoint(t, n, r) {
    const u = this.treeAdapter.getNamespaceURI(n), a = this.treeAdapter.getAttrList(n);
    return Ch(t, u, a, r);
  }
  //Active formatting elements reconstruction
  /** @protected */
  _reconstructActiveFormattingElements() {
    const t = this.activeFormattingElements.entries.length;
    if (t) {
      const n = this.activeFormattingElements.entries.findIndex((u) => u.type === Be.Marker || this.openElements.contains(u.element)), r = n < 0 ? t - 1 : n - 1;
      for (let u = r; u >= 0; u--) {
        const a = this.activeFormattingElements.entries[u];
        this._insertElement(a.token, this.treeAdapter.getNamespaceURI(a.element)), a.element = this.openElements.current;
      }
    }
  }
  //Close elements
  /** @protected */
  _closeTableCell() {
    this.openElements.generateImpliedEndTags(), this.openElements.popUntilTableCellPopped(), this.activeFormattingElements.clearToLastMarker(), this.insertionMode = T.IN_ROW;
  }
  /** @protected */
  _closePElement() {
    this.openElements.generateImpliedEndTagsWithExclusion(s.P), this.openElements.popUntilTagNamePopped(s.P);
  }
  //Insertion modes
  /** @protected */
  _resetInsertionMode() {
    for (let t = this.openElements.stackTop; t >= 0; t--)
      switch (t === 0 && this.fragmentContext ? this.fragmentContextID : this.openElements.tagIDs[t]) {
        case s.TR: {
          this.insertionMode = T.IN_ROW;
          return;
        }
        case s.TBODY:
        case s.THEAD:
        case s.TFOOT: {
          this.insertionMode = T.IN_TABLE_BODY;
          return;
        }
        case s.CAPTION: {
          this.insertionMode = T.IN_CAPTION;
          return;
        }
        case s.COLGROUP: {
          this.insertionMode = T.IN_COLUMN_GROUP;
          return;
        }
        case s.TABLE: {
          this.insertionMode = T.IN_TABLE;
          return;
        }
        case s.BODY: {
          this.insertionMode = T.IN_BODY;
          return;
        }
        case s.FRAMESET: {
          this.insertionMode = T.IN_FRAMESET;
          return;
        }
        case s.SELECT: {
          this._resetInsertionModeForSelect(t);
          return;
        }
        case s.TEMPLATE: {
          this.insertionMode = this.tmplInsertionModeStack[0];
          return;
        }
        case s.HTML: {
          this.insertionMode = this.headElement ? T.AFTER_HEAD : T.BEFORE_HEAD;
          return;
        }
        case s.TD:
        case s.TH: {
          if (t > 0) {
            this.insertionMode = T.IN_CELL;
            return;
          }
          break;
        }
        case s.HEAD: {
          if (t > 0) {
            this.insertionMode = T.IN_HEAD;
            return;
          }
          break;
        }
      }
    this.insertionMode = T.IN_BODY;
  }
  /** @protected */
  _resetInsertionModeForSelect(t) {
    if (t > 0)
      for (let n = t - 1; n > 0; n--) {
        const r = this.openElements.tagIDs[n];
        if (r === s.TEMPLATE)
          break;
        if (r === s.TABLE) {
          this.insertionMode = T.IN_SELECT_IN_TABLE;
          return;
        }
      }
    this.insertionMode = T.IN_SELECT;
  }
  //Foster parenting
  /** @protected */
  _isElementCausesFosterParenting(t) {
    return Ga.has(t);
  }
  /** @protected */
  _shouldFosterParentOnInsertion() {
    return this.fosterParentingEnabled && this._isElementCausesFosterParenting(this.openElements.currentTagId);
  }
  /** @protected */
  _findFosterParentingLocation() {
    for (let t = this.openElements.stackTop; t >= 0; t--) {
      const n = this.openElements.items[t];
      switch (this.openElements.tagIDs[t]) {
        case s.TEMPLATE: {
          if (this.treeAdapter.getNamespaceURI(n) === D.HTML)
            return { parent: this.treeAdapter.getTemplateContent(n), beforeElement: null };
          break;
        }
        case s.TABLE: {
          const r = this.treeAdapter.getParentNode(n);
          return r ? { parent: r, beforeElement: n } : { parent: this.openElements.items[t - 1], beforeElement: null };
        }
      }
    }
    return { parent: this.openElements.items[0], beforeElement: null };
  }
  /** @protected */
  _fosterParentElement(t) {
    const n = this._findFosterParentingLocation();
    n.beforeElement ? this.treeAdapter.insertBefore(n.parent, t, n.beforeElement) : this.treeAdapter.appendChild(n.parent, t);
  }
  //Special elements
  /** @protected */
  _isSpecialElement(t, n) {
    const r = this.treeAdapter.getNamespaceURI(t);
    return Qd[r].has(n);
  }
  /** @internal */
  onCharacter(t) {
    if (this.skipNextNewLine = !1, this.tokenizer.inForeignNode) {
      rp(this, t);
      return;
    }
    switch (this.insertionMode) {
      case T.INITIAL: {
        Ut(this, t);
        break;
      }
      case T.BEFORE_HTML: {
        Wt(this, t);
        break;
      }
      case T.BEFORE_HEAD: {
        Qt(this, t);
        break;
      }
      case T.IN_HEAD: {
        Gt(this, t);
        break;
      }
      case T.IN_HEAD_NO_SCRIPT: {
        $t(this, t);
        break;
      }
      case T.AFTER_HEAD: {
        Kt(this, t);
        break;
      }
      case T.IN_BODY:
      case T.IN_CAPTION:
      case T.IN_CELL:
      case T.IN_TEMPLATE: {
        Ka(this, t);
        break;
      }
      case T.TEXT:
      case T.IN_SELECT:
      case T.IN_SELECT_IN_TABLE: {
        this._insertCharacters(t);
        break;
      }
      case T.IN_TABLE:
      case T.IN_TABLE_BODY:
      case T.IN_ROW: {
        dr(this, t);
        break;
      }
      case T.IN_TABLE_TEXT: {
        ns(this, t);
        break;
      }
      case T.IN_COLUMN_GROUP: {
        Pn(this, t);
        break;
      }
      case T.AFTER_BODY: {
        wn(this, t);
        break;
      }
      case T.AFTER_AFTER_BODY: {
        Cn(this, t);
        break;
      }
    }
  }
  /** @internal */
  onNullCharacter(t) {
    if (this.skipNextNewLine = !1, this.tokenizer.inForeignNode) {
      np(this, t);
      return;
    }
    switch (this.insertionMode) {
      case T.INITIAL: {
        Ut(this, t);
        break;
      }
      case T.BEFORE_HTML: {
        Wt(this, t);
        break;
      }
      case T.BEFORE_HEAD: {
        Qt(this, t);
        break;
      }
      case T.IN_HEAD: {
        Gt(this, t);
        break;
      }
      case T.IN_HEAD_NO_SCRIPT: {
        $t(this, t);
        break;
      }
      case T.AFTER_HEAD: {
        Kt(this, t);
        break;
      }
      case T.TEXT: {
        this._insertCharacters(t);
        break;
      }
      case T.IN_TABLE:
      case T.IN_TABLE_BODY:
      case T.IN_ROW: {
        dr(this, t);
        break;
      }
      case T.IN_COLUMN_GROUP: {
        Pn(this, t);
        break;
      }
      case T.AFTER_BODY: {
        wn(this, t);
        break;
      }
      case T.AFTER_AFTER_BODY: {
        Cn(this, t);
        break;
      }
    }
  }
  /** @internal */
  onComment(t) {
    if (this.skipNextNewLine = !1, this.currentNotInHTML) {
      Or(this, t);
      return;
    }
    switch (this.insertionMode) {
      case T.INITIAL:
      case T.BEFORE_HTML:
      case T.BEFORE_HEAD:
      case T.IN_HEAD:
      case T.IN_HEAD_NO_SCRIPT:
      case T.AFTER_HEAD:
      case T.IN_BODY:
      case T.IN_TABLE:
      case T.IN_CAPTION:
      case T.IN_COLUMN_GROUP:
      case T.IN_TABLE_BODY:
      case T.IN_ROW:
      case T.IN_CELL:
      case T.IN_SELECT:
      case T.IN_SELECT_IN_TABLE:
      case T.IN_TEMPLATE:
      case T.IN_FRAMESET:
      case T.AFTER_FRAMESET: {
        Or(this, t);
        break;
      }
      case T.IN_TABLE_TEXT: {
        jt(this, t);
        break;
      }
      case T.AFTER_BODY: {
        wh(this, t);
        break;
      }
      case T.AFTER_AFTER_BODY:
      case T.AFTER_AFTER_FRAMESET: {
        Mh(this, t);
        break;
      }
    }
  }
  /** @internal */
  onDoctype(t) {
    switch (this.skipNextNewLine = !1, this.insertionMode) {
      case T.INITIAL: {
        Bh(this, t);
        break;
      }
      case T.BEFORE_HEAD:
      case T.IN_HEAD:
      case T.IN_HEAD_NO_SCRIPT:
      case T.AFTER_HEAD: {
        this._err(t, k.misplacedDoctype);
        break;
      }
      case T.IN_TABLE_TEXT: {
        jt(this, t);
        break;
      }
    }
  }
  /** @internal */
  onStartTag(t) {
    this.skipNextNewLine = !1, this.currentToken = t, this._processStartTag(t), t.selfClosing && !t.ackSelfClosing && this._err(t, k.nonVoidHtmlElementStartTagWithTrailingSolidus);
  }
  /**
   * Processes a given start tag.
   *
   * `onStartTag` checks if a self-closing tag was recognized. When a token
   * is moved inbetween multiple insertion modes, this check for self-closing
   * could lead to false positives. To avoid this, `_processStartTag` is used
   * for nested calls.
   *
   * @param token The token to process.
   * @protected
   */
  _processStartTag(t) {
    this.shouldProcessStartTagTokenInForeignContent(t) ? up(this, t) : this._startTagOutsideForeignContent(t);
  }
  /** @protected */
  _startTagOutsideForeignContent(t) {
    switch (this.insertionMode) {
      case T.INITIAL: {
        Ut(this, t);
        break;
      }
      case T.BEFORE_HTML: {
        Fh(this, t);
        break;
      }
      case T.BEFORE_HEAD: {
        Hh(this, t);
        break;
      }
      case T.IN_HEAD: {
        Pe(this, t);
        break;
      }
      case T.IN_HEAD_NO_SCRIPT: {
        zh(this, t);
        break;
      }
      case T.AFTER_HEAD: {
        Yh(this, t);
        break;
      }
      case T.IN_BODY: {
        pe(this, t);
        break;
      }
      case T.IN_TABLE: {
        Nt(this, t);
        break;
      }
      case T.IN_TABLE_TEXT: {
        jt(this, t);
        break;
      }
      case T.IN_CAPTION: {
        Um(this, t);
        break;
      }
      case T.IN_COLUMN_GROUP: {
        au(this, t);
        break;
      }
      case T.IN_TABLE_BODY: {
        Gn(this, t);
        break;
      }
      case T.IN_ROW: {
        $n(this, t);
        break;
      }
      case T.IN_CELL: {
        qm(this, t);
        break;
      }
      case T.IN_SELECT: {
        is(this, t);
        break;
      }
      case T.IN_SELECT_IN_TABLE: {
        Vm(this, t);
        break;
      }
      case T.IN_TEMPLATE: {
        Qm(this, t);
        break;
      }
      case T.AFTER_BODY: {
        $m(this, t);
        break;
      }
      case T.IN_FRAMESET: {
        Km(this, t);
        break;
      }
      case T.AFTER_FRAMESET: {
        Zm(this, t);
        break;
      }
      case T.AFTER_AFTER_BODY: {
        ep(this, t);
        break;
      }
      case T.AFTER_AFTER_FRAMESET: {
        tp(this, t);
        break;
      }
    }
  }
  /** @internal */
  onEndTag(t) {
    this.skipNextNewLine = !1, this.currentToken = t, this.currentNotInHTML ? ip(this, t) : this._endTagOutsideForeignContent(t);
  }
  /** @protected */
  _endTagOutsideForeignContent(t) {
    switch (this.insertionMode) {
      case T.INITIAL: {
        Ut(this, t);
        break;
      }
      case T.BEFORE_HTML: {
        vh(this, t);
        break;
      }
      case T.BEFORE_HEAD: {
        Uh(this, t);
        break;
      }
      case T.IN_HEAD: {
        jh(this, t);
        break;
      }
      case T.IN_HEAD_NO_SCRIPT: {
        qh(this, t);
        break;
      }
      case T.AFTER_HEAD: {
        Vh(this, t);
        break;
      }
      case T.IN_BODY: {
        Qn(this, t);
        break;
      }
      case T.TEXT: {
        Lm(this, t);
        break;
      }
      case T.IN_TABLE: {
        en(this, t);
        break;
      }
      case T.IN_TABLE_TEXT: {
        jt(this, t);
        break;
      }
      case T.IN_CAPTION: {
        jm(this, t);
        break;
      }
      case T.IN_COLUMN_GROUP: {
        zm(this, t);
        break;
      }
      case T.IN_TABLE_BODY: {
        Lr(this, t);
        break;
      }
      case T.IN_ROW: {
        us(this, t);
        break;
      }
      case T.IN_CELL: {
        Ym(this, t);
        break;
      }
      case T.IN_SELECT: {
        as(this, t);
        break;
      }
      case T.IN_SELECT_IN_TABLE: {
        Wm(this, t);
        break;
      }
      case T.IN_TEMPLATE: {
        Gm(this, t);
        break;
      }
      case T.AFTER_BODY: {
        os(this, t);
        break;
      }
      case T.IN_FRAMESET: {
        Xm(this, t);
        break;
      }
      case T.AFTER_FRAMESET: {
        Jm(this, t);
        break;
      }
      case T.AFTER_AFTER_BODY: {
        Cn(this, t);
        break;
      }
    }
  }
  /** @internal */
  onEof(t) {
    switch (this.insertionMode) {
      case T.INITIAL: {
        Ut(this, t);
        break;
      }
      case T.BEFORE_HTML: {
        Wt(this, t);
        break;
      }
      case T.BEFORE_HEAD: {
        Qt(this, t);
        break;
      }
      case T.IN_HEAD: {
        Gt(this, t);
        break;
      }
      case T.IN_HEAD_NO_SCRIPT: {
        $t(this, t);
        break;
      }
      case T.AFTER_HEAD: {
        Kt(this, t);
        break;
      }
      case T.IN_BODY:
      case T.IN_TABLE:
      case T.IN_CAPTION:
      case T.IN_COLUMN_GROUP:
      case T.IN_TABLE_BODY:
      case T.IN_ROW:
      case T.IN_CELL:
      case T.IN_SELECT:
      case T.IN_SELECT_IN_TABLE: {
        es(this, t);
        break;
      }
      case T.TEXT: {
        Rm(this, t);
        break;
      }
      case T.IN_TABLE_TEXT: {
        jt(this, t);
        break;
      }
      case T.IN_TEMPLATE: {
        ss(this, t);
        break;
      }
      case T.AFTER_BODY:
      case T.IN_FRAMESET:
      case T.AFTER_FRAMESET:
      case T.AFTER_AFTER_BODY:
      case T.AFTER_AFTER_FRAMESET: {
        iu(this, t);
        break;
      }
    }
  }
  /** @internal */
  onWhitespaceCharacter(t) {
    if (this.skipNextNewLine && (this.skipNextNewLine = !1, t.chars.charCodeAt(0) === p.LINE_FEED)) {
      if (t.chars.length === 1)
        return;
      t.chars = t.chars.substr(1);
    }
    if (this.tokenizer.inForeignNode) {
      this._insertCharacters(t);
      return;
    }
    switch (this.insertionMode) {
      case T.IN_HEAD:
      case T.IN_HEAD_NO_SCRIPT:
      case T.AFTER_HEAD:
      case T.TEXT:
      case T.IN_COLUMN_GROUP:
      case T.IN_SELECT:
      case T.IN_SELECT_IN_TABLE:
      case T.IN_FRAMESET:
      case T.AFTER_FRAMESET: {
        this._insertCharacters(t);
        break;
      }
      case T.IN_BODY:
      case T.IN_CAPTION:
      case T.IN_CELL:
      case T.IN_TEMPLATE:
      case T.AFTER_BODY:
      case T.AFTER_AFTER_BODY:
      case T.AFTER_AFTER_FRAMESET: {
        $a(this, t);
        break;
      }
      case T.IN_TABLE:
      case T.IN_TABLE_BODY:
      case T.IN_ROW: {
        dr(this, t);
        break;
      }
      case T.IN_TABLE_TEXT: {
        ts(this, t);
        break;
      }
    }
  }
}
function yh(e, t) {
  let n = e.activeFormattingElements.getElementEntryInScopeWithTagName(t.tagName);
  return n ? e.openElements.contains(n.element) ? e.openElements.hasInScope(t.tagID) || (n = null) : (e.activeFormattingElements.removeEntry(n), n = null) : Ja(e, t), n;
}
function Oh(e, t) {
  let n = null, r = e.openElements.stackTop;
  for (; r >= 0; r--) {
    const u = e.openElements.items[r];
    if (u === t.element)
      break;
    e._isSpecialElement(u, e.openElements.tagIDs[r]) && (n = u);
  }
  return n || (e.openElements.shortenToLength(r < 0 ? 0 : r), e.activeFormattingElements.removeEntry(t)), n;
}
function Lh(e, t, n) {
  let r = t, u = e.openElements.getCommonAncestor(t);
  for (let a = 0, i = u; i !== n; a++, i = u) {
    u = e.openElements.getCommonAncestor(i);
    const o = e.activeFormattingElements.getElementEntry(i), l = o && a >= Nh;
    !o || l ? (l && e.activeFormattingElements.removeEntry(o), e.openElements.remove(i)) : (i = Rh(e, o), r === t && (e.activeFormattingElements.bookmark = o), e.treeAdapter.detachNode(r), e.treeAdapter.appendChild(i, r), r = i);
  }
  return r;
}
function Rh(e, t) {
  const n = e.treeAdapter.getNamespaceURI(t.element), r = e.treeAdapter.createElement(t.token.tagName, n, t.token.attrs);
  return e.openElements.replace(t.element, r), t.element = r, r;
}
function Dh(e, t, n) {
  const r = e.treeAdapter.getTagName(t), u = Rt(r);
  if (e._isElementCausesFosterParenting(u))
    e._fosterParentElement(n);
  else {
    const a = e.treeAdapter.getNamespaceURI(t);
    u === s.TEMPLATE && a === D.HTML && (t = e.treeAdapter.getTemplateContent(t)), e.treeAdapter.appendChild(t, n);
  }
}
function Ph(e, t, n) {
  const r = e.treeAdapter.getNamespaceURI(n.element), { token: u } = n, a = e.treeAdapter.createElement(u.tagName, r, u.attrs);
  e._adoptNodes(t, a), e.treeAdapter.appendChild(t, a), e.activeFormattingElements.insertElementAfterBookmark(a, u), e.activeFormattingElements.removeEntry(n), e.openElements.remove(n.element), e.openElements.insertAfter(t, a, u.tagID);
}
function uu(e, t) {
  for (let n = 0; n < Sh; n++) {
    const r = yh(e, t);
    if (!r)
      break;
    const u = Oh(e, r);
    if (!u)
      break;
    e.activeFormattingElements.bookmark = r;
    const a = Lh(e, u, r.element), i = e.openElements.getCommonAncestor(r.element);
    e.treeAdapter.detachNode(a), i && Dh(e, i, a), Ph(e, u, r);
  }
}
function Or(e, t) {
  e._appendCommentNode(t, e.openElements.currentTmplContentOrNode);
}
function wh(e, t) {
  e._appendCommentNode(t, e.openElements.items[0]);
}
function Mh(e, t) {
  e._appendCommentNode(t, e.document);
}
function iu(e, t) {
  if (e.stopped = !0, t.location) {
    const n = e.fragmentContext ? 0 : 2;
    for (let r = e.openElements.stackTop; r >= n; r--)
      e._setEndLocation(e.openElements.items[r], t);
    if (!e.fragmentContext && e.openElements.stackTop >= 0) {
      const r = e.openElements.items[0], u = e.treeAdapter.getNodeSourceCodeLocation(r);
      if (u && !u.endTag && (e._setEndLocation(r, t), e.openElements.stackTop >= 1)) {
        const a = e.openElements.items[1], i = e.treeAdapter.getNodeSourceCodeLocation(a);
        i && !i.endTag && e._setEndLocation(a, t);
      }
    }
  }
}
function Bh(e, t) {
  e._setDocumentType(t);
  const n = t.forceQuirks ? ke.QUIRKS : dh(t);
  fh(t) || e._err(t, k.nonConformingDoctype), e.treeAdapter.setDocumentMode(e.document, n), e.insertionMode = T.BEFORE_HTML;
}
function Ut(e, t) {
  e._err(t, k.missingDoctype, !0), e.treeAdapter.setDocumentMode(e.document, ke.QUIRKS), e.insertionMode = T.BEFORE_HTML, e._processToken(t);
}
function Fh(e, t) {
  t.tagID === s.HTML ? (e._insertElement(t, D.HTML), e.insertionMode = T.BEFORE_HEAD) : Wt(e, t);
}
function vh(e, t) {
  const n = t.tagID;
  (n === s.HTML || n === s.HEAD || n === s.BODY || n === s.BR) && Wt(e, t);
}
function Wt(e, t) {
  e._insertFakeRootElement(), e.insertionMode = T.BEFORE_HEAD, e._processToken(t);
}
function Hh(e, t) {
  switch (t.tagID) {
    case s.HTML: {
      pe(e, t);
      break;
    }
    case s.HEAD: {
      e._insertElement(t, D.HTML), e.headElement = e.openElements.current, e.insertionMode = T.IN_HEAD;
      break;
    }
    default:
      Qt(e, t);
  }
}
function Uh(e, t) {
  const n = t.tagID;
  n === s.HEAD || n === s.BODY || n === s.HTML || n === s.BR ? Qt(e, t) : e._err(t, k.endTagWithoutMatchingOpenElement);
}
function Qt(e, t) {
  e._insertFakeElement(x.HEAD, s.HEAD), e.headElement = e.openElements.current, e.insertionMode = T.IN_HEAD, e._processToken(t);
}
function Pe(e, t) {
  switch (t.tagID) {
    case s.HTML: {
      pe(e, t);
      break;
    }
    case s.BASE:
    case s.BASEFONT:
    case s.BGSOUND:
    case s.LINK:
    case s.META: {
      e._appendElement(t, D.HTML), t.ackSelfClosing = !0;
      break;
    }
    case s.TITLE: {
      e._switchToTextParsing(t, se.RCDATA);
      break;
    }
    case s.NOSCRIPT: {
      e.options.scriptingEnabled ? e._switchToTextParsing(t, se.RAWTEXT) : (e._insertElement(t, D.HTML), e.insertionMode = T.IN_HEAD_NO_SCRIPT);
      break;
    }
    case s.NOFRAMES:
    case s.STYLE: {
      e._switchToTextParsing(t, se.RAWTEXT);
      break;
    }
    case s.SCRIPT: {
      e._switchToTextParsing(t, se.SCRIPT_DATA);
      break;
    }
    case s.TEMPLATE: {
      e._insertTemplate(t), e.activeFormattingElements.insertMarker(), e.framesetOk = !1, e.insertionMode = T.IN_TEMPLATE, e.tmplInsertionModeStack.unshift(T.IN_TEMPLATE);
      break;
    }
    case s.HEAD: {
      e._err(t, k.misplacedStartTagForHeadElement);
      break;
    }
    default:
      Gt(e, t);
  }
}
function jh(e, t) {
  switch (t.tagID) {
    case s.HEAD: {
      e.openElements.pop(), e.insertionMode = T.AFTER_HEAD;
      break;
    }
    case s.BODY:
    case s.BR:
    case s.HTML: {
      Gt(e, t);
      break;
    }
    case s.TEMPLATE: {
      mt(e, t);
      break;
    }
    default:
      e._err(t, k.endTagWithoutMatchingOpenElement);
  }
}
function mt(e, t) {
  e.openElements.tmplCount > 0 ? (e.openElements.generateImpliedEndTagsThoroughly(), e.openElements.currentTagId !== s.TEMPLATE && e._err(t, k.closingOfElementWithOpenChildElements), e.openElements.popUntilTagNamePopped(s.TEMPLATE), e.activeFormattingElements.clearToLastMarker(), e.tmplInsertionModeStack.shift(), e._resetInsertionMode()) : e._err(t, k.endTagWithoutMatchingOpenElement);
}
function Gt(e, t) {
  e.openElements.pop(), e.insertionMode = T.AFTER_HEAD, e._processToken(t);
}
function zh(e, t) {
  switch (t.tagID) {
    case s.HTML: {
      pe(e, t);
      break;
    }
    case s.BASEFONT:
    case s.BGSOUND:
    case s.HEAD:
    case s.LINK:
    case s.META:
    case s.NOFRAMES:
    case s.STYLE: {
      Pe(e, t);
      break;
    }
    case s.NOSCRIPT: {
      e._err(t, k.nestedNoscriptInHead);
      break;
    }
    default:
      $t(e, t);
  }
}
function qh(e, t) {
  switch (t.tagID) {
    case s.NOSCRIPT: {
      e.openElements.pop(), e.insertionMode = T.IN_HEAD;
      break;
    }
    case s.BR: {
      $t(e, t);
      break;
    }
    default:
      e._err(t, k.endTagWithoutMatchingOpenElement);
  }
}
function $t(e, t) {
  const n = t.type === V.EOF ? k.openElementsLeftAfterEof : k.disallowedContentInNoscriptInHead;
  e._err(t, n), e.openElements.pop(), e.insertionMode = T.IN_HEAD, e._processToken(t);
}
function Yh(e, t) {
  switch (t.tagID) {
    case s.HTML: {
      pe(e, t);
      break;
    }
    case s.BODY: {
      e._insertElement(t, D.HTML), e.framesetOk = !1, e.insertionMode = T.IN_BODY;
      break;
    }
    case s.FRAMESET: {
      e._insertElement(t, D.HTML), e.insertionMode = T.IN_FRAMESET;
      break;
    }
    case s.BASE:
    case s.BASEFONT:
    case s.BGSOUND:
    case s.LINK:
    case s.META:
    case s.NOFRAMES:
    case s.SCRIPT:
    case s.STYLE:
    case s.TEMPLATE:
    case s.TITLE: {
      e._err(t, k.abandonedHeadElementChild), e.openElements.push(e.headElement, s.HEAD), Pe(e, t), e.openElements.remove(e.headElement);
      break;
    }
    case s.HEAD: {
      e._err(t, k.misplacedStartTagForHeadElement);
      break;
    }
    default:
      Kt(e, t);
  }
}
function Vh(e, t) {
  switch (t.tagID) {
    case s.BODY:
    case s.HTML:
    case s.BR: {
      Kt(e, t);
      break;
    }
    case s.TEMPLATE: {
      mt(e, t);
      break;
    }
    default:
      e._err(t, k.endTagWithoutMatchingOpenElement);
  }
}
function Kt(e, t) {
  e._insertFakeElement(x.BODY, s.BODY), e.insertionMode = T.IN_BODY, Wn(e, t);
}
function Wn(e, t) {
  switch (t.type) {
    case V.CHARACTER: {
      Ka(e, t);
      break;
    }
    case V.WHITESPACE_CHARACTER: {
      $a(e, t);
      break;
    }
    case V.COMMENT: {
      Or(e, t);
      break;
    }
    case V.START_TAG: {
      pe(e, t);
      break;
    }
    case V.END_TAG: {
      Qn(e, t);
      break;
    }
    case V.EOF: {
      es(e, t);
      break;
    }
  }
}
function $a(e, t) {
  e._reconstructActiveFormattingElements(), e._insertCharacters(t);
}
function Ka(e, t) {
  e._reconstructActiveFormattingElements(), e._insertCharacters(t), e.framesetOk = !1;
}
function Wh(e, t) {
  e.openElements.tmplCount === 0 && e.treeAdapter.adoptAttributes(e.openElements.items[0], t.attrs);
}
function Qh(e, t) {
  const n = e.openElements.tryPeekProperlyNestedBodyElement();
  n && e.openElements.tmplCount === 0 && (e.framesetOk = !1, e.treeAdapter.adoptAttributes(n, t.attrs));
}
function Gh(e, t) {
  const n = e.openElements.tryPeekProperlyNestedBodyElement();
  e.framesetOk && n && (e.treeAdapter.detachNode(n), e.openElements.popAllUpToHtmlElement(), e._insertElement(t, D.HTML), e.insertionMode = T.IN_FRAMESET);
}
function $h(e, t) {
  e.openElements.hasInButtonScope(s.P) && e._closePElement(), e._insertElement(t, D.HTML);
}
function Kh(e, t) {
  e.openElements.hasInButtonScope(s.P) && e._closePElement(), yr.has(e.openElements.currentTagId) && e.openElements.pop(), e._insertElement(t, D.HTML);
}
function Xh(e, t) {
  e.openElements.hasInButtonScope(s.P) && e._closePElement(), e._insertElement(t, D.HTML), e.skipNextNewLine = !0, e.framesetOk = !1;
}
function Zh(e, t) {
  const n = e.openElements.tmplCount > 0;
  (!e.formElement || n) && (e.openElements.hasInButtonScope(s.P) && e._closePElement(), e._insertElement(t, D.HTML), n || (e.formElement = e.openElements.current));
}
function Jh(e, t) {
  e.framesetOk = !1;
  const n = t.tagID;
  for (let r = e.openElements.stackTop; r >= 0; r--) {
    const u = e.openElements.tagIDs[r];
    if (n === s.LI && u === s.LI || (n === s.DD || n === s.DT) && (u === s.DD || u === s.DT)) {
      e.openElements.generateImpliedEndTagsWithExclusion(u), e.openElements.popUntilTagNamePopped(u);
      break;
    }
    if (u !== s.ADDRESS && u !== s.DIV && u !== s.P && e._isSpecialElement(e.openElements.items[r], u))
      break;
  }
  e.openElements.hasInButtonScope(s.P) && e._closePElement(), e._insertElement(t, D.HTML);
}
function em(e, t) {
  e.openElements.hasInButtonScope(s.P) && e._closePElement(), e._insertElement(t, D.HTML), e.tokenizer.state = se.PLAINTEXT;
}
function tm(e, t) {
  e.openElements.hasInScope(s.BUTTON) && (e.openElements.generateImpliedEndTags(), e.openElements.popUntilTagNamePopped(s.BUTTON)), e._reconstructActiveFormattingElements(), e._insertElement(t, D.HTML), e.framesetOk = !1;
}
function nm(e, t) {
  const n = e.activeFormattingElements.getElementEntryInScopeWithTagName(x.A);
  n && (uu(e, t), e.openElements.remove(n.element), e.activeFormattingElements.removeEntry(n)), e._reconstructActiveFormattingElements(), e._insertElement(t, D.HTML), e.activeFormattingElements.pushElement(e.openElements.current, t);
}
function rm(e, t) {
  e._reconstructActiveFormattingElements(), e._insertElement(t, D.HTML), e.activeFormattingElements.pushElement(e.openElements.current, t);
}
function um(e, t) {
  e._reconstructActiveFormattingElements(), e.openElements.hasInScope(s.NOBR) && (uu(e, t), e._reconstructActiveFormattingElements()), e._insertElement(t, D.HTML), e.activeFormattingElements.pushElement(e.openElements.current, t);
}
function im(e, t) {
  e._reconstructActiveFormattingElements(), e._insertElement(t, D.HTML), e.activeFormattingElements.insertMarker(), e.framesetOk = !1;
}
function am(e, t) {
  e.treeAdapter.getDocumentMode(e.document) !== ke.QUIRKS && e.openElements.hasInButtonScope(s.P) && e._closePElement(), e._insertElement(t, D.HTML), e.framesetOk = !1, e.insertionMode = T.IN_TABLE;
}
function Xa(e, t) {
  e._reconstructActiveFormattingElements(), e._appendElement(t, D.HTML), e.framesetOk = !1, t.ackSelfClosing = !0;
}
function Za(e) {
  const t = Fa(e, ct.TYPE);
  return t != null && t.toLowerCase() === Ih;
}
function sm(e, t) {
  e._reconstructActiveFormattingElements(), e._appendElement(t, D.HTML), Za(t) || (e.framesetOk = !1), t.ackSelfClosing = !0;
}
function om(e, t) {
  e._appendElement(t, D.HTML), t.ackSelfClosing = !0;
}
function lm(e, t) {
  e.openElements.hasInButtonScope(s.P) && e._closePElement(), e._appendElement(t, D.HTML), e.framesetOk = !1, t.ackSelfClosing = !0;
}
function cm(e, t) {
  t.tagName = x.IMG, t.tagID = s.IMG, Xa(e, t);
}
function fm(e, t) {
  e._insertElement(t, D.HTML), e.skipNextNewLine = !0, e.tokenizer.state = se.RCDATA, e.originalInsertionMode = e.insertionMode, e.framesetOk = !1, e.insertionMode = T.TEXT;
}
function dm(e, t) {
  e.openElements.hasInButtonScope(s.P) && e._closePElement(), e._reconstructActiveFormattingElements(), e.framesetOk = !1, e._switchToTextParsing(t, se.RAWTEXT);
}
function hm(e, t) {
  e.framesetOk = !1, e._switchToTextParsing(t, se.RAWTEXT);
}
function mi(e, t) {
  e._switchToTextParsing(t, se.RAWTEXT);
}
function mm(e, t) {
  e._reconstructActiveFormattingElements(), e._insertElement(t, D.HTML), e.framesetOk = !1, e.insertionMode = e.insertionMode === T.IN_TABLE || e.insertionMode === T.IN_CAPTION || e.insertionMode === T.IN_TABLE_BODY || e.insertionMode === T.IN_ROW || e.insertionMode === T.IN_CELL ? T.IN_SELECT_IN_TABLE : T.IN_SELECT;
}
function pm(e, t) {
  e.openElements.currentTagId === s.OPTION && e.openElements.pop(), e._reconstructActiveFormattingElements(), e._insertElement(t, D.HTML);
}
function Em(e, t) {
  e.openElements.hasInScope(s.RUBY) && e.openElements.generateImpliedEndTags(), e._insertElement(t, D.HTML);
}
function gm(e, t) {
  e.openElements.hasInScope(s.RUBY) && e.openElements.generateImpliedEndTagsWithExclusion(s.RTC), e._insertElement(t, D.HTML);
}
function Tm(e, t) {
  e._reconstructActiveFormattingElements(), Wa(t), ru(t), t.selfClosing ? e._appendElement(t, D.MATHML) : e._insertElement(t, D.MATHML), t.ackSelfClosing = !0;
}
function bm(e, t) {
  e._reconstructActiveFormattingElements(), Qa(t), ru(t), t.selfClosing ? e._appendElement(t, D.SVG) : e._insertElement(t, D.SVG), t.ackSelfClosing = !0;
}
function pi(e, t) {
  e._reconstructActiveFormattingElements(), e._insertElement(t, D.HTML);
}
function pe(e, t) {
  switch (t.tagID) {
    case s.I:
    case s.S:
    case s.B:
    case s.U:
    case s.EM:
    case s.TT:
    case s.BIG:
    case s.CODE:
    case s.FONT:
    case s.SMALL:
    case s.STRIKE:
    case s.STRONG: {
      rm(e, t);
      break;
    }
    case s.A: {
      nm(e, t);
      break;
    }
    case s.H1:
    case s.H2:
    case s.H3:
    case s.H4:
    case s.H5:
    case s.H6: {
      Kh(e, t);
      break;
    }
    case s.P:
    case s.DL:
    case s.OL:
    case s.UL:
    case s.DIV:
    case s.DIR:
    case s.NAV:
    case s.MAIN:
    case s.MENU:
    case s.ASIDE:
    case s.CENTER:
    case s.FIGURE:
    case s.FOOTER:
    case s.HEADER:
    case s.HGROUP:
    case s.DIALOG:
    case s.DETAILS:
    case s.ADDRESS:
    case s.ARTICLE:
    case s.SEARCH:
    case s.SECTION:
    case s.SUMMARY:
    case s.FIELDSET:
    case s.BLOCKQUOTE:
    case s.FIGCAPTION: {
      $h(e, t);
      break;
    }
    case s.LI:
    case s.DD:
    case s.DT: {
      Jh(e, t);
      break;
    }
    case s.BR:
    case s.IMG:
    case s.WBR:
    case s.AREA:
    case s.EMBED:
    case s.KEYGEN: {
      Xa(e, t);
      break;
    }
    case s.HR: {
      lm(e, t);
      break;
    }
    case s.RB:
    case s.RTC: {
      Em(e, t);
      break;
    }
    case s.RT:
    case s.RP: {
      gm(e, t);
      break;
    }
    case s.PRE:
    case s.LISTING: {
      Xh(e, t);
      break;
    }
    case s.XMP: {
      dm(e, t);
      break;
    }
    case s.SVG: {
      bm(e, t);
      break;
    }
    case s.HTML: {
      Wh(e, t);
      break;
    }
    case s.BASE:
    case s.LINK:
    case s.META:
    case s.STYLE:
    case s.TITLE:
    case s.SCRIPT:
    case s.BGSOUND:
    case s.BASEFONT:
    case s.TEMPLATE: {
      Pe(e, t);
      break;
    }
    case s.BODY: {
      Qh(e, t);
      break;
    }
    case s.FORM: {
      Zh(e, t);
      break;
    }
    case s.NOBR: {
      um(e, t);
      break;
    }
    case s.MATH: {
      Tm(e, t);
      break;
    }
    case s.TABLE: {
      am(e, t);
      break;
    }
    case s.INPUT: {
      sm(e, t);
      break;
    }
    case s.PARAM:
    case s.TRACK:
    case s.SOURCE: {
      om(e, t);
      break;
    }
    case s.IMAGE: {
      cm(e, t);
      break;
    }
    case s.BUTTON: {
      tm(e, t);
      break;
    }
    case s.APPLET:
    case s.OBJECT:
    case s.MARQUEE: {
      im(e, t);
      break;
    }
    case s.IFRAME: {
      hm(e, t);
      break;
    }
    case s.SELECT: {
      mm(e, t);
      break;
    }
    case s.OPTION:
    case s.OPTGROUP: {
      pm(e, t);
      break;
    }
    case s.NOEMBED:
    case s.NOFRAMES: {
      mi(e, t);
      break;
    }
    case s.FRAMESET: {
      Gh(e, t);
      break;
    }
    case s.TEXTAREA: {
      fm(e, t);
      break;
    }
    case s.NOSCRIPT: {
      e.options.scriptingEnabled ? mi(e, t) : pi(e, t);
      break;
    }
    case s.PLAINTEXT: {
      em(e, t);
      break;
    }
    case s.COL:
    case s.TH:
    case s.TD:
    case s.TR:
    case s.HEAD:
    case s.FRAME:
    case s.TBODY:
    case s.TFOOT:
    case s.THEAD:
    case s.CAPTION:
    case s.COLGROUP:
      break;
    default:
      pi(e, t);
  }
}
function Am(e, t) {
  if (e.openElements.hasInScope(s.BODY) && (e.insertionMode = T.AFTER_BODY, e.options.sourceCodeLocationInfo)) {
    const n = e.openElements.tryPeekProperlyNestedBodyElement();
    n && e._setEndLocation(n, t);
  }
}
function _m(e, t) {
  e.openElements.hasInScope(s.BODY) && (e.insertionMode = T.AFTER_BODY, os(e, t));
}
function xm(e, t) {
  const n = t.tagID;
  e.openElements.hasInScope(n) && (e.openElements.generateImpliedEndTags(), e.openElements.popUntilTagNamePopped(n));
}
function Cm(e) {
  const t = e.openElements.tmplCount > 0, { formElement: n } = e;
  t || (e.formElement = null), (n || t) && e.openElements.hasInScope(s.FORM) && (e.openElements.generateImpliedEndTags(), t ? e.openElements.popUntilTagNamePopped(s.FORM) : n && e.openElements.remove(n));
}
function Im(e) {
  e.openElements.hasInButtonScope(s.P) || e._insertFakeElement(x.P, s.P), e._closePElement();
}
function Sm(e) {
  e.openElements.hasInListItemScope(s.LI) && (e.openElements.generateImpliedEndTagsWithExclusion(s.LI), e.openElements.popUntilTagNamePopped(s.LI));
}
function Nm(e, t) {
  const n = t.tagID;
  e.openElements.hasInScope(n) && (e.openElements.generateImpliedEndTagsWithExclusion(n), e.openElements.popUntilTagNamePopped(n));
}
function km(e) {
  e.openElements.hasNumberedHeaderInScope() && (e.openElements.generateImpliedEndTags(), e.openElements.popUntilNumberedHeaderPopped());
}
function ym(e, t) {
  const n = t.tagID;
  e.openElements.hasInScope(n) && (e.openElements.generateImpliedEndTags(), e.openElements.popUntilTagNamePopped(n), e.activeFormattingElements.clearToLastMarker());
}
function Om(e) {
  e._reconstructActiveFormattingElements(), e._insertFakeElement(x.BR, s.BR), e.openElements.pop(), e.framesetOk = !1;
}
function Ja(e, t) {
  const n = t.tagName, r = t.tagID;
  for (let u = e.openElements.stackTop; u > 0; u--) {
    const a = e.openElements.items[u], i = e.openElements.tagIDs[u];
    if (r === i && (r !== s.UNKNOWN || e.treeAdapter.getTagName(a) === n)) {
      e.openElements.generateImpliedEndTagsWithExclusion(r), e.openElements.stackTop >= u && e.openElements.shortenToLength(u);
      break;
    }
    if (e._isSpecialElement(a, i))
      break;
  }
}
function Qn(e, t) {
  switch (t.tagID) {
    case s.A:
    case s.B:
    case s.I:
    case s.S:
    case s.U:
    case s.EM:
    case s.TT:
    case s.BIG:
    case s.CODE:
    case s.FONT:
    case s.NOBR:
    case s.SMALL:
    case s.STRIKE:
    case s.STRONG: {
      uu(e, t);
      break;
    }
    case s.P: {
      Im(e);
      break;
    }
    case s.DL:
    case s.UL:
    case s.OL:
    case s.DIR:
    case s.DIV:
    case s.NAV:
    case s.PRE:
    case s.MAIN:
    case s.MENU:
    case s.ASIDE:
    case s.BUTTON:
    case s.CENTER:
    case s.FIGURE:
    case s.FOOTER:
    case s.HEADER:
    case s.HGROUP:
    case s.DIALOG:
    case s.ADDRESS:
    case s.ARTICLE:
    case s.DETAILS:
    case s.SEARCH:
    case s.SECTION:
    case s.SUMMARY:
    case s.LISTING:
    case s.FIELDSET:
    case s.BLOCKQUOTE:
    case s.FIGCAPTION: {
      xm(e, t);
      break;
    }
    case s.LI: {
      Sm(e);
      break;
    }
    case s.DD:
    case s.DT: {
      Nm(e, t);
      break;
    }
    case s.H1:
    case s.H2:
    case s.H3:
    case s.H4:
    case s.H5:
    case s.H6: {
      km(e);
      break;
    }
    case s.BR: {
      Om(e);
      break;
    }
    case s.BODY: {
      Am(e, t);
      break;
    }
    case s.HTML: {
      _m(e, t);
      break;
    }
    case s.FORM: {
      Cm(e);
      break;
    }
    case s.APPLET:
    case s.OBJECT:
    case s.MARQUEE: {
      ym(e, t);
      break;
    }
    case s.TEMPLATE: {
      mt(e, t);
      break;
    }
    default:
      Ja(e, t);
  }
}
function es(e, t) {
  e.tmplInsertionModeStack.length > 0 ? ss(e, t) : iu(e, t);
}
function Lm(e, t) {
  var n;
  t.tagID === s.SCRIPT && ((n = e.scriptHandler) === null || n === void 0 || n.call(e, e.openElements.current)), e.openElements.pop(), e.insertionMode = e.originalInsertionMode;
}
function Rm(e, t) {
  e._err(t, k.eofInElementThatCanContainOnlyText), e.openElements.pop(), e.insertionMode = e.originalInsertionMode, e.onEof(t);
}
function dr(e, t) {
  if (Ga.has(e.openElements.currentTagId))
    switch (e.pendingCharacterTokens.length = 0, e.hasNonWhitespacePendingCharacterToken = !1, e.originalInsertionMode = e.insertionMode, e.insertionMode = T.IN_TABLE_TEXT, t.type) {
      case V.CHARACTER: {
        ns(e, t);
        break;
      }
      case V.WHITESPACE_CHARACTER: {
        ts(e, t);
        break;
      }
    }
  else
    sn(e, t);
}
function Dm(e, t) {
  e.openElements.clearBackToTableContext(), e.activeFormattingElements.insertMarker(), e._insertElement(t, D.HTML), e.insertionMode = T.IN_CAPTION;
}
function Pm(e, t) {
  e.openElements.clearBackToTableContext(), e._insertElement(t, D.HTML), e.insertionMode = T.IN_COLUMN_GROUP;
}
function wm(e, t) {
  e.openElements.clearBackToTableContext(), e._insertFakeElement(x.COLGROUP, s.COLGROUP), e.insertionMode = T.IN_COLUMN_GROUP, au(e, t);
}
function Mm(e, t) {
  e.openElements.clearBackToTableContext(), e._insertElement(t, D.HTML), e.insertionMode = T.IN_TABLE_BODY;
}
function Bm(e, t) {
  e.openElements.clearBackToTableContext(), e._insertFakeElement(x.TBODY, s.TBODY), e.insertionMode = T.IN_TABLE_BODY, Gn(e, t);
}
function Fm(e, t) {
  e.openElements.hasInTableScope(s.TABLE) && (e.openElements.popUntilTagNamePopped(s.TABLE), e._resetInsertionMode(), e._processStartTag(t));
}
function vm(e, t) {
  Za(t) ? e._appendElement(t, D.HTML) : sn(e, t), t.ackSelfClosing = !0;
}
function Hm(e, t) {
  !e.formElement && e.openElements.tmplCount === 0 && (e._insertElement(t, D.HTML), e.formElement = e.openElements.current, e.openElements.pop());
}
function Nt(e, t) {
  switch (t.tagID) {
    case s.TD:
    case s.TH:
    case s.TR: {
      Bm(e, t);
      break;
    }
    case s.STYLE:
    case s.SCRIPT:
    case s.TEMPLATE: {
      Pe(e, t);
      break;
    }
    case s.COL: {
      wm(e, t);
      break;
    }
    case s.FORM: {
      Hm(e, t);
      break;
    }
    case s.TABLE: {
      Fm(e, t);
      break;
    }
    case s.TBODY:
    case s.TFOOT:
    case s.THEAD: {
      Mm(e, t);
      break;
    }
    case s.INPUT: {
      vm(e, t);
      break;
    }
    case s.CAPTION: {
      Dm(e, t);
      break;
    }
    case s.COLGROUP: {
      Pm(e, t);
      break;
    }
    default:
      sn(e, t);
  }
}
function en(e, t) {
  switch (t.tagID) {
    case s.TABLE: {
      e.openElements.hasInTableScope(s.TABLE) && (e.openElements.popUntilTagNamePopped(s.TABLE), e._resetInsertionMode());
      break;
    }
    case s.TEMPLATE: {
      mt(e, t);
      break;
    }
    case s.BODY:
    case s.CAPTION:
    case s.COL:
    case s.COLGROUP:
    case s.HTML:
    case s.TBODY:
    case s.TD:
    case s.TFOOT:
    case s.TH:
    case s.THEAD:
    case s.TR:
      break;
    default:
      sn(e, t);
  }
}
function sn(e, t) {
  const n = e.fosterParentingEnabled;
  e.fosterParentingEnabled = !0, Wn(e, t), e.fosterParentingEnabled = n;
}
function ts(e, t) {
  e.pendingCharacterTokens.push(t);
}
function ns(e, t) {
  e.pendingCharacterTokens.push(t), e.hasNonWhitespacePendingCharacterToken = !0;
}
function jt(e, t) {
  let n = 0;
  if (e.hasNonWhitespacePendingCharacterToken)
    for (; n < e.pendingCharacterTokens.length; n++)
      sn(e, e.pendingCharacterTokens[n]);
  else
    for (; n < e.pendingCharacterTokens.length; n++)
      e._insertCharacters(e.pendingCharacterTokens[n]);
  e.insertionMode = e.originalInsertionMode, e._processToken(t);
}
const rs = /* @__PURE__ */ new Set([s.CAPTION, s.COL, s.COLGROUP, s.TBODY, s.TD, s.TFOOT, s.TH, s.THEAD, s.TR]);
function Um(e, t) {
  const n = t.tagID;
  rs.has(n) ? e.openElements.hasInTableScope(s.CAPTION) && (e.openElements.generateImpliedEndTags(), e.openElements.popUntilTagNamePopped(s.CAPTION), e.activeFormattingElements.clearToLastMarker(), e.insertionMode = T.IN_TABLE, Nt(e, t)) : pe(e, t);
}
function jm(e, t) {
  const n = t.tagID;
  switch (n) {
    case s.CAPTION:
    case s.TABLE: {
      e.openElements.hasInTableScope(s.CAPTION) && (e.openElements.generateImpliedEndTags(), e.openElements.popUntilTagNamePopped(s.CAPTION), e.activeFormattingElements.clearToLastMarker(), e.insertionMode = T.IN_TABLE, n === s.TABLE && en(e, t));
      break;
    }
    case s.BODY:
    case s.COL:
    case s.COLGROUP:
    case s.HTML:
    case s.TBODY:
    case s.TD:
    case s.TFOOT:
    case s.TH:
    case s.THEAD:
    case s.TR:
      break;
    default:
      Qn(e, t);
  }
}
function au(e, t) {
  switch (t.tagID) {
    case s.HTML: {
      pe(e, t);
      break;
    }
    case s.COL: {
      e._appendElement(t, D.HTML), t.ackSelfClosing = !0;
      break;
    }
    case s.TEMPLATE: {
      Pe(e, t);
      break;
    }
    default:
      Pn(e, t);
  }
}
function zm(e, t) {
  switch (t.tagID) {
    case s.COLGROUP: {
      e.openElements.currentTagId === s.COLGROUP && (e.openElements.pop(), e.insertionMode = T.IN_TABLE);
      break;
    }
    case s.TEMPLATE: {
      mt(e, t);
      break;
    }
    case s.COL:
      break;
    default:
      Pn(e, t);
  }
}
function Pn(e, t) {
  e.openElements.currentTagId === s.COLGROUP && (e.openElements.pop(), e.insertionMode = T.IN_TABLE, e._processToken(t));
}
function Gn(e, t) {
  switch (t.tagID) {
    case s.TR: {
      e.openElements.clearBackToTableBodyContext(), e._insertElement(t, D.HTML), e.insertionMode = T.IN_ROW;
      break;
    }
    case s.TH:
    case s.TD: {
      e.openElements.clearBackToTableBodyContext(), e._insertFakeElement(x.TR, s.TR), e.insertionMode = T.IN_ROW, $n(e, t);
      break;
    }
    case s.CAPTION:
    case s.COL:
    case s.COLGROUP:
    case s.TBODY:
    case s.TFOOT:
    case s.THEAD: {
      e.openElements.hasTableBodyContextInTableScope() && (e.openElements.clearBackToTableBodyContext(), e.openElements.pop(), e.insertionMode = T.IN_TABLE, Nt(e, t));
      break;
    }
    default:
      Nt(e, t);
  }
}
function Lr(e, t) {
  const n = t.tagID;
  switch (t.tagID) {
    case s.TBODY:
    case s.TFOOT:
    case s.THEAD: {
      e.openElements.hasInTableScope(n) && (e.openElements.clearBackToTableBodyContext(), e.openElements.pop(), e.insertionMode = T.IN_TABLE);
      break;
    }
    case s.TABLE: {
      e.openElements.hasTableBodyContextInTableScope() && (e.openElements.clearBackToTableBodyContext(), e.openElements.pop(), e.insertionMode = T.IN_TABLE, en(e, t));
      break;
    }
    case s.BODY:
    case s.CAPTION:
    case s.COL:
    case s.COLGROUP:
    case s.HTML:
    case s.TD:
    case s.TH:
    case s.TR:
      break;
    default:
      en(e, t);
  }
}
function $n(e, t) {
  switch (t.tagID) {
    case s.TH:
    case s.TD: {
      e.openElements.clearBackToTableRowContext(), e._insertElement(t, D.HTML), e.insertionMode = T.IN_CELL, e.activeFormattingElements.insertMarker();
      break;
    }
    case s.CAPTION:
    case s.COL:
    case s.COLGROUP:
    case s.TBODY:
    case s.TFOOT:
    case s.THEAD:
    case s.TR: {
      e.openElements.hasInTableScope(s.TR) && (e.openElements.clearBackToTableRowContext(), e.openElements.pop(), e.insertionMode = T.IN_TABLE_BODY, Gn(e, t));
      break;
    }
    default:
      Nt(e, t);
  }
}
function us(e, t) {
  switch (t.tagID) {
    case s.TR: {
      e.openElements.hasInTableScope(s.TR) && (e.openElements.clearBackToTableRowContext(), e.openElements.pop(), e.insertionMode = T.IN_TABLE_BODY);
      break;
    }
    case s.TABLE: {
      e.openElements.hasInTableScope(s.TR) && (e.openElements.clearBackToTableRowContext(), e.openElements.pop(), e.insertionMode = T.IN_TABLE_BODY, Lr(e, t));
      break;
    }
    case s.TBODY:
    case s.TFOOT:
    case s.THEAD: {
      (e.openElements.hasInTableScope(t.tagID) || e.openElements.hasInTableScope(s.TR)) && (e.openElements.clearBackToTableRowContext(), e.openElements.pop(), e.insertionMode = T.IN_TABLE_BODY, Lr(e, t));
      break;
    }
    case s.BODY:
    case s.CAPTION:
    case s.COL:
    case s.COLGROUP:
    case s.HTML:
    case s.TD:
    case s.TH:
      break;
    default:
      en(e, t);
  }
}
function qm(e, t) {
  const n = t.tagID;
  rs.has(n) ? (e.openElements.hasInTableScope(s.TD) || e.openElements.hasInTableScope(s.TH)) && (e._closeTableCell(), $n(e, t)) : pe(e, t);
}
function Ym(e, t) {
  const n = t.tagID;
  switch (n) {
    case s.TD:
    case s.TH: {
      e.openElements.hasInTableScope(n) && (e.openElements.generateImpliedEndTags(), e.openElements.popUntilTagNamePopped(n), e.activeFormattingElements.clearToLastMarker(), e.insertionMode = T.IN_ROW);
      break;
    }
    case s.TABLE:
    case s.TBODY:
    case s.TFOOT:
    case s.THEAD:
    case s.TR: {
      e.openElements.hasInTableScope(n) && (e._closeTableCell(), us(e, t));
      break;
    }
    case s.BODY:
    case s.CAPTION:
    case s.COL:
    case s.COLGROUP:
    case s.HTML:
      break;
    default:
      Qn(e, t);
  }
}
function is(e, t) {
  switch (t.tagID) {
    case s.HTML: {
      pe(e, t);
      break;
    }
    case s.OPTION: {
      e.openElements.currentTagId === s.OPTION && e.openElements.pop(), e._insertElement(t, D.HTML);
      break;
    }
    case s.OPTGROUP: {
      e.openElements.currentTagId === s.OPTION && e.openElements.pop(), e.openElements.currentTagId === s.OPTGROUP && e.openElements.pop(), e._insertElement(t, D.HTML);
      break;
    }
    case s.HR: {
      e.openElements.currentTagId === s.OPTION && e.openElements.pop(), e.openElements.currentTagId === s.OPTGROUP && e.openElements.pop(), e._appendElement(t, D.HTML), t.ackSelfClosing = !0;
      break;
    }
    case s.INPUT:
    case s.KEYGEN:
    case s.TEXTAREA:
    case s.SELECT: {
      e.openElements.hasInSelectScope(s.SELECT) && (e.openElements.popUntilTagNamePopped(s.SELECT), e._resetInsertionMode(), t.tagID !== s.SELECT && e._processStartTag(t));
      break;
    }
    case s.SCRIPT:
    case s.TEMPLATE: {
      Pe(e, t);
      break;
    }
  }
}
function as(e, t) {
  switch (t.tagID) {
    case s.OPTGROUP: {
      e.openElements.stackTop > 0 && e.openElements.currentTagId === s.OPTION && e.openElements.tagIDs[e.openElements.stackTop - 1] === s.OPTGROUP && e.openElements.pop(), e.openElements.currentTagId === s.OPTGROUP && e.openElements.pop();
      break;
    }
    case s.OPTION: {
      e.openElements.currentTagId === s.OPTION && e.openElements.pop();
      break;
    }
    case s.SELECT: {
      e.openElements.hasInSelectScope(s.SELECT) && (e.openElements.popUntilTagNamePopped(s.SELECT), e._resetInsertionMode());
      break;
    }
    case s.TEMPLATE: {
      mt(e, t);
      break;
    }
  }
}
function Vm(e, t) {
  const n = t.tagID;
  n === s.CAPTION || n === s.TABLE || n === s.TBODY || n === s.TFOOT || n === s.THEAD || n === s.TR || n === s.TD || n === s.TH ? (e.openElements.popUntilTagNamePopped(s.SELECT), e._resetInsertionMode(), e._processStartTag(t)) : is(e, t);
}
function Wm(e, t) {
  const n = t.tagID;
  n === s.CAPTION || n === s.TABLE || n === s.TBODY || n === s.TFOOT || n === s.THEAD || n === s.TR || n === s.TD || n === s.TH ? e.openElements.hasInTableScope(n) && (e.openElements.popUntilTagNamePopped(s.SELECT), e._resetInsertionMode(), e.onEndTag(t)) : as(e, t);
}
function Qm(e, t) {
  switch (t.tagID) {
    // First, handle tags that can start without a mode change
    case s.BASE:
    case s.BASEFONT:
    case s.BGSOUND:
    case s.LINK:
    case s.META:
    case s.NOFRAMES:
    case s.SCRIPT:
    case s.STYLE:
    case s.TEMPLATE:
    case s.TITLE: {
      Pe(e, t);
      break;
    }
    // Re-process the token in the appropriate mode
    case s.CAPTION:
    case s.COLGROUP:
    case s.TBODY:
    case s.TFOOT:
    case s.THEAD: {
      e.tmplInsertionModeStack[0] = T.IN_TABLE, e.insertionMode = T.IN_TABLE, Nt(e, t);
      break;
    }
    case s.COL: {
      e.tmplInsertionModeStack[0] = T.IN_COLUMN_GROUP, e.insertionMode = T.IN_COLUMN_GROUP, au(e, t);
      break;
    }
    case s.TR: {
      e.tmplInsertionModeStack[0] = T.IN_TABLE_BODY, e.insertionMode = T.IN_TABLE_BODY, Gn(e, t);
      break;
    }
    case s.TD:
    case s.TH: {
      e.tmplInsertionModeStack[0] = T.IN_ROW, e.insertionMode = T.IN_ROW, $n(e, t);
      break;
    }
    default:
      e.tmplInsertionModeStack[0] = T.IN_BODY, e.insertionMode = T.IN_BODY, pe(e, t);
  }
}
function Gm(e, t) {
  t.tagID === s.TEMPLATE && mt(e, t);
}
function ss(e, t) {
  e.openElements.tmplCount > 0 ? (e.openElements.popUntilTagNamePopped(s.TEMPLATE), e.activeFormattingElements.clearToLastMarker(), e.tmplInsertionModeStack.shift(), e._resetInsertionMode(), e.onEof(t)) : iu(e, t);
}
function $m(e, t) {
  t.tagID === s.HTML ? pe(e, t) : wn(e, t);
}
function os(e, t) {
  var n;
  if (t.tagID === s.HTML) {
    if (e.fragmentContext || (e.insertionMode = T.AFTER_AFTER_BODY), e.options.sourceCodeLocationInfo && e.openElements.tagIDs[0] === s.HTML) {
      e._setEndLocation(e.openElements.items[0], t);
      const r = e.openElements.items[1];
      r && !(!((n = e.treeAdapter.getNodeSourceCodeLocation(r)) === null || n === void 0) && n.endTag) && e._setEndLocation(r, t);
    }
  } else
    wn(e, t);
}
function wn(e, t) {
  e.insertionMode = T.IN_BODY, Wn(e, t);
}
function Km(e, t) {
  switch (t.tagID) {
    case s.HTML: {
      pe(e, t);
      break;
    }
    case s.FRAMESET: {
      e._insertElement(t, D.HTML);
      break;
    }
    case s.FRAME: {
      e._appendElement(t, D.HTML), t.ackSelfClosing = !0;
      break;
    }
    case s.NOFRAMES: {
      Pe(e, t);
      break;
    }
  }
}
function Xm(e, t) {
  t.tagID === s.FRAMESET && !e.openElements.isRootHtmlElementCurrent() && (e.openElements.pop(), !e.fragmentContext && e.openElements.currentTagId !== s.FRAMESET && (e.insertionMode = T.AFTER_FRAMESET));
}
function Zm(e, t) {
  switch (t.tagID) {
    case s.HTML: {
      pe(e, t);
      break;
    }
    case s.NOFRAMES: {
      Pe(e, t);
      break;
    }
  }
}
function Jm(e, t) {
  t.tagID === s.HTML && (e.insertionMode = T.AFTER_AFTER_FRAMESET);
}
function ep(e, t) {
  t.tagID === s.HTML ? pe(e, t) : Cn(e, t);
}
function Cn(e, t) {
  e.insertionMode = T.IN_BODY, Wn(e, t);
}
function tp(e, t) {
  switch (t.tagID) {
    case s.HTML: {
      pe(e, t);
      break;
    }
    case s.NOFRAMES: {
      Pe(e, t);
      break;
    }
  }
}
function np(e, t) {
  t.chars = ae, e._insertCharacters(t);
}
function rp(e, t) {
  e._insertCharacters(t), e.framesetOk = !1;
}
function ls(e) {
  for (; e.treeAdapter.getNamespaceURI(e.openElements.current) !== D.HTML && !e._isIntegrationPoint(e.openElements.currentTagId, e.openElements.current); )
    e.openElements.pop();
}
function up(e, t) {
  if (bh(t))
    ls(e), e._startTagOutsideForeignContent(t);
  else {
    const n = e._getAdjustedCurrentElement(), r = e.treeAdapter.getNamespaceURI(n);
    r === D.MATHML ? Wa(t) : r === D.SVG && (Ah(t), Qa(t)), ru(t), t.selfClosing ? e._appendElement(t, r) : e._insertElement(t, r), t.ackSelfClosing = !0;
  }
}
function ip(e, t) {
  if (t.tagID === s.P || t.tagID === s.BR) {
    ls(e), e._endTagOutsideForeignContent(t);
    return;
  }
  for (let n = e.openElements.stackTop; n > 0; n--) {
    const r = e.openElements.items[n];
    if (e.treeAdapter.getNamespaceURI(r) === D.HTML) {
      e._endTagOutsideForeignContent(t);
      break;
    }
    const u = e.treeAdapter.getTagName(r);
    if (u.toLowerCase() === t.tagName) {
      t.tagName = u, e.openElements.shortenToLength(n);
      break;
    }
  }
}
x.AREA, x.BASE, x.BASEFONT, x.BGSOUND, x.BR, x.COL, x.EMBED, x.FRAME, x.HR, x.IMG, x.INPUT, x.KEYGEN, x.LINK, x.META, x.PARAM, x.SOURCE, x.TRACK, x.WBR;
const ap = /<(\/?)(iframe|noembed|noframes|plaintext|script|style|textarea|title|xmp)(?=[\t\n\f\r />])/gi, sp = /* @__PURE__ */ new Set([
  "mdxFlowExpression",
  "mdxJsxFlowElement",
  "mdxJsxTextElement",
  "mdxTextExpression",
  "mdxjsEsm"
]), Ei = { sourceCodeLocationInfo: !0, scriptingEnabled: !1 };
function cs(e, t) {
  const n = gp(e), r = Gi("type", {
    handlers: { root: op, element: lp, text: cp, comment: ds, doctype: fp, raw: hp },
    unknown: mp
  }), u = {
    parser: n ? new hi(Ei) : hi.getFragmentParser(void 0, Ei),
    handle(o) {
      r(o, u);
    },
    stitches: !1,
    options: t || {}
  };
  r(e, u), Dt(u, tt());
  const a = n ? u.parser.document : u.parser.getFragment(), i = bd(a, {
    // To do: support `space`?
    file: u.options.file
  });
  return u.stitches && Hn(i, "comment", function(o, l, c) {
    const d = (
      /** @type {Stitch} */
      /** @type {unknown} */
      o
    );
    if (d.value.stitch && c && l !== void 0) {
      const f = c.children;
      return f[l] = d.value.stitch, l;
    }
  }), i.type === "root" && i.children.length === 1 && i.children[0].type === e.type ? i.children[0] : i;
}
function fs(e, t) {
  let n = -1;
  if (e)
    for (; ++n < e.length; )
      t.handle(e[n]);
}
function op(e, t) {
  fs(e.children, t);
}
function lp(e, t) {
  pp(e, t), fs(e.children, t), Ep(e, t);
}
function cp(e, t) {
  t.parser.tokenizer.state > 4 && (t.parser.tokenizer.state = 0);
  const n = {
    type: V.CHARACTER,
    chars: e.value,
    location: on(e)
  };
  Dt(t, tt(e)), t.parser.currentToken = n, t.parser._processToken(t.parser.currentToken);
}
function fp(e, t) {
  const n = {
    type: V.DOCTYPE,
    name: "html",
    forceQuirks: !1,
    publicId: "",
    systemId: "",
    location: on(e)
  };
  Dt(t, tt(e)), t.parser.currentToken = n, t.parser._processToken(t.parser.currentToken);
}
function dp(e, t) {
  t.stitches = !0;
  const n = Tp(e);
  if ("children" in e && "children" in n) {
    const r = (
      /** @type {Root} */
      cs({ type: "root", children: e.children }, t.options)
    );
    n.children = r.children;
  }
  ds({ type: "comment", value: { stitch: n } }, t);
}
function ds(e, t) {
  const n = e.value, r = {
    type: V.COMMENT,
    data: n,
    location: on(e)
  };
  Dt(t, tt(e)), t.parser.currentToken = r, t.parser._processToken(t.parser.currentToken);
}
function hp(e, t) {
  if (t.parser.tokenizer.preprocessor.html = "", t.parser.tokenizer.preprocessor.pos = -1, t.parser.tokenizer.preprocessor.lastGapPos = -2, t.parser.tokenizer.preprocessor.gapStack = [], t.parser.tokenizer.preprocessor.skipNextNewLine = !1, t.parser.tokenizer.preprocessor.lastChunkWritten = !1, t.parser.tokenizer.preprocessor.endOfChunkHit = !1, t.parser.tokenizer.preprocessor.isEol = !1, hs(t, tt(e)), t.parser.tokenizer.write(
    t.options.tagfilter ? e.value.replace(ap, "&lt;$1$2") : e.value,
    !1
  ), t.parser.tokenizer._runParsingLoop(), t.parser.tokenizer.state === 72 || // @ts-expect-error: removed.
  t.parser.tokenizer.state === 78) {
    t.parser.tokenizer.preprocessor.lastChunkWritten = !0;
    const n = t.parser.tokenizer._consume();
    t.parser.tokenizer._callState(n);
  }
}
function mp(e, t) {
  const n = (
    /** @type {Nodes} */
    e
  );
  if (t.options.passThrough && t.options.passThrough.includes(n.type))
    dp(n, t);
  else {
    let r = "";
    throw sp.has(n.type) && (r = ". It looks like you are using MDX nodes with `hast-util-raw` (or `rehype-raw`). If you use this because you are using remark or rehype plugins that inject `'html'` nodes, then please raise an issue with that plugin, as its a bad and slow idea. If you use this because you are using markdown syntax, then you have to configure this utility (or plugin) to pass through these nodes (see `passThrough` in docs), but you can also migrate to use the MDX syntax"), new Error("Cannot compile `" + n.type + "` node" + r);
  }
}
function Dt(e, t) {
  hs(e, t);
  const n = e.parser.tokenizer.currentCharacterToken;
  n && n.location && (n.location.endLine = e.parser.tokenizer.preprocessor.line, n.location.endCol = e.parser.tokenizer.preprocessor.col + 1, n.location.endOffset = e.parser.tokenizer.preprocessor.offset + 1, e.parser.currentToken = n, e.parser._processToken(e.parser.currentToken)), e.parser.tokenizer.paused = !1, e.parser.tokenizer.inLoop = !1, e.parser.tokenizer.active = !1, e.parser.tokenizer.returnState = se.DATA, e.parser.tokenizer.charRefCode = -1, e.parser.tokenizer.consumedAfterSnapshot = -1, e.parser.tokenizer.currentLocation = null, e.parser.tokenizer.currentCharacterToken = null, e.parser.tokenizer.currentToken = null, e.parser.tokenizer.currentAttr = { name: "", value: "" };
}
function hs(e, t) {
  if (t && t.offset !== void 0) {
    const n = {
      startLine: t.line,
      startCol: t.column,
      startOffset: t.offset,
      endLine: -1,
      endCol: -1,
      endOffset: -1
    };
    e.parser.tokenizer.preprocessor.lineStartPos = -t.column + 1, e.parser.tokenizer.preprocessor.droppedBufferSize = t.offset, e.parser.tokenizer.preprocessor.line = t.line, e.parser.tokenizer.currentLocation = n;
  }
}
function pp(e, t) {
  const n = e.tagName.toLowerCase();
  if (t.parser.tokenizer.state === se.PLAINTEXT) return;
  Dt(t, tt(e));
  const r = t.parser.openElements.current;
  let u = "namespaceURI" in r ? r.namespaceURI : lt.html;
  u === lt.html && n === "svg" && (u = lt.svg);
  const a = Id(
    // Shallow clone to not delve into `children`: we only need the attributes.
    { ...e, children: [] },
    { space: u === lt.svg ? "svg" : "html" }
  ), i = {
    type: V.START_TAG,
    tagName: n,
    tagID: Rt(n),
    // We always send start and end tags.
    selfClosing: !1,
    ackSelfClosing: !1,
    // Always element.
    /* c8 ignore next */
    attrs: "attrs" in a ? a.attrs : [],
    location: on(e)
  };
  t.parser.currentToken = i, t.parser._processToken(t.parser.currentToken), t.parser.tokenizer.lastStartTagName = n;
}
function Ep(e, t) {
  const n = e.tagName.toLowerCase();
  if (!t.parser.tokenizer.inForeignNode && Yo.includes(n) || t.parser.tokenizer.state === se.PLAINTEXT) return;
  Dt(t, vr(e));
  const r = {
    type: V.END_TAG,
    tagName: n,
    tagID: Rt(n),
    selfClosing: !1,
    ackSelfClosing: !1,
    attrs: [],
    location: on(e)
  };
  t.parser.currentToken = r, t.parser._processToken(t.parser.currentToken), // Current element is closed.
  n === t.parser.tokenizer.lastStartTagName && // `<textarea>` and `<title>`
  (t.parser.tokenizer.state === se.RCDATA || // `<iframe>`, `<noembed>`, `<noframes>`, `<style>`, `<xmp>`
  t.parser.tokenizer.state === se.RAWTEXT || // `<script>`
  t.parser.tokenizer.state === se.SCRIPT_DATA) && (t.parser.tokenizer.state = se.DATA);
}
function gp(e) {
  const t = e.type === "root" ? e.children[0] : e;
  return !!(t && (t.type === "doctype" || t.type === "element" && t.tagName.toLowerCase() === "html"));
}
function on(e) {
  const t = tt(e) || {
    line: void 0,
    column: void 0,
    offset: void 0
  }, n = vr(e) || {
    line: void 0,
    column: void 0,
    offset: void 0
  };
  return {
    startLine: t.line,
    startCol: t.column,
    startOffset: t.offset,
    endLine: n.line,
    endCol: n.column,
    endOffset: n.offset
  };
}
function Tp(e) {
  return "children" in e ? Xu({ ...e, children: [] }) : Xu(e);
}
function bp(e) {
  return function(t, n) {
    return (
      /** @type {Root} */
      cs(t, { ...e, file: n })
    );
  };
}
function Ap(e) {
  if (typeof e != "string")
    throw new TypeError("Expected a string");
  return e.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
}
function _p(e, t, n) {
  const u = $i((n || {}).ignore || []), a = xp(t);
  let i = -1;
  for (; ++i < a.length; )
    Vo(e, "text", o);
  function o(c, d) {
    let f = -1, m;
    for (; ++f < d.length; ) {
      const h = d[f], b = m ? m.children : void 0;
      if (u(
        h,
        b ? b.indexOf(h) : void 0,
        m
      ))
        return;
      m = h;
    }
    if (m)
      return l(c, d);
  }
  function l(c, d) {
    const f = d[d.length - 1], m = a[i][0], h = a[i][1];
    let b = 0;
    const y = f.children.indexOf(c);
    let C = !1, w = [];
    m.lastIndex = 0;
    let O = m.exec(c.value);
    for (; O; ) {
      const v = O.index, R = {
        index: O.index,
        input: O.input,
        stack: [...d, c]
      };
      let N = h(...O, R);
      if (typeof N == "string" && (N = N.length > 0 ? { type: "text", value: N } : void 0), N === !1 ? m.lastIndex = v + 1 : (b !== v && w.push({
        type: "text",
        value: c.value.slice(b, v)
      }), Array.isArray(N) ? w.push(...N) : N && w.push(N), b = v + O[0].length, C = !0), !m.global)
        break;
      O = m.exec(c.value);
    }
    return C ? (b < c.value.length && w.push({ type: "text", value: c.value.slice(b) }), f.children.splice(y, 1, ...w)) : w = [c], y + w.length;
  }
}
function xp(e) {
  const t = [];
  if (!Array.isArray(e))
    throw new TypeError("Expected find and replace tuple or list of tuples");
  const n = !e[0] || Array.isArray(e[0]) ? e : [e];
  let r = -1;
  for (; ++r < n.length; ) {
    const u = n[r];
    t.push([Cp(u[0]), Ip(u[1])]);
  }
  return t;
}
function Cp(e) {
  return typeof e == "string" ? new RegExp(Ap(e), "g") : e;
}
function Ip(e) {
  return typeof e == "function" ? e : function() {
    return e;
  };
}
const hr = "phrasing", mr = ["autolink", "link", "image", "label"];
function Sp() {
  return {
    transforms: [Dp],
    enter: {
      literalAutolink: kp,
      literalAutolinkEmail: pr,
      literalAutolinkHttp: pr,
      literalAutolinkWww: pr
    },
    exit: {
      literalAutolink: Rp,
      literalAutolinkEmail: Lp,
      literalAutolinkHttp: yp,
      literalAutolinkWww: Op
    }
  };
}
function Np() {
  return {
    unsafe: [
      {
        character: "@",
        before: "[+\\-.\\w]",
        after: "[\\-.\\w]",
        inConstruct: hr,
        notInConstruct: mr
      },
      {
        character: ".",
        before: "[Ww]",
        after: "[\\-.\\w]",
        inConstruct: hr,
        notInConstruct: mr
      },
      {
        character: ":",
        before: "[ps]",
        after: "\\/",
        inConstruct: hr,
        notInConstruct: mr
      }
    ]
  };
}
function kp(e) {
  this.enter({ type: "link", title: null, url: "", children: [] }, e);
}
function pr(e) {
  this.config.enter.autolinkProtocol.call(this, e);
}
function yp(e) {
  this.config.exit.autolinkProtocol.call(this, e);
}
function Op(e) {
  this.config.exit.data.call(this, e);
  const t = this.stack[this.stack.length - 1];
  Ve(t.type === "link"), t.url = "http://" + this.sliceSerialize(e);
}
function Lp(e) {
  this.config.exit.autolinkEmail.call(this, e);
}
function Rp(e) {
  this.exit(e);
}
function Dp(e) {
  _p(
    e,
    [
      [/(https?:\/\/|www(?=\.))([-.\w]+)([^ \t\r\n]*)/gi, Pp],
      [/(?<=^|\s|\p{P}|\p{S})([-.\w+]+)@([-\w]+(?:\.[-\w]+)+)/gu, wp]
    ],
    { ignore: ["link", "linkReference"] }
  );
}
function Pp(e, t, n, r, u) {
  let a = "";
  if (!ms(u) || (/^w/i.test(t) && (n = t + n, t = "", a = "http://"), !Mp(n)))
    return !1;
  const i = Bp(n + r);
  if (!i[0]) return !1;
  const o = {
    type: "link",
    title: null,
    url: a + t + i[0],
    children: [{ type: "text", value: t + i[0] }]
  };
  return i[1] ? [o, { type: "text", value: i[1] }] : o;
}
function wp(e, t, n, r) {
  return (
    // Not an expected previous character.
    !ms(r, !0) || // Label ends in not allowed character.
    /[-\d_]$/.test(n) ? !1 : {
      type: "link",
      title: null,
      url: "mailto:" + t + "@" + n,
      children: [{ type: "text", value: t + "@" + n }]
    }
  );
}
function Mp(e) {
  const t = e.split(".");
  return !(t.length < 2 || t[t.length - 1] && (/_/.test(t[t.length - 1]) || !/[a-zA-Z\d]/.test(t[t.length - 1])) || t[t.length - 2] && (/_/.test(t[t.length - 2]) || !/[a-zA-Z\d]/.test(t[t.length - 2])));
}
function Bp(e) {
  const t = /[!"&'),.:;<>?\]}]+$/.exec(e);
  if (!t)
    return [e, void 0];
  e = e.slice(0, t.index);
  let n = t[0], r = n.indexOf(")");
  const u = Au(e, "(");
  let a = Au(e, ")");
  for (; r !== -1 && u > a; )
    e += n.slice(0, r + 1), n = n.slice(r + 1), r = n.indexOf(")"), a++;
  return [e, n];
}
function ms(e, t) {
  const n = e.input.charCodeAt(e.index - 1);
  return (e.index === 0 || dt(n) || jn(n)) && // If it’s an email, the previous character should not be a slash.
  (!t || n !== 47);
}
function ln(e) {
  return e.replace(/[\t\n\r ]+/g, " ").replace(/^ | $/g, "").toLowerCase().toUpperCase();
}
ps.peek = Vp;
function Fp() {
  this.buffer();
}
function vp(e) {
  this.enter({ type: "footnoteReference", identifier: "", label: "" }, e);
}
function Hp() {
  this.buffer();
}
function Up(e) {
  this.enter(
    { type: "footnoteDefinition", identifier: "", label: "", children: [] },
    e
  );
}
function jp(e) {
  const t = this.resume(), n = this.stack[this.stack.length - 1];
  Ve(n.type === "footnoteReference"), n.identifier = ln(
    this.sliceSerialize(e)
  ).toLowerCase(), n.label = t;
}
function zp(e) {
  this.exit(e);
}
function qp(e) {
  const t = this.resume(), n = this.stack[this.stack.length - 1];
  Ve(n.type === "footnoteDefinition"), n.identifier = ln(
    this.sliceSerialize(e)
  ).toLowerCase(), n.label = t;
}
function Yp(e) {
  this.exit(e);
}
function Vp() {
  return "[";
}
function ps(e, t, n, r) {
  const u = n.createTracker(r);
  let a = u.move("[^");
  const i = n.enter("footnoteReference"), o = n.enter("reference");
  return a += u.move(
    n.safe(n.associationId(e), { after: "]", before: a })
  ), o(), i(), a += u.move("]"), a;
}
function Wp() {
  return {
    enter: {
      gfmFootnoteCallString: Fp,
      gfmFootnoteCall: vp,
      gfmFootnoteDefinitionLabelString: Hp,
      gfmFootnoteDefinition: Up
    },
    exit: {
      gfmFootnoteCallString: jp,
      gfmFootnoteCall: zp,
      gfmFootnoteDefinitionLabelString: qp,
      gfmFootnoteDefinition: Yp
    }
  };
}
function Qp(e) {
  let t = !1;
  return e && e.firstLineBlank && (t = !0), {
    handlers: { footnoteDefinition: n, footnoteReference: ps },
    // This is on by default already.
    unsafe: [{ character: "[", inConstruct: ["label", "phrasing", "reference"] }]
  };
  function n(r, u, a, i) {
    const o = a.createTracker(i);
    let l = o.move("[^");
    const c = a.enter("footnoteDefinition"), d = a.enter("label");
    return l += o.move(
      a.safe(a.associationId(r), { before: l, after: "]" })
    ), d(), l += o.move("]:"), r.children && r.children.length > 0 && (o.shift(4), l += o.move(
      (t ? `
` : " ") + a.indentLines(
        a.containerFlow(r, o.current()),
        t ? Es : Gp
      )
    )), c(), l;
  }
}
function Gp(e, t, n) {
  return t === 0 ? e : Es(e, t, n);
}
function Es(e, t, n) {
  return (n ? "" : "    ") + e;
}
const $p = [
  "autolink",
  "destinationLiteral",
  "destinationRaw",
  "reference",
  "titleQuote",
  "titleApostrophe"
];
gs.peek = e1;
function Kp() {
  return {
    canContainEols: ["delete"],
    enter: { strikethrough: Zp },
    exit: { strikethrough: Jp }
  };
}
function Xp() {
  return {
    unsafe: [
      {
        character: "~",
        inConstruct: "phrasing",
        notInConstruct: $p
      }
    ],
    handlers: { delete: gs }
  };
}
function Zp(e) {
  this.enter({ type: "delete", children: [] }, e);
}
function Jp(e) {
  this.exit(e);
}
function gs(e, t, n, r) {
  const u = n.createTracker(r), a = n.enter("strikethrough");
  let i = u.move("~~");
  return i += n.containerPhrasing(e, {
    ...u.current(),
    before: i,
    after: "~"
  }), i += u.move("~~"), a(), i;
}
function e1() {
  return "~";
}
function t1(e) {
  return e.length;
}
function n1(e, t) {
  const n = t || {}, r = (n.align || []).concat(), u = n.stringLength || t1, a = [], i = [], o = [], l = [];
  let c = 0, d = -1;
  for (; ++d < e.length; ) {
    const I = [], y = [];
    let C = -1;
    for (e[d].length > c && (c = e[d].length); ++C < e[d].length; ) {
      const w = r1(e[d][C]);
      if (n.alignDelimiters !== !1) {
        const O = u(w);
        y[C] = O, (l[C] === void 0 || O > l[C]) && (l[C] = O);
      }
      I.push(w);
    }
    i[d] = I, o[d] = y;
  }
  let f = -1;
  if (typeof r == "object" && "length" in r)
    for (; ++f < c; )
      a[f] = gi(r[f]);
  else {
    const I = gi(r);
    for (; ++f < c; )
      a[f] = I;
  }
  f = -1;
  const m = [], h = [];
  for (; ++f < c; ) {
    const I = a[f];
    let y = "", C = "";
    I === 99 ? (y = ":", C = ":") : I === 108 ? y = ":" : I === 114 && (C = ":");
    let w = n.alignDelimiters === !1 ? 1 : Math.max(
      1,
      l[f] - y.length - C.length
    );
    const O = y + "-".repeat(w) + C;
    n.alignDelimiters !== !1 && (w = y.length + w + C.length, w > l[f] && (l[f] = w), h[f] = w), m[f] = O;
  }
  i.splice(1, 0, m), o.splice(1, 0, h), d = -1;
  const b = [];
  for (; ++d < i.length; ) {
    const I = i[d], y = o[d];
    f = -1;
    const C = [];
    for (; ++f < c; ) {
      const w = I[f] || "";
      let O = "", v = "";
      if (n.alignDelimiters !== !1) {
        const R = l[f] - (y[f] || 0), N = a[f];
        N === 114 ? O = " ".repeat(R) : N === 99 ? R % 2 ? (O = " ".repeat(R / 2 + 0.5), v = " ".repeat(R / 2 - 0.5)) : (O = " ".repeat(R / 2), v = O) : v = " ".repeat(R);
      }
      n.delimiterStart !== !1 && !f && C.push("|"), n.padding !== !1 && // Don’t add the opening space if we’re not aligning and the cell is
      // empty: there will be a closing space.
      !(n.alignDelimiters === !1 && w === "") && (n.delimiterStart !== !1 || f) && C.push(" "), n.alignDelimiters !== !1 && C.push(O), C.push(w), n.alignDelimiters !== !1 && C.push(v), n.padding !== !1 && C.push(" "), (n.delimiterEnd !== !1 || f !== c - 1) && C.push("|");
    }
    b.push(
      n.delimiterEnd === !1 ? C.join("").replace(/ +$/, "") : C.join("")
    );
  }
  return b.join(`
`);
}
function r1(e) {
  return e == null ? "" : String(e);
}
function gi(e) {
  const t = typeof e == "string" ? e.codePointAt(0) : 0;
  return t === 67 || t === 99 ? 99 : t === 76 || t === 108 ? 108 : t === 82 || t === 114 ? 114 : 0;
}
function u1(e, t, n, r) {
  const u = n.enter("blockquote"), a = n.createTracker(r);
  a.move("> "), a.shift(2);
  const i = n.indentLines(
    n.containerFlow(e, a.current()),
    i1
  );
  return u(), i;
}
function i1(e, t, n) {
  return ">" + (n ? "" : " ") + e;
}
function a1(e, t) {
  return Ti(e, t.inConstruct, !0) && !Ti(e, t.notInConstruct, !1);
}
function Ti(e, t, n) {
  if (typeof t == "string" && (t = [t]), !t || t.length === 0)
    return n;
  let r = -1;
  for (; ++r < t.length; )
    if (e.includes(t[r]))
      return !0;
  return !1;
}
function bi(e, t, n, r) {
  let u = -1;
  for (; ++u < n.unsafe.length; )
    if (n.unsafe[u].character === `
` && a1(n.stack, n.unsafe[u]))
      return /[ \t]/.test(r.before) ? "" : " ";
  return `\\
`;
}
function s1(e, t) {
  const n = String(e);
  let r = n.indexOf(t), u = r, a = 0, i = 0;
  if (typeof t != "string")
    throw new TypeError("Expected substring");
  for (; r !== -1; )
    r === u ? ++a > i && (i = a) : a = 1, u = r + t.length, r = n.indexOf(t, u);
  return i;
}
function o1(e, t) {
  return !!(t.options.fences === !1 && e.value && // If there’s no info…
  !e.lang && // And there’s a non-whitespace character…
  /[^ \r\n]/.test(e.value) && // And the value doesn’t start or end in a blank…
  !/^[\t ]*(?:[\r\n]|$)|(?:^|[\r\n])[\t ]*$/.test(e.value));
}
function l1(e) {
  const t = e.options.fence || "`";
  if (t !== "`" && t !== "~")
    throw new Error(
      "Cannot serialize code with `" + t + "` for `options.fence`, expected `` ` `` or `~`"
    );
  return t;
}
function c1(e, t, n, r) {
  const u = l1(n), a = e.value || "", i = u === "`" ? "GraveAccent" : "Tilde";
  if (o1(e, n)) {
    const f = n.enter("codeIndented"), m = n.indentLines(a, f1);
    return f(), m;
  }
  const o = n.createTracker(r), l = u.repeat(Math.max(s1(a, u) + 1, 3)), c = n.enter("codeFenced");
  let d = o.move(l);
  if (e.lang) {
    const f = n.enter(`codeFencedLang${i}`);
    d += o.move(
      n.safe(e.lang, {
        before: d,
        after: " ",
        encode: ["`"],
        ...o.current()
      })
    ), f();
  }
  if (e.lang && e.meta) {
    const f = n.enter(`codeFencedMeta${i}`);
    d += o.move(" "), d += o.move(
      n.safe(e.meta, {
        before: d,
        after: `
`,
        encode: ["`"],
        ...o.current()
      })
    ), f();
  }
  return d += o.move(`
`), a && (d += o.move(a + `
`)), d += o.move(l), c(), d;
}
function f1(e, t, n) {
  return (n ? "" : "    ") + e;
}
function su(e) {
  const t = e.options.quote || '"';
  if (t !== '"' && t !== "'")
    throw new Error(
      "Cannot serialize title with `" + t + "` for `options.quote`, expected `\"`, or `'`"
    );
  return t;
}
function d1(e, t, n, r) {
  const u = su(n), a = u === '"' ? "Quote" : "Apostrophe", i = n.enter("definition");
  let o = n.enter("label");
  const l = n.createTracker(r);
  let c = l.move("[");
  return c += l.move(
    n.safe(n.associationId(e), {
      before: c,
      after: "]",
      ...l.current()
    })
  ), c += l.move("]: "), o(), // If there’s no url, or…
  !e.url || // If there are control characters or whitespace.
  /[\0- \u007F]/.test(e.url) ? (o = n.enter("destinationLiteral"), c += l.move("<"), c += l.move(
    n.safe(e.url, { before: c, after: ">", ...l.current() })
  ), c += l.move(">")) : (o = n.enter("destinationRaw"), c += l.move(
    n.safe(e.url, {
      before: c,
      after: e.title ? " " : `
`,
      ...l.current()
    })
  )), o(), e.title && (o = n.enter(`title${a}`), c += l.move(" " + u), c += l.move(
    n.safe(e.title, {
      before: c,
      after: u,
      ...l.current()
    })
  ), c += l.move(u), o()), i(), c;
}
function h1(e) {
  const t = e.options.emphasis || "*";
  if (t !== "*" && t !== "_")
    throw new Error(
      "Cannot serialize emphasis with `" + t + "` for `options.emphasis`, expected `*`, or `_`"
    );
  return t;
}
function tn(e) {
  return "&#x" + e.toString(16).toUpperCase() + ";";
}
function Mn(e, t, n) {
  const r = St(e), u = St(t);
  return r === void 0 ? u === void 0 ? (
    // Letter inside:
    // we have to encode *both* letters for `_` as it is looser.
    // it already forms for `*` (and GFMs `~`).
    n === "_" ? { inside: !0, outside: !0 } : { inside: !1, outside: !1 }
  ) : u === 1 ? (
    // Whitespace inside: encode both (letter, whitespace).
    { inside: !0, outside: !0 }
  ) : (
    // Punctuation inside: encode outer (letter)
    { inside: !1, outside: !0 }
  ) : r === 1 ? u === void 0 ? (
    // Letter inside: already forms.
    { inside: !1, outside: !1 }
  ) : u === 1 ? (
    // Whitespace inside: encode both (whitespace).
    { inside: !0, outside: !0 }
  ) : (
    // Punctuation inside: already forms.
    { inside: !1, outside: !1 }
  ) : u === void 0 ? (
    // Letter inside: already forms.
    { inside: !1, outside: !1 }
  ) : u === 1 ? (
    // Whitespace inside: encode inner (whitespace).
    { inside: !0, outside: !1 }
  ) : (
    // Punctuation inside: already forms.
    { inside: !1, outside: !1 }
  );
}
Ts.peek = m1;
function Ts(e, t, n, r) {
  const u = h1(n), a = n.enter("emphasis"), i = n.createTracker(r), o = i.move(u);
  let l = i.move(
    n.containerPhrasing(e, {
      after: u,
      before: o,
      ...i.current()
    })
  );
  const c = l.charCodeAt(0), d = Mn(
    r.before.charCodeAt(r.before.length - 1),
    c,
    u
  );
  d.inside && (l = tn(c) + l.slice(1));
  const f = l.charCodeAt(l.length - 1), m = Mn(r.after.charCodeAt(0), f, u);
  m.inside && (l = l.slice(0, -1) + tn(f));
  const h = i.move(u);
  return a(), n.attentionEncodeSurroundingInfo = {
    after: m.outside,
    before: d.outside
  }, o + l + h;
}
function m1(e, t, n) {
  return n.options.emphasis || "*";
}
function p1(e, t) {
  let n = !1;
  return Hn(e, function(r) {
    if ("value" in r && /\r?\n|\r/.test(r.value) || r.type === "break")
      return n = !0, Wo;
  }), !!((!e.depth || e.depth < 3) && Ur(e) && (t.options.setext || n));
}
function E1(e, t, n, r) {
  const u = Math.max(Math.min(6, e.depth || 1), 1), a = n.createTracker(r);
  if (p1(e, n)) {
    const d = n.enter("headingSetext"), f = n.enter("phrasing"), m = n.containerPhrasing(e, {
      ...a.current(),
      before: `
`,
      after: `
`
    });
    return f(), d(), m + `
` + (u === 1 ? "=" : "-").repeat(
      // The whole size…
      m.length - // Minus the position of the character after the last EOL (or
      // 0 if there is none)…
      (Math.max(m.lastIndexOf("\r"), m.lastIndexOf(`
`)) + 1)
    );
  }
  const i = "#".repeat(u), o = n.enter("headingAtx"), l = n.enter("phrasing");
  a.move(i + " ");
  let c = n.containerPhrasing(e, {
    before: "# ",
    after: `
`,
    ...a.current()
  });
  return /^[\t ]/.test(c) && (c = tn(c.charCodeAt(0)) + c.slice(1)), c = c ? i + " " + c : i, n.options.closeAtx && (c += " " + i), l(), o(), c;
}
bs.peek = g1;
function bs(e) {
  return e.value || "";
}
function g1() {
  return "<";
}
As.peek = T1;
function As(e, t, n, r) {
  const u = su(n), a = u === '"' ? "Quote" : "Apostrophe", i = n.enter("image");
  let o = n.enter("label");
  const l = n.createTracker(r);
  let c = l.move("![");
  return c += l.move(
    n.safe(e.alt, { before: c, after: "]", ...l.current() })
  ), c += l.move("]("), o(), // If there’s no url but there is a title…
  !e.url && e.title || // If there are control characters or whitespace.
  /[\0- \u007F]/.test(e.url) ? (o = n.enter("destinationLiteral"), c += l.move("<"), c += l.move(
    n.safe(e.url, { before: c, after: ">", ...l.current() })
  ), c += l.move(">")) : (o = n.enter("destinationRaw"), c += l.move(
    n.safe(e.url, {
      before: c,
      after: e.title ? " " : ")",
      ...l.current()
    })
  )), o(), e.title && (o = n.enter(`title${a}`), c += l.move(" " + u), c += l.move(
    n.safe(e.title, {
      before: c,
      after: u,
      ...l.current()
    })
  ), c += l.move(u), o()), c += l.move(")"), i(), c;
}
function T1() {
  return "!";
}
_s.peek = b1;
function _s(e, t, n, r) {
  const u = e.referenceType, a = n.enter("imageReference");
  let i = n.enter("label");
  const o = n.createTracker(r);
  let l = o.move("![");
  const c = n.safe(e.alt, {
    before: l,
    after: "]",
    ...o.current()
  });
  l += o.move(c + "]["), i();
  const d = n.stack;
  n.stack = [], i = n.enter("reference");
  const f = n.safe(n.associationId(e), {
    before: l,
    after: "]",
    ...o.current()
  });
  return i(), n.stack = d, a(), u === "full" || !c || c !== f ? l += o.move(f + "]") : u === "shortcut" ? l = l.slice(0, -1) : l += o.move("]"), l;
}
function b1() {
  return "!";
}
xs.peek = A1;
function xs(e, t, n) {
  let r = e.value || "", u = "`", a = -1;
  for (; new RegExp("(^|[^`])" + u + "([^`]|$)").test(r); )
    u += "`";
  for (/[^ \r\n]/.test(r) && (/^[ \r\n]/.test(r) && /[ \r\n]$/.test(r) || /^`|`$/.test(r)) && (r = " " + r + " "); ++a < n.unsafe.length; ) {
    const i = n.unsafe[a], o = n.compilePattern(i);
    let l;
    if (i.atBreak)
      for (; l = o.exec(r); ) {
        let c = l.index;
        r.charCodeAt(c) === 10 && r.charCodeAt(c - 1) === 13 && c--, r = r.slice(0, c) + " " + r.slice(l.index + 1);
      }
  }
  return u + r + u;
}
function A1() {
  return "`";
}
function Cs(e, t) {
  const n = Ur(e);
  return !!(!t.options.resourceLink && // If there’s a url…
  e.url && // And there’s a no title…
  !e.title && // And the content of `node` is a single text node…
  e.children && e.children.length === 1 && e.children[0].type === "text" && // And if the url is the same as the content…
  (n === e.url || "mailto:" + n === e.url) && // And that starts w/ a protocol…
  /^[a-z][a-z+.-]+:/i.test(e.url) && // And that doesn’t contain ASCII control codes (character escapes and
  // references don’t work), space, or angle brackets…
  !/[\0- <>\u007F]/.test(e.url));
}
Is.peek = _1;
function Is(e, t, n, r) {
  const u = su(n), a = u === '"' ? "Quote" : "Apostrophe", i = n.createTracker(r);
  let o, l;
  if (Cs(e, n)) {
    const d = n.stack;
    n.stack = [], o = n.enter("autolink");
    let f = i.move("<");
    return f += i.move(
      n.containerPhrasing(e, {
        before: f,
        after: ">",
        ...i.current()
      })
    ), f += i.move(">"), o(), n.stack = d, f;
  }
  o = n.enter("link"), l = n.enter("label");
  let c = i.move("[");
  return c += i.move(
    n.containerPhrasing(e, {
      before: c,
      after: "](",
      ...i.current()
    })
  ), c += i.move("]("), l(), // If there’s no url but there is a title…
  !e.url && e.title || // If there are control characters or whitespace.
  /[\0- \u007F]/.test(e.url) ? (l = n.enter("destinationLiteral"), c += i.move("<"), c += i.move(
    n.safe(e.url, { before: c, after: ">", ...i.current() })
  ), c += i.move(">")) : (l = n.enter("destinationRaw"), c += i.move(
    n.safe(e.url, {
      before: c,
      after: e.title ? " " : ")",
      ...i.current()
    })
  )), l(), e.title && (l = n.enter(`title${a}`), c += i.move(" " + u), c += i.move(
    n.safe(e.title, {
      before: c,
      after: u,
      ...i.current()
    })
  ), c += i.move(u), l()), c += i.move(")"), o(), c;
}
function _1(e, t, n) {
  return Cs(e, n) ? "<" : "[";
}
Ss.peek = x1;
function Ss(e, t, n, r) {
  const u = e.referenceType, a = n.enter("linkReference");
  let i = n.enter("label");
  const o = n.createTracker(r);
  let l = o.move("[");
  const c = n.containerPhrasing(e, {
    before: l,
    after: "]",
    ...o.current()
  });
  l += o.move(c + "]["), i();
  const d = n.stack;
  n.stack = [], i = n.enter("reference");
  const f = n.safe(n.associationId(e), {
    before: l,
    after: "]",
    ...o.current()
  });
  return i(), n.stack = d, a(), u === "full" || !c || c !== f ? l += o.move(f + "]") : u === "shortcut" ? l = l.slice(0, -1) : l += o.move("]"), l;
}
function x1() {
  return "[";
}
function ou(e) {
  const t = e.options.bullet || "*";
  if (t !== "*" && t !== "+" && t !== "-")
    throw new Error(
      "Cannot serialize items with `" + t + "` for `options.bullet`, expected `*`, `+`, or `-`"
    );
  return t;
}
function C1(e) {
  const t = ou(e), n = e.options.bulletOther;
  if (!n)
    return t === "*" ? "-" : "*";
  if (n !== "*" && n !== "+" && n !== "-")
    throw new Error(
      "Cannot serialize items with `" + n + "` for `options.bulletOther`, expected `*`, `+`, or `-`"
    );
  if (n === t)
    throw new Error(
      "Expected `bullet` (`" + t + "`) and `bulletOther` (`" + n + "`) to be different"
    );
  return n;
}
function I1(e) {
  const t = e.options.bulletOrdered || ".";
  if (t !== "." && t !== ")")
    throw new Error(
      "Cannot serialize items with `" + t + "` for `options.bulletOrdered`, expected `.` or `)`"
    );
  return t;
}
function Ns(e) {
  const t = e.options.rule || "*";
  if (t !== "*" && t !== "-" && t !== "_")
    throw new Error(
      "Cannot serialize rules with `" + t + "` for `options.rule`, expected `*`, `-`, or `_`"
    );
  return t;
}
function S1(e, t, n, r) {
  const u = n.enter("list"), a = n.bulletCurrent;
  let i = e.ordered ? I1(n) : ou(n);
  const o = e.ordered ? i === "." ? ")" : "." : C1(n);
  let l = t && n.bulletLastUsed ? i === n.bulletLastUsed : !1;
  if (!e.ordered) {
    const d = e.children ? e.children[0] : void 0;
    if (
      // Bullet could be used as a thematic break marker:
      (i === "*" || i === "-") && // Empty first list item:
      d && (!d.children || !d.children[0]) && // Directly in two other list items:
      n.stack[n.stack.length - 1] === "list" && n.stack[n.stack.length - 2] === "listItem" && n.stack[n.stack.length - 3] === "list" && n.stack[n.stack.length - 4] === "listItem" && // That are each the first child.
      n.indexStack[n.indexStack.length - 1] === 0 && n.indexStack[n.indexStack.length - 2] === 0 && n.indexStack[n.indexStack.length - 3] === 0 && (l = !0), Ns(n) === i && d
    ) {
      let f = -1;
      for (; ++f < e.children.length; ) {
        const m = e.children[f];
        if (m && m.type === "listItem" && m.children && m.children[0] && m.children[0].type === "thematicBreak") {
          l = !0;
          break;
        }
      }
    }
  }
  l && (i = o), n.bulletCurrent = i;
  const c = n.containerFlow(e, r);
  return n.bulletLastUsed = i, n.bulletCurrent = a, u(), c;
}
function N1(e) {
  const t = e.options.listItemIndent || "one";
  if (t !== "tab" && t !== "one" && t !== "mixed")
    throw new Error(
      "Cannot serialize items with `" + t + "` for `options.listItemIndent`, expected `tab`, `one`, or `mixed`"
    );
  return t;
}
function k1(e, t, n, r) {
  const u = N1(n);
  let a = n.bulletCurrent || ou(n);
  t && t.type === "list" && t.ordered && (a = (typeof t.start == "number" && t.start > -1 ? t.start : 1) + (n.options.incrementListMarker === !1 ? 0 : t.children.indexOf(e)) + a);
  let i = a.length + 1;
  (u === "tab" || u === "mixed" && (t && t.type === "list" && t.spread || e.spread)) && (i = Math.ceil(i / 4) * 4);
  const o = n.createTracker(r);
  o.move(a + " ".repeat(i - a.length)), o.shift(i);
  const l = n.enter("listItem"), c = n.indentLines(
    n.containerFlow(e, o.current()),
    d
  );
  return l(), c;
  function d(f, m, h) {
    return m ? (h ? "" : " ".repeat(i)) + f : (h ? a : a + " ".repeat(i - a.length)) + f;
  }
}
function y1(e, t, n, r) {
  const u = n.enter("paragraph"), a = n.enter("phrasing"), i = n.containerPhrasing(e, r);
  return a(), u(), i;
}
const O1 = (
  /** @type {(node?: unknown) => node is Exclude<PhrasingContent, Html>} */
  $i([
    "break",
    "delete",
    "emphasis",
    // To do: next major: removed since footnotes were added to GFM.
    "footnote",
    "footnoteReference",
    "image",
    "imageReference",
    "inlineCode",
    // Enabled by `mdast-util-math`:
    "inlineMath",
    "link",
    "linkReference",
    // Enabled by `mdast-util-mdx`:
    "mdxJsxTextElement",
    // Enabled by `mdast-util-mdx`:
    "mdxTextExpression",
    "strong",
    "text",
    // Enabled by `mdast-util-directive`:
    "textDirective"
  ])
);
function L1(e, t, n, r) {
  return (e.children.some(function(i) {
    return O1(i);
  }) ? n.containerPhrasing : n.containerFlow).call(n, e, r);
}
function R1(e) {
  const t = e.options.strong || "*";
  if (t !== "*" && t !== "_")
    throw new Error(
      "Cannot serialize strong with `" + t + "` for `options.strong`, expected `*`, or `_`"
    );
  return t;
}
ks.peek = D1;
function ks(e, t, n, r) {
  const u = R1(n), a = n.enter("strong"), i = n.createTracker(r), o = i.move(u + u);
  let l = i.move(
    n.containerPhrasing(e, {
      after: u,
      before: o,
      ...i.current()
    })
  );
  const c = l.charCodeAt(0), d = Mn(
    r.before.charCodeAt(r.before.length - 1),
    c,
    u
  );
  d.inside && (l = tn(c) + l.slice(1));
  const f = l.charCodeAt(l.length - 1), m = Mn(r.after.charCodeAt(0), f, u);
  m.inside && (l = l.slice(0, -1) + tn(f));
  const h = i.move(u + u);
  return a(), n.attentionEncodeSurroundingInfo = {
    after: m.outside,
    before: d.outside
  }, o + l + h;
}
function D1(e, t, n) {
  return n.options.strong || "*";
}
function P1(e, t, n, r) {
  return n.safe(e.value, r);
}
function w1(e) {
  const t = e.options.ruleRepetition || 3;
  if (t < 3)
    throw new Error(
      "Cannot serialize rules with repetition `" + t + "` for `options.ruleRepetition`, expected `3` or more"
    );
  return t;
}
function M1(e, t, n) {
  const r = (Ns(n) + (n.options.ruleSpaces ? " " : "")).repeat(w1(n));
  return n.options.ruleSpaces ? r.slice(0, -1) : r;
}
const ys = {
  blockquote: u1,
  break: bi,
  code: c1,
  definition: d1,
  emphasis: Ts,
  hardBreak: bi,
  heading: E1,
  html: bs,
  image: As,
  imageReference: _s,
  inlineCode: xs,
  link: Is,
  linkReference: Ss,
  list: S1,
  listItem: k1,
  paragraph: y1,
  root: L1,
  strong: ks,
  text: P1,
  thematicBreak: M1
};
function B1() {
  return {
    enter: {
      table: F1,
      tableData: Ai,
      tableHeader: Ai,
      tableRow: H1
    },
    exit: {
      codeText: U1,
      table: v1,
      tableData: Er,
      tableHeader: Er,
      tableRow: Er
    }
  };
}
function F1(e) {
  const t = e._align;
  this.enter(
    {
      type: "table",
      align: t.map(function(n) {
        return n === "none" ? null : n;
      }),
      children: []
    },
    e
  ), this.data.inTable = !0;
}
function v1(e) {
  this.exit(e), this.data.inTable = void 0;
}
function H1(e) {
  this.enter({ type: "tableRow", children: [] }, e);
}
function Er(e) {
  this.exit(e);
}
function Ai(e) {
  this.enter({ type: "tableCell", children: [] }, e);
}
function U1(e) {
  let t = this.resume();
  this.data.inTable && (t = t.replace(/\\([\\|])/g, j1));
  const n = this.stack[this.stack.length - 1];
  Ve(n.type === "inlineCode"), n.value = t, this.exit(e);
}
function j1(e, t) {
  return t === "|" ? t : e;
}
function z1(e) {
  const t = e || {}, n = t.tableCellPadding, r = t.tablePipeAlign, u = t.stringLength, a = n ? " " : "|";
  return {
    unsafe: [
      { character: "\r", inConstruct: "tableCell" },
      { character: `
`, inConstruct: "tableCell" },
      // A pipe, when followed by a tab or space (padding), or a dash or colon
      // (unpadded delimiter row), could result in a table.
      { atBreak: !0, character: "|", after: "[	 :-]" },
      // A pipe in a cell must be encoded.
      { character: "|", inConstruct: "tableCell" },
      // A colon must be followed by a dash, in which case it could start a
      // delimiter row.
      { atBreak: !0, character: ":", after: "-" },
      // A delimiter row can also start with a dash, when followed by more
      // dashes, a colon, or a pipe.
      // This is a stricter version than the built in check for lists, thematic
      // breaks, and setex heading underlines though:
      // <https://github.com/syntax-tree/mdast-util-to-markdown/blob/51a2038/lib/unsafe.js#L57>
      { atBreak: !0, character: "-", after: "[:|-]" }
    ],
    handlers: {
      inlineCode: m,
      table: i,
      tableCell: l,
      tableRow: o
    }
  };
  function i(h, b, I, y) {
    return c(d(h, I, y), h.align);
  }
  function o(h, b, I, y) {
    const C = f(h, I, y), w = c([C]);
    return w.slice(0, w.indexOf(`
`));
  }
  function l(h, b, I, y) {
    const C = I.enter("tableCell"), w = I.enter("phrasing"), O = I.containerPhrasing(h, {
      ...y,
      before: a,
      after: a
    });
    return w(), C(), O;
  }
  function c(h, b) {
    return n1(h, {
      align: b,
      // @ts-expect-error: `markdown-table` types should support `null`.
      alignDelimiters: r,
      // @ts-expect-error: `markdown-table` types should support `null`.
      padding: n,
      // @ts-expect-error: `markdown-table` types should support `null`.
      stringLength: u
    });
  }
  function d(h, b, I) {
    const y = h.children;
    let C = -1;
    const w = [], O = b.enter("table");
    for (; ++C < y.length; )
      w[C] = f(y[C], b, I);
    return O(), w;
  }
  function f(h, b, I) {
    const y = h.children;
    let C = -1;
    const w = [], O = b.enter("tableRow");
    for (; ++C < y.length; )
      w[C] = l(y[C], h, b, I);
    return O(), w;
  }
  function m(h, b, I) {
    let y = ys.inlineCode(h, b, I);
    return I.stack.includes("tableCell") && (y = y.replace(/\|/g, "\\$&")), y;
  }
}
function q1() {
  return {
    exit: {
      taskListCheckValueChecked: _i,
      taskListCheckValueUnchecked: _i,
      paragraph: V1
    }
  };
}
function Y1() {
  return {
    unsafe: [{ atBreak: !0, character: "-", after: "[:|-]" }],
    handlers: { listItem: W1 }
  };
}
function _i(e) {
  const t = this.stack[this.stack.length - 2];
  Ve(t.type === "listItem"), t.checked = e.type === "taskListCheckValueChecked";
}
function V1(e) {
  const t = this.stack[this.stack.length - 2];
  if (t && t.type === "listItem" && typeof t.checked == "boolean") {
    const n = this.stack[this.stack.length - 1];
    Ve(n.type === "paragraph");
    const r = n.children[0];
    if (r && r.type === "text") {
      const u = t.children;
      let a = -1, i;
      for (; ++a < u.length; ) {
        const o = u[a];
        if (o.type === "paragraph") {
          i = o;
          break;
        }
      }
      i === n && (r.value = r.value.slice(1), r.value.length === 0 ? n.children.shift() : n.position && r.position && typeof r.position.start.offset == "number" && (r.position.start.column++, r.position.start.offset++, n.position.start = Object.assign({}, r.position.start)));
    }
  }
  this.exit(e);
}
function W1(e, t, n, r) {
  const u = e.children[0], a = typeof e.checked == "boolean" && u && u.type === "paragraph", i = "[" + (e.checked ? "x" : " ") + "] ", o = n.createTracker(r);
  a && o.move(i);
  let l = ys.listItem(e, t, n, {
    ...r,
    ...o.current()
  });
  return a && (l = l.replace(/^(?:[*+-]|\d+\.)([\r\n]| {1,3})/, c)), l;
  function c(d) {
    return d + i;
  }
}
function Q1() {
  return [
    Sp(),
    Wp(),
    Kp(),
    B1(),
    q1()
  ];
}
function G1(e) {
  return {
    extensions: [
      Np(),
      Qp(e),
      Xp(),
      z1(e),
      Y1()
    ]
  };
}
function In(e, t, n, r) {
  const u = e.length;
  let a = 0, i;
  if (t < 0 ? t = -t > u ? 0 : u + t : t = t > u ? u : t, n = n > 0 ? n : 0, r.length < 1e4)
    i = Array.from(r), i.unshift(t, n), e.splice(...i);
  else
    for (n && e.splice(t, n); a < r.length; )
      i = r.slice(a, a + 1e4), i.unshift(t, 0), e.splice(...i), a += 1e4, t += 1e4;
}
const xi = {}.hasOwnProperty;
function $1(e) {
  const t = {};
  let n = -1;
  for (; ++n < e.length; )
    K1(t, e[n]);
  return t;
}
function K1(e, t) {
  let n;
  for (n in t) {
    const u = (xi.call(e, n) ? e[n] : void 0) || (e[n] = {}), a = t[n];
    let i;
    if (a)
      for (i in a) {
        xi.call(u, i) || (u[i] = []);
        const o = a[i];
        X1(
          // @ts-expect-error Looks like a list.
          u[i],
          Array.isArray(o) ? o : o ? [o] : []
        );
      }
  }
}
function X1(e, t) {
  let n = -1;
  const r = [];
  for (; ++n < t.length; )
    (t[n].add === "after" ? e : r).push(t[n]);
  In(e, 0, 0, r);
}
const Z1 = {
  tokenize: uE,
  partial: !0
}, Os = {
  tokenize: iE,
  partial: !0
}, Ls = {
  tokenize: aE,
  partial: !0
}, Rs = {
  tokenize: sE,
  partial: !0
}, J1 = {
  tokenize: oE,
  partial: !0
}, Ds = {
  name: "wwwAutolink",
  tokenize: nE,
  previous: ws
}, Ps = {
  name: "protocolAutolink",
  tokenize: rE,
  previous: Ms
}, We = {
  name: "emailAutolink",
  tokenize: tE,
  previous: Bs
}, He = {};
function eE() {
  return {
    text: He
  };
}
let st = 48;
for (; st < 123; )
  He[st] = We, st++, st === 58 ? st = 65 : st === 91 && (st = 97);
He[43] = We;
He[45] = We;
He[46] = We;
He[95] = We;
He[72] = [We, Ps];
He[104] = [We, Ps];
He[87] = [We, Ds];
He[119] = [We, Ds];
function tE(e, t, n) {
  const r = this;
  let u, a;
  return i;
  function i(f) {
    return !Rr(f) || !Bs.call(r, r.previous) || lu(r.events) ? n(f) : (e.enter("literalAutolink"), e.enter("literalAutolinkEmail"), o(f));
  }
  function o(f) {
    return Rr(f) ? (e.consume(f), o) : f === 64 ? (e.consume(f), l) : n(f);
  }
  function l(f) {
    return f === 46 ? e.check(J1, d, c)(f) : f === 45 || f === 95 || me(f) ? (a = !0, e.consume(f), l) : d(f);
  }
  function c(f) {
    return e.consume(f), u = !0, l;
  }
  function d(f) {
    return a && u && Ee(r.previous) ? (e.exit("literalAutolinkEmail"), e.exit("literalAutolink"), t(f)) : n(f);
  }
}
function nE(e, t, n) {
  const r = this;
  return u;
  function u(i) {
    return i !== 87 && i !== 119 || !ws.call(r, r.previous) || lu(r.events) ? n(i) : (e.enter("literalAutolink"), e.enter("literalAutolinkWww"), e.check(Z1, e.attempt(Os, e.attempt(Ls, a), n), n)(i));
  }
  function a(i) {
    return e.exit("literalAutolinkWww"), e.exit("literalAutolink"), t(i);
  }
}
function rE(e, t, n) {
  const r = this;
  let u = "", a = !1;
  return i;
  function i(f) {
    return (f === 72 || f === 104) && Ms.call(r, r.previous) && !lu(r.events) ? (e.enter("literalAutolink"), e.enter("literalAutolinkHttp"), u += String.fromCodePoint(f), e.consume(f), o) : n(f);
  }
  function o(f) {
    if (Ee(f) && u.length < 5)
      return u += String.fromCodePoint(f), e.consume(f), o;
    if (f === 58) {
      const m = u.toLowerCase();
      if (m === "http" || m === "https")
        return e.consume(f), l;
    }
    return n(f);
  }
  function l(f) {
    return f === 47 ? (e.consume(f), a ? c : (a = !0, l)) : n(f);
  }
  function c(f) {
    return f === null || kn(f) || ne(f) || dt(f) || jn(f) ? n(f) : e.attempt(Os, e.attempt(Ls, d), n)(f);
  }
  function d(f) {
    return e.exit("literalAutolinkHttp"), e.exit("literalAutolink"), t(f);
  }
}
function uE(e, t, n) {
  let r = 0;
  return u;
  function u(i) {
    return (i === 87 || i === 119) && r < 3 ? (r++, e.consume(i), u) : i === 46 && r === 3 ? (e.consume(i), a) : n(i);
  }
  function a(i) {
    return i === null ? n(i) : t(i);
  }
}
function iE(e, t, n) {
  let r, u, a;
  return i;
  function i(c) {
    return c === 46 || c === 95 ? e.check(Rs, l, o)(c) : c === null || ne(c) || dt(c) || c !== 45 && jn(c) ? l(c) : (a = !0, e.consume(c), i);
  }
  function o(c) {
    return c === 95 ? r = !0 : (u = r, r = void 0), e.consume(c), i;
  }
  function l(c) {
    return u || r || !a ? n(c) : t(c);
  }
}
function aE(e, t) {
  let n = 0, r = 0;
  return u;
  function u(i) {
    return i === 40 ? (n++, e.consume(i), u) : i === 41 && r < n ? a(i) : i === 33 || i === 34 || i === 38 || i === 39 || i === 41 || i === 42 || i === 44 || i === 46 || i === 58 || i === 59 || i === 60 || i === 63 || i === 93 || i === 95 || i === 126 ? e.check(Rs, t, a)(i) : i === null || ne(i) || dt(i) ? t(i) : (e.consume(i), u);
  }
  function a(i) {
    return i === 41 && r++, e.consume(i), u;
  }
}
function sE(e, t, n) {
  return r;
  function r(o) {
    return o === 33 || o === 34 || o === 39 || o === 41 || o === 42 || o === 44 || o === 46 || o === 58 || o === 59 || o === 63 || o === 95 || o === 126 ? (e.consume(o), r) : o === 38 ? (e.consume(o), a) : o === 93 ? (e.consume(o), u) : (
      // `<` is an end.
      o === 60 || // So is whitespace.
      o === null || ne(o) || dt(o) ? t(o) : n(o)
    );
  }
  function u(o) {
    return o === null || o === 40 || o === 91 || ne(o) || dt(o) ? t(o) : r(o);
  }
  function a(o) {
    return Ee(o) ? i(o) : n(o);
  }
  function i(o) {
    return o === 59 ? (e.consume(o), r) : Ee(o) ? (e.consume(o), i) : n(o);
  }
}
function oE(e, t, n) {
  return r;
  function r(a) {
    return e.consume(a), u;
  }
  function u(a) {
    return me(a) ? n(a) : t(a);
  }
}
function ws(e) {
  return e === null || e === 40 || e === 42 || e === 95 || e === 91 || e === 93 || e === 126 || ne(e);
}
function Ms(e) {
  return !Ee(e);
}
function Bs(e) {
  return !(e === 47 || Rr(e));
}
function Rr(e) {
  return e === 43 || e === 45 || e === 46 || e === 95 || me(e);
}
function lu(e) {
  let t = e.length, n = !1;
  for (; t--; ) {
    const r = e[t][1];
    if ((r.type === "labelLink" || r.type === "labelImage") && !r._balanced) {
      n = !0;
      break;
    }
    if (r._gfmAutolinkLiteralWalkedInto) {
      n = !1;
      break;
    }
  }
  return e.length > 0 && !n && (e[e.length - 1][1]._gfmAutolinkLiteralWalkedInto = !0), n;
}
function lE(e, t, n) {
  const r = [];
  let u = -1;
  for (; ++u < e.length; ) {
    const a = e[u].resolveAll;
    a && !r.includes(a) && (t = a(t, n), r.push(a));
  }
  return t;
}
const cE = {
  partial: !0,
  tokenize: fE
};
function fE(e, t, n) {
  return r;
  function r(a) {
    return W(a) ? K(e, u, "linePrefix")(a) : u(a);
  }
  function u(a) {
    return a === null || j(a) ? t(a) : n(a);
  }
}
const dE = {
  tokenize: AE,
  partial: !0
};
function hE() {
  return {
    document: {
      91: {
        name: "gfmFootnoteDefinition",
        tokenize: gE,
        continuation: {
          tokenize: TE
        },
        exit: bE
      }
    },
    text: {
      91: {
        name: "gfmFootnoteCall",
        tokenize: EE
      },
      93: {
        name: "gfmPotentialFootnoteCall",
        add: "after",
        tokenize: mE,
        resolveTo: pE
      }
    }
  };
}
function mE(e, t, n) {
  const r = this;
  let u = r.events.length;
  const a = r.parser.gfmFootnotes || (r.parser.gfmFootnotes = []);
  let i;
  for (; u--; ) {
    const l = r.events[u][1];
    if (l.type === "labelImage") {
      i = l;
      break;
    }
    if (l.type === "gfmFootnoteCall" || l.type === "labelLink" || l.type === "label" || l.type === "image" || l.type === "link")
      break;
  }
  return o;
  function o(l) {
    if (!i || !i._balanced)
      return n(l);
    const c = ln(r.sliceSerialize({
      start: i.end,
      end: r.now()
    }));
    return c.codePointAt(0) !== 94 || !a.includes(c.slice(1)) ? n(l) : (e.enter("gfmFootnoteCallLabelMarker"), e.consume(l), e.exit("gfmFootnoteCallLabelMarker"), t(l));
  }
}
function pE(e, t) {
  let n = e.length;
  for (; n--; )
    if (e[n][1].type === "labelImage" && e[n][0] === "enter") {
      e[n][1];
      break;
    }
  e[n + 1][1].type = "data", e[n + 3][1].type = "gfmFootnoteCallLabelMarker";
  const r = {
    type: "gfmFootnoteCall",
    start: Object.assign({}, e[n + 3][1].start),
    end: Object.assign({}, e[e.length - 1][1].end)
  }, u = {
    type: "gfmFootnoteCallMarker",
    start: Object.assign({}, e[n + 3][1].end),
    end: Object.assign({}, e[n + 3][1].end)
  };
  u.end.column++, u.end.offset++, u.end._bufferIndex++;
  const a = {
    type: "gfmFootnoteCallString",
    start: Object.assign({}, u.end),
    end: Object.assign({}, e[e.length - 1][1].start)
  }, i = {
    type: "chunkString",
    contentType: "string",
    start: Object.assign({}, a.start),
    end: Object.assign({}, a.end)
  }, o = [
    // Take the `labelImageMarker` (now `data`, the `!`)
    e[n + 1],
    e[n + 2],
    ["enter", r, t],
    // The `[`
    e[n + 3],
    e[n + 4],
    // The `^`.
    ["enter", u, t],
    ["exit", u, t],
    // Everything in between.
    ["enter", a, t],
    ["enter", i, t],
    ["exit", i, t],
    ["exit", a, t],
    // The ending (`]`, properly parsed and labelled).
    e[e.length - 2],
    e[e.length - 1],
    ["exit", r, t]
  ];
  return e.splice(n, e.length - n + 1, ...o), e;
}
function EE(e, t, n) {
  const r = this, u = r.parser.gfmFootnotes || (r.parser.gfmFootnotes = []);
  let a = 0, i;
  return o;
  function o(f) {
    return e.enter("gfmFootnoteCall"), e.enter("gfmFootnoteCallLabelMarker"), e.consume(f), e.exit("gfmFootnoteCallLabelMarker"), l;
  }
  function l(f) {
    return f !== 94 ? n(f) : (e.enter("gfmFootnoteCallMarker"), e.consume(f), e.exit("gfmFootnoteCallMarker"), e.enter("gfmFootnoteCallString"), e.enter("chunkString").contentType = "string", c);
  }
  function c(f) {
    if (
      // Too long.
      a > 999 || // Closing brace with nothing.
      f === 93 && !i || // Space or tab is not supported by GFM for some reason.
      // `\n` and `[` not being supported makes sense.
      f === null || f === 91 || ne(f)
    )
      return n(f);
    if (f === 93) {
      e.exit("chunkString");
      const m = e.exit("gfmFootnoteCallString");
      return u.includes(ln(r.sliceSerialize(m))) ? (e.enter("gfmFootnoteCallLabelMarker"), e.consume(f), e.exit("gfmFootnoteCallLabelMarker"), e.exit("gfmFootnoteCall"), t) : n(f);
    }
    return ne(f) || (i = !0), a++, e.consume(f), f === 92 ? d : c;
  }
  function d(f) {
    return f === 91 || f === 92 || f === 93 ? (e.consume(f), a++, c) : c(f);
  }
}
function gE(e, t, n) {
  const r = this, u = r.parser.gfmFootnotes || (r.parser.gfmFootnotes = []);
  let a, i = 0, o;
  return l;
  function l(b) {
    return e.enter("gfmFootnoteDefinition")._container = !0, e.enter("gfmFootnoteDefinitionLabel"), e.enter("gfmFootnoteDefinitionLabelMarker"), e.consume(b), e.exit("gfmFootnoteDefinitionLabelMarker"), c;
  }
  function c(b) {
    return b === 94 ? (e.enter("gfmFootnoteDefinitionMarker"), e.consume(b), e.exit("gfmFootnoteDefinitionMarker"), e.enter("gfmFootnoteDefinitionLabelString"), e.enter("chunkString").contentType = "string", d) : n(b);
  }
  function d(b) {
    if (
      // Too long.
      i > 999 || // Closing brace with nothing.
      b === 93 && !o || // Space or tab is not supported by GFM for some reason.
      // `\n` and `[` not being supported makes sense.
      b === null || b === 91 || ne(b)
    )
      return n(b);
    if (b === 93) {
      e.exit("chunkString");
      const I = e.exit("gfmFootnoteDefinitionLabelString");
      return a = ln(r.sliceSerialize(I)), e.enter("gfmFootnoteDefinitionLabelMarker"), e.consume(b), e.exit("gfmFootnoteDefinitionLabelMarker"), e.exit("gfmFootnoteDefinitionLabel"), m;
    }
    return ne(b) || (o = !0), i++, e.consume(b), b === 92 ? f : d;
  }
  function f(b) {
    return b === 91 || b === 92 || b === 93 ? (e.consume(b), i++, d) : d(b);
  }
  function m(b) {
    return b === 58 ? (e.enter("definitionMarker"), e.consume(b), e.exit("definitionMarker"), u.includes(a) || u.push(a), K(e, h, "gfmFootnoteDefinitionWhitespace")) : n(b);
  }
  function h(b) {
    return t(b);
  }
}
function TE(e, t, n) {
  return e.check(cE, t, e.attempt(dE, t, n));
}
function bE(e) {
  e.exit("gfmFootnoteDefinition");
}
function AE(e, t, n) {
  const r = this;
  return K(e, u, "gfmFootnoteDefinitionIndent", 5);
  function u(a) {
    const i = r.events[r.events.length - 1];
    return i && i[1].type === "gfmFootnoteDefinitionIndent" && i[2].sliceSerialize(i[1], !0).length === 4 ? t(a) : n(a);
  }
}
function _E(e) {
  let n = (e || {}).singleTilde;
  const r = {
    name: "strikethrough",
    tokenize: a,
    resolveAll: u
  };
  return n == null && (n = !0), {
    text: {
      126: r
    },
    insideSpan: {
      null: [r]
    },
    attentionMarkers: {
      null: [126]
    }
  };
  function u(i, o) {
    let l = -1;
    for (; ++l < i.length; )
      if (i[l][0] === "enter" && i[l][1].type === "strikethroughSequenceTemporary" && i[l][1]._close) {
        let c = l;
        for (; c--; )
          if (i[c][0] === "exit" && i[c][1].type === "strikethroughSequenceTemporary" && i[c][1]._open && // If the sizes are the same:
          i[l][1].end.offset - i[l][1].start.offset === i[c][1].end.offset - i[c][1].start.offset) {
            i[l][1].type = "strikethroughSequence", i[c][1].type = "strikethroughSequence";
            const d = {
              type: "strikethrough",
              start: Object.assign({}, i[c][1].start),
              end: Object.assign({}, i[l][1].end)
            }, f = {
              type: "strikethroughText",
              start: Object.assign({}, i[c][1].end),
              end: Object.assign({}, i[l][1].start)
            }, m = [["enter", d, o], ["enter", i[c][1], o], ["exit", i[c][1], o], ["enter", f, o]], h = o.parser.constructs.insideSpan.null;
            h && In(m, m.length, 0, lE(h, i.slice(c + 1, l), o)), In(m, m.length, 0, [["exit", f, o], ["enter", i[l][1], o], ["exit", i[l][1], o], ["exit", d, o]]), In(i, c - 1, l - c + 3, m), l = c + m.length - 2;
            break;
          }
      }
    for (l = -1; ++l < i.length; )
      i[l][1].type === "strikethroughSequenceTemporary" && (i[l][1].type = "data");
    return i;
  }
  function a(i, o, l) {
    const c = this.previous, d = this.events;
    let f = 0;
    return m;
    function m(b) {
      return c === 126 && d[d.length - 1][1].type !== "characterEscape" ? l(b) : (i.enter("strikethroughSequenceTemporary"), h(b));
    }
    function h(b) {
      const I = St(c);
      if (b === 126)
        return f > 1 ? l(b) : (i.consume(b), f++, h);
      if (f < 2 && !n) return l(b);
      const y = i.exit("strikethroughSequenceTemporary"), C = St(b);
      return y._open = !C || C === 2 && !!I, y._close = !I || I === 2 && !!C, o(b);
    }
  }
}
class xE {
  /**
   * Create a new edit map.
   */
  constructor() {
    this.map = [];
  }
  /**
   * Create an edit: a remove and/or add at a certain place.
   *
   * @param {number} index
   * @param {number} remove
   * @param {Array<Event>} add
   * @returns {undefined}
   */
  add(t, n, r) {
    CE(this, t, n, r);
  }
  // To do: add this when moving to `micromark`.
  // /**
  //  * Create an edit: but insert `add` before existing additions.
  //  *
  //  * @param {number} index
  //  * @param {number} remove
  //  * @param {Array<Event>} add
  //  * @returns {undefined}
  //  */
  // addBefore(index, remove, add) {
  //   addImplementation(this, index, remove, add, true)
  // }
  /**
   * Done, change the events.
   *
   * @param {Array<Event>} events
   * @returns {undefined}
   */
  consume(t) {
    if (this.map.sort(function(a, i) {
      return a[0] - i[0];
    }), this.map.length === 0)
      return;
    let n = this.map.length;
    const r = [];
    for (; n > 0; )
      n -= 1, r.push(t.slice(this.map[n][0] + this.map[n][1]), this.map[n][2]), t.length = this.map[n][0];
    r.push(t.slice()), t.length = 0;
    let u = r.pop();
    for (; u; ) {
      for (const a of u)
        t.push(a);
      u = r.pop();
    }
    this.map.length = 0;
  }
}
function CE(e, t, n, r) {
  let u = 0;
  if (!(n === 0 && r.length === 0)) {
    for (; u < e.map.length; ) {
      if (e.map[u][0] === t) {
        e.map[u][1] += n, e.map[u][2].push(...r);
        return;
      }
      u += 1;
    }
    e.map.push([t, n, r]);
  }
}
function IE(e, t) {
  let n = !1;
  const r = [];
  for (; t < e.length; ) {
    const u = e[t];
    if (n) {
      if (u[0] === "enter")
        u[1].type === "tableContent" && r.push(e[t + 1][1].type === "tableDelimiterMarker" ? "left" : "none");
      else if (u[1].type === "tableContent") {
        if (e[t - 1][1].type === "tableDelimiterMarker") {
          const a = r.length - 1;
          r[a] = r[a] === "left" ? "center" : "right";
        }
      } else if (u[1].type === "tableDelimiterRow")
        break;
    } else u[0] === "enter" && u[1].type === "tableDelimiterRow" && (n = !0);
    t += 1;
  }
  return r;
}
function SE() {
  return {
    flow: {
      null: {
        name: "table",
        tokenize: NE,
        resolveAll: kE
      }
    }
  };
}
function NE(e, t, n) {
  const r = this;
  let u = 0, a = 0, i;
  return o;
  function o(S) {
    let H = r.events.length - 1;
    for (; H > -1; ) {
      const ue = r.events[H][1].type;
      if (ue === "lineEnding" || // Note: markdown-rs uses `whitespace` instead of `linePrefix`
      ue === "linePrefix") H--;
      else break;
    }
    const F = H > -1 ? r.events[H][1].type : null, ee = F === "tableHead" || F === "tableRow" ? N : l;
    return ee === N && r.parser.lazy[r.now().line] ? n(S) : ee(S);
  }
  function l(S) {
    return e.enter("tableHead"), e.enter("tableRow"), c(S);
  }
  function c(S) {
    return S === 124 || (i = !0, a += 1), d(S);
  }
  function d(S) {
    return S === null ? n(S) : j(S) ? a > 1 ? (a = 0, r.interrupt = !0, e.exit("tableRow"), e.enter("lineEnding"), e.consume(S), e.exit("lineEnding"), h) : n(S) : W(S) ? K(e, d, "whitespace")(S) : (a += 1, i && (i = !1, u += 1), S === 124 ? (e.enter("tableCellDivider"), e.consume(S), e.exit("tableCellDivider"), i = !0, d) : (e.enter("data"), f(S)));
  }
  function f(S) {
    return S === null || S === 124 || ne(S) ? (e.exit("data"), d(S)) : (e.consume(S), S === 92 ? m : f);
  }
  function m(S) {
    return S === 92 || S === 124 ? (e.consume(S), f) : f(S);
  }
  function h(S) {
    return r.interrupt = !1, r.parser.lazy[r.now().line] ? n(S) : (e.enter("tableDelimiterRow"), i = !1, W(S) ? K(e, b, "linePrefix", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(S) : b(S));
  }
  function b(S) {
    return S === 45 || S === 58 ? y(S) : S === 124 ? (i = !0, e.enter("tableCellDivider"), e.consume(S), e.exit("tableCellDivider"), I) : R(S);
  }
  function I(S) {
    return W(S) ? K(e, y, "whitespace")(S) : y(S);
  }
  function y(S) {
    return S === 58 ? (a += 1, i = !0, e.enter("tableDelimiterMarker"), e.consume(S), e.exit("tableDelimiterMarker"), C) : S === 45 ? (a += 1, C(S)) : S === null || j(S) ? v(S) : R(S);
  }
  function C(S) {
    return S === 45 ? (e.enter("tableDelimiterFiller"), w(S)) : R(S);
  }
  function w(S) {
    return S === 45 ? (e.consume(S), w) : S === 58 ? (i = !0, e.exit("tableDelimiterFiller"), e.enter("tableDelimiterMarker"), e.consume(S), e.exit("tableDelimiterMarker"), O) : (e.exit("tableDelimiterFiller"), O(S));
  }
  function O(S) {
    return W(S) ? K(e, v, "whitespace")(S) : v(S);
  }
  function v(S) {
    return S === 124 ? b(S) : S === null || j(S) ? !i || u !== a ? R(S) : (e.exit("tableDelimiterRow"), e.exit("tableHead"), t(S)) : R(S);
  }
  function R(S) {
    return n(S);
  }
  function N(S) {
    return e.enter("tableRow"), z(S);
  }
  function z(S) {
    return S === 124 ? (e.enter("tableCellDivider"), e.consume(S), e.exit("tableCellDivider"), z) : S === null || j(S) ? (e.exit("tableRow"), t(S)) : W(S) ? K(e, z, "whitespace")(S) : (e.enter("data"), X(S));
  }
  function X(S) {
    return S === null || S === 124 || ne(S) ? (e.exit("data"), z(S)) : (e.consume(S), S === 92 ? Q : X);
  }
  function Q(S) {
    return S === 92 || S === 124 ? (e.consume(S), X) : X(S);
  }
}
function kE(e, t) {
  let n = -1, r = !0, u = 0, a = [0, 0, 0, 0], i = [0, 0, 0, 0], o = !1, l = 0, c, d, f;
  const m = new xE();
  for (; ++n < e.length; ) {
    const h = e[n], b = h[1];
    h[0] === "enter" ? b.type === "tableHead" ? (o = !1, l !== 0 && (Ci(m, t, l, c, d), d = void 0, l = 0), c = {
      type: "table",
      start: Object.assign({}, b.start),
      // Note: correct end is set later.
      end: Object.assign({}, b.end)
    }, m.add(n, 0, [["enter", c, t]])) : b.type === "tableRow" || b.type === "tableDelimiterRow" ? (r = !0, f = void 0, a = [0, 0, 0, 0], i = [0, n + 1, 0, 0], o && (o = !1, d = {
      type: "tableBody",
      start: Object.assign({}, b.start),
      // Note: correct end is set later.
      end: Object.assign({}, b.end)
    }, m.add(n, 0, [["enter", d, t]])), u = b.type === "tableDelimiterRow" ? 2 : d ? 3 : 1) : u && (b.type === "data" || b.type === "tableDelimiterMarker" || b.type === "tableDelimiterFiller") ? (r = !1, i[2] === 0 && (a[1] !== 0 && (i[0] = i[1], f = pn(m, t, a, u, void 0, f), a = [0, 0, 0, 0]), i[2] = n)) : b.type === "tableCellDivider" && (r ? r = !1 : (a[1] !== 0 && (i[0] = i[1], f = pn(m, t, a, u, void 0, f)), a = i, i = [a[1], n, 0, 0])) : b.type === "tableHead" ? (o = !0, l = n) : b.type === "tableRow" || b.type === "tableDelimiterRow" ? (l = n, a[1] !== 0 ? (i[0] = i[1], f = pn(m, t, a, u, n, f)) : i[1] !== 0 && (f = pn(m, t, i, u, n, f)), u = 0) : u && (b.type === "data" || b.type === "tableDelimiterMarker" || b.type === "tableDelimiterFiller") && (i[3] = n);
  }
  for (l !== 0 && Ci(m, t, l, c, d), m.consume(t.events), n = -1; ++n < t.events.length; ) {
    const h = t.events[n];
    h[0] === "enter" && h[1].type === "table" && (h[1]._align = IE(t.events, n));
  }
  return e;
}
function pn(e, t, n, r, u, a) {
  const i = r === 1 ? "tableHeader" : r === 2 ? "tableDelimiter" : "tableData", o = "tableContent";
  n[0] !== 0 && (a.end = Object.assign({}, bt(t.events, n[0])), e.add(n[0], 0, [["exit", a, t]]));
  const l = bt(t.events, n[1]);
  if (a = {
    type: i,
    start: Object.assign({}, l),
    // Note: correct end is set later.
    end: Object.assign({}, l)
  }, e.add(n[1], 0, [["enter", a, t]]), n[2] !== 0) {
    const c = bt(t.events, n[2]), d = bt(t.events, n[3]), f = {
      type: o,
      start: Object.assign({}, c),
      end: Object.assign({}, d)
    };
    if (e.add(n[2], 0, [["enter", f, t]]), r !== 2) {
      const m = t.events[n[2]], h = t.events[n[3]];
      if (m[1].end = Object.assign({}, h[1].end), m[1].type = "chunkText", m[1].contentType = "text", n[3] > n[2] + 1) {
        const b = n[2] + 1, I = n[3] - n[2] - 1;
        e.add(b, I, []);
      }
    }
    e.add(n[3] + 1, 0, [["exit", f, t]]);
  }
  return u !== void 0 && (a.end = Object.assign({}, bt(t.events, u)), e.add(u, 0, [["exit", a, t]]), a = void 0), a;
}
function Ci(e, t, n, r, u) {
  const a = [], i = bt(t.events, n);
  u && (u.end = Object.assign({}, i), a.push(["exit", u, t])), r.end = Object.assign({}, i), a.push(["exit", r, t]), e.add(n + 1, 0, a);
}
function bt(e, t) {
  const n = e[t], r = n[0] === "enter" ? "start" : "end";
  return n[1][r];
}
const yE = {
  name: "tasklistCheck",
  tokenize: LE
};
function OE() {
  return {
    text: {
      91: yE
    }
  };
}
function LE(e, t, n) {
  const r = this;
  return u;
  function u(l) {
    return (
      // Exit if there’s stuff before.
      r.previous !== null || // Exit if not in the first content that is the first child of a list
      // item.
      !r._gfmTasklistFirstContentOfListItem ? n(l) : (e.enter("taskListCheck"), e.enter("taskListCheckMarker"), e.consume(l), e.exit("taskListCheckMarker"), a)
    );
  }
  function a(l) {
    return ne(l) ? (e.enter("taskListCheckValueUnchecked"), e.consume(l), e.exit("taskListCheckValueUnchecked"), i) : l === 88 || l === 120 ? (e.enter("taskListCheckValueChecked"), e.consume(l), e.exit("taskListCheckValueChecked"), i) : n(l);
  }
  function i(l) {
    return l === 93 ? (e.enter("taskListCheckMarker"), e.consume(l), e.exit("taskListCheckMarker"), e.exit("taskListCheck"), o) : n(l);
  }
  function o(l) {
    return j(l) ? t(l) : W(l) ? e.check({
      tokenize: RE
    }, t, n)(l) : n(l);
  }
}
function RE(e, t, n) {
  return K(e, r, "whitespace");
  function r(u) {
    return u === null ? n(u) : t(u);
  }
}
function DE(e) {
  return $1([
    eE(),
    hE(),
    _E(e),
    SE(),
    OE()
  ]);
}
const PE = {};
function wE(e) {
  const t = (
    /** @type {Processor<Root>} */
    this
  ), n = e || PE, r = t.data(), u = r.micromarkExtensions || (r.micromarkExtensions = []), a = r.fromMarkdownExtensions || (r.fromMarkdownExtensions = []), i = r.toMarkdownExtensions || (r.toMarkdownExtensions = []);
  u.push(DE(n)), a.push(Q1()), i.push(G1(n));
}
function cu({
  className: e,
  orientation: t = "horizontal",
  decorative: n = !0,
  ...r
}) {
  return /* @__PURE__ */ g.jsx(
    El.Root,
    {
      "data-slot": "separator",
      decorative: n,
      orientation: t,
      className: ie(
        "bg-border shrink-0 data-[orientation=horizontal]:h-px data-[orientation=horizontal]:w-full data-[orientation=vertical]:h-full data-[orientation=vertical]:w-px",
        e
      ),
      ...r
    }
  );
}
function ME({
  delayDuration: e = 0,
  ...t
}) {
  return /* @__PURE__ */ g.jsx(
    xt.Provider,
    {
      "data-slot": "tooltip-provider",
      delayDuration: e,
      ...t
    }
  );
}
function BE({
  ...e
}) {
  return /* @__PURE__ */ g.jsx(ME, { children: /* @__PURE__ */ g.jsx(xt.Root, { "data-slot": "tooltip", ...e }) });
}
function FE({
  ...e
}) {
  return /* @__PURE__ */ g.jsx(xt.Trigger, { "data-slot": "tooltip-trigger", ...e });
}
function vE({
  className: e,
  sideOffset: t = 0,
  children: n,
  ...r
}) {
  return /* @__PURE__ */ g.jsx(xt.Portal, { children: /* @__PURE__ */ g.jsxs(
    xt.Content,
    {
      "data-slot": "tooltip-content",
      sideOffset: t,
      className: xl(
        "bg-foreground text-background animate-in fade-in-0 zoom-in-95 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 w-fit origin-(--radix-tooltip-content-transform-origin) rounded-md px-3 py-1.5 text-xs text-balance",
        e
      ),
      ...r,
      children: [
        n,
        /* @__PURE__ */ g.jsx(xt.Arrow, { className: "bg-foreground fill-foreground z-50 size-2.5 translate-y-[calc(-50%-2px)] rotate-45 rounded-[2px]" })
      ]
    }
  ) });
}
const HE = {
  green: "bg-green-400 dark:bg-green-800",
  blue: "bg-sky-400 dark:bg-sky-800",
  yellow: "bg-yellow-400 dark:bg-yellow-800",
  red: "bg-red-400 dark:bg-red-800",
  purple: "bg-purple-400 dark:bg-purple-600",
  indigo: "bg-indigo-400 dark:bg-indigo-600",
  gray: "bg-gray-400 dark:bg-gray-600",
  outline: "border border-border rounded-md text-foreground"
}, UE = {
  green: "text-green-500 dark:text-green-600",
  blue: "text-sky-400 dark:text-sky-600",
  yellow: "text-yellow-400 dark:text-yellow-600",
  red: "text-red-400 dark:text-red-600",
  purple: "text-purple-400 dark:text-purple-600",
  indigo: "text-indigo-400 dark:text-indigo-600",
  gray: "text-gray-400 dark:text-gray-600",
  outline: ""
}, Ii = ({
  color: e,
  label: t,
  className: n,
  invert: r
}) => /* @__PURE__ */ g.jsx(
  "span",
  {
    className: ie(
      "flex items-center duration-200 transition-opacity text-center uppercase text-[0.65rem] leading-5 font-bold rounded-sm text-background dark:text-zinc-50 h-full",
      e === "outline" ? "px-3" : "mt-0.5 px-1",
      r ? UE[e] : HE[e],
      n
    ),
    children: t
  }
);
var jE = Object.getOwnPropertyNames, zE = Object.getOwnPropertySymbols, qE = Object.prototype.hasOwnProperty;
function Si(e, t) {
  return function(r, u, a) {
    return e(r, u, a) && t(r, u, a);
  };
}
function En(e) {
  return function(n, r, u) {
    if (!n || !r || typeof n != "object" || typeof r != "object")
      return e(n, r, u);
    var a = u.cache, i = a.get(n), o = a.get(r);
    if (i && o)
      return i === r && o === n;
    a.set(n, r), a.set(r, n);
    var l = e(n, r, u);
    return a.delete(n), a.delete(r), l;
  };
}
function Ni(e) {
  return jE(e).concat(zE(e));
}
var YE = Object.hasOwn || (function(e, t) {
  return qE.call(e, t);
});
function pt(e, t) {
  return e === t || !e && !t && e !== e && t !== t;
}
var VE = "__v", WE = "__o", QE = "_owner", ki = Object.getOwnPropertyDescriptor, yi = Object.keys;
function GE(e, t, n) {
  var r = e.length;
  if (t.length !== r)
    return !1;
  for (; r-- > 0; )
    if (!n.equals(e[r], t[r], r, r, e, t, n))
      return !1;
  return !0;
}
function $E(e, t) {
  return pt(e.getTime(), t.getTime());
}
function KE(e, t) {
  return e.name === t.name && e.message === t.message && e.cause === t.cause && e.stack === t.stack;
}
function XE(e, t) {
  return e === t;
}
function Oi(e, t, n) {
  var r = e.size;
  if (r !== t.size)
    return !1;
  if (!r)
    return !0;
  for (var u = new Array(r), a = e.entries(), i, o, l = 0; (i = a.next()) && !i.done; ) {
    for (var c = t.entries(), d = !1, f = 0; (o = c.next()) && !o.done; ) {
      if (u[f]) {
        f++;
        continue;
      }
      var m = i.value, h = o.value;
      if (n.equals(m[0], h[0], l, f, e, t, n) && n.equals(m[1], h[1], m[0], h[0], e, t, n)) {
        d = u[f] = !0;
        break;
      }
      f++;
    }
    if (!d)
      return !1;
    l++;
  }
  return !0;
}
var ZE = pt;
function JE(e, t, n) {
  var r = yi(e), u = r.length;
  if (yi(t).length !== u)
    return !1;
  for (; u-- > 0; )
    if (!Fs(e, t, n, r[u]))
      return !1;
  return !0;
}
function zt(e, t, n) {
  var r = Ni(e), u = r.length;
  if (Ni(t).length !== u)
    return !1;
  for (var a, i, o; u-- > 0; )
    if (a = r[u], !Fs(e, t, n, a) || (i = ki(e, a), o = ki(t, a), (i || o) && (!i || !o || i.configurable !== o.configurable || i.enumerable !== o.enumerable || i.writable !== o.writable)))
      return !1;
  return !0;
}
function eg(e, t) {
  return pt(e.valueOf(), t.valueOf());
}
function tg(e, t) {
  return e.source === t.source && e.flags === t.flags;
}
function Li(e, t, n) {
  var r = e.size;
  if (r !== t.size)
    return !1;
  if (!r)
    return !0;
  for (var u = new Array(r), a = e.values(), i, o; (i = a.next()) && !i.done; ) {
    for (var l = t.values(), c = !1, d = 0; (o = l.next()) && !o.done; ) {
      if (!u[d] && n.equals(i.value, o.value, i.value, o.value, e, t, n)) {
        c = u[d] = !0;
        break;
      }
      d++;
    }
    if (!c)
      return !1;
  }
  return !0;
}
function ng(e, t) {
  var n = e.length;
  if (t.length !== n)
    return !1;
  for (; n-- > 0; )
    if (e[n] !== t[n])
      return !1;
  return !0;
}
function rg(e, t) {
  return e.hostname === t.hostname && e.pathname === t.pathname && e.protocol === t.protocol && e.port === t.port && e.hash === t.hash && e.username === t.username && e.password === t.password;
}
function Fs(e, t, n, r) {
  return (r === QE || r === WE || r === VE) && (e.$$typeof || t.$$typeof) ? !0 : YE(t, r) && n.equals(e[r], t[r], r, r, e, t, n);
}
var ug = "[object Arguments]", ig = "[object Boolean]", ag = "[object Date]", sg = "[object Error]", og = "[object Map]", lg = "[object Number]", cg = "[object Object]", fg = "[object RegExp]", dg = "[object Set]", hg = "[object String]", mg = "[object URL]", pg = Array.isArray, Ri = typeof ArrayBuffer == "function" && ArrayBuffer.isView ? ArrayBuffer.isView : null, Di = Object.assign, Eg = Object.prototype.toString.call.bind(Object.prototype.toString);
function gg(e) {
  var t = e.areArraysEqual, n = e.areDatesEqual, r = e.areErrorsEqual, u = e.areFunctionsEqual, a = e.areMapsEqual, i = e.areNumbersEqual, o = e.areObjectsEqual, l = e.arePrimitiveWrappersEqual, c = e.areRegExpsEqual, d = e.areSetsEqual, f = e.areTypedArraysEqual, m = e.areUrlsEqual;
  return function(b, I, y) {
    if (b === I)
      return !0;
    if (b == null || I == null)
      return !1;
    var C = typeof b;
    if (C !== typeof I)
      return !1;
    if (C !== "object")
      return C === "number" ? i(b, I, y) : C === "function" ? u(b, I, y) : !1;
    var w = b.constructor;
    if (w !== I.constructor)
      return !1;
    if (w === Object)
      return o(b, I, y);
    if (pg(b))
      return t(b, I, y);
    if (Ri != null && Ri(b))
      return f(b, I, y);
    if (w === Date)
      return n(b, I, y);
    if (w === RegExp)
      return c(b, I, y);
    if (w === Map)
      return a(b, I, y);
    if (w === Set)
      return d(b, I, y);
    var O = Eg(b);
    return O === ag ? n(b, I, y) : O === fg ? c(b, I, y) : O === og ? a(b, I, y) : O === dg ? d(b, I, y) : O === cg ? typeof b.then != "function" && typeof I.then != "function" && o(b, I, y) : O === mg ? m(b, I, y) : O === sg ? r(b, I, y) : O === ug ? o(b, I, y) : O === ig || O === lg || O === hg ? l(b, I, y) : !1;
  };
}
function Tg(e) {
  var t = e.circular, n = e.createCustomConfig, r = e.strict, u = {
    areArraysEqual: r ? zt : GE,
    areDatesEqual: $E,
    areErrorsEqual: KE,
    areFunctionsEqual: XE,
    areMapsEqual: r ? Si(Oi, zt) : Oi,
    areNumbersEqual: ZE,
    areObjectsEqual: r ? zt : JE,
    arePrimitiveWrappersEqual: eg,
    areRegExpsEqual: tg,
    areSetsEqual: r ? Si(Li, zt) : Li,
    areTypedArraysEqual: r ? zt : ng,
    areUrlsEqual: rg
  };
  if (n && (u = Di({}, u, n(u))), t) {
    var a = En(u.areArraysEqual), i = En(u.areMapsEqual), o = En(u.areObjectsEqual), l = En(u.areSetsEqual);
    u = Di({}, u, {
      areArraysEqual: a,
      areMapsEqual: i,
      areObjectsEqual: o,
      areSetsEqual: l
    });
  }
  return u;
}
function bg(e) {
  return function(t, n, r, u, a, i, o) {
    return e(t, n, o);
  };
}
function Ag(e) {
  var t = e.circular, n = e.comparator, r = e.createState, u = e.equals, a = e.strict;
  if (r)
    return function(l, c) {
      var d = r(), f = d.cache, m = f === void 0 ? t ? /* @__PURE__ */ new WeakMap() : void 0 : f, h = d.meta;
      return n(l, c, {
        cache: m,
        equals: u,
        meta: h,
        strict: a
      });
    };
  if (t)
    return function(l, c) {
      return n(l, c, {
        cache: /* @__PURE__ */ new WeakMap(),
        equals: u,
        meta: void 0,
        strict: a
      });
    };
  var i = {
    cache: void 0,
    equals: u,
    meta: void 0,
    strict: a
  };
  return function(l, c) {
    return n(l, c, i);
  };
}
var vs = rt();
rt({ strict: !0 });
rt({ circular: !0 });
rt({
  circular: !0,
  strict: !0
});
rt({
  createInternalComparator: function() {
    return pt;
  }
});
rt({
  strict: !0,
  createInternalComparator: function() {
    return pt;
  }
});
rt({
  circular: !0,
  createInternalComparator: function() {
    return pt;
  }
});
rt({
  circular: !0,
  createInternalComparator: function() {
    return pt;
  },
  strict: !0
});
function rt(e) {
  e === void 0 && (e = {});
  var t = e.circular, n = t === void 0 ? !1 : t, r = e.createInternalComparator, u = e.createState, a = e.strict, i = a === void 0 ? !1 : a, o = Tg(e), l = gg(o), c = r ? r(l) : bg(l);
  return Ag({ circular: n, comparator: l, createState: u, equals: c, strict: i });
}
const Hs = nn({
  query: "",
  setQuery: () => {
  }
}), KT = ({ children: e }) => {
  const [t, n] = De("");
  return /* @__PURE__ */ g.jsx(Hs.Provider, { value: { query: t, setQuery: n }, children: e });
}, fu = () => Eo(Hs), _g = ({
  category: e,
  onRequestClose: t
}) => {
  const n = wo(e), [r, u] = De(!1), a = kt(), { query: i } = fu(), o = e.collapsible ?? !0, l = e.collapsed ?? !0, c = !!(!o || !l || n), [d, f] = De(c), m = _o(e.link?.path ?? "");
  ge(() => {
    n && f(!0);
  }, [n]), ge(() => {
    i.trim() && f(!0);
  }, [i]);
  const h = o && /* @__PURE__ */ g.jsx(
    Nn,
    {
      onClick: (y) => {
        y.preventDefault(), f((C) => !C), u(!0);
      },
      variant: "ghost",
      size: "icon",
      className: "size-6 hover:bg-[hsl(from_var(--accent)_h_s_calc(l+6*var(--dark)))]",
      children: /* @__PURE__ */ g.jsx(
        Xi,
        {
          size: 16,
          className: ie(
            r && "transition",
            "shrink-0 group-data-[state=open]:rotate-90 rtl:rotate-180"
          )
        }
      )
    }
  ), b = e.icon && /* @__PURE__ */ g.jsx(
    e.icon,
    {
      size: 16,
      className: ie("align-[-0.125em] ", m && "text-primary")
    }
  ), I = bn({
    className: [
      "group text-start font-medium",
      o || typeof e.link < "u" ? "cursor-pointer" : "cursor-default hover:bg-transparent"
    ]
  });
  return /* @__PURE__ */ g.jsxs(
    Xn.Root,
    {
      className: "flex flex-col",
      defaultOpen: c,
      open: d,
      onOpenChange: () => f(!0),
      children: [
        /* @__PURE__ */ g.jsx(Xn.Trigger, { className: "group", asChild: !0, disabled: !o, children: e.link?.type === "doc" ? /* @__PURE__ */ g.jsxs(
          vn,
          {
            to: {
              pathname: Je(e.link.path),
              search: a.search
            },
            className: I,
            onClick: () => {
              u(!0), m && !d && f(!0);
            },
            children: [
              b,
              /* @__PURE__ */ g.jsxs("div", { className: "flex items-center gap-2 justify-between w-full text-foreground/80 group-aria-[current='page']:text-primary", children: [
                /* @__PURE__ */ g.jsx("div", { className: "truncate", children: e.label }),
                h
              ] })
            ]
          }
        ) : (
          // biome-ignore lint/a11y/noStaticElementInteractions: This is only to track if the user has interacted
          /* @__PURE__ */ g.jsxs(
            "div",
            {
              onClick: () => u(!0),
              onKeyUp: (y) => {
                (y.key === "Enter" || y.key === " ") && u(!0);
              },
              className: I,
              children: [
                b,
                /* @__PURE__ */ g.jsxs("div", { className: "flex items-center justify-between w-full", children: [
                  /* @__PURE__ */ g.jsx("div", { className: "flex gap-2 truncate w-full", children: e.label }),
                  h
                ] })
              ]
            }
          )
        ) }),
        /* @__PURE__ */ g.jsx(
          Xn.Content,
          {
            className: ie(
              // CollapsibleContent class is used to animate and it should only be applied when the user has triggered the toggle
              r && "CollapsibleContent",
              e.items.length === 0 && "hidden",
              "ms-6 my-1"
            ),
            children: /* @__PURE__ */ g.jsx("ul", { className: "relative after:absolute after:-start-(--padding-nav-item) after:translate-x-[1.5px] after:top-0 after:bottom-0 after:w-px after:bg-border", children: e.items.map((y) => /* @__PURE__ */ g.jsx(
              Og,
              {
                onRequestClose: t,
                item: y
              },
              y.type + (y.label ?? "") + ("path" in y ? y.path : "") + ("file" in y ? y.file : "") + ("to" in y ? y.to : "")
            )) })
          }
        )
      ]
    }
  );
}, Us = Fn(_g, vs);
Us.displayName = "NavigationCategory";
function xg({ className: e, ...t }) {
  return /* @__PURE__ */ g.jsx(
    "div",
    {
      "data-slot": "input-group",
      role: "group",
      className: ie(
        "group/input-group border-input dark:bg-input/30 relative flex w-full items-center rounded-md border shadow-xs transition-[color,box-shadow] outline-none",
        "h-9 min-w-0 has-[>textarea]:h-auto",
        // Variants based on alignment.
        "has-[>[data-align=inline-start]]:[&>input]:pl-2",
        "has-[>[data-align=inline-end]]:[&>input]:pr-2",
        "has-[>[data-align=block-start]]:h-auto has-[>[data-align=block-start]]:flex-col has-[>[data-align=block-start]]:[&>input]:pb-3",
        "has-[>[data-align=block-end]]:h-auto has-[>[data-align=block-end]]:flex-col has-[>[data-align=block-end]]:[&>input]:pt-3",
        // Focus state.
        "has-[[data-slot=input-group-control]:focus-visible]:border-ring has-[[data-slot=input-group-control]:focus-visible]:ring-ring/50 has-[[data-slot=input-group-control]:focus-visible]:ring-[3px]",
        // Error state.
        "has-[[data-slot][aria-invalid=true]]:ring-destructive/20 has-[[data-slot][aria-invalid=true]]:border-destructive dark:has-[[data-slot][aria-invalid=true]]:ring-destructive/40",
        e
      ),
      ...t
    }
  );
}
const Cg = Un(
  "text-muted-foreground flex h-auto cursor-text items-center justify-center gap-2 py-1.5 text-sm font-medium select-none [&>svg:not([class*='size-'])]:size-4 [&>kbd]:rounded-[calc(var(--radius)-5px)] group-data-[disabled=true]/input-group:opacity-50",
  {
    variants: {
      align: {
        "inline-start": "order-first pl-3 has-[>button]:ml-[-0.45rem] has-[>kbd]:ml-[-0.35rem]",
        "inline-end": "order-last pr-3 has-[>button]:mr-[-0.45rem] has-[>kbd]:mr-[-0.35rem]",
        "block-start": "order-first w-full justify-start px-3 pt-3 [.border-b]:pb-3 group-has-[>input]/input-group:pt-2.5",
        "block-end": "order-last w-full justify-start px-3 pb-3 [.border-t]:pt-3 group-has-[>input]/input-group:pb-2.5"
      }
    },
    defaultVariants: {
      align: "inline-start"
    }
  }
);
function Ig({
  className: e,
  align: t = "inline-start",
  ...n
}) {
  return (
    // biome-ignore lint/a11y/useKeyWithClickEvents: Focus management
    /* @__PURE__ */ g.jsx(
      "div",
      {
        role: "group",
        "data-slot": "input-group-addon",
        "data-align": t,
        className: ie(Cg({ align: t }), e),
        onClick: (r) => {
          r.target.closest("button") || r.currentTarget.parentElement?.querySelector("input")?.focus();
        },
        ...n
      }
    )
  );
}
const Sg = Un(
  "text-sm shadow-none flex gap-2 items-center",
  {
    variants: {
      size: {
        xs: "h-6 gap-1 px-2 rounded-[calc(var(--radius)-5px)] [&>svg:not([class*='size-'])]:size-3.5 has-[>svg]:px-2",
        sm: "h-8 px-2.5 gap-1.5 rounded-md has-[>svg]:px-2.5",
        "icon-xs": "size-6 rounded-[calc(var(--radius)-5px)] p-0 has-[>svg]:p-0",
        "icon-sm": "size-8 p-0 has-[>svg]:p-0"
      }
    },
    defaultVariants: {
      size: "xs"
    }
  }
);
function Ng({
  className: e,
  type: t = "button",
  variant: n = "ghost",
  size: r = "xs",
  ...u
}) {
  return /* @__PURE__ */ g.jsx(
    Ki,
    {
      type: t,
      "data-size": r,
      variant: n,
      className: ie(Sg({ size: r }), e),
      ...u
    }
  );
}
function kg({
  className: e,
  ...t
}) {
  return /* @__PURE__ */ g.jsx(
    Cl,
    {
      "data-slot": "input-group-control",
      className: ie(
        "flex-1 rounded-none border-0 bg-transparent shadow-none focus-visible:ring-0 dark:bg-transparent",
        e
      ),
      ...t
    }
  );
}
const yg = ({
  placeholder: e
}) => {
  const { query: t, setQuery: n } = fu();
  return /* @__PURE__ */ g.jsxs(xg, { className: "my-2", children: [
    /* @__PURE__ */ g.jsx(Ig, { children: /* @__PURE__ */ g.jsx(Zi, { className: "size-3.5" }) }),
    /* @__PURE__ */ g.jsx(
      kg,
      {
        type: "text",
        placeholder: e,
        value: t,
        onChange: (r) => n(r.target.value)
      }
    ),
    t && /* @__PURE__ */ g.jsx(Ng, { onClick: () => n(""), children: /* @__PURE__ */ g.jsx(Zo, { className: "size-3" }) })
  ] });
}, Pi = ({
  label: e,
  className: t
}) => {
  const n = Se(null), [r, u] = De(!1);
  return ge(() => {
    n.current && n.current.offsetWidth < n.current.scrollWidth && u(!0);
  }, []), /* @__PURE__ */ g.jsxs(g.Fragment, { children: [
    /* @__PURE__ */ g.jsx(
      "span",
      {
        className: ie("truncate flex-1", t),
        title: e,
        ref: n,
        children: e
      }
    ),
    r && /* @__PURE__ */ g.jsxs(BE, { disableHoverableContent: !0, children: [
      /* @__PURE__ */ g.jsx(FE, { className: "absolute inset-0 z-10" }),
      /* @__PURE__ */ g.jsx(vE, { className: "max-w-64", side: "bottom", align: "center", children: e })
    ] })
  ] });
}, js = "data-anchor", Og = ({
  item: e,
  onRequestClose: t
}) => {
  const n = kt(), { activeAnchor: r } = Hr(), u = Xt(), a = et(), { query: i } = fu();
  if (!Fr(u, a, i)(e))
    return null;
  switch (e.type) {
    case "category":
      return /* @__PURE__ */ g.jsx(Us, { category: e, onRequestClose: t });
    case "separator":
      return /* @__PURE__ */ g.jsx(cu, { className: "my-1 mx-auto w-[calc(100%-var(--padding-nav-item)*2)]!" });
    case "section":
      return /* @__PURE__ */ g.jsx("div", { className: "mt-4 px-(--padding-nav-item) text-xs font-semibold text-muted-foreground uppercase tracking-wider", children: e.label });
    case "filter":
      return /* @__PURE__ */ g.jsx(yg, { placeholder: e.placeholder });
    case "doc":
      return /* @__PURE__ */ g.jsxs(
        vn,
        {
          viewTransition: !0,
          className: ({ isActive: o, isPending: l }) => bn({ isActive: o, isPending: l }),
          to: Je(e.path),
          onClick: t,
          end: !0,
          children: [
            e.icon && /* @__PURE__ */ g.jsx(e.icon, { size: 16, className: "align-[-0.125em] shrink-0" }),
            e.badge ? /* @__PURE__ */ g.jsxs(g.Fragment, { children: [
              e.label && /* @__PURE__ */ g.jsx(Pi, { label: e.label, className: "flex-1" }),
              /* @__PURE__ */ g.jsx(Ii, { ...e.badge })
            ] }) : e.label
          ]
        }
      );
    case "link":
    case "custom-page": {
      const o = e.type === "link" ? e.to : Je(e.path);
      return o.startsWith("http") ? /* @__PURE__ */ g.jsxs(
        "a",
        {
          className: bn(),
          href: o,
          target: "target" in e ? e.target : "_blank",
          rel: "noopener noreferrer",
          onClick: t,
          children: [
            e.icon && /* @__PURE__ */ g.jsx(e.icon, { size: 16, className: "align-[-0.125em] shrink-0" }),
            /* @__PURE__ */ g.jsx("span", { className: "whitespace-normal", children: e.label }),
            /* @__PURE__ */ g.jsx("span", { className: "whitespace-nowrap", children: /* @__PURE__ */ g.jsx(Jo, { className: "inline -translate-y-0.5", size: 12 }) })
          ]
        }
      ) : /* @__PURE__ */ g.jsxs(
        qs,
        {
          to: {
            pathname: o.split("#")[0],
            hash: o.split("#")[1],
            search: n.search
          },
          [js]: o.split("#")[1],
          className: bn({
            isActive: o === [n.pathname, r].filter(Boolean).join("#")
          }),
          onClick: t,
          children: [
            e.icon && /* @__PURE__ */ g.jsx(e.icon, { size: 16, className: "align-[-0.125em] shrink-0" }),
            e.badge ? /* @__PURE__ */ g.jsxs(g.Fragment, { children: [
              e.label && /* @__PURE__ */ g.jsx(Pi, { label: e.label }),
              /* @__PURE__ */ g.jsx(Ii, { ...e.badge })
            ] }) : /* @__PURE__ */ g.jsx("span", { className: "break-all", children: e.label })
          ]
        }
      );
    }
  }
}, Lg = (e, t = { block: "center" }) => {
  if (!e) return;
  const n = e.getBoundingClientRect();
  n.top >= 0 && n.left >= 0 && n.bottom <= (window.innerHeight || document.documentElement.clientHeight) && n.right <= (window.innerWidth || document.documentElement.clientWidth) || e.scrollIntoView(t);
}, zs = () => {
  const { setActiveAnchor: e } = Hr();
  return Fe(
    (n) => {
      const r = n.replace(/^#/, ""), u = r.split("/").at(0);
      if (!u) return !1;
      const a = document.getElementById(decodeURIComponent(r)), i = document.querySelector(
        `[${js}="${u}"]`
      );
      return a ? (a.scrollIntoView(), Lg(i), requestIdleCallback(() => e(u)), !0) : !1;
    },
    [e]
  );
}, XT = () => {
  const e = kt(), t = zs(), n = Se(!1);
  ge(() => {
    !e.hash || !n.current || t(e.hash);
  }, [e.hash, t]), ge(() => {
    if (!e.hash) {
      n.current = !0;
      return;
    }
    const r = new MutationObserver((u, a) => {
      t(e.hash) && (n.current = !0, a.disconnect());
    });
    return r.observe(document.body, { childList: !0, subtree: !0 }), () => r.disconnect();
  }, [e.hash, t]);
}, qs = (e) => {
  const t = kt(), n = zs(), r = xo(e.to), [u, a] = r.split("#"), i = (o) => {
    e.onClick?.(o), !(a !== t.hash.slice(1) || u !== t.pathname) && (o.preventDefault(), n(a));
  };
  return /* @__PURE__ */ g.jsx(vn, { ...e, onClick: i });
}, Rg = Un("", {
  variants: {
    size: {
      sm: "max-w-sm",
      md: "max-w-md",
      lg: "max-w-lg",
      xl: "max-w-xl",
      "2xl": "max-w-2xl",
      full: "max-w-full"
    },
    align: {
      center: "mx-auto",
      start: "me-auto",
      end: "ms-auto"
    }
  },
  defaultVariants: {
    size: "xl",
    align: "center"
  }
}), Dg = ({
  caption: e,
  className: t,
  size: n = "xl",
  align: r = "center",
  children: u
}) => /* @__PURE__ */ g.jsxs("figure", { className: ie(Rg({ size: n, align: r }), t), children: [
  /* @__PURE__ */ g.jsx("div", { className: "relative overflow-hidden rounded-lg border border-border bg-muted/50 p-1 shadow-sm", children: /* @__PURE__ */ g.jsx("div", { className: "not-prose rounded-md [&_img]:rounded-md! relative overflow-hidden bg-background", children: u }) }),
  e && /* @__PURE__ */ g.jsx("figcaption", { className: "mt-3 text-center text-sm text-muted-foreground", children: e })
] }), Pg = ({
  asChild: e,
  onClick: t,
  enabled: n = !0,
  ...r
}) => {
  const u = e ? Il : "span";
  return /* @__PURE__ */ g.jsx(
    u,
    {
      onClick: (a) => {
        if (n) {
          const i = document.createRange();
          i.selectNodeContents(a.currentTarget);
          const o = window.getSelection();
          o?.removeAllRanges(), o?.addRange(i);
        }
        t?.(a);
      },
      ...r
    }
  );
}, wg = ({
  className: e,
  children: t,
  selectOnClick: n,
  onClick: r
}) => /* @__PURE__ */ g.jsx(Pg, { asChild: !0, enabled: n, onClick: r, children: /* @__PURE__ */ g.jsx(
  "code",
  {
    className: ie(
      "font-mono border p-1 py-0.5 rounded-sm bg-border/50 dark:bg-border/70 [overflow-wrap:anywhere]",
      e
    ),
    children: t
  }
) }), Ys = {
  img: ({ node: e, ...t }) => /\.(mp4|webm|mov|avi)$/.test(t.src ?? "") ? (
    // biome-ignore lint/a11y/useMediaCaption: No in control of the caption here
    /* @__PURE__ */ g.jsx(
      "video",
      {
        src: t.src,
        controls: !0,
        playsInline: !0,
        autoPlay: !0,
        loop: !0,
        className: ie("rounded-lg", t.className)
      }
    )
  ) : /* @__PURE__ */ g.jsx(
    "img",
    {
      alt: t.alt,
      ...t,
      className: ie("rounded-lg", t.className)
    }
  ),
  Framed: Dg,
  h1: ({ children: e, id: t }) => /* @__PURE__ */ g.jsx(ot, { level: 1, id: t, children: e }),
  h2: ({ children: e, id: t }) => /* @__PURE__ */ g.jsx(ot, { level: 2, id: t, children: e }),
  h3: ({ children: e, id: t }) => /* @__PURE__ */ g.jsx(ot, { level: 3, id: t, children: e }),
  h4: ({ children: e, id: t }) => /* @__PURE__ */ g.jsx(ot, { level: 4, id: t, children: e }),
  h5: ({ children: e, id: t }) => /* @__PURE__ */ g.jsx(ot, { level: 5, id: t, children: e }),
  h6: ({ children: e, id: t }) => /* @__PURE__ */ g.jsx(ot, { level: 6, id: t, children: e }),
  a: ({ href: e, node: t, ...n }) => e && !e.startsWith("http") ? /* @__PURE__ */ g.jsx(qs, { to: e, relative: "path", ...n }) : /* @__PURE__ */ g.jsx("a", { href: e, target: "_blank", ...n, rel: "noreferrer" }),
  Link: Br,
  Button: Ki,
  Callout: $e,
  Stepper: kl,
  Mermaid: Sl,
  SyntaxHighlight: Qo,
  tip: (e) => /* @__PURE__ */ g.jsx($e, { type: "tip", ...e }),
  info: (e) => /* @__PURE__ */ g.jsx($e, { type: "info", ...e }),
  note: (e) => /* @__PURE__ */ g.jsx($e, { type: "note", ...e }),
  caution: (e) => /* @__PURE__ */ g.jsx($e, { type: "caution", ...e }),
  warning: (e) => /* @__PURE__ */ g.jsx($e, { type: "caution", ...e }),
  danger: (e) => /* @__PURE__ */ g.jsx($e, { type: "danger", ...e }),
  pre: (e) => /* @__PURE__ */ g.jsx("pre", { className: ie("not-prose my-4", e.className), ...e }),
  code: ({
    className: e,
    node: t,
    children: n,
    title: r,
    inline: u,
    showLineNumbers: a,
    ...i
  }) => {
    const o = e?.match(/language?-(\w+)/);
    return u === "true" || u === !0 ? /* @__PURE__ */ g.jsx(wg, { className: ie(e, "inline"), children: n }) : /* @__PURE__ */ g.jsx(
      Nl,
      {
        language: o?.[1],
        showLanguageIndicator: !0,
        showLineNumbers: a,
        title: r,
        children: /* @__PURE__ */ g.jsx("code", { className: ie(e, Go), ...i, children: n })
      }
    );
  }
}, Mg = "prose dark:prose-invert prose-neutral typography", Vs = ({
  children: e,
  className: t
}) => /* @__PURE__ */ g.jsx("div", { className: ie(Mg, t), children: e }), Bg = [wE], Ws = Fn(
  ({
    content: e,
    className: t,
    components: n
  }) => {
    const { syntaxHighlighting: r } = et().options, u = ft(
      () => [
        bp,
        ...$o(
          r?.themes,
          r?.highlighter
        )
      ],
      [r?.themes, r?.highlighter]
    ), a = ft(
      () => ({ ...Ys, ...n }),
      [n]
    );
    return /* @__PURE__ */ g.jsx(Vs, { className: t, children: /* @__PURE__ */ g.jsx(
      Wf,
      {
        remarkPlugins: Bg,
        rehypePlugins: u,
        components: a,
        children: e
      }
    ) });
  }
);
Ws.displayName = "Markdown";
function Fg() {
  const e = navigator.userAgent.toLowerCase();
  if (e.includes("win")) return "Windows";
  if (e.includes("mac")) return "macOS";
  if (e.includes("linux")) return "Linux";
}
const Qs = ({ className: e }) => {
  const t = et(), [n, r] = De(!1), u = Fe(() => r(!1), []);
  ge(() => {
    if (n)
      return;
    function i(o) {
      o.key === "k" && (o.metaKey || o.ctrlKey) && (o.preventDefault(), r(!0));
    }
    return window.addEventListener("keydown", i), () => {
      window.removeEventListener("keydown", i);
    };
  }, [n]);
  const a = t.options.plugins?.find(Io);
  return a ? /* @__PURE__ */ g.jsxs("div", { className: e, children: [
    /* @__PURE__ */ g.jsxs(
      "button",
      {
        type: "button",
        onClick: () => r(!0),
        className: "flex items-center border border-input hover:bg-accent hover:text-accent-foreground p-4 relative h-8 justify-start rounded-lg bg-background text-sm text-muted-foreground shadow-none w-full sm:w-72",
        children: [
          /* @__PURE__ */ g.jsxs("div", { className: "flex items-center gap-2 grow", children: [
            /* @__PURE__ */ g.jsx(Zi, { size: 14 }),
            "Search"
          ] }),
          /* @__PURE__ */ g.jsx(Zt, { children: /* @__PURE__ */ g.jsx(vg, {}) })
        ]
      }
    ),
    /* @__PURE__ */ g.jsx(Mr, { children: a.renderSearch({ isOpen: n, onClose: u }) })
  ] }) : null;
}, vg = () => {
  const e = Fg();
  return /* @__PURE__ */ g.jsxs("kbd", { className: "absolute end-1.5 hidden h-5 select-none items-center gap-1 rounded-sm border bg-muted px-1.5 font-mono text-[11px] font-medium opacity-100 sm:flex", children: [
    e === "macOS" ? "⌘" : "Ctrl",
    "+K"
  ] });
}, Gs = ({
  slots: e = {}
} = {}) => {
  const t = new Map(
    Object.entries(e).map(([r, u]) => [
      r,
      [{ id: r, content: u, type: "replace", sequence: 0 }]
    ])
  ), n = [];
  return Ro()((r, u) => ({
    items: t,
    sequences: /* @__PURE__ */ new Map(),
    getItems: (a) => u().items.get(a) ?? n,
    setSlot: (a, i, o, l) => r((c) => {
      if (o == null) return c;
      const d = new Map(c.items), f = new Map(c.sequences), h = (d.get(i) ?? []).filter((C) => C.id !== a), I = (f.get(i) ?? 0) + 1;
      f.set(i, I);
      const y = {
        id: a,
        content: o,
        type: l,
        // Use negative sequence values for "prepend" to ensure they are sorted before positive values for "append".
        sequence: l === "prepend" ? -I : I
      };
      if (l === "replace") {
        const C = h.filter(
          (w) => w.type !== "replace"
        );
        d.set(i, [...C, y]);
      } else
        d.set(i, [...h, y]);
      return { items: d, sequences: f };
    }),
    clearSlot: (a, i) => r((o) => {
      const l = new Map(o.items), c = new Map(o.sequences), f = (l.get(i) ?? []).filter((m) => m.id !== a);
      return f.length === 0 ? (l.delete(i), c.delete(i)) : l.set(i, f), { items: l, sequences: c };
    })
  }));
}, $s = nn(Gs()), Hg = ({
  children: e,
  slots: t
}) => {
  const n = Se(Gs({ slots: t })).current;
  return /* @__PURE__ */ g.jsx($s, { value: n, children: e });
};
function Dr(e) {
  const t = Vi($s);
  return Do(t, e);
}
const wi = ["prepend", "replace", "append"], Ug = (e) => {
  const t = ul(), n = Dr((r) => r.getItems(e));
  return ft(() => n.length === 0 ? [] : n.toSorted((r, u) => {
    const a = wi.indexOf(r.type) - wi.indexOf(u.type);
    return a !== 0 ? a : r.sequence - u.sequence;
  }).map(
    (r) => typeof r.content == "function" ? /* @__PURE__ */ g.jsx(r.content, { ...t }, r.id) : /* @__PURE__ */ g.jsx(go, { children: r.content }, r.id)
  ), [n, t]);
}, _t = {
  Source: ({
    name: e,
    children: t,
    type: n = "replace"
  }) => {
    const r = To(), u = Dr((i) => i.setSlot), a = Dr((i) => i.clearSlot);
    return bo(() => (u(r, e, t, n), () => a(r, e)), [r, e, t, n, u, a]), null;
  },
  Target: ({ name: e, fallback: t }) => {
    const n = Ug(e);
    return n.length === 0 ? t : n;
  }
}, jg = nn(null), gr = {
  didCatch: !1,
  error: null
};
class zg extends Ao {
  constructor(t) {
    super(t), this.resetErrorBoundary = this.resetErrorBoundary.bind(this), this.state = gr;
  }
  static getDerivedStateFromError(t) {
    return {
      didCatch: !0,
      error: t
    };
  }
  resetErrorBoundary() {
    const {
      error: t
    } = this.state;
    if (t !== null) {
      for (var n, r, u = arguments.length, a = new Array(u), i = 0; i < u; i++)
        a[i] = arguments[i];
      (n = (r = this.props).onReset) === null || n === void 0 || n.call(r, {
        args: a,
        reason: "imperative-api"
      }), this.setState(gr);
    }
  }
  componentDidCatch(t, n) {
    var r, u;
    (r = (u = this.props).onError) === null || r === void 0 || r.call(u, t, n);
  }
  componentDidUpdate(t, n) {
    const {
      didCatch: r
    } = this.state, {
      resetKeys: u
    } = this.props;
    if (r && n.error !== null && qg(t.resetKeys, u)) {
      var a, i;
      (a = (i = this.props).onReset) === null || a === void 0 || a.call(i, {
        next: u,
        prev: t.resetKeys,
        reason: "keys"
      }), this.setState(gr);
    }
  }
  render() {
    const {
      children: t,
      fallbackRender: n,
      FallbackComponent: r,
      fallback: u
    } = this.props, {
      didCatch: a,
      error: i
    } = this.state;
    let o = t;
    if (a) {
      const l = {
        error: i,
        resetErrorBoundary: this.resetErrorBoundary
      };
      if (typeof n == "function")
        o = n(l);
      else if (r)
        o = pu(r, l);
      else if (u !== void 0)
        o = u;
      else
        throw i;
    }
    return pu(jg.Provider, {
      value: {
        didCatch: a,
        error: i,
        resetErrorBoundary: this.resetErrorBoundary
      }
    }, o);
  }
}
function qg() {
  let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [], t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
  return e.length !== t.length || e.some((n, r) => !Object.is(n, t[r]));
}
let Yg = () => ({
  emit(e, ...t) {
    for (let n = this.events[e] || [], r = 0, u = n.length; r < u; r++)
      n[r](...t);
  },
  events: {},
  on(e, t) {
    return (this.events[e] ||= []).push(t), () => {
      this.events[e] = this.events[e]?.filter((n) => t !== n);
    };
  }
});
const Vg = (e) => Object.entries(e), Mi = (e) => {
  if (e)
    return Array.isArray(e) ? Object.fromEntries(
      e.map((t) => [
        t,
        (n) => n.auth.isAuthenticated
      ])
    ) : e;
};
class Wg {
  authentication;
  getAuthState;
  queryClient;
  options;
  env;
  protectedRoutes;
  plugins;
  emitter = Yg();
  constructor(t, n, r) {
    this.queryClient = n, this.env = r, this.options = t, this.plugins = t.plugins ?? [], this.authentication = this.plugins.find(So), this.getAuthState = gu.getState;
    const u = Object.fromEntries(
      this.plugins.flatMap((a) => {
        if (!Eu(a)) return [];
        const i = a.getProtectedRoutes?.();
        return i ? Object.entries(Mi(i) ?? {}) : [];
      })
    );
    this.protectedRoutes = {
      ...u,
      ...Mi(t.protectedRoutes)
    }, this.plugins.forEach((a) => {
      No(a) && Vg(a.events).forEach(([i, o]) => {
        this.emitter.on(i, o);
      });
    }), gu.subscribe((a, i) => {
      this.emitEvent("auth", {
        prev: i,
        next: a
      });
    });
  }
  initialize = async () => {
    await Promise.all(
      this.plugins.filter(ko).map((t) => t.initialize?.(this))
    );
  };
  getApiIdentities = async () => (await Promise.all(
    this.plugins.filter(yo).map((n) => n.getIdentities(this))
  )).flat();
  addEventListener(t, n) {
    return this.emitter.on(t, n);
  }
  emitEvent = (t, ...n) => this.emitter.emit(t, ...n);
  getPluginNavigation = async (t) => (await Promise.all(
    this.plugins.filter(Eu).map((r) => r.getNavigation?.(Je(t), this))
  )).flatMap((r) => r ?? []);
  getProfileMenuItems = () => this.plugins.filter((n) => Qi(n)).flatMap((n) => n.getProfileMenuItems(this)).sort(Qg(["top", "middle", "bottom"])).sort((n) => n.weight ?? 0);
  signRequest = async (t) => {
    if (!this.authentication)
      throw new Error("No authentication provider configured");
    return await this.authentication.signRequest(t);
  };
}
const Qg = (e) => (t, n) => {
  const r = e.indexOf(t.category ?? "middle"), u = e.indexOf(n.category ?? "middle");
  return r - u;
}, Gg = ({
  children: e,
  className: t
}) => {
  if (process.env.NODE_ENV === "development")
    return /* @__PURE__ */ g.jsx($e, { type: "caution", title: "Developer hint", className: t, children: /* @__PURE__ */ g.jsxs("div", { className: "flex flex-col gap-2", children: [
      typeof e == "string" ? /* @__PURE__ */ g.jsx(Ws, { content: e }) : /* @__PURE__ */ g.jsx("div", { children: e }),
      /* @__PURE__ */ g.jsx("small", { className: "italic", children: "Note: This hint is only shown in development mode." })
    ] }) });
};
function $g({ error: e }) {
  const t = e instanceof Error ? e.message : "Something went wrong", n = e instanceof _u ? e.developerHint : void 0, r = e instanceof _u ? e.title : "Something went wrong", u = e instanceof Error ? e.stack : void 0, a = e instanceof Error ? e.cause : void 0, i = a instanceof Error ? String(a.stack) : u;
  return /* @__PURE__ */ g.jsxs(Vs, { className: "grid grid-cols-1 max-w-none! pt-(--padding-content-top)", children: [
    /* @__PURE__ */ g.jsx(ot, { level: 1, children: r }),
    "Error: ",
    t,
    n && /* @__PURE__ */ g.jsx(Gg, { className: "mb-4", children: n }),
    i && /* @__PURE__ */ g.jsx("pre", { className: "max-h-[400px] [&>pre]:p-4", children: i })
  ] });
}
function Kg({ error: e }) {
  return /* @__PURE__ */ g.jsx($g, { error: e });
}
const gn = globalThis;
(!gn.requestIdleCallback || !gn.cancelIdleCallback) && (gn.requestIdleCallback = (e) => setTimeout(e, 1), gn.cancelIdleCallback = clearTimeout);
function Pr({
  className: e,
  ...t
}) {
  return /* @__PURE__ */ g.jsx(
    "div",
    {
      className: ie("animate-pulse rounded-md bg-muted", e),
      ...t
    }
  );
}
const Bi = {
  info: "bg-blue-500",
  note: "bg-gray-500",
  tip: "bg-green-600",
  caution: "bg-orange-500",
  danger: "bg-rose-500"
}, Xg = () => {
  const { options: e } = et(), { site: t } = e, [n, r] = De(!0);
  if (!t?.banner || !n)
    return /* @__PURE__ */ g.jsx("style", { children: ":root { --banner-height: 0px; }" });
  const u = t.banner.color && t.banner.color in Bi ? Bi[t.banner.color] : t.banner.color ? void 0 : "bg-primary", a = u ? {} : { backgroundColor: t.banner.color };
  return /* @__PURE__ */ g.jsxs(
    "div",
    {
      className: ie(
        "relative text-primary-foreground text-sm font-medium px-4 py-2 flex gap-2 items-center lg:h-(--banner-height)",
        u
      ),
      style: a,
      children: [
        /* @__PURE__ */ g.jsx("div", { className: "w-full", children: t.banner.message }),
        t.banner.dismissible && /* @__PURE__ */ g.jsx(
          "button",
          {
            type: "button",
            className: "md:absolute md:end-4 -m-1.5 p-1.5 hover:bg-accent-foreground/10 rounded-md",
            onClick: () => r(!1),
            children: /* @__PURE__ */ g.jsx(el, { size: 16 })
          }
        )
      ]
    }
  );
}, Ks = (e) => /* @__PURE__ */ g.jsxs(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 132 100",
    fill: "none",
    ...e,
    children: [
      /* @__PURE__ */ g.jsx(
        "path",
        {
          fill: "currentColor",
          fillRule: "evenodd",
          d: "M80.092 2.963A4.66 4.66 0 0 1 84.449 0h34.049c6.325 0 10.835 6.135 8.948 12.172L116.653 46.71a4.688 4.688 0 0 1-4.474 3.29H75c-5.178 0-7.813 4.687-9.375 9.374-1.288 3.864-11.07 28.963-14.467 37.662A4.66 4.66 0 0 1 46.801 100H12.75c-6.324 0-10.834-6.134-8.947-12.171l10.793-34.54A4.688 4.688 0 0 1 19.071 50H56.25c5.178 0 7.813-4.687 9.375-9.375 1.288-3.864 11.07-28.962 14.467-37.662Z",
          clipRule: "evenodd"
        }
      ),
      /* @__PURE__ */ g.jsx(
        "path",
        {
          fill: "currentColor",
          d: "M83.54 57.813a7.813 7.813 0 0 0-7.316 5.07L63.888 95.777c-.766 2.043.744 4.222 2.926 4.222h36.828c5.211 0 9.875-3.232 11.704-8.11l8.821-23.522c1.915-5.107-1.861-10.555-7.315-10.555H83.539ZM29.17 0a12.5 12.5 0 0 0-11.704 8.111l-8.82 23.521c-1.915 5.107 1.86 10.556 7.315 10.556h33.312a7.813 7.813 0 0 0 7.316-5.07L68.924 4.223C69.691 2.18 68.18 0 65.998 0H29.17Z"
        }
      )
    ]
  }
);
Ks.displayName = "ZudokuLogo";
const Zg = ({ className: e }) => /* @__PURE__ */ g.jsxs(
  "a",
  {
    href: "https://zudoku.dev",
    target: "_blank",
    rel: "noopener noreferrer",
    className: ie(
      "flex justify-between items-center w-full border border-transparent hover:border-border rounded-full hover:shadow-xs h-7 px-3 text-nowrap hover:bg-muted/80 transition-all",
      e
    ),
    children: [
      /* @__PURE__ */ g.jsxs("div", { className: "opacity-70 hover:opacity-100 transition-opacity gap-1.5 text-[11px] font-medium rounded-full h-7 flex items-center text-nowrap", children: [
        /* @__PURE__ */ g.jsx(Ks, { className: "w-3.5 h-3.5 dark:fill-white" }),
        "powered by ",
        "Zudoku"
      ] }),
      /* @__PURE__ */ g.jsx("div", { className: "text-xs font-medium opacity-70 hover:text-foreground transition-colors cursor-pointer", children: /* @__PURE__ */ g.jsx(
        Xi,
        {
          size: 12,
          absoluteStrokeWidth: !0,
          strokeWidth: 1.5,
          className: "rtl:rotate-180"
        }
      ) })
    ]
  }
);
function Bn() {
  return Bn = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n) ({}).hasOwnProperty.call(n, r) && (e[r] = n[r]);
    }
    return e;
  }, Bn.apply(null, arguments);
}
var Tn = { exports: {} }, Z = {};
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Fi;
function Jg() {
  if (Fi) return Z;
  Fi = 1;
  var e = typeof Symbol == "function" && Symbol.for, t = e ? Symbol.for("react.element") : 60103, n = e ? Symbol.for("react.portal") : 60106, r = e ? Symbol.for("react.fragment") : 60107, u = e ? Symbol.for("react.strict_mode") : 60108, a = e ? Symbol.for("react.profiler") : 60114, i = e ? Symbol.for("react.provider") : 60109, o = e ? Symbol.for("react.context") : 60110, l = e ? Symbol.for("react.async_mode") : 60111, c = e ? Symbol.for("react.concurrent_mode") : 60111, d = e ? Symbol.for("react.forward_ref") : 60112, f = e ? Symbol.for("react.suspense") : 60113, m = e ? Symbol.for("react.suspense_list") : 60120, h = e ? Symbol.for("react.memo") : 60115, b = e ? Symbol.for("react.lazy") : 60116, I = e ? Symbol.for("react.block") : 60121, y = e ? Symbol.for("react.fundamental") : 60117, C = e ? Symbol.for("react.responder") : 60118, w = e ? Symbol.for("react.scope") : 60119;
  function O(R) {
    if (typeof R == "object" && R !== null) {
      var N = R.$$typeof;
      switch (N) {
        case t:
          switch (R = R.type, R) {
            case l:
            case c:
            case r:
            case a:
            case u:
            case f:
              return R;
            default:
              switch (R = R && R.$$typeof, R) {
                case o:
                case d:
                case b:
                case h:
                case i:
                  return R;
                default:
                  return N;
              }
          }
        case n:
          return N;
      }
    }
  }
  function v(R) {
    return O(R) === c;
  }
  return Z.AsyncMode = l, Z.ConcurrentMode = c, Z.ContextConsumer = o, Z.ContextProvider = i, Z.Element = t, Z.ForwardRef = d, Z.Fragment = r, Z.Lazy = b, Z.Memo = h, Z.Portal = n, Z.Profiler = a, Z.StrictMode = u, Z.Suspense = f, Z.isAsyncMode = function(R) {
    return v(R) || O(R) === l;
  }, Z.isConcurrentMode = v, Z.isContextConsumer = function(R) {
    return O(R) === o;
  }, Z.isContextProvider = function(R) {
    return O(R) === i;
  }, Z.isElement = function(R) {
    return typeof R == "object" && R !== null && R.$$typeof === t;
  }, Z.isForwardRef = function(R) {
    return O(R) === d;
  }, Z.isFragment = function(R) {
    return O(R) === r;
  }, Z.isLazy = function(R) {
    return O(R) === b;
  }, Z.isMemo = function(R) {
    return O(R) === h;
  }, Z.isPortal = function(R) {
    return O(R) === n;
  }, Z.isProfiler = function(R) {
    return O(R) === a;
  }, Z.isStrictMode = function(R) {
    return O(R) === u;
  }, Z.isSuspense = function(R) {
    return O(R) === f;
  }, Z.isValidElementType = function(R) {
    return typeof R == "string" || typeof R == "function" || R === r || R === c || R === a || R === u || R === f || R === m || typeof R == "object" && R !== null && (R.$$typeof === b || R.$$typeof === h || R.$$typeof === i || R.$$typeof === o || R.$$typeof === d || R.$$typeof === y || R.$$typeof === C || R.$$typeof === w || R.$$typeof === I);
  }, Z.typeOf = O, Z;
}
var J = {};
/** @license React v16.13.1
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var vi;
function eT() {
  return vi || (vi = 1, process.env.NODE_ENV !== "production" && (function() {
    var e = typeof Symbol == "function" && Symbol.for, t = e ? Symbol.for("react.element") : 60103, n = e ? Symbol.for("react.portal") : 60106, r = e ? Symbol.for("react.fragment") : 60107, u = e ? Symbol.for("react.strict_mode") : 60108, a = e ? Symbol.for("react.profiler") : 60114, i = e ? Symbol.for("react.provider") : 60109, o = e ? Symbol.for("react.context") : 60110, l = e ? Symbol.for("react.async_mode") : 60111, c = e ? Symbol.for("react.concurrent_mode") : 60111, d = e ? Symbol.for("react.forward_ref") : 60112, f = e ? Symbol.for("react.suspense") : 60113, m = e ? Symbol.for("react.suspense_list") : 60120, h = e ? Symbol.for("react.memo") : 60115, b = e ? Symbol.for("react.lazy") : 60116, I = e ? Symbol.for("react.block") : 60121, y = e ? Symbol.for("react.fundamental") : 60117, C = e ? Symbol.for("react.responder") : 60118, w = e ? Symbol.for("react.scope") : 60119;
    function O(U) {
      return typeof U == "string" || typeof U == "function" || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
      U === r || U === c || U === a || U === u || U === f || U === m || typeof U == "object" && U !== null && (U.$$typeof === b || U.$$typeof === h || U.$$typeof === i || U.$$typeof === o || U.$$typeof === d || U.$$typeof === y || U.$$typeof === C || U.$$typeof === w || U.$$typeof === I);
    }
    function v(U) {
      if (typeof U == "object" && U !== null) {
        var wt = U.$$typeof;
        switch (wt) {
          case t:
            var it = U.type;
            switch (it) {
              case l:
              case c:
              case r:
              case a:
              case u:
              case f:
                return it;
              default:
                var Mt = it && it.$$typeof;
                switch (Mt) {
                  case o:
                  case d:
                  case b:
                  case h:
                  case i:
                    return Mt;
                  default:
                    return wt;
                }
            }
          case n:
            return wt;
        }
      }
    }
    var R = l, N = c, z = o, X = i, Q = t, S = d, H = r, F = b, ee = h, ue = n, G = a, fe = u, le = f, Te = !1;
    function Oe(U) {
      return Te || (Te = !0, console.warn("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.")), A(U) || v(U) === l;
    }
    function A(U) {
      return v(U) === c;
    }
    function _e(U) {
      return v(U) === o;
    }
    function Le(U) {
      return v(U) === i;
    }
    function _(U) {
      return typeof U == "object" && U !== null && U.$$typeof === t;
    }
    function xe(U) {
      return v(U) === d;
    }
    function Ue(U) {
      return v(U) === r;
    }
    function ce(U) {
      return v(U) === b;
    }
    function ut(U) {
      return v(U) === h;
    }
    function we(U) {
      return v(U) === n;
    }
    function Qe(U) {
      return v(U) === a;
    }
    function je(U) {
      return v(U) === u;
    }
    function Pt(U) {
      return v(U) === f;
    }
    J.AsyncMode = R, J.ConcurrentMode = N, J.ContextConsumer = z, J.ContextProvider = X, J.Element = Q, J.ForwardRef = S, J.Fragment = H, J.Lazy = F, J.Memo = ee, J.Portal = ue, J.Profiler = G, J.StrictMode = fe, J.Suspense = le, J.isAsyncMode = Oe, J.isConcurrentMode = A, J.isContextConsumer = _e, J.isContextProvider = Le, J.isElement = _, J.isForwardRef = xe, J.isFragment = Ue, J.isLazy = ce, J.isMemo = ut, J.isPortal = we, J.isProfiler = Qe, J.isStrictMode = je, J.isSuspense = Pt, J.isValidElementType = O, J.typeOf = v;
  })()), J;
}
var Hi;
function tT() {
  return Hi || (Hi = 1, process.env.NODE_ENV === "production" ? Tn.exports = Jg() : Tn.exports = eT()), Tn.exports;
}
var Tr, Ui;
function nT() {
  if (Ui) return Tr;
  Ui = 1;
  var e = tT(), t = {
    childContextTypes: !0,
    contextType: !0,
    contextTypes: !0,
    defaultProps: !0,
    displayName: !0,
    getDefaultProps: !0,
    getDerivedStateFromError: !0,
    getDerivedStateFromProps: !0,
    mixins: !0,
    propTypes: !0,
    type: !0
  }, n = {
    name: !0,
    length: !0,
    prototype: !0,
    caller: !0,
    callee: !0,
    arguments: !0,
    arity: !0
  }, r = {
    $$typeof: !0,
    render: !0,
    defaultProps: !0,
    displayName: !0,
    propTypes: !0
  }, u = {
    $$typeof: !0,
    compare: !0,
    defaultProps: !0,
    displayName: !0,
    propTypes: !0,
    type: !0
  }, a = {};
  a[e.ForwardRef] = r, a[e.Memo] = u;
  function i(b) {
    return e.isMemo(b) ? u : a[b.$$typeof] || t;
  }
  var o = Object.defineProperty, l = Object.getOwnPropertyNames, c = Object.getOwnPropertySymbols, d = Object.getOwnPropertyDescriptor, f = Object.getPrototypeOf, m = Object.prototype;
  function h(b, I, y) {
    if (typeof I != "string") {
      if (m) {
        var C = f(I);
        C && C !== m && h(b, C, y);
      }
      var w = l(I);
      c && (w = w.concat(c(I)));
      for (var O = i(b), v = i(I), R = 0; R < w.length; ++R) {
        var N = w[R];
        if (!n[N] && !(y && y[N]) && !(v && v[N]) && !(O && O[N])) {
          var z = d(I, N);
          try {
            o(b, N, z);
          } catch {
          }
        }
      }
    }
    return b;
  }
  return Tr = h, Tr;
}
nT();
var Xs = function(t, n, r) {
  return t = t <= r ? t : r, t = t >= n ? t : n, t;
}, rT = function() {
  var t = !1, n = [], r = function() {
    t = !0;
    var o = n.shift();
    if (o)
      return o(r);
    t = !1;
  }, u = function() {
    t = !1, n = [];
  }, a = function(o) {
    n.push(o), !t && n.length === 1 && r();
  };
  return {
    clear: u,
    enqueue: a
  };
}, uT = function() {
  var t, n = function() {
    t && window.cancelAnimationFrame(t);
  }, r = function(a, i) {
    var o, l, c = function(f) {
      if (l = l || f, o = f - l, o > i) {
        a();
        return;
      }
      t = window.requestAnimationFrame(c);
    };
    t = window.requestAnimationFrame(c);
  };
  return {
    cancel: n,
    schedule: r
  };
}, iT = function(t) {
  var n = 0;
  return t >= 0 && t < 0.2 ? n = 0.1 : t >= 0.2 && t < 0.5 ? n = 0.04 : t >= 0.5 && t < 0.8 ? n = 0.02 : t >= 0.8 && t < 0.99 && (n = 5e-3), Xs(t + n, 0, 0.994);
}, ji = function(t) {
  ge(t, []);
}, aT = function(t) {
  return ++t % 1e6;
}, sT = function() {
  var t = De(0), n = t[1];
  return Fe(function() {
    return n(aT);
  }, []);
}, oT = function(t) {
  t === void 0 && (t = {});
  var n = sT(), r = Se(Bn({}, t)), u = Fe(function() {
    return r.current;
  }, []), a = Fe(function(i) {
    i && (Object.assign(r.current, i), n());
  }, []);
  return [u, a];
}, lT = function() {
  var t = Se(!0);
  return t.current ? (t.current = !1, !0) : t.current;
}, zi = function(t, n) {
  var r = lT();
  ge(function() {
    if (!r)
      return t();
  }, n);
}, Zs = function() {
}, qi = {
  isFinished: !0,
  progress: 0,
  sideEffect: Zs
}, cT = function(t) {
  var n = t === void 0 ? {} : t, r = n.animationDuration, u = r === void 0 ? 200 : r, a = n.incrementDuration, i = a === void 0 ? 800 : a, o = n.isAnimating, l = o === void 0 ? !1 : o, c = n.minimum, d = c === void 0 ? 0.08 : c, f = oT(qi), m = f[0], h = f[1], b = Se(null), I = Se(null);
  ji(function() {
    b.current = rT(), I.current = uT();
  });
  var y = Fe(function() {
    var N, z;
    (N = I.current) == null || N.cancel(), (z = b.current) == null || z.clear();
  }, []), C = Fe(function(N) {
    var z;
    if (N = Xs(N, d, 1), N === 1) {
      var X, Q;
      y(), (X = b.current) == null || X.enqueue(function(S) {
        h({
          progress: N,
          sideEffect: function() {
            var F;
            return (F = I.current) == null ? void 0 : F.schedule(S, u);
          }
        });
      }), (Q = b.current) == null || Q.enqueue(function() {
        h({
          isFinished: !0,
          sideEffect: y
        });
      });
      return;
    }
    (z = b.current) == null || z.enqueue(function(S) {
      h({
        isFinished: !1,
        progress: N,
        sideEffect: function() {
          var F;
          return (F = I.current) == null ? void 0 : F.schedule(S, u);
        }
      });
    });
  }, [u, y, d, b, h, I]), w = Fe(function() {
    C(iT(m().progress));
  }, [m, C]), O = Fe(function() {
    var N = function() {
      var X;
      w(), (X = b.current) == null || X.enqueue(function(Q) {
        var S;
        (S = I.current) == null || S.schedule(function() {
          N(), Q();
        }, i);
      });
    };
    N();
  }, [i, b, I, w]), v = Se(Zs), R = m().sideEffect;
  return ge(function() {
    v.current = w;
  }), ji(function() {
    return l && O(), y;
  }), zi(function() {
    m().sideEffect();
  }, [m, R]), zi(function() {
    l ? h(Bn({}, qi, {
      sideEffect: O
    })) : C(1);
  }, [l, C, h, O]), {
    animationDuration: u,
    isFinished: m().isFinished,
    progress: m().progress
  };
};
const Js = () => {
  const t = Wi().state === "loading", [n, r] = De(!1);
  ge(() => {
    const i = setTimeout(() => r(t), 200);
    return () => clearTimeout(i);
  }, [t]);
  const { isFinished: u, progress: a } = cT({ isAnimating: n });
  return /* @__PURE__ */ g.jsx(
    "div",
    {
      className: "absolute w-0 left-0 right-0 bottom-[-1px] h-[2px] bg-primary transition-all duration-300 ease-in-out",
      style: {
        opacity: u ? 0 : 1,
        width: u ? 0 : `${a * 100}%`
      }
    }
  );
}, eo = () => {
  const { resolvedTheme: e, setTheme: t } = mo();
  return /* @__PURE__ */ g.jsx(Zt, { fallback: /* @__PURE__ */ g.jsx(Nn, { variant: "ghost", size: "icon" }), children: /* @__PURE__ */ g.jsxs(
    "button",
    {
      type: "button",
      className: "flex rounded-full border p-0.5 gap-0.5 group",
      onClick: () => t(e === "dark" ? "light" : "dark"),
      "aria-label": e === "dark" ? "Switch to light mode" : "Switch to dark mode",
      children: [
        /* @__PURE__ */ g.jsx(
          "div",
          {
            className: ie(
              "border border-transparent rounded-full p-0.5 [&>svg>circle]:transition-colors [&>svg>path]:transition-transform transition-all [&>svg>path]:duration-200 [&>svg>circle]:duration-500 [&>svg>circle]:fill-transparent",
              e === "light" && "border-border bg-muted",
              e === "dark" && "group-hover:[&>svg>path]:scale-110 group-hover:[&>svg>path]:-translate-x-[1px] group-hover:[&>svg>path]:-translate-y-[1px] group-hover:rotate-[15deg] "
            ),
            children: /* @__PURE__ */ g.jsx(tl, { size: 16 })
          }
        ),
        /* @__PURE__ */ g.jsx(
          "div",
          {
            className: ie(
              "border border-transparent rounded-full p-0.5 transition-transform transform-gpu duration-500",
              e === "dark" && "border-border bg-muted [&>svg>path]:fill-white [&>svg>path]:stroke-transparent",
              e === "light" && "group-hover:rotate-[-10deg] [&>svg>path]:stroke-currentColor"
            ),
            children: /* @__PURE__ */ g.jsx(nl, { size: 16 })
          }
        )
      ]
    }
  ) });
}, fT = () => {
  const e = et(), {
    options: { navigation: t = [] }
  } = e, n = Xt(), r = t.filter(Fr(n, e));
  return r.length === 0 ? /* @__PURE__ */ g.jsx("style", { children: ":root { --top-nav-height: 0px; }" }) : /* @__PURE__ */ g.jsx(Mr, { children: /* @__PURE__ */ g.jsxs("div", { className: "items-center justify-between px-8 h-(--top-nav-height) hidden lg:flex text-sm relative", children: [
    /* @__PURE__ */ g.jsx("nav", { className: "text-sm", children: /* @__PURE__ */ g.jsx("ul", { className: "flex flex-row items-center gap-8", children: r.map(
      (u) => u.type === "separator" ? /* @__PURE__ */ g.jsx("li", { className: "-mx-4 h-7", children: /* @__PURE__ */ g.jsx(cu, { orientation: "vertical" }) }, u.label) : u.type !== "section" && u.type !== "filter" ? /* @__PURE__ */ g.jsx("li", { children: /* @__PURE__ */ g.jsx(no, { ...u }) }, u.label + u.type) : null
    ) }) }),
    /* @__PURE__ */ g.jsx(_t.Target, { name: "top-navigation-side" })
  ] }) });
}, to = (e) => {
  switch (e.type) {
    case "doc":
      return Je(e.path);
    case "link":
      return e.to;
    case "category":
      return e.link?.path ? Je(e.link.path) : Bo(e, (t) => {
        if (t.type !== "category" && t.type !== "separator" && t.type !== "section")
          return to(t);
      }) ?? "";
    case "custom-page":
      return e.path;
    default:
      return "";
  }
}, wr = ({
  isActive: e,
  children: t,
  ...n
}) => /* @__PURE__ */ g.jsx(
  vn,
  {
    viewTransition: !0,
    className: ({ isActive: r, isPending: u }) => {
      const a = r || e;
      return Ko(
        "flex items-center gap-2 lg:py-3.5 font-medium -mb-px transition duration-150 delay-75 relative",
        a || u ? [
          "text-foreground",
          // underline with view transition animation
          "after:content-[''] after:absolute after:bottom-0 after:left-0 after:right-0",
          "after:h-0.5 after:bg-primary",
          a && "after:[view-transition-name:top-nav-underline]",
          u && "after:bg-primary/25"
        ] : "text-foreground/75 hover:text-foreground"
      );
    },
    ...n,
    children: t
  }
), no = (e) => {
  const t = Mo(), n = vs(t.topNavItem, e), r = to(e);
  return (
    // We don't use isActive here because it has to be inside the navigation,
    // the top nav id doesn't necessarily start with the navigation id
    /* @__PURE__ */ g.jsxs(wr, { to: r, isActive: n, children: [
      e.icon && /* @__PURE__ */ g.jsx(e.icon, { size: 16, className: "align-[-0.125em]" }),
      e.label
    ] })
  );
}, dT = () => {
  const e = et(), t = Xt(), {
    options: { navigation: n = [], site: r },
    getProfileMenuItems: u
  } = e, { isAuthenticated: a, profile: i, isAuthEnabled: o } = t, [l, c] = De(!1), d = u(), f = n.filter(Fr(t, e));
  return /* @__PURE__ */ g.jsxs(
    gl,
    {
      direction: r?.dir === "rtl" ? "left" : "right",
      open: l,
      onOpenChange: (m) => c(m),
      children: [
        /* @__PURE__ */ g.jsxs("div", { className: "flex lg:hidden justify-self-end", children: [
          /* @__PURE__ */ g.jsx(Tl, { className: "lg:hidden", children: /* @__PURE__ */ g.jsx(rl, { size: 22 }) }),
          /* @__PURE__ */ g.jsx(Js, {})
        ] }),
        /* @__PURE__ */ g.jsx(
          bl,
          {
            className: "lg:hidden h-dvh end-0 start-auto w-[320px] rounded-none",
            "aria-describedby": void 0,
            children: /* @__PURE__ */ g.jsxs("div", { className: "p-4 overflow-y-auto overscroll-none h-full flex flex-col justify-between", children: [
              /* @__PURE__ */ g.jsxs("div", { children: [
                /* @__PURE__ */ g.jsx(pl, { children: /* @__PURE__ */ g.jsx(Al, { children: "Navigation" }) }),
                /* @__PURE__ */ g.jsx(Qs, { className: "flex p-4" }),
                /* @__PURE__ */ g.jsxs("ul", { className: "flex flex-col items-center gap-4 p-4", children: [
                  /* @__PURE__ */ g.jsx("li", { className: "empty:hidden", children: /* @__PURE__ */ g.jsx(_t.Target, { name: "top-navigation-side" }) }),
                  o && /* @__PURE__ */ g.jsx(
                    Zt,
                    {
                      fallback: /* @__PURE__ */ g.jsx(Pr, { className: "rounded-sm h-5 w-24 mr-4" }),
                      children: a ? Object.values(u()).length > 0 && /* @__PURE__ */ g.jsxs("li", { children: [
                        i?.name ? `${i.name}` : "My Account",
                        i?.email && /* @__PURE__ */ g.jsx("div", { className: "font-normal text-muted-foreground", children: i.email })
                      ] }) : /* @__PURE__ */ g.jsx("li", { children: /* @__PURE__ */ g.jsx(
                        wr,
                        {
                          to: "/signin",
                          onClick: () => c(!1),
                          children: "Login"
                        }
                      ) })
                    }
                  ),
                  f.map(
                    (m) => m.type === "separator" ? /* @__PURE__ */ g.jsx(cu, { className: "w-full" }, m.label) : m.type !== "section" && m.type !== "filter" ? /* @__PURE__ */ g.jsx("li", { children: /* @__PURE__ */ g.jsx("button", { type: "button", onClick: () => c(!1), children: /* @__PURE__ */ g.jsx(no, { ...m }) }) }, m.label) : null
                  ),
                  o && a && d.length > 0 && /* @__PURE__ */ g.jsx(
                    Zt,
                    {
                      fallback: /* @__PURE__ */ g.jsx(Pr, { className: "rounded-sm h-5 w-24 mr-4" }),
                      children: d.map((m) => /* @__PURE__ */ g.jsx("li", { children: /* @__PURE__ */ g.jsx(
                        wr,
                        {
                          to: m.path ?? "",
                          onClick: () => c(!1),
                          children: m.label
                        }
                      ) }, m.label))
                    }
                  ),
                  /* @__PURE__ */ g.jsx("li", { children: /* @__PURE__ */ g.jsx(eo, {}) })
                ] })
              ] }),
              r?.showPoweredBy !== !1 && /* @__PURE__ */ g.jsx(Zg, { className: "grow-0 justify-center gap-1" })
            ] })
          }
        )
      ]
    }
  );
}, Sn = ({ item: e }) => e.children ? /* @__PURE__ */ g.jsxs(cl, { children: [
  /* @__PURE__ */ g.jsx(fl, { children: e.label }),
  /* @__PURE__ */ g.jsx(dl, { children: /* @__PURE__ */ g.jsx(hl, { children: e.children.map((t) => /* @__PURE__ */ g.jsx(Sn, { item: t }, t.label)) }) })
] }, e.label) : /* @__PURE__ */ g.jsx(Br, { to: e.path ?? "", children: /* @__PURE__ */ g.jsxs(ml, { className: "flex gap-2", children: [
  e.icon && /* @__PURE__ */ g.jsx(e.icon, { size: 16, strokeWidth: 1, absoluteStrokeWidth: !0 }),
  e.label
] }, e.label) }), hT = Fn(function() {
  const t = Xt(), { isAuthenticated: n, profile: r, isAuthEnabled: u } = Xt(), a = et(), {
    options: { plugins: i = [], site: o, basePath: l }
  } = a, c = i.filter((h) => Qi(h)).flatMap((h) => h.getProfileMenuItems(a)).sort((h) => h.weight ?? 0), d = o?.logo ? /https?:\/\//.test(o.logo.src.light) ? o.logo.src.light : Je(l, o.logo.src.light) : void 0, f = o?.logo ? /https?:\/\//.test(o.logo.src.dark) ? o.logo.src.dark : Je(l, o.logo.src.dark) : void 0, m = "inset-shadow-[0_-1px_0_0_var(--border)]";
  return /* @__PURE__ */ g.jsxs(
    "header",
    {
      className: "sticky lg:top-0 z-10 bg-background/80 backdrop-blur w-full",
      "data-pagefind-ignore": "all",
      children: [
        /* @__PURE__ */ g.jsx(Xg, {}),
        /* @__PURE__ */ g.jsxs("div", { className: ie(m, "relative"), children: [
          /* @__PURE__ */ g.jsx(Js, {}),
          /* @__PURE__ */ g.jsxs("div", { className: "max-w-screen-2xl mx-auto flex items-center justify-between h-(--top-header-height) px-4 lg:px-8 border-transparent", children: [
            /* @__PURE__ */ g.jsx("div", { className: "flex", children: /* @__PURE__ */ g.jsx(Br, { to: o?.logo?.href ?? "/", children: /* @__PURE__ */ g.jsx("div", { className: "flex items-center gap-3.5", children: o?.logo ? /* @__PURE__ */ g.jsxs(g.Fragment, { children: [
              /* @__PURE__ */ g.jsx(
                "img",
                {
                  src: d,
                  alt: o.logo.alt ?? o.title,
                  style: { width: o.logo.width },
                  className: "max-h-(--top-header-height) dark:hidden",
                  loading: "lazy"
                }
              ),
              /* @__PURE__ */ g.jsx(
                "img",
                {
                  src: f,
                  alt: o.logo.alt ?? o.title,
                  style: { width: o.logo.width },
                  className: "max-h-(--top-header-height) hidden dark:block",
                  loading: "lazy"
                }
              )
            ] }) : /* @__PURE__ */ g.jsx("span", { className: "font-semibold text-2xl", children: o?.title }) }) }) }),
            /* @__PURE__ */ g.jsx("div", { className: "absolute inset-x-0 justify-center items-center hidden lg:flex w-full pointer-events-none", children: /* @__PURE__ */ g.jsx(Qs, { className: "pointer-events-auto" }) }),
            /* @__PURE__ */ g.jsxs("div", { className: "flex items-center gap-8", children: [
              /* @__PURE__ */ g.jsx(dT, {}),
              /* @__PURE__ */ g.jsxs("div", { className: "hidden lg:flex items-center justify-self-end text-sm gap-2", children: [
                /* @__PURE__ */ g.jsx(_t.Target, { name: "head-navigation-start" }),
                u && /* @__PURE__ */ g.jsx(
                  Zt,
                  {
                    fallback: /* @__PURE__ */ g.jsx(Pr, { className: "rounded-sm h-5 w-24 mr-4" }),
                    children: n ? Object.values(c).length > 0 && /* @__PURE__ */ g.jsxs(al, { modal: !1, children: [
                      /* @__PURE__ */ g.jsx(sl, { asChild: !0, children: /* @__PURE__ */ g.jsx(Nn, { variant: "ghost", children: r?.name ?? "My Account" }) }),
                      /* @__PURE__ */ g.jsxs(ol, { className: "w-56", children: [
                        /* @__PURE__ */ g.jsxs(ll, { children: [
                          r?.name ? `${r.name}` : "My Account",
                          r?.email && /* @__PURE__ */ g.jsx("div", { className: "font-normal text-muted-foreground", children: r.email })
                        ] }),
                        c.filter((h) => h.category === "top").length > 0 && /* @__PURE__ */ g.jsx(Kn, {}),
                        c.filter((h) => h.category === "top").map((h) => /* @__PURE__ */ g.jsx(Sn, { item: h }, h.label)),
                        c.filter(
                          (h) => !h.category || h.category === "middle"
                        ).length > 0 && /* @__PURE__ */ g.jsx(Kn, {}),
                        c.filter(
                          (h) => !h.category || h.category === "middle"
                        ).map((h) => /* @__PURE__ */ g.jsx(Sn, { item: h }, h.label)),
                        c.filter((h) => h.category === "bottom").length > 0 && /* @__PURE__ */ g.jsx(Kn, {}),
                        c.filter((h) => h.category === "bottom").map((h) => /* @__PURE__ */ g.jsx(Sn, { item: h }, h.label))
                      ] })
                    ] }) : /* @__PURE__ */ g.jsx(Nn, { variant: "ghost", onClick: () => t.login(), children: "Login" })
                  }
                ),
                /* @__PURE__ */ g.jsx(_t.Target, { name: "head-navigation-end" }),
                /* @__PURE__ */ g.jsx(eo, {})
              ] })
            ] })
          ] })
        ] }),
        /* @__PURE__ */ g.jsx("div", { className: ie("hidden lg:block", m), children: /* @__PURE__ */ g.jsxs("div", { className: "max-w-screen-2xl mx-auto border-transparent relative", children: [
          /* @__PURE__ */ g.jsx(_t.Target, { name: "top-navigation-before" }),
          /* @__PURE__ */ g.jsx(fT, {}),
          /* @__PURE__ */ g.jsx(_t.Target, { name: "top-navigation-after" })
        ] }) })
      ]
    }
  );
}), ro = {
  Header: hT
}, mT = nn(ro), pT = mT.Provider, ET = () => {
  const e = kt(), t = et(), n = Se(void 0);
  return ge(() => {
    t.emitEvent("location", {
      from: n.current,
      to: e
    }), n.current = e;
  }, [t, e]), null;
}, gT = ({
  children: e,
  context: t
}) => (_l({
  queryFn: async () => (await t.initialize(), !0),
  queryKey: ["zudoku-initialize", Fo]
}), /* @__PURE__ */ g.jsx(Po.Provider, { value: t, children: e }));
let Yi;
const uo = Fn(
  ({
    children: e,
    env: t,
    ...n
  }) => {
    const r = ft(
      () => ({ ...ro, ...n.overrides }),
      [n.overrides]
    ), u = kt(), a = ft(() => ({
      ...(n.plugins ?? []).filter(Oo).flatMap(
        (m) => m.getMdxComponents ? [m.getMdxComponents()] : []
      ).reduce(
        (m, h) => ({ ...m, ...h }),
        {}
      ),
      ...Ys,
      ...n.mdx?.components
    }), [n.mdx?.components, n.plugins]), [i, o] = De(!1), l = Wi(), c = fo();
    ge(() => {
      i || !l.location || o(!0);
    }, [i, l.location]), Yi ??= new Wg(n, c, t);
    const d = n.plugins?.flatMap(
      (f) => Lo(f) ? f.getHead?.({ location: u }) ?? [] : []
    );
    return /* @__PURE__ */ g.jsxs(g.Fragment, { children: [
      /* @__PURE__ */ g.jsx(ho, { children: d }),
      /* @__PURE__ */ g.jsx(gT, { context: Yi, children: /* @__PURE__ */ g.jsxs(Mr, { fallback: /* @__PURE__ */ g.jsx("div", { children: "Zudoku Loading..." }), children: [
        /* @__PURE__ */ g.jsx(ET, {}),
        /* @__PURE__ */ g.jsx(Hg, { slots: n.slots ?? n.UNSAFE_slotlets, children: /* @__PURE__ */ g.jsx(il, { components: a, children: /* @__PURE__ */ g.jsx(po, { attribute: "class", disableTransitionOnChange: !0, children: /* @__PURE__ */ g.jsx(pT, { value: r, children: /* @__PURE__ */ g.jsx(Ll, { children: e ?? /* @__PURE__ */ g.jsx(Co, {}) }) }) }) }) })
      ] }) })
    ] });
  }
);
uo.displayName = "ZudokuInner";
const TT = (e) => /* @__PURE__ */ g.jsx(zg, { FallbackComponent: Kg, children: /* @__PURE__ */ g.jsx(uo, { ...e }) });
TT.displayName = "Zudoku";
export {
  qs as A,
  Gg as D,
  zg as E,
  ot as H,
  wg as I,
  Ws as M,
  KT as N,
  Zg as P,
  Qs as S,
  Vs as T,
  TT as Z,
  _t as a,
  Pg as b,
  cu as c,
  Og as d,
  Ap as e,
  XT as f,
  ME as g,
  hT as h,
  $g as i,
  BE as j,
  FE as k,
  vE as l,
  cT as m,
  Lg as s,
  Hr as u
};
//# sourceMappingURL=Zudoku-BPvTuMy8.js.map
