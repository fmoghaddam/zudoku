import { j as O } from "./jsx-runtime-BzflLqGi.js";
import { E as le } from "./Zudoku-BPvTuMy8.js";
import { C as pe } from "./ClientOnly-E7hGysn1.js";
import { j as me } from "./ZudokuContext-Mfno-z8f.js";
import { C as _e, A as g } from "./errors-Bbk86Y_Y.js";
import { C as we, O as ge } from "./OAuthErrorPage-CVyXV7cI.js";
import { u as w } from "./ZudokuReactContext-DGJAP1sN.js";
let W;
(typeof navigator > "u" || !navigator.userAgent?.startsWith?.("Mozilla/5.0 ")) && (W = "oauth4webapi/v3.8.3");
function v(t, e) {
  if (t == null)
    return !1;
  try {
    return t instanceof e || Object.getPrototypeOf(t)[Symbol.toStringTag] === e.prototype[Symbol.toStringTag];
  } catch {
    return !1;
  }
}
const _ = "ERR_INVALID_ARG_VALUE", m = "ERR_INVALID_ARG_TYPE";
function f(t, e, n) {
  const r = new TypeError(t, { cause: n });
  return Object.assign(r, { code: e }), r;
}
const N = Symbol(), te = Symbol(), ye = Symbol(), B = Symbol(), Te = new TextEncoder(), Re = new TextDecoder();
function j(t) {
  return typeof t == "string" ? Te.encode(t) : Re.decode(t);
}
let H;
Uint8Array.prototype.toBase64 ? H = (t) => (t instanceof ArrayBuffer && (t = new Uint8Array(t)), t.toBase64({ alphabet: "base64url", omitPadding: !0 })) : H = (e) => {
  e instanceof ArrayBuffer && (e = new Uint8Array(e));
  const n = [];
  for (let r = 0; r < e.byteLength; r += 32768)
    n.push(String.fromCharCode.apply(null, e.subarray(r, r + 32768)));
  return btoa(n.join("")).replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
};
let z;
Uint8Array.fromBase64 ? z = (t) => {
  try {
    return Uint8Array.fromBase64(t, { alphabet: "base64url" });
  } catch (e) {
    throw f("The input to be decoded is not correctly encoded.", _, e);
  }
} : z = (t) => {
  try {
    const e = atob(t.replace(/-/g, "+").replace(/_/g, "/").replace(/\s/g, "")), n = new Uint8Array(e.length);
    for (let r = 0; r < e.length; r++)
      n[r] = e.charCodeAt(r);
    return n;
  } catch (e) {
    throw f("The input to be decoded is not correctly encoded.", _, e);
  }
};
function P(t) {
  return typeof t == "string" ? z(t) : H(t);
}
class U extends Error {
  code;
  constructor(e, n) {
    super(e, n), this.name = this.constructor.name, this.code = lt, Error.captureStackTrace?.(this, this.constructor);
  }
}
class Se extends Error {
  code;
  constructor(e, n) {
    super(e, n), this.name = this.constructor.name, n?.code && (this.code = n?.code), Error.captureStackTrace?.(this, this.constructor);
  }
}
function c(t, e, n) {
  return new Se(t, { code: e, cause: n });
}
function I(t) {
  return !(t === null || typeof t != "object" || Array.isArray(t));
}
function C(t) {
  v(t, Headers) && (t = Object.fromEntries(t.entries()));
  const e = new Headers(t ?? {});
  if (W && !e.has("user-agent") && e.set("user-agent", W), e.has("authorization"))
    throw f('"options.headers" must not include the "authorization" header name', _);
  return e;
}
function F(t, e) {
  if (e !== void 0) {
    if (typeof e == "function" && (e = e(t.href)), !(e instanceof AbortSignal))
      throw f('"options.signal" must return or be an instance of AbortSignal', m);
    return e;
  }
}
function ne(t) {
  return t.includes("//") ? t.replace("//", "/") : t;
}
function be(t, e, n = !1) {
  return t.pathname === "/" ? t.pathname = e : t.pathname = ne(`${e}/${n ? t.pathname : t.pathname.replace(/(\/)$/, "")}`), t;
}
function Ae(t, e) {
  return t.pathname = ne(`${t.pathname}/${e}`), t;
}
async function Ee(t, e, n, r) {
  if (!(t instanceof URL))
    throw f(`"${e}" must be an instance of URL`, m);
  q(t, r?.[N] !== !0);
  const s = n(new URL(t.href)), a = C(r?.headers);
  return a.set("accept", "application/json"), (r?.[B] || fetch)(s.href, {
    body: void 0,
    headers: Object.fromEntries(a.entries()),
    method: "GET",
    redirect: "manual",
    signal: F(s, r?.signal)
  });
}
async function Oe(t, e) {
  return Ee(t, "issuerIdentifier", (n) => {
    switch (e?.algorithm) {
      case void 0:
      case "oidc":
        Ae(n, ".well-known/openid-configuration");
        break;
      case "oauth2":
        be(n, ".well-known/oauth-authorization-server");
        break;
      default:
        throw f('"options.algorithm" must be "oidc" (default), or "oauth2"', _);
    }
    return n;
  }, e);
}
function k(t, e, n, r, s) {
  try {
    if (typeof t != "number" || !Number.isFinite(t))
      throw f(`${n} must be a number`, m, s);
    if (t > 0)
      return;
    if (e) {
      if (t !== 0)
        throw f(`${n} must be a non-negative number`, _, s);
      return;
    }
    throw f(`${n} must be a positive number`, _, s);
  } catch (a) {
    throw r ? c(a.message, r, s) : a;
  }
}
function p(t, e, n, r) {
  try {
    if (typeof t != "string")
      throw f(`${e} must be a string`, m, r);
    if (t.length === 0)
      throw f(`${e} must not be empty`, _, r);
  } catch (s) {
    throw n ? c(s.message, n, r) : s;
  }
}
async function ke(t, e) {
  const n = t;
  if (!(n instanceof URL) && n !== X)
    throw f('"expectedIssuerIdentifier" must be an instance of URL', m);
  if (!v(e, Response))
    throw f('"response" must be an instance of Response', m);
  if (e.status !== 200)
    throw c('"response" is not a conform Authorization Server Metadata response (unexpected HTTP status code)', he, e);
  K(e);
  const r = await fe(e);
  if (p(r.issuer, '"response" body "issuer" property', h, { body: r }), n !== X && new URL(r.issuer).href !== n.href)
    throw c('"response" body "issuer" property does not match the expected value', gt, { expected: n.href, body: r, attribute: "issuer" });
  return r;
}
function re(t) {
  Ue(t, "application/json");
}
function Pe(t, ...e) {
  let n = '"response" content-type must be ';
  if (e.length > 2) {
    const r = e.pop();
    n += `${e.join(", ")}, or ${r}`;
  } else e.length === 2 ? n += `${e[0]} or ${e[1]}` : n += e[0];
  return c(n, mt, t);
}
function Ue(t, e) {
  if (Ye(t) !== e)
    throw Pe(t, e);
}
function se() {
  return P(crypto.getRandomValues(new Uint8Array(32)));
}
function Ie() {
  return se();
}
function xe() {
  return se();
}
async function ve(t) {
  return p(t, "codeVerifier"), P(await crypto.subtle.digest("SHA-256", j(t)));
}
function V(t) {
  const e = t?.[te];
  return typeof e == "number" && Number.isFinite(e) ? e : 0;
}
function oe(t) {
  const e = t?.[ye];
  return typeof e == "number" && Number.isFinite(e) && Math.sign(e) !== -1 ? e : 30;
}
function ae() {
  return Math.floor(Date.now() / 1e3);
}
function b(t) {
  if (typeof t != "object" || t === null)
    throw f('"as" must be an object', m);
  p(t.issuer, '"as.issuer"');
}
function A(t) {
  if (typeof t != "object" || t === null)
    throw f('"client" must be an object', m);
  p(t.client_id, '"client.client_id"');
}
function D() {
  return (t, e, n, r) => {
    n.set("client_id", e.client_id);
  };
}
const Ne = URL.parse ? (t, e) => URL.parse(t, e) : (t, e) => {
  try {
    return new URL(t, e);
  } catch {
    return null;
  }
};
function q(t, e) {
  if (e && t.protocol !== "https:")
    throw c("only requests to HTTPS are allowed", _t, t);
  if (t.protocol !== "https:" && t.protocol !== "http:")
    throw c("only HTTP and HTTPS requests are allowed", wt, t);
}
function Z(t, e, n, r) {
  let s;
  if (typeof t != "string" || !(s = Ne(t)))
    throw c(`authorization server metadata does not contain a valid ${n ? `"as.mtls_endpoint_aliases.${e}"` : `"as.${e}"`}`, t === void 0 ? yt : Tt, { attribute: n ? `mtls_endpoint_aliases.${e}` : e });
  return q(s, r), s;
}
function ie(t, e, n, r) {
  return n && t.mtls_endpoint_aliases && e in t.mtls_endpoint_aliases ? Z(t.mtls_endpoint_aliases[e], e, n, r) : Z(t[e], e, n, r);
}
class Ce extends Error {
  cause;
  code;
  error;
  status;
  error_description;
  response;
  constructor(e, n) {
    super(e, n), this.name = this.constructor.name, this.code = ft, this.cause = n.cause, this.error = n.cause.error, this.status = n.response.status, this.error_description = n.cause.error_description, Object.defineProperty(this, "response", { enumerable: !1, value: n.response }), Error.captureStackTrace?.(this, this.constructor);
  }
}
class De extends Error {
  cause;
  code;
  error;
  error_description;
  constructor(e, n) {
    super(e, n), this.name = this.constructor.name, this.code = pt, this.cause = n.cause, this.error = n.cause.get("error"), this.error_description = n.cause.get("error_description") ?? void 0, Error.captureStackTrace?.(this, this.constructor);
  }
}
class Le extends Error {
  cause;
  code;
  response;
  status;
  constructor(e, n) {
    super(e, n), this.name = this.constructor.name, this.code = ht, this.cause = n.cause, this.status = n.response.status, this.response = n.response, Object.defineProperty(this, "response", { enumerable: !1 }), Error.captureStackTrace?.(this, this.constructor);
  }
}
const x = "[a-zA-Z0-9!#$%&\\'\\*\\+\\-\\.\\^_`\\|~]+", Je = "[a-zA-Z0-9\\-\\._\\~\\+\\/]+={0,2}", We = '"((?:[^"\\\\]|\\\\[\\s\\S])*)"', je = "(" + x + ")\\s*=\\s*" + We, He = "(" + x + ")\\s*=\\s*(" + x + ")", ze = new RegExp("^[,\\s]*(" + x + ")"), $e = new RegExp("^[,\\s]*" + je + "[,\\s]*(.*)"), Me = new RegExp("^[,\\s]*" + He + "[,\\s]*(.*)"), Be = new RegExp("^(" + Je + ")(?:$|[,\\s])(.*)");
function Fe(t) {
  if (!v(t, Response))
    throw f('"response" must be an instance of Response', m);
  const e = t.headers.get("www-authenticate");
  if (e === null)
    return;
  const n = [];
  let r = e;
  for (; r; ) {
    let s = r.match(ze);
    const a = s?.[1].toLowerCase();
    if (!a)
      return;
    const o = r.substring(s[0].length);
    if (o && !o.match(/^[\s,]/))
      return;
    const d = o.match(/^\s+(.*)$/), i = !!d;
    r = d ? d[1] : void 0;
    const u = {};
    let l;
    if (i)
      for (; r; ) {
        let E, y;
        if (s = r.match($e)) {
          if ([, E, y, r] = s, y.includes("\\"))
            try {
              y = JSON.parse(`"${y}"`);
            } catch {
            }
          u[E.toLowerCase()] = y;
          continue;
        }
        if (s = r.match(Me)) {
          [, E, y, r] = s, u[E.toLowerCase()] = y;
          continue;
        }
        if (s = r.match(Be)) {
          if (Object.keys(u).length)
            break;
          [, l, r] = s;
          break;
        }
        return;
      }
    else
      r = o || void 0;
    const R = { scheme: a, parameters: u };
    l && (R.token68 = l), n.push(R);
  }
  if (n.length)
    return n;
}
async function Ve(t) {
  if (t.status > 399 && t.status < 500) {
    K(t), re(t);
    try {
      const e = await t.clone().json();
      if (I(e) && typeof e.error == "string" && e.error.length)
        return e;
    } catch {
    }
  }
}
async function qe(t, e, n) {
  if (t.status !== e) {
    tt(t);
    let r;
    throw (r = await Ve(t)) ? (await t.body?.cancel(), new Ce("server responded with an error in the response body", {
      cause: r,
      response: t
    })) : c(`"response" is not a conform ${n} response (unexpected HTTP status code)`, he, t);
  }
}
function Ge(t) {
  if (!G.has(t))
    throw f('"options.DPoP" is not a valid DPoPHandle', _);
}
async function Ke(t, e, n, r, s, a) {
  if (p(t, '"accessToken"'), !(n instanceof URL))
    throw f('"url" must be an instance of URL', m);
  q(n, a?.[N] !== !0), r = C(r), a?.DPoP && (Ge(a.DPoP), await a.DPoP.addProof(n, r, e.toUpperCase(), t)), r.set("authorization", `${r.has("dpop") ? "DPoP" : "Bearer"} ${t}`);
  const o = await (a?.[B] || fetch)(n.href, {
    body: s,
    headers: Object.fromEntries(r.entries()),
    method: e,
    redirect: "manual",
    signal: F(n, a?.signal)
  });
  return a?.DPoP?.cacheNonce(o, n), o;
}
async function Ze(t, e, n, r) {
  b(t), A(e);
  const s = ie(t, "userinfo_endpoint", e.use_mtls_endpoint_aliases, r?.[N] !== !0), a = C(r?.headers);
  return e.userinfo_signed_response_alg ? a.set("accept", "application/jwt") : (a.set("accept", "application/json"), a.append("accept", "application/jwt")), Ke(n, "GET", s, a, null, {
    ...r,
    [te]: V(e)
  });
}
function Ye(t) {
  return t.headers.get("content-type")?.split(";")[0];
}
async function Qe(t, e, n, r, s, a, o) {
  return await n(t, e, s, a), a.set("content-type", "application/x-www-form-urlencoded;charset=UTF-8"), (o?.[B] || fetch)(r.href, {
    body: s,
    headers: Object.fromEntries(a.entries()),
    method: "POST",
    redirect: "manual",
    signal: F(r, o?.signal)
  });
}
async function ce(t, e, n, r, s, a) {
  const o = ie(t, "token_endpoint", e.use_mtls_endpoint_aliases, a?.[N] !== !0);
  s.set("grant_type", r);
  const d = C(a?.headers);
  return d.set("accept", "application/json"), await Qe(t, e, n, o, s, d, a);
}
async function Y(t, e, n, r, s) {
  b(t), A(e), p(r, '"refreshToken"');
  const a = new URLSearchParams(s?.additionalParameters);
  return a.set("refresh_token", r), ce(t, e, n, "refresh_token", a, s);
}
const ue = /* @__PURE__ */ new WeakMap(), Xe = /* @__PURE__ */ new WeakMap();
function et(t) {
  if (!t.id_token)
    return;
  const e = ue.get(t);
  if (!e)
    throw f('"ref" was already garbage collected or did not resolve from the proper sources', _);
  return e;
}
async function de(t, e, n, r, s, a) {
  if (b(t), A(e), !v(n, Response))
    throw f('"response" must be an instance of Response', m);
  await qe(n, 200, "Token Endpoint"), K(n);
  const o = await fe(n);
  if (p(o.access_token, '"response" body "access_token" property', h, {
    body: o
  }), p(o.token_type, '"response" body "token_type" property', h, {
    body: o
  }), o.token_type = o.token_type.toLowerCase(), o.expires_in !== void 0) {
    let d = typeof o.expires_in != "number" ? parseFloat(o.expires_in) : o.expires_in;
    k(d, !0, '"response" body "expires_in" property', h, {
      body: o
    }), o.expires_in = d;
  }
  if (o.refresh_token !== void 0 && p(o.refresh_token, '"response" body "refresh_token" property', h, {
    body: o
  }), o.scope !== void 0 && typeof o.scope != "string")
    throw c('"response" body "scope" property must be a string', h, { body: o });
  if (o.id_token !== void 0) {
    p(o.id_token, '"response" body "id_token" property', h, {
      body: o
    });
    const d = ["aud", "exp", "iat", "iss", "sub"];
    e.require_auth_time === !0 && d.push("auth_time"), e.default_max_age !== void 0 && (k(e.default_max_age, !0, '"client.default_max_age"'), d.push("auth_time"));
    const { claims: i, jwt: u } = await Rt(o.id_token, St.bind(void 0, e.id_token_signed_response_alg, t.id_token_signing_alg_values_supported, "RS256"), V(e), oe(e)).then(ct.bind(void 0, d)).then(rt.bind(void 0, t)).then(nt.bind(void 0, e.client_id));
    if (Array.isArray(i.aud) && i.aud.length !== 1) {
      if (i.azp === void 0)
        throw c('ID Token "aud" (audience) claim includes additional untrusted audiences', S, { claims: i, claim: "aud" });
      if (i.azp !== e.client_id)
        throw c('unexpected ID Token "azp" (authorized party) claim value', S, { expected: e.client_id, claims: i, claim: "azp" });
    }
    i.auth_time !== void 0 && k(i.auth_time, !0, 'ID Token "auth_time" (authentication time)', h, { claims: i }), Xe.set(n, u), ue.set(o, i);
  }
  if (o.token_type !== "dpop" && o.token_type !== "bearer")
    throw new U("unsupported `token_type` value", { cause: { body: o } });
  return o;
}
function tt(t) {
  let e;
  if (e = Fe(t))
    throw new Le("server responded with a challenge in the WWW-Authenticate HTTP Header", { cause: e, response: t });
}
async function Q(t, e, n, r) {
  return de(t, e, n);
}
function nt(t, e) {
  if (Array.isArray(e.claims.aud)) {
    if (!e.claims.aud.includes(t))
      throw c('unexpected JWT "aud" (audience) claim value', S, {
        expected: t,
        claims: e.claims,
        claim: "aud"
      });
  } else if (e.claims.aud !== t)
    throw c('unexpected JWT "aud" (audience) claim value', S, {
      expected: t,
      claims: e.claims,
      claim: "aud"
    });
  return e;
}
function rt(t, e) {
  const n = t[Ot]?.(e) ?? t.issuer;
  if (e.claims.iss !== n)
    throw c('unexpected JWT "iss" (issuer) claim value', S, {
      expected: n,
      claims: e.claims,
      claim: "iss"
    });
  return e;
}
const G = /* @__PURE__ */ new WeakSet();
function st(t) {
  return G.add(t), t;
}
const ot = Symbol();
async function at(t, e, n, r, s, a, o) {
  if (b(t), A(e), !G.has(r))
    throw f('"callbackParameters" must be an instance of URLSearchParams obtained from "validateAuthResponse()", or "validateJwtAuthResponse()', _);
  p(s, '"redirectUri"');
  const d = T(r, "code");
  if (!d)
    throw c('no authorization code in "callbackParameters"', h);
  const i = new URLSearchParams(o?.additionalParameters);
  return i.set("redirect_uri", s), i.set("code", d), a !== ot && (p(a, '"codeVerifier"'), i.set("code_verifier", a)), ce(t, e, n, "authorization_code", i, o);
}
const it = {
  aud: "audience",
  c_hash: "code hash",
  client_id: "client id",
  exp: "expiration time",
  iat: "issued at",
  iss: "issuer",
  jti: "jwt id",
  nonce: "nonce",
  s_hash: "state hash",
  sub: "subject",
  ath: "access token hash",
  htm: "http method",
  htu: "http uri",
  cnf: "confirmation",
  auth_time: "authentication time"
};
function ct(t, e) {
  for (const n of t)
    if (e.claims[n] === void 0)
      throw c(`JWT "${n}" (${it[n]}) claim missing`, h, {
        claims: e.claims
      });
  return e;
}
async function ut(t, e, n, r) {
  return dt(t, e, n);
}
async function dt(t, e, n, r, s) {
  const a = await de(t, e, n), o = et(a);
  if (o) {
    if (e.default_max_age !== void 0) {
      k(e.default_max_age, !0, '"client.default_max_age"');
      const d = ae() + V(e), i = oe(e);
      if (o.auth_time + e.default_max_age < d - i)
        throw c("too much time has elapsed since the last End-User authentication", M, { claims: o, now: d, tolerance: i, claim: "auth_time" });
    }
    if (o.nonce !== void 0)
      throw c('unexpected ID Token "nonce" claim value', S, {
        expected: void 0,
        claims: o,
        claim: "nonce"
      });
  }
  return a;
}
const ht = "OAUTH_WWW_AUTHENTICATE_CHALLENGE", ft = "OAUTH_RESPONSE_BODY_ERROR", lt = "OAUTH_UNSUPPORTED_OPERATION", pt = "OAUTH_AUTHORIZATION_RESPONSE_ERROR", $ = "OAUTH_PARSE_ERROR", h = "OAUTH_INVALID_RESPONSE", mt = "OAUTH_RESPONSE_IS_NOT_JSON", he = "OAUTH_RESPONSE_IS_NOT_CONFORM", _t = "OAUTH_HTTP_REQUEST_FORBIDDEN", wt = "OAUTH_REQUEST_PROTOCOL_FORBIDDEN", M = "OAUTH_JWT_TIMESTAMP_CHECK_FAILED", S = "OAUTH_JWT_CLAIM_COMPARISON_FAILED", gt = "OAUTH_JSON_ATTRIBUTE_COMPARISON_FAILED", yt = "OAUTH_MISSING_SERVER_METADATA", Tt = "OAUTH_INVALID_SERVER_METADATA";
function K(t) {
  if (t.bodyUsed)
    throw f('"response" body has been used already', _);
}
async function Rt(t, e, n, r, s) {
  let { 0: a, 1: o, length: d } = t.split(".");
  if (d === 5)
    throw new U("JWE decryption is not configured", { cause: t });
  if (d !== 3)
    throw c("Invalid JWT", h, t);
  let i;
  try {
    i = JSON.parse(j(P(a)));
  } catch (R) {
    throw c("failed to parse JWT Header body as base64url encoded JSON", $, R);
  }
  if (!I(i))
    throw c("JWT Header must be a top level object", h, t);
  if (e(i), i.crit !== void 0)
    throw new U('no JWT "crit" header parameter extensions are supported', {
      cause: { header: i }
    });
  let u;
  try {
    u = JSON.parse(j(P(o)));
  } catch (R) {
    throw c("failed to parse JWT Payload body as base64url encoded JSON", $, R);
  }
  if (!I(u))
    throw c("JWT Payload must be a top level object", h, t);
  const l = ae() + n;
  if (u.exp !== void 0) {
    if (typeof u.exp != "number")
      throw c('unexpected JWT "exp" (expiration time) claim type', h, { claims: u });
    if (u.exp <= l - r)
      throw c('unexpected JWT "exp" (expiration time) claim value, expiration is past current timestamp', M, { claims: u, now: l, tolerance: r, claim: "exp" });
  }
  if (u.iat !== void 0 && typeof u.iat != "number")
    throw c('unexpected JWT "iat" (issued at) claim type', h, { claims: u });
  if (u.iss !== void 0 && typeof u.iss != "string")
    throw c('unexpected JWT "iss" (issuer) claim type', h, { claims: u });
  if (u.nbf !== void 0) {
    if (typeof u.nbf != "number")
      throw c('unexpected JWT "nbf" (not before) claim type', h, { claims: u });
    if (u.nbf > l + r)
      throw c('unexpected JWT "nbf" (not before) claim value', M, {
        claims: u,
        now: l,
        tolerance: r,
        claim: "nbf"
      });
  }
  if (u.aud !== void 0 && typeof u.aud != "string" && !Array.isArray(u.aud))
    throw c('unexpected JWT "aud" (audience) claim type', h, { claims: u });
  return { header: i, claims: u, jwt: t };
}
function St(t, e, n, r) {
  if (t !== void 0) {
    if (typeof t == "string" ? r.alg !== t : !t.includes(r.alg))
      throw c('unexpected JWT "alg" header parameter', h, {
        header: r,
        expected: t,
        reason: "client configuration"
      });
    return;
  }
  if (Array.isArray(e)) {
    if (!e.includes(r.alg))
      throw c('unexpected JWT "alg" header parameter', h, {
        header: r,
        expected: e,
        reason: "authorization server metadata"
      });
    return;
  }
  if (n !== void 0) {
    if (typeof n == "string" ? r.alg !== n : typeof n == "function" ? !n(r.alg) : !n.includes(r.alg))
      throw c('unexpected JWT "alg" header parameter', h, {
        header: r,
        expected: n,
        reason: "default value"
      });
    return;
  }
  throw c('missing client or server configuration to verify used JWT "alg" header parameter', void 0, { client: t, issuer: e, fallback: n });
}
function T(t, e) {
  const { 0: n, length: r } = t.getAll(e);
  if (r > 1)
    throw c(`"${e}" parameter must be provided only once`, h);
  return n;
}
const bt = Symbol(), At = Symbol();
function Et(t, e, n, r) {
  if (b(t), A(e), n instanceof URL && (n = n.searchParams), !(n instanceof URLSearchParams))
    throw f('"parameters" must be an instance of URLSearchParams, or URL', m);
  if (T(n, "response"))
    throw c('"parameters" contains a JARM response, use validateJwtAuthResponse() instead of validateAuthResponse()', h, { parameters: n });
  const s = T(n, "iss"), a = T(n, "state");
  if (!s && t.authorization_response_iss_parameter_supported)
    throw c('response parameter "iss" (issuer) missing', h, { parameters: n });
  if (s && s !== t.issuer)
    throw c('unexpected "iss" (issuer) response parameter value', h, {
      expected: t.issuer,
      parameters: n
    });
  switch (r) {
    case void 0:
    case At:
      if (a !== void 0)
        throw c('unexpected "state" response parameter encountered', h, {
          expected: void 0,
          parameters: n
        });
      break;
    case bt:
      break;
    default:
      if (p(r, '"expectedState" argument'), a !== r)
        throw c(a === void 0 ? 'response parameter "state" missing' : 'unexpected "state" response parameter value', h, { expected: r, parameters: n });
  }
  if (T(n, "error"))
    throw new De("authorization response from the server is an error", {
      cause: n
    });
  const d = T(n, "id_token"), i = T(n, "token");
  if (d !== void 0 || i !== void 0)
    throw new U("implicit and hybrid flows are not supported");
  return st(new URLSearchParams(n));
}
async function fe(t, e = re) {
  let n;
  try {
    n = await t.json();
  } catch (r) {
    throw e(t), c('failed to parse "response" body as JSON', $, r);
  }
  if (!I(n))
    throw c('"response" body must be a top level object', h, { body: n });
  return n;
}
const X = Symbol(), Ot = Symbol(), L = "code-verifier", J = "oauth-state", ee = "/oauth/callback";
class kt extends _e {
  client;
  issuer;
  authorizationServer;
  callbackUrlPath;
  onAuthorizationUrl;
  redirectToAfterSignUp;
  redirectToAfterSignIn;
  redirectToAfterSignOut;
  audience;
  scopes;
  constructor({
    issuer: e,
    audience: n,
    clientId: r,
    redirectToAfterSignUp: s,
    redirectToAfterSignIn: a,
    redirectToAfterSignOut: o = "/",
    basePath: d,
    scopes: i
  }) {
    super(), this.client = {
      client_id: r,
      token_endpoint_auth_method: "none"
    }, this.audience = n, this.issuer = e, this.callbackUrlPath = me(d, ee), this.scopes = i ?? ["openid", "profile", "email"], this.redirectToAfterSignUp = s, this.redirectToAfterSignIn = a, this.redirectToAfterSignOut = o;
  }
  async getAuthServer() {
    if (!this.authorizationServer) {
      const e = new URL(this.issuer), n = await Oe(e);
      this.authorizationServer = await ke(
        e,
        n
      );
    }
    return this.authorizationServer;
  }
  /**
   * Sets the tokens from various OAuth responses
   * @param response
   */
  setTokensFromResponse(e) {
    if (!e.expires_in)
      throw new g("No expires_in in response");
    const n = {
      accessToken: e.access_token,
      refreshToken: e.refresh_token,
      idToken: e.id_token,
      expiresOn: new Date(Date.now() + e.expires_in * 1e3),
      tokenType: e.token_type
    };
    w.setState({
      providerData: n
    });
  }
  async signUp(e, {
    redirectTo: n,
    replace: r = !1
  } = {}) {
    return this.authorize({
      redirectTo: this.redirectToAfterSignUp ?? n ?? "/",
      replace: r,
      isSignUp: !0
    });
  }
  async signIn(e, { redirectTo: n, replace: r = !1 }) {
    return this.authorize({
      redirectTo: this.redirectToAfterSignIn ?? n ?? "/",
      replace: r
    });
  }
  async refreshUserProfile() {
    const e = await this.getAccessToken(), n = await this.getAuthServer(), s = await (await Ze(
      n,
      this.client,
      e
    )).json(), a = {
      sub: s.sub,
      email: s.email,
      name: s.name,
      emailVerified: s.email_verified ?? !1,
      pictureUrl: s.picture
    };
    return w.setState({
      isAuthenticated: !0,
      isPending: !1,
      profile: a
    }), !0;
  }
  async authorize({
    redirectTo: e,
    isSignUp: n = !1,
    replace: r = !1
  }) {
    const s = "S256", a = await this.getAuthServer();
    if (!a.authorization_endpoint)
      throw new g("No authorization endpoint");
    const o = Ie(), d = await ve(o);
    sessionStorage.setItem(L, o);
    const i = new URL(
      a.authorization_endpoint
    );
    sessionStorage.setItem("redirect-to", e);
    const u = new URL(window.location.origin);
    u.pathname = this.callbackUrlPath, u.search = "", u.hash = "", i.searchParams.set("client_id", this.client.client_id), i.searchParams.set("redirect_uri", u.toString()), i.searchParams.set("response_type", "code"), i.searchParams.set("scope", this.scopes.join(" ")), i.searchParams.set("code_challenge", d), i.searchParams.set(
      "code_challenge_method",
      s
    ), this.audience && i.searchParams.set("audience", this.audience), this.onAuthorizationUrl?.(i, {
      isSignIn: !n,
      isSignUp: n
    });
    const l = xe();
    sessionStorage.setItem(J, l), i.searchParams.set("state", l), r ? location.replace(i.href) : location.href = i.href;
  }
  async getAccessToken() {
    const e = await this.getAuthServer(), { providerData: n, setLoggedOut: r } = w.getState();
    if (!n)
      throw r(), new g("User is not authenticated");
    const s = n;
    if (new Date(s.expiresOn) < /* @__PURE__ */ new Date()) {
      if (!s.refreshToken)
        throw w.getState().setLoggedOut(), new g("No refresh token found");
      const a = await Y(
        e,
        this.client,
        D(),
        s.refreshToken
      ), o = await Q(
        e,
        this.client,
        a
      );
      if (!o.access_token)
        throw r(), new g("No access token in response");
      return this.setTokensFromResponse(o), o.access_token.toString();
    } else
      return s.accessToken;
  }
  signRequest = async (e) => {
    const n = await this.getAccessToken();
    return e.headers.set("Authorization", `Bearer ${n}`), e;
  };
  signOut = async (e) => {
    w.setState({
      isAuthenticated: !1,
      isPending: !1,
      profile: void 0,
      providerData: void 0
    });
    const n = await this.getAuthServer(), r = new URL(
      window.location.origin + this.redirectToAfterSignOut
    );
    r.pathname = this.callbackUrlPath;
    let s;
    n.end_session_endpoint ? (s = new URL(n.end_session_endpoint), s.searchParams.set(
      "post_logout_redirect_uri",
      r.toString()
    )) : s = r;
  };
  onPageLoad = async () => {
    const { providerData: e } = w.getState();
    if (!e) {
      w.setState({ isPending: !1 });
      return;
    }
    const n = e;
    if (new Date(n.expiresOn) < /* @__PURE__ */ new Date()) {
      if (!n.refreshToken) {
        w.setState({
          isAuthenticated: !1,
          isPending: !1,
          profile: null,
          providerData: null
        });
        return;
      }
      try {
        const r = await this.getAuthServer(), s = await Y(
          r,
          this.client,
          D(),
          n.refreshToken
        ), a = await Q(
          r,
          this.client,
          s
        );
        if (!a.access_token)
          throw new g("No access token in response");
        this.setTokensFromResponse(a);
      } catch {
        w.setState({
          isAuthenticated: !1,
          isPending: !1,
          profile: null,
          providerData: null
        });
        return;
      }
    }
    w.setState({ isPending: !1 });
  };
  handleCallback = async () => {
    const e = new URL(window.location.href), n = e.searchParams.get("state"), r = sessionStorage.getItem(J);
    if (sessionStorage.removeItem(J), n !== r)
      throw new g("Invalid state parameter");
    const s = sessionStorage.getItem(L);
    if (sessionStorage.removeItem(L), !s)
      throw new g("No code verifier found in state.");
    const a = await this.getAuthServer(), o = Et(
      a,
      this.client,
      e.searchParams,
      n ?? void 0
    ), d = new URL(e);
    d.pathname = this.callbackUrlPath, d.search = "", d.hash = "";
    const i = await at(
      a,
      this.client,
      D(),
      o,
      d.toString(),
      s
    ), u = await ut(
      a,
      this.client,
      i
    );
    this.setTokensFromResponse(u), await this.refreshUserProfile();
    const l = sessionStorage.getItem("redirect-to") ?? "/";
    return sessionStorage.removeItem("redirect-to"), l;
  };
  getRoutes() {
    return [
      ...super.getRoutes(),
      {
        path: ee,
        element: /* @__PURE__ */ O.jsx(pe, { children: /* @__PURE__ */ O.jsx(
          le,
          {
            fallbackRender: ({ error: e }) => /* @__PURE__ */ O.jsx(ge, { error: e }),
            children: /* @__PURE__ */ O.jsx(we, { handleCallback: this.handleCallback })
          }
        ) })
      }
    ];
  }
}
const Dt = (t) => new kt(t);
export {
  ee as OPENID_CALLBACK_PATH,
  kt as OpenIDAuthenticationProvider,
  Dt as default
};
//# sourceMappingURL=zudoku.auth-openid.js.map
