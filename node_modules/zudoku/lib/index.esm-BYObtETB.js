import m from "react";
var he = (t) => t.type === "checkbox", le = (t) => t instanceof Date, j = (t) => t == null;
const gt = (t) => typeof t == "object";
var I = (t) => !j(t) && !Array.isArray(t) && gt(t) && !le(t), ht = (t) => I(t) && t.target ? he(t.target) ? t.target.checked : t.target.value : t, Lt = (t) => t.substring(0, t.search(/\.\d+(\.|$)/)) || t, mt = (t, r) => t.has(Lt(r)), Nt = (t) => {
  const r = t.constructor && t.constructor.prototype;
  return I(r) && r.hasOwnProperty("isPrototypeOf");
}, je = typeof window < "u" && typeof window.HTMLElement < "u" && typeof document < "u";
function T(t) {
  let r;
  const e = Array.isArray(t), s = typeof FileList < "u" ? t instanceof FileList : !1;
  if (t instanceof Date)
    r = new Date(t);
  else if (!(je && (t instanceof Blob || s)) && (e || I(t)))
    if (r = e ? [] : Object.create(Object.getPrototypeOf(t)), !e && !Nt(t))
      r = t;
    else
      for (const l in t)
        t.hasOwnProperty(l) && (r[l] = T(t[l]));
  else
    return t;
  return r;
}
var Ae = (t) => /^\w*$/.test(t), U = (t) => t === void 0, xe = (t) => Array.isArray(t) ? t.filter(Boolean) : [], Ke = (t) => xe(t.replace(/["|']|\]/g, "").split(/\.|\[/)), f = (t, r, e) => {
  if (!r || !I(t))
    return e;
  const s = (Ae(r) ? [r] : Ke(r)).reduce((l, n) => j(l) ? l : l[n], t);
  return U(s) || s === t ? U(t[r]) ? e : t[r] : s;
}, G = (t) => typeof t == "boolean", R = (t, r, e) => {
  let s = -1;
  const l = Ae(r) ? [r] : Ke(r), n = l.length, d = n - 1;
  for (; ++s < n; ) {
    const c = l[s];
    let w = e;
    if (s !== d) {
      const x = t[c];
      w = I(x) || Array.isArray(x) ? x : isNaN(+l[s + 1]) ? {} : [];
    }
    if (c === "__proto__" || c === "constructor" || c === "prototype")
      return;
    t[c] = w, t = t[c];
  }
};
const be = {
  BLUR: "blur",
  FOCUS_OUT: "focusout",
  CHANGE: "change"
}, Z = {
  onBlur: "onBlur",
  onChange: "onChange",
  onSubmit: "onSubmit",
  onTouched: "onTouched",
  all: "all"
}, ie = {
  max: "max",
  min: "min",
  maxLength: "maxLength",
  minLength: "minLength",
  pattern: "pattern",
  required: "required",
  validate: "validate"
}, ze = m.createContext(null);
ze.displayName = "HookFormContext";
const pe = () => m.useContext(ze), ir = (t) => {
  const { children: r, ...e } = t;
  return m.createElement(ze.Provider, { value: e }, r);
};
var vt = (t, r, e, s = !0) => {
  const l = {
    defaultValues: r._defaultValues
  };
  for (const n in t)
    Object.defineProperty(l, n, {
      get: () => {
        const d = n;
        return r._proxyFormState[d] !== Z.all && (r._proxyFormState[d] = !s || Z.all), e && (e[d] = !0), t[d];
      }
    });
  return l;
};
const we = typeof window < "u" ? m.useLayoutEffect : m.useEffect;
function It(t) {
  const r = pe(), { control: e = r.control, disabled: s, name: l, exact: n } = t || {}, [d, c] = m.useState(e._formState), w = m.useRef({
    isDirty: !1,
    isLoading: !1,
    dirtyFields: !1,
    touchedFields: !1,
    validatingFields: !1,
    isValidating: !1,
    isValid: !1,
    errors: !1
  });
  return we(() => e._subscribe({
    name: l,
    formState: w.current,
    exact: n,
    callback: (x) => {
      !s && c({
        ...e._formState,
        ...x
      });
    }
  }), [l, s, n]), m.useEffect(() => {
    w.current.isValid && e._setValid(!0);
  }, [e]), m.useMemo(() => vt(d, e, w.current, !1), [d, e]);
}
var Y = (t) => typeof t == "string", Pe = (t, r, e, s, l) => Y(t) ? (s && r.watch.add(t), f(e, t, l)) : Array.isArray(t) ? t.map((n) => (s && r.watch.add(n), f(e, n))) : (s && (r.watchAll = !0), e), We = (t) => j(t) || !gt(t);
function ee(t, r, e = /* @__PURE__ */ new WeakSet()) {
  if (We(t) || We(r))
    return t === r;
  if (le(t) && le(r))
    return t.getTime() === r.getTime();
  const s = Object.keys(t), l = Object.keys(r);
  if (s.length !== l.length)
    return !1;
  if (e.has(t) || e.has(r))
    return !0;
  e.add(t), e.add(r);
  for (const n of s) {
    const d = t[n];
    if (!l.includes(n))
      return !1;
    if (n !== "ref") {
      const c = r[n];
      if (le(d) && le(c) || I(d) && I(c) || Array.isArray(d) && Array.isArray(c) ? !ee(d, c, e) : d !== c)
        return !1;
    }
  }
  return !0;
}
function Bt(t) {
  const r = pe(), { control: e = r.control, name: s, defaultValue: l, disabled: n, exact: d, compute: c } = t || {}, w = m.useRef(l), x = m.useRef(c), A = m.useRef(void 0), b = m.useRef(e), F = m.useRef(s);
  x.current = c;
  const [J, P] = m.useState(() => {
    const g = e._getWatch(s, w.current);
    return x.current ? x.current(g) : g;
  }), O = m.useCallback((g) => {
    const y = Pe(s, e._names, g || e._formValues, !1, w.current);
    return x.current ? x.current(y) : y;
  }, [e._formValues, e._names, s]), B = m.useCallback((g) => {
    if (!n) {
      const y = Pe(s, e._names, g || e._formValues, !1, w.current);
      if (x.current) {
        const V = x.current(y);
        ee(V, A.current) || (P(V), A.current = V);
      } else
        P(y);
    }
  }, [e._formValues, e._names, n, s]);
  we(() => ((b.current !== e || !ee(F.current, s)) && (b.current = e, F.current = s, B()), e._subscribe({
    name: s,
    formState: {
      values: !0
    },
    exact: d,
    callback: (g) => {
      B(g.values);
    }
  })), [e, d, s, B]), m.useEffect(() => e._removeUnmounted());
  const Q = b.current !== e, p = F.current, E = m.useMemo(() => {
    if (n)
      return null;
    const g = !Q && !ee(p, s);
    return Q || g ? O() : null;
  }, [n, Q, s, p, O]);
  return E !== null ? E : J;
}
function Pt(t) {
  const r = pe(), { name: e, disabled: s, control: l = r.control, shouldUnregister: n, defaultValue: d } = t, c = mt(l._names.array, e), w = m.useMemo(() => f(l._formValues, e, f(l._defaultValues, e, d)), [l, e, d]), x = Bt({
    control: l,
    name: e,
    defaultValue: w,
    exact: !0
  }), A = It({
    control: l,
    name: e,
    exact: !0
  }), b = m.useRef(t), F = m.useRef(void 0), J = m.useRef(l.register(e, {
    ...t.rules,
    value: x,
    ...G(t.disabled) ? { disabled: t.disabled } : {}
  }));
  b.current = t;
  const P = m.useMemo(() => Object.defineProperties({}, {
    invalid: {
      enumerable: !0,
      get: () => !!f(A.errors, e)
    },
    isDirty: {
      enumerable: !0,
      get: () => !!f(A.dirtyFields, e)
    },
    isTouched: {
      enumerable: !0,
      get: () => !!f(A.touchedFields, e)
    },
    isValidating: {
      enumerable: !0,
      get: () => !!f(A.validatingFields, e)
    },
    error: {
      enumerable: !0,
      get: () => f(A.errors, e)
    }
  }), [A, e]), O = m.useCallback((E) => J.current.onChange({
    target: {
      value: ht(E),
      name: e
    },
    type: be.CHANGE
  }), [e]), B = m.useCallback(() => J.current.onBlur({
    target: {
      value: f(l._formValues, e),
      name: e
    },
    type: be.BLUR
  }), [e, l._formValues]), Q = m.useCallback((E) => {
    const g = f(l._fields, e);
    g && E && (g._f.ref = {
      focus: () => E.focus && E.focus(),
      select: () => E.select && E.select(),
      setCustomValidity: (y) => E.setCustomValidity(y),
      reportValidity: () => E.reportValidity()
    });
  }, [l._fields, e]), p = m.useMemo(() => ({
    name: e,
    value: x,
    ...G(s) || A.disabled ? { disabled: A.disabled || s } : {},
    onChange: O,
    onBlur: B,
    ref: Q
  }), [e, s, A.disabled, O, B, Q, x]);
  return m.useEffect(() => {
    const E = l._options.shouldUnregister || n, g = F.current;
    g && g !== e && !c && l.unregister(g), l.register(e, {
      ...b.current.rules,
      ...G(b.current.disabled) ? { disabled: b.current.disabled } : {}
    });
    const y = (V, S) => {
      const z = f(l._fields, V);
      z && z._f && (z._f.mount = S);
    };
    if (y(e, !0), E) {
      const V = T(f(l._options.defaultValues, e, b.current.defaultValue));
      R(l._defaultValues, e, V), U(f(l._formValues, e)) && R(l._formValues, e, V);
    }
    return !c && l.register(e), F.current = e, () => {
      (c ? E && !l._state.action : E) ? l.unregister(e) : y(e, !1);
    };
  }, [e, l, c, n]), m.useEffect(() => {
    l._setDisabledField({
      disabled: s,
      name: e
    });
  }, [s, e, l]), m.useMemo(() => ({
    field: p,
    formState: A,
    fieldState: P
  }), [p, A, P]);
}
const ar = (t) => t.render(Pt(t));
var Wt = (t, r, e, s, l) => r ? {
  ...e[t],
  types: {
    ...e[t] && e[t].types ? e[t].types : {},
    [s]: l || !0
  }
} : {}, K = (t) => Array.isArray(t) ? t : [t], nt = () => {
  let t = [];
  return {
    get observers() {
      return t;
    },
    next: (l) => {
      for (const n of t)
        n.next && n.next(l);
    },
    subscribe: (l) => (t.push(l), {
      unsubscribe: () => {
        t = t.filter((n) => n !== l);
      }
    }),
    unsubscribe: () => {
      t = [];
    }
  };
};
function bt(t, r) {
  const e = {};
  for (const s in t)
    if (t.hasOwnProperty(s)) {
      const l = t[s], n = r[s];
      if (l && I(l) && n) {
        const d = bt(l, n);
        I(d) && (e[s] = d);
      } else t[s] && (e[s] = n);
    }
  return e;
}
var W = (t) => I(t) && !Object.keys(t).length, Ge = (t) => t.type === "file", te = (t) => typeof t == "function", Ve = (t) => {
  if (!je)
    return !1;
  const r = t ? t.ownerDocument : 0;
  return t instanceof (r && r.defaultView ? r.defaultView.HTMLElement : HTMLElement);
}, Vt = (t) => t.type === "select-multiple", Ye = (t) => t.type === "radio", qt = (t) => Ye(t) || he(t), Re = (t) => Ve(t) && t.isConnected;
function Ht(t, r) {
  const e = r.slice(0, -1).length;
  let s = 0;
  for (; s < e; )
    t = U(t) ? s++ : t[r[s++]];
  return t;
}
function $t(t) {
  for (const r in t)
    if (t.hasOwnProperty(r) && !U(t[r]))
      return !1;
  return !0;
}
function N(t, r) {
  const e = Array.isArray(r) ? r : Ae(r) ? [r] : Ke(r), s = e.length === 1 ? t : Ht(t, e), l = e.length - 1, n = e[l];
  return s && delete s[n], l !== 0 && (I(s) && W(s) || Array.isArray(s) && $t(s)) && N(t, e.slice(0, -1)), t;
}
var jt = (t) => {
  for (const r in t)
    if (te(t[r]))
      return !0;
  return !1;
};
function Ft(t) {
  return Array.isArray(t) || I(t) && !jt(t);
}
function qe(t, r = {}) {
  for (const e in t)
    Ft(t[e]) ? (r[e] = Array.isArray(t[e]) ? [] : {}, qe(t[e], r[e])) : U(t[e]) || (r[e] = !0);
  return r;
}
function de(t, r, e) {
  e || (e = qe(r));
  for (const s in t)
    Ft(t[s]) ? U(r) || We(e[s]) ? e[s] = qe(t[s], Array.isArray(t[s]) ? [] : {}) : de(t[s], j(r) ? {} : r[s], e[s]) : e[s] = !ee(t[s], r[s]);
  return e;
}
const ut = {
  value: !1,
  isValid: !1
}, lt = { value: !0, isValid: !0 };
var At = (t) => {
  if (Array.isArray(t)) {
    if (t.length > 1) {
      const r = t.filter((e) => e && e.checked && !e.disabled).map((e) => e.value);
      return { value: r, isValid: !!r.length };
    }
    return t[0].checked && !t[0].disabled ? (
      // @ts-expect-error expected to work in the browser
      t[0].attributes && !U(t[0].attributes.value) ? U(t[0].value) || t[0].value === "" ? lt : { value: t[0].value, isValid: !0 } : lt
    ) : ut;
  }
  return ut;
}, xt = (t, { valueAsNumber: r, valueAsDate: e, setValueAs: s }) => U(t) ? t : r ? t === "" ? NaN : t && +t : e && Y(t) ? new Date(t) : s ? s(t) : t;
const ot = {
  isValid: !1,
  value: null
};
var pt = (t) => Array.isArray(t) ? t.reduce((r, e) => e && e.checked && !e.disabled ? {
  isValid: !0,
  value: e.value
} : r, ot) : ot;
function ct(t) {
  const r = t.ref;
  return Ge(r) ? r.files : Ye(r) ? pt(t.refs).value : Vt(r) ? [...r.selectedOptions].map(({ value: e }) => e) : he(r) ? At(t.refs).value : xt(U(r.value) ? t.ref.value : r.value, t);
}
var Kt = (t, r, e, s) => {
  const l = {};
  for (const n of t) {
    const d = f(r, n);
    d && R(l, n, d._f);
  }
  return {
    criteriaMode: e,
    names: [...t],
    fields: l,
    shouldUseNativeValidation: s
  };
}, Fe = (t) => t instanceof RegExp, ge = (t) => U(t) ? t : Fe(t) ? t.source : I(t) ? Fe(t.value) ? t.value.source : t.value : t, fe = (t) => ({
  isOnSubmit: !t || t === Z.onSubmit,
  isOnBlur: t === Z.onBlur,
  isOnChange: t === Z.onChange,
  isOnAll: t === Z.all,
  isOnTouch: t === Z.onTouched
});
const dt = "AsyncFunction";
var zt = (t) => !!t && !!t.validate && !!(te(t.validate) && t.validate.constructor.name === dt || I(t.validate) && Object.values(t.validate).find((r) => r.constructor.name === dt)), Gt = (t) => t.mount && (t.required || t.min || t.max || t.maxLength || t.minLength || t.pattern || t.validate), He = (t, r, e) => !e && (r.watchAll || r.watch.has(t) || [...r.watch].some((s) => t.startsWith(s) && /^\.\w+/.test(t.slice(s.length))));
const ye = (t, r, e, s) => {
  for (const l of e || Object.keys(t)) {
    const n = f(t, l);
    if (n) {
      const { _f: d, ...c } = n;
      if (d) {
        if (d.refs && d.refs[0] && r(d.refs[0], l) && !s)
          return !0;
        if (d.ref && r(d.ref, d.name) && !s)
          return !0;
        if (ye(c, r))
          break;
      } else if (I(c) && ye(c, r))
        break;
    }
  }
};
function ft(t, r, e) {
  const s = f(t, e);
  if (s || Ae(e))
    return {
      error: s,
      name: e
    };
  const l = e.split(".");
  for (; l.length; ) {
    const n = l.join("."), d = f(r, n), c = f(t, n);
    if (d && !Array.isArray(d) && e !== n)
      return { name: e };
    if (c && c.type)
      return {
        name: n,
        error: c
      };
    if (c && c.root && c.root.type)
      return {
        name: `${n}.root`,
        error: c.root
      };
    l.pop();
  }
  return {
    name: e
  };
}
var Yt = (t, r, e, s) => {
  e(t);
  const { name: l, ...n } = t;
  return W(n) || Object.keys(n).length >= Object.keys(r).length || Object.keys(n).find((d) => r[d] === (!s || Z.all));
}, Jt = (t, r, e) => !t || !r || t === r || K(t).some((s) => s && (e ? s === r : s.startsWith(r) || r.startsWith(s))), Qt = (t, r, e, s, l) => l.isOnAll ? !1 : !e && l.isOnTouch ? !(r || t) : (e ? s.isOnBlur : l.isOnBlur) ? !t : (e ? s.isOnChange : l.isOnChange) ? t : !0, Xt = (t, r) => !xe(f(t, r)).length && N(t, r), wt = (t, r, e) => {
  const s = K(f(t, e));
  return R(s, "root", r[e]), R(t, e, s), t;
};
function yt(t, r, e = "validate") {
  if (Y(t) || Array.isArray(t) && t.every(Y) || G(t) && !t)
    return {
      type: e,
      message: Y(t) ? t : "",
      ref: r
    };
}
var ce = (t) => I(t) && !Fe(t) ? t : {
  value: t,
  message: ""
}, $e = async (t, r, e, s, l, n) => {
  const { ref: d, refs: c, required: w, maxLength: x, minLength: A, min: b, max: F, pattern: J, validate: P, name: O, valueAsNumber: B, mount: Q } = t._f, p = f(e, O);
  if (!Q || r.has(O))
    return {};
  const E = c ? c[0] : d, g = (k) => {
    l && E.reportValidity && (E.setCustomValidity(G(k) ? "" : k || ""), E.reportValidity());
  }, y = {}, V = Ye(d), S = he(d), z = V || S, H = (B || Ge(d)) && U(d.value) && U(p) || Ve(d) && d.value === "" || p === "" || Array.isArray(p) && !p.length, ue = Wt.bind(null, O, s, y), re = (k, C, L, q = ie.maxLength, $ = ie.minLength) => {
    const se = k ? C : L;
    y[O] = {
      type: k ? q : $,
      message: se,
      ref: d,
      ...ue(k ? q : $, se)
    };
  };
  if (n ? !Array.isArray(p) || !p.length : w && (!z && (H || j(p)) || G(p) && !p || S && !At(c).isValid || V && !pt(c).isValid)) {
    const { value: k, message: C } = Y(w) ? { value: !!w, message: w } : ce(w);
    if (k && (y[O] = {
      type: ie.required,
      message: C,
      ref: E,
      ...ue(ie.required, C)
    }, !s))
      return g(C), y;
  }
  if (!H && (!j(b) || !j(F))) {
    let k, C;
    const L = ce(F), q = ce(b);
    if (!j(p) && !isNaN(p)) {
      const $ = d.valueAsNumber || p && +p;
      j(L.value) || (k = $ > L.value), j(q.value) || (C = $ < q.value);
    } else {
      const $ = d.valueAsDate || new Date(p), se = (me) => /* @__PURE__ */ new Date((/* @__PURE__ */ new Date()).toDateString() + " " + me), _e = d.type == "time", oe = d.type == "week";
      Y(L.value) && p && (k = _e ? se(p) > se(L.value) : oe ? p > L.value : $ > new Date(L.value)), Y(q.value) && p && (C = _e ? se(p) < se(q.value) : oe ? p < q.value : $ < new Date(q.value));
    }
    if ((k || C) && (re(!!k, L.message, q.message, ie.max, ie.min), !s))
      return g(y[O].message), y;
  }
  if ((x || A) && !H && (Y(p) || n && Array.isArray(p))) {
    const k = ce(x), C = ce(A), L = !j(k.value) && p.length > +k.value, q = !j(C.value) && p.length < +C.value;
    if ((L || q) && (re(L, k.message, C.message), !s))
      return g(y[O].message), y;
  }
  if (J && !H && Y(p)) {
    const { value: k, message: C } = ce(J);
    if (Fe(k) && !p.match(k) && (y[O] = {
      type: ie.pattern,
      message: C,
      ref: d,
      ...ue(ie.pattern, C)
    }, !s))
      return g(C), y;
  }
  if (P) {
    if (te(P)) {
      const k = await P(p, e), C = yt(k, E);
      if (C && (y[O] = {
        ...C,
        ...ue(ie.validate, C.message)
      }, !s))
        return g(C.message), y;
    } else if (I(P)) {
      let k = {};
      for (const C in P) {
        if (!W(k) && !s)
          break;
        const L = yt(await P[C](p, e), E, C);
        L && (k = {
          ...L,
          ...ue(C, L.message)
        }, g(L.message), s && (y[O] = k));
      }
      if (!W(k) && (y[O] = {
        ref: E,
        ...k
      }, !s))
        return y;
    }
  }
  return g(!0), y;
};
const Zt = {
  mode: Z.onSubmit,
  reValidateMode: Z.onChange,
  shouldFocusError: !0
};
function er(t = {}) {
  let r = {
    ...Zt,
    ...t
  }, e = {
    submitCount: 0,
    isDirty: !1,
    isReady: !1,
    isLoading: te(r.defaultValues),
    isValidating: !1,
    isSubmitted: !1,
    isSubmitting: !1,
    isSubmitSuccessful: !1,
    isValid: !1,
    touchedFields: {},
    dirtyFields: {},
    validatingFields: {},
    errors: r.errors || {},
    disabled: r.disabled || !1
  }, s = {}, l = I(r.defaultValues) || I(r.values) ? T(r.defaultValues || r.values) || {} : {}, n = r.shouldUnregister ? {} : T(l), d = {
    action: !1,
    mount: !1,
    watch: !1
  }, c = {
    mount: /* @__PURE__ */ new Set(),
    disabled: /* @__PURE__ */ new Set(),
    unMount: /* @__PURE__ */ new Set(),
    array: /* @__PURE__ */ new Set(),
    watch: /* @__PURE__ */ new Set()
  }, w, x = 0;
  const A = {
    isDirty: !1,
    dirtyFields: !1,
    validatingFields: !1,
    touchedFields: !1,
    isValidating: !1,
    isValid: !1,
    errors: !1
  };
  let b = {
    ...A
  };
  const F = {
    array: nt(),
    state: nt()
  }, J = r.criteriaMode === Z.all, P = (i) => (a) => {
    clearTimeout(x), x = setTimeout(i, a);
  }, O = async (i) => {
    if (!r.disabled && (A.isValid || b.isValid || i)) {
      const a = r.resolver ? W((await S()).errors) : await H(s, !0);
      a !== e.isValid && F.state.next({
        isValid: a
      });
    }
  }, B = (i, a) => {
    !r.disabled && (A.isValidating || A.validatingFields || b.isValidating || b.validatingFields) && ((i || Array.from(c.mount)).forEach((u) => {
      u && (a ? R(e.validatingFields, u, a) : N(e.validatingFields, u));
    }), F.state.next({
      validatingFields: e.validatingFields,
      isValidating: !W(e.validatingFields)
    }));
  }, Q = (i, a = [], u, h, _ = !0, o = !0) => {
    if (h && u && !r.disabled) {
      if (d.action = !0, o && Array.isArray(f(s, i))) {
        const v = u(f(s, i), h.argA, h.argB);
        _ && R(s, i, v);
      }
      if (o && Array.isArray(f(e.errors, i))) {
        const v = u(f(e.errors, i), h.argA, h.argB);
        _ && R(e.errors, i, v), Xt(e.errors, i);
      }
      if ((A.touchedFields || b.touchedFields) && o && Array.isArray(f(e.touchedFields, i))) {
        const v = u(f(e.touchedFields, i), h.argA, h.argB);
        _ && R(e.touchedFields, i, v);
      }
      (A.dirtyFields || b.dirtyFields) && (e.dirtyFields = de(l, n)), F.state.next({
        name: i,
        isDirty: re(i, a),
        dirtyFields: e.dirtyFields,
        errors: e.errors,
        isValid: e.isValid
      });
    } else
      R(n, i, a);
  }, p = (i, a) => {
    R(e.errors, i, a), F.state.next({
      errors: e.errors
    });
  }, E = (i) => {
    e.errors = i, F.state.next({
      errors: e.errors,
      isValid: !1
    });
  }, g = (i, a, u, h) => {
    const _ = f(s, i);
    if (_) {
      const o = f(n, i, U(u) ? f(l, i) : u);
      U(o) || h && h.defaultChecked || a ? R(n, i, a ? o : ct(_._f)) : L(i, o), d.mount && O();
    }
  }, y = (i, a, u, h, _) => {
    let o = !1, v = !1;
    const D = {
      name: i
    };
    if (!r.disabled) {
      if (!u || h) {
        (A.isDirty || b.isDirty) && (v = e.isDirty, e.isDirty = D.isDirty = re(), o = v !== D.isDirty);
        const M = ee(f(l, i), a);
        v = !!f(e.dirtyFields, i), M ? N(e.dirtyFields, i) : R(e.dirtyFields, i, !0), D.dirtyFields = e.dirtyFields, o = o || (A.dirtyFields || b.dirtyFields) && v !== !M;
      }
      if (u) {
        const M = f(e.touchedFields, i);
        M || (R(e.touchedFields, i, u), D.touchedFields = e.touchedFields, o = o || (A.touchedFields || b.touchedFields) && M !== u);
      }
      o && _ && F.state.next(D);
    }
    return o ? D : {};
  }, V = (i, a, u, h) => {
    const _ = f(e.errors, i), o = (A.isValid || b.isValid) && G(a) && e.isValid !== a;
    if (r.delayError && u ? (w = P(() => p(i, u)), w(r.delayError)) : (clearTimeout(x), w = null, u ? R(e.errors, i, u) : N(e.errors, i)), (u ? !ee(_, u) : _) || !W(h) || o) {
      const v = {
        ...h,
        ...o && G(a) ? { isValid: a } : {},
        errors: e.errors,
        name: i
      };
      e = {
        ...e,
        ...v
      }, F.state.next(v);
    }
  }, S = async (i) => {
    B(i, !0);
    const a = await r.resolver(n, r.context, Kt(i || c.mount, s, r.criteriaMode, r.shouldUseNativeValidation));
    return B(i), a;
  }, z = async (i) => {
    const { errors: a } = await S(i);
    if (i)
      for (const u of i) {
        const h = f(a, u);
        h ? R(e.errors, u, h) : N(e.errors, u);
      }
    else
      e.errors = a;
    return a;
  }, H = async (i, a, u = {
    valid: !0
  }) => {
    for (const h in i) {
      const _ = i[h];
      if (_) {
        const { _f: o, ...v } = _;
        if (o) {
          const D = c.array.has(o.name), M = _._f && zt(_._f);
          M && A.validatingFields && B([o.name], !0);
          const X = await $e(_, c.disabled, n, J, r.shouldUseNativeValidation && !a, D);
          if (M && A.validatingFields && B([o.name]), X[o.name] && (u.valid = !1, a))
            break;
          !a && (f(X, o.name) ? D ? wt(e.errors, X, o.name) : R(e.errors, o.name, X[o.name]) : N(e.errors, o.name));
        }
        !W(v) && await H(v, a, u);
      }
    }
    return u.valid;
  }, ue = () => {
    for (const i of c.unMount) {
      const a = f(s, i);
      a && (a._f.refs ? a._f.refs.every((u) => !Re(u)) : !Re(a._f.ref)) && ke(i);
    }
    c.unMount = /* @__PURE__ */ new Set();
  }, re = (i, a) => !r.disabled && (i && a && R(n, i, a), !ee(me(), l)), k = (i, a, u) => Pe(i, c, {
    ...d.mount ? n : U(a) ? l : Y(i) ? { [i]: a } : a
  }, u, a), C = (i) => xe(f(d.mount ? n : l, i, r.shouldUnregister ? f(l, i, []) : [])), L = (i, a, u = {}) => {
    const h = f(s, i);
    let _ = a;
    if (h) {
      const o = h._f;
      o && (!o.disabled && R(n, i, xt(a, o)), _ = Ve(o.ref) && j(a) ? "" : a, Vt(o.ref) ? [...o.ref.options].forEach((v) => v.selected = _.includes(v.value)) : o.refs ? he(o.ref) ? o.refs.forEach((v) => {
        (!v.defaultChecked || !v.disabled) && (Array.isArray(_) ? v.checked = !!_.find((D) => D === v.value) : v.checked = _ === v.value || !!_);
      }) : o.refs.forEach((v) => v.checked = v.value === _) : Ge(o.ref) ? o.ref.value = "" : (o.ref.value = _, o.ref.type || F.state.next({
        name: i,
        values: T(n)
      })));
    }
    (u.shouldDirty || u.shouldTouch) && y(i, _, u.shouldTouch, u.shouldDirty, !0), u.shouldValidate && oe(i);
  }, q = (i, a, u) => {
    for (const h in a) {
      if (!a.hasOwnProperty(h))
        return;
      const _ = a[h], o = i + "." + h, v = f(s, o);
      (c.array.has(i) || I(_) || v && !v._f) && !le(_) ? q(o, _, u) : L(o, _, u);
    }
  }, $ = (i, a, u = {}) => {
    const h = f(s, i), _ = c.array.has(i), o = T(a);
    R(n, i, o), _ ? (F.array.next({
      name: i,
      values: T(n)
    }), (A.isDirty || A.dirtyFields || b.isDirty || b.dirtyFields) && u.shouldDirty && F.state.next({
      name: i,
      dirtyFields: de(l, n),
      isDirty: re(i, o)
    })) : h && !h._f && !j(o) ? q(i, o, u) : L(i, o, u), He(i, c) && F.state.next({ ...e, name: i }), F.state.next({
      name: d.mount ? i : void 0,
      values: T(n)
    });
  }, se = async (i) => {
    d.mount = !0;
    const a = i.target;
    let u = a.name, h = !0;
    const _ = f(s, u), o = (M) => {
      h = Number.isNaN(M) || le(M) && isNaN(M.getTime()) || ee(M, f(n, u, M));
    }, v = fe(r.mode), D = fe(r.reValidateMode);
    if (_) {
      let M, X;
      const ve = a.type ? ct(_._f) : ht(i), ae = i.type === be.BLUR || i.type === be.FOCUS_OUT, Mt = !Gt(_._f) && !r.resolver && !f(e.errors, u) && !_._f.deps || Qt(ae, f(e.touchedFields, u), e.isSubmitted, D, v), Ee = He(u, c, ae);
      R(n, u, ve), ae ? (!a || !a.readOnly) && (_._f.onBlur && _._f.onBlur(i), w && w(0)) : _._f.onChange && _._f.onChange(i);
      const Ce = y(u, ve, ae), Ut = !W(Ce) || Ee;
      if (!ae && F.state.next({
        name: u,
        type: i.type,
        values: T(n)
      }), Mt)
        return (A.isValid || b.isValid) && (r.mode === "onBlur" ? ae && O() : ae || O()), Ut && F.state.next({ name: u, ...Ee ? {} : Ce });
      if (!ae && Ee && F.state.next({ ...e }), r.resolver) {
        const { errors: it } = await S([u]);
        if (o(ve), h) {
          const Tt = ft(e.errors, s, u), at = ft(it, s, Tt.name || u);
          M = at.error, u = at.name, X = W(it);
        }
      } else
        B([u], !0), M = (await $e(_, c.disabled, n, J, r.shouldUseNativeValidation))[u], B([u]), o(ve), h && (M ? X = !1 : (A.isValid || b.isValid) && (X = await H(s, !0)));
      h && (_._f.deps && (!Array.isArray(_._f.deps) || _._f.deps.length > 0) && oe(_._f.deps), V(u, X, M, Ce));
    }
  }, _e = (i, a) => {
    if (f(e.errors, a) && i.focus)
      return i.focus(), 1;
  }, oe = async (i, a = {}) => {
    let u, h;
    const _ = K(i);
    if (r.resolver) {
      const o = await z(U(i) ? i : _);
      u = W(o), h = i ? !_.some((v) => f(o, v)) : u;
    } else i ? (h = (await Promise.all(_.map(async (o) => {
      const v = f(s, o);
      return await H(v && v._f ? { [o]: v } : v);
    }))).every(Boolean), !(!h && !e.isValid) && O()) : h = u = await H(s);
    return F.state.next({
      ...!Y(i) || (A.isValid || b.isValid) && u !== e.isValid ? {} : { name: i },
      ...r.resolver || !i ? { isValid: u } : {},
      errors: e.errors
    }), a.shouldFocus && !h && ye(s, _e, i ? _ : c.mount), h;
  }, me = (i, a) => {
    let u = {
      ...d.mount ? n : l
    };
    return a && (u = bt(a.dirtyFields ? e.dirtyFields : e.touchedFields, u)), U(i) ? u : Y(i) ? f(u, i) : i.map((h) => f(u, h));
  }, Je = (i, a) => ({
    invalid: !!f((a || e).errors, i),
    isDirty: !!f((a || e).dirtyFields, i),
    error: f((a || e).errors, i),
    isValidating: !!f(e.validatingFields, i),
    isTouched: !!f((a || e).touchedFields, i)
  }), kt = (i) => {
    i && K(i).forEach((a) => N(e.errors, a)), F.state.next({
      errors: i ? e.errors : {}
    });
  }, Qe = (i, a, u) => {
    const h = (f(s, i, { _f: {} })._f || {}).ref, _ = f(e.errors, i) || {}, { ref: o, message: v, type: D, ...M } = _;
    R(e.errors, i, {
      ...M,
      ...a,
      ref: h
    }), F.state.next({
      name: i,
      errors: e.errors,
      isValid: !1
    }), u && u.shouldFocus && h && h.focus && h.focus();
  }, St = (i, a) => te(i) ? F.state.subscribe({
    next: (u) => "values" in u && i(k(void 0, a), u)
  }) : k(i, a, !0), Xe = (i) => F.state.subscribe({
    next: (a) => {
      Jt(i.name, a.name, i.exact) && Yt(a, i.formState || A, Ot, i.reRenderRoot) && i.callback({
        values: { ...n },
        ...e,
        ...a,
        defaultValues: l
      });
    }
  }).unsubscribe, Dt = (i) => (d.mount = !0, b = {
    ...b,
    ...i.formState
  }, Xe({
    ...i,
    formState: b
  })), ke = (i, a = {}) => {
    for (const u of i ? K(i) : c.mount)
      c.mount.delete(u), c.array.delete(u), a.keepValue || (N(s, u), N(n, u)), !a.keepError && N(e.errors, u), !a.keepDirty && N(e.dirtyFields, u), !a.keepTouched && N(e.touchedFields, u), !a.keepIsValidating && N(e.validatingFields, u), !r.shouldUnregister && !a.keepDefaultValue && N(l, u);
    F.state.next({
      values: T(n)
    }), F.state.next({
      ...e,
      ...a.keepDirty ? { isDirty: re() } : {}
    }), !a.keepIsValid && O();
  }, Ze = ({ disabled: i, name: a }) => {
    (G(i) && d.mount || i || c.disabled.has(a)) && (i ? c.disabled.add(a) : c.disabled.delete(a));
  }, Se = (i, a = {}) => {
    let u = f(s, i);
    const h = G(a.disabled) || G(r.disabled);
    return R(s, i, {
      ...u || {},
      _f: {
        ...u && u._f ? u._f : { ref: { name: i } },
        name: i,
        mount: !0,
        ...a
      }
    }), c.mount.add(i), u ? Ze({
      disabled: G(a.disabled) ? a.disabled : r.disabled,
      name: i
    }) : g(i, !0, a.value), {
      ...h ? { disabled: a.disabled || r.disabled } : {},
      ...r.progressive ? {
        required: !!a.required,
        min: ge(a.min),
        max: ge(a.max),
        minLength: ge(a.minLength),
        maxLength: ge(a.maxLength),
        pattern: ge(a.pattern)
      } : {},
      name: i,
      onChange: se,
      onBlur: se,
      ref: (_) => {
        if (_) {
          Se(i, a), u = f(s, i);
          const o = U(_.value) && _.querySelectorAll && _.querySelectorAll("input,select,textarea")[0] || _, v = qt(o), D = u._f.refs || [];
          if (v ? D.find((M) => M === o) : o === u._f.ref)
            return;
          R(s, i, {
            _f: {
              ...u._f,
              ...v ? {
                refs: [
                  ...D.filter(Re),
                  o,
                  ...Array.isArray(f(l, i)) ? [{}] : []
                ],
                ref: { type: o.type, name: i }
              } : { ref: o }
            }
          }), g(i, !1, void 0, o);
        } else
          u = f(s, i, {}), u._f && (u._f.mount = !1), (r.shouldUnregister || a.shouldUnregister) && !(mt(c.array, i) && d.action) && c.unMount.add(i);
      }
    };
  }, De = () => r.shouldFocusError && ye(s, _e, c.mount), Et = (i) => {
    G(i) && (F.state.next({ disabled: i }), ye(s, (a, u) => {
      const h = f(s, u);
      h && (a.disabled = h._f.disabled || i, Array.isArray(h._f.refs) && h._f.refs.forEach((_) => {
        _.disabled = h._f.disabled || i;
      }));
    }, 0, !1));
  }, et = (i, a) => async (u) => {
    let h;
    u && (u.preventDefault && u.preventDefault(), u.persist && u.persist());
    let _ = T(n);
    if (F.state.next({
      isSubmitting: !0
    }), r.resolver) {
      const { errors: o, values: v } = await S();
      e.errors = o, _ = T(v);
    } else
      await H(s);
    if (c.disabled.size)
      for (const o of c.disabled)
        N(_, o);
    if (N(e.errors, "root"), W(e.errors)) {
      F.state.next({
        errors: {}
      });
      try {
        await i(_, u);
      } catch (o) {
        h = o;
      }
    } else
      a && await a({ ...e.errors }, u), De(), setTimeout(De);
    if (F.state.next({
      isSubmitted: !0,
      isSubmitting: !1,
      isSubmitSuccessful: W(e.errors) && !h,
      submitCount: e.submitCount + 1,
      errors: e.errors
    }), h)
      throw h;
  }, Ct = (i, a = {}) => {
    f(s, i) && (U(a.defaultValue) ? $(i, T(f(l, i))) : ($(i, a.defaultValue), R(l, i, T(a.defaultValue))), a.keepTouched || N(e.touchedFields, i), a.keepDirty || (N(e.dirtyFields, i), e.isDirty = a.defaultValue ? re(i, T(f(l, i))) : re()), a.keepError || (N(e.errors, i), A.isValid && O()), F.state.next({ ...e }));
  }, tt = (i, a = {}) => {
    const u = i ? T(i) : l, h = T(u), _ = W(i), o = _ ? l : h;
    if (a.keepDefaultValues || (l = u), !a.keepValues) {
      if (a.keepDirtyValues) {
        const v = /* @__PURE__ */ new Set([
          ...c.mount,
          ...Object.keys(de(l, n))
        ]);
        for (const D of Array.from(v))
          f(e.dirtyFields, D) ? R(o, D, f(n, D)) : $(D, f(o, D));
      } else {
        if (je && U(i))
          for (const v of c.mount) {
            const D = f(s, v);
            if (D && D._f) {
              const M = Array.isArray(D._f.refs) ? D._f.refs[0] : D._f.ref;
              if (Ve(M)) {
                const X = M.closest("form");
                if (X) {
                  X.reset();
                  break;
                }
              }
            }
          }
        if (a.keepFieldsRef)
          for (const v of c.mount)
            $(v, f(o, v));
        else
          s = {};
      }
      n = r.shouldUnregister ? a.keepDefaultValues ? T(l) : {} : T(o), F.array.next({
        values: { ...o }
      }), F.state.next({
        values: { ...o }
      });
    }
    c = {
      mount: a.keepDirtyValues ? c.mount : /* @__PURE__ */ new Set(),
      unMount: /* @__PURE__ */ new Set(),
      array: /* @__PURE__ */ new Set(),
      disabled: /* @__PURE__ */ new Set(),
      watch: /* @__PURE__ */ new Set(),
      watchAll: !1,
      focus: ""
    }, d.mount = !A.isValid || !!a.keepIsValid || !!a.keepDirtyValues || !r.shouldUnregister && !W(o), d.watch = !!r.shouldUnregister, F.state.next({
      submitCount: a.keepSubmitCount ? e.submitCount : 0,
      isDirty: _ ? !1 : a.keepDirty ? e.isDirty : !!(a.keepDefaultValues && !ee(i, l)),
      isSubmitted: a.keepIsSubmitted ? e.isSubmitted : !1,
      dirtyFields: _ ? {} : a.keepDirtyValues ? a.keepDefaultValues && n ? de(l, n) : e.dirtyFields : a.keepDefaultValues && i ? de(l, i) : a.keepDirty ? e.dirtyFields : {},
      touchedFields: a.keepTouched ? e.touchedFields : {},
      errors: a.keepErrors ? e.errors : {},
      isSubmitSuccessful: a.keepIsSubmitSuccessful ? e.isSubmitSuccessful : !1,
      isSubmitting: !1,
      defaultValues: l
    });
  }, rt = (i, a) => tt(te(i) ? i(n) : i, a), Rt = (i, a = {}) => {
    const u = f(s, i), h = u && u._f;
    if (h) {
      const _ = h.refs ? h.refs[0] : h.ref;
      _.focus && (_.focus(), a.shouldSelect && te(_.select) && _.select());
    }
  }, Ot = (i) => {
    e = {
      ...e,
      ...i
    };
  }, st = {
    control: {
      register: Se,
      unregister: ke,
      getFieldState: Je,
      handleSubmit: et,
      setError: Qe,
      _subscribe: Xe,
      _runSchema: S,
      _focusError: De,
      _getWatch: k,
      _getDirty: re,
      _setValid: O,
      _setFieldArray: Q,
      _setDisabledField: Ze,
      _setErrors: E,
      _getFieldArray: C,
      _reset: tt,
      _resetDefaultValues: () => te(r.defaultValues) && r.defaultValues().then((i) => {
        rt(i, r.resetOptions), F.state.next({
          isLoading: !1
        });
      }),
      _removeUnmounted: ue,
      _disableForm: Et,
      _subjects: F,
      _proxyFormState: A,
      get _fields() {
        return s;
      },
      get _formValues() {
        return n;
      },
      get _state() {
        return d;
      },
      set _state(i) {
        d = i;
      },
      get _defaultValues() {
        return l;
      },
      get _names() {
        return c;
      },
      set _names(i) {
        c = i;
      },
      get _formState() {
        return e;
      },
      get _options() {
        return r;
      },
      set _options(i) {
        r = {
          ...r,
          ...i
        };
      }
    },
    subscribe: Dt,
    trigger: oe,
    register: Se,
    handleSubmit: et,
    watch: St,
    setValue: $,
    getValues: me,
    reset: rt,
    resetField: Ct,
    clearErrors: kt,
    unregister: ke,
    setError: Qe,
    setFocus: Rt,
    getFieldState: Je
  };
  return {
    ...st,
    formControl: st
  };
}
var ne = () => {
  if (typeof crypto < "u" && crypto.randomUUID)
    return crypto.randomUUID();
  const t = typeof performance > "u" ? Date.now() : performance.now() * 1e3;
  return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, (r) => {
    const e = (Math.random() * 16 + t) % 16 | 0;
    return (r == "x" ? e : e & 3 | 8).toString(16);
  });
}, Oe = (t, r, e = {}) => e.shouldFocus || U(e.shouldFocus) ? e.focusName || `${t}.${U(e.focusIndex) ? r : e.focusIndex}.` : "", Me = (t, r) => [
  ...t,
  ...K(r)
], Ue = (t) => Array.isArray(t) ? t.map(() => {
}) : void 0;
function Te(t, r, e) {
  return [
    ...t.slice(0, r),
    ...K(e),
    ...t.slice(r)
  ];
}
var Le = (t, r, e) => Array.isArray(t) ? (U(t[e]) && (t[e] = void 0), t.splice(e, 0, t.splice(r, 1)[0]), t) : [], Ne = (t, r) => [
  ...K(r),
  ...K(t)
];
function tr(t, r) {
  let e = 0;
  const s = [...t];
  for (const l of r)
    s.splice(l - e, 1), e++;
  return xe(s).length ? s : [];
}
var Ie = (t, r) => U(r) ? [] : tr(t, K(r).sort((e, s) => e - s)), Be = (t, r, e) => {
  [t[r], t[e]] = [t[e], t[r]];
}, _t = (t, r, e) => (t[r] = e, t);
function nr(t) {
  const r = pe(), { control: e = r.control, name: s, keyName: l = "id", shouldUnregister: n, rules: d } = t, [c, w] = m.useState(e._getFieldArray(s)), x = m.useRef(e._getFieldArray(s).map(ne)), A = m.useRef(!1);
  e._names.array.add(s), m.useMemo(() => d && c.length >= 0 && e.register(s, d), [e, s, c.length, d]), we(() => e._subjects.array.subscribe({
    next: ({ values: g, name: y }) => {
      if (y === s || !y) {
        const V = f(g, s);
        Array.isArray(V) && (w(V), x.current = V.map(ne));
      }
    }
  }).unsubscribe, [e, s]);
  const b = m.useCallback((g) => {
    A.current = !0, e._setFieldArray(s, g);
  }, [e, s]), F = (g, y) => {
    const V = K(T(g)), S = Me(e._getFieldArray(s), V);
    e._names.focus = Oe(s, S.length - 1, y), x.current = Me(x.current, V.map(ne)), b(S), w(S), e._setFieldArray(s, S, Me, {
      argA: Ue(g)
    });
  }, J = (g, y) => {
    const V = K(T(g)), S = Ne(e._getFieldArray(s), V);
    e._names.focus = Oe(s, 0, y), x.current = Ne(x.current, V.map(ne)), b(S), w(S), e._setFieldArray(s, S, Ne, {
      argA: Ue(g)
    });
  }, P = (g) => {
    const y = Ie(e._getFieldArray(s), g);
    x.current = Ie(x.current, g), b(y), w(y), !Array.isArray(f(e._fields, s)) && R(e._fields, s, void 0), e._setFieldArray(s, y, Ie, {
      argA: g
    });
  }, O = (g, y, V) => {
    const S = K(T(y)), z = Te(e._getFieldArray(s), g, S);
    e._names.focus = Oe(s, g, V), x.current = Te(x.current, g, S.map(ne)), b(z), w(z), e._setFieldArray(s, z, Te, {
      argA: g,
      argB: Ue(y)
    });
  }, B = (g, y) => {
    const V = e._getFieldArray(s);
    Be(V, g, y), Be(x.current, g, y), b(V), w(V), e._setFieldArray(s, V, Be, {
      argA: g,
      argB: y
    }, !1);
  }, Q = (g, y) => {
    const V = e._getFieldArray(s);
    Le(V, g, y), Le(x.current, g, y), b(V), w(V), e._setFieldArray(s, V, Le, {
      argA: g,
      argB: y
    }, !1);
  }, p = (g, y) => {
    const V = T(y), S = _t(e._getFieldArray(s), g, V);
    x.current = [...S].map((z, H) => !z || H === g ? ne() : x.current[H]), b(S), w([...S]), e._setFieldArray(s, S, _t, {
      argA: g,
      argB: V
    }, !0, !1);
  }, E = (g) => {
    const y = K(T(g));
    x.current = y.map(ne), b([...y]), w([...y]), e._setFieldArray(s, [...y], (V) => V, {}, !0, !1);
  };
  return m.useEffect(() => {
    if (e._state.action = !1, He(s, e._names) && e._subjects.state.next({
      ...e._formState
    }), A.current && (!fe(e._options.mode).isOnSubmit || e._formState.isSubmitted) && !fe(e._options.reValidateMode).isOnSubmit)
      if (e._options.resolver)
        e._runSchema([s]).then((g) => {
          const y = f(g.errors, s), V = f(e._formState.errors, s);
          (V ? !y && V.type || y && (V.type !== y.type || V.message !== y.message) : y && y.type) && (y ? R(e._formState.errors, s, y) : N(e._formState.errors, s), e._subjects.state.next({
            errors: e._formState.errors
          }));
        });
      else {
        const g = f(e._fields, s);
        g && g._f && !(fe(e._options.reValidateMode).isOnSubmit && fe(e._options.mode).isOnSubmit) && $e(g, e._names.disabled, e._formValues, e._options.criteriaMode === Z.all, e._options.shouldUseNativeValidation, !0).then((y) => !W(y) && e._subjects.state.next({
          errors: wt(e._formState.errors, y, s)
        }));
      }
    e._subjects.state.next({
      name: s,
      values: T(e._formValues)
    }), e._names.focus && ye(e._fields, (g, y) => {
      if (e._names.focus && y.startsWith(e._names.focus) && g.focus)
        return g.focus(), 1;
    }), e._names.focus = "", e._setValid(), A.current = !1;
  }, [c, s, e]), m.useEffect(() => (!f(e._formValues, s) && e._setFieldArray(s), () => {
    const g = (y, V) => {
      const S = f(e._fields, y);
      S && S._f && (S._f.mount = V);
    };
    e._options.shouldUnregister || n ? e.unregister(s) : g(s, !1);
  }), [s, e, l, n]), {
    swap: m.useCallback(B, [b, s, e]),
    move: m.useCallback(Q, [b, s, e]),
    prepend: m.useCallback(J, [b, s, e]),
    append: m.useCallback(F, [b, s, e]),
    remove: m.useCallback(P, [b, s, e]),
    insert: m.useCallback(O, [b, s, e]),
    update: m.useCallback(p, [b, s, e]),
    replace: m.useCallback(E, [b, s, e]),
    fields: m.useMemo(() => c.map((g, y) => ({
      ...g,
      [l]: x.current[y] || ne()
    })), [c, l])
  };
}
function ur(t = {}) {
  const r = m.useRef(void 0), e = m.useRef(void 0), [s, l] = m.useState({
    isDirty: !1,
    isValidating: !1,
    isLoading: te(t.defaultValues),
    isSubmitted: !1,
    isSubmitting: !1,
    isSubmitSuccessful: !1,
    isValid: !1,
    submitCount: 0,
    dirtyFields: {},
    touchedFields: {},
    validatingFields: {},
    errors: t.errors || {},
    disabled: t.disabled || !1,
    isReady: !1,
    defaultValues: te(t.defaultValues) ? void 0 : t.defaultValues
  });
  if (!r.current)
    if (t.formControl)
      r.current = {
        ...t.formControl,
        formState: s
      }, t.defaultValues && !te(t.defaultValues) && t.formControl.reset(t.defaultValues, t.resetOptions);
    else {
      const { formControl: d, ...c } = er(t);
      r.current = {
        ...c,
        formState: s
      };
    }
  const n = r.current.control;
  return n._options = t, we(() => {
    const d = n._subscribe({
      formState: n._proxyFormState,
      callback: () => l({ ...n._formState }),
      reRenderRoot: !0
    });
    return l((c) => ({
      ...c,
      isReady: !0
    })), n._formState.isReady = !0, d;
  }, [n]), m.useEffect(() => n._disableForm(t.disabled), [n, t.disabled]), m.useEffect(() => {
    t.mode && (n._options.mode = t.mode), t.reValidateMode && (n._options.reValidateMode = t.reValidateMode);
  }, [n, t.mode, t.reValidateMode]), m.useEffect(() => {
    t.errors && (n._setErrors(t.errors), n._focusError());
  }, [n, t.errors]), m.useEffect(() => {
    t.shouldUnregister && n._subjects.state.next({
      values: n._getWatch()
    });
  }, [n, t.shouldUnregister]), m.useEffect(() => {
    if (n._proxyFormState.isDirty) {
      const d = n._getDirty();
      d !== s.isDirty && n._subjects.state.next({
        isDirty: d
      });
    }
  }, [n, s.isDirty]), m.useEffect(() => {
    t.values && !ee(t.values, e.current) ? (n._reset(t.values, {
      keepFieldsRef: !0,
      ...n._options.resetOptions
    }), e.current = t.values, l((d) => ({ ...d }))) : n._resetDefaultValues();
  }, [n, t.values]), m.useEffect(() => {
    n._state.mount || (n._setValid(), n._state.mount = !0), n._state.watch && (n._state.watch = !1, n._subjects.state.next({ ...n._formState })), n._removeUnmounted();
  }), r.current.formState = vt(s, n), r.current;
}
export {
  ar as C,
  ir as F,
  ur as a,
  nr as b,
  pe as u
};
//# sourceMappingURL=index.esm-BYObtETB.js.map
