{"version":3,"file":"HydrationBoundary-DD-EI0m6.js","sources":["../../../node_modules/.pnpm/@tanstack+query-core@5.90.12/node_modules/@tanstack/query-core/build/modern/hydration.js","../../../node_modules/.pnpm/@tanstack+query-core@5.90.12/node_modules/@tanstack/query-core/build/modern/infiniteQueryBehavior.js","../../../node_modules/.pnpm/@tanstack+query-core@5.90.12/node_modules/@tanstack/query-core/build/modern/mutationCache.js","../../../node_modules/.pnpm/@tanstack+query-core@5.90.12/node_modules/@tanstack/query-core/build/modern/queryCache.js","../../../node_modules/.pnpm/@tanstack+query-core@5.90.12/node_modules/@tanstack/query-core/build/modern/queryClient.js","../../../node_modules/.pnpm/@tanstack+react-query@5.90.12_react@19.2.4/node_modules/@tanstack/react-query/build/modern/HydrationBoundary.js"],"sourcesContent":["// src/hydration.ts\nimport { tryResolveSync } from \"./thenable.js\";\nimport { noop } from \"./utils.js\";\nfunction defaultTransformerFn(data) {\n  return data;\n}\nfunction dehydrateMutation(mutation) {\n  return {\n    mutationKey: mutation.options.mutationKey,\n    state: mutation.state,\n    ...mutation.options.scope && { scope: mutation.options.scope },\n    ...mutation.meta && { meta: mutation.meta }\n  };\n}\nfunction dehydrateQuery(query, serializeData, shouldRedactErrors) {\n  const dehydratePromise = () => {\n    const promise = query.promise?.then(serializeData).catch((error) => {\n      if (!shouldRedactErrors(error)) {\n        return Promise.reject(error);\n      }\n      if (process.env.NODE_ENV !== \"production\") {\n        console.error(\n          `A query that was dehydrated as pending ended up rejecting. [${query.queryHash}]: ${error}; The error will be redacted in production builds`\n        );\n      }\n      return Promise.reject(new Error(\"redacted\"));\n    });\n    promise?.catch(noop);\n    return promise;\n  };\n  return {\n    dehydratedAt: Date.now(),\n    state: {\n      ...query.state,\n      ...query.state.data !== void 0 && {\n        data: serializeData(query.state.data)\n      }\n    },\n    queryKey: query.queryKey,\n    queryHash: query.queryHash,\n    ...query.state.status === \"pending\" && {\n      promise: dehydratePromise()\n    },\n    ...query.meta && { meta: query.meta }\n  };\n}\nfunction defaultShouldDehydrateMutation(mutation) {\n  return mutation.state.isPaused;\n}\nfunction defaultShouldDehydrateQuery(query) {\n  return query.state.status === \"success\";\n}\nfunction defaultShouldRedactErrors(_) {\n  return true;\n}\nfunction dehydrate(client, options = {}) {\n  const filterMutation = options.shouldDehydrateMutation ?? client.getDefaultOptions().dehydrate?.shouldDehydrateMutation ?? defaultShouldDehydrateMutation;\n  const mutations = client.getMutationCache().getAll().flatMap(\n    (mutation) => filterMutation(mutation) ? [dehydrateMutation(mutation)] : []\n  );\n  const filterQuery = options.shouldDehydrateQuery ?? client.getDefaultOptions().dehydrate?.shouldDehydrateQuery ?? defaultShouldDehydrateQuery;\n  const shouldRedactErrors = options.shouldRedactErrors ?? client.getDefaultOptions().dehydrate?.shouldRedactErrors ?? defaultShouldRedactErrors;\n  const serializeData = options.serializeData ?? client.getDefaultOptions().dehydrate?.serializeData ?? defaultTransformerFn;\n  const queries = client.getQueryCache().getAll().flatMap(\n    (query) => filterQuery(query) ? [dehydrateQuery(query, serializeData, shouldRedactErrors)] : []\n  );\n  return { mutations, queries };\n}\nfunction hydrate(client, dehydratedState, options) {\n  if (typeof dehydratedState !== \"object\" || dehydratedState === null) {\n    return;\n  }\n  const mutationCache = client.getMutationCache();\n  const queryCache = client.getQueryCache();\n  const deserializeData = options?.defaultOptions?.deserializeData ?? client.getDefaultOptions().hydrate?.deserializeData ?? defaultTransformerFn;\n  const mutations = dehydratedState.mutations || [];\n  const queries = dehydratedState.queries || [];\n  mutations.forEach(({ state, ...mutationOptions }) => {\n    mutationCache.build(\n      client,\n      {\n        ...client.getDefaultOptions().hydrate?.mutations,\n        ...options?.defaultOptions?.mutations,\n        ...mutationOptions\n      },\n      state\n    );\n  });\n  queries.forEach(\n    ({ queryKey, state, queryHash, meta, promise, dehydratedAt }) => {\n      const syncData = promise ? tryResolveSync(promise) : void 0;\n      const rawData = state.data === void 0 ? syncData?.data : state.data;\n      const data = rawData === void 0 ? rawData : deserializeData(rawData);\n      let query = queryCache.get(queryHash);\n      const existingQueryIsPending = query?.state.status === \"pending\";\n      const existingQueryIsFetching = query?.state.fetchStatus === \"fetching\";\n      if (query) {\n        const hasNewerSyncData = syncData && // We only need this undefined check to handle older dehydration\n        // payloads that might not have dehydratedAt\n        dehydratedAt !== void 0 && dehydratedAt > query.state.dataUpdatedAt;\n        if (state.dataUpdatedAt > query.state.dataUpdatedAt || hasNewerSyncData) {\n          const { fetchStatus: _ignored, ...serializedState } = state;\n          query.setState({\n            ...serializedState,\n            data\n          });\n        }\n      } else {\n        query = queryCache.build(\n          client,\n          {\n            ...client.getDefaultOptions().hydrate?.queries,\n            ...options?.defaultOptions?.queries,\n            queryKey,\n            queryHash,\n            meta\n          },\n          // Reset fetch status to idle to avoid\n          // query being stuck in fetching state upon hydration\n          {\n            ...state,\n            data,\n            fetchStatus: \"idle\",\n            status: data !== void 0 ? \"success\" : state.status\n          }\n        );\n      }\n      if (promise && !existingQueryIsPending && !existingQueryIsFetching && // Only hydrate if dehydration is newer than any existing data,\n      // this is always true for new queries\n      (dehydratedAt === void 0 || dehydratedAt > query.state.dataUpdatedAt)) {\n        query.fetch(void 0, {\n          // RSC transformed promises are not thenable\n          initialPromise: Promise.resolve(promise).then(deserializeData)\n        }).catch(noop);\n      }\n    }\n  );\n}\nexport {\n  defaultShouldDehydrateMutation,\n  defaultShouldDehydrateQuery,\n  dehydrate,\n  hydrate\n};\n//# sourceMappingURL=hydration.js.map","// src/infiniteQueryBehavior.ts\nimport { addToEnd, addToStart, ensureQueryFn } from \"./utils.js\";\nfunction infiniteQueryBehavior(pages) {\n  return {\n    onFetch: (context, query) => {\n      const options = context.options;\n      const direction = context.fetchOptions?.meta?.fetchMore?.direction;\n      const oldPages = context.state.data?.pages || [];\n      const oldPageParams = context.state.data?.pageParams || [];\n      let result = { pages: [], pageParams: [] };\n      let currentPage = 0;\n      const fetchFn = async () => {\n        let cancelled = false;\n        const addSignalProperty = (object) => {\n          Object.defineProperty(object, \"signal\", {\n            enumerable: true,\n            get: () => {\n              if (context.signal.aborted) {\n                cancelled = true;\n              } else {\n                context.signal.addEventListener(\"abort\", () => {\n                  cancelled = true;\n                });\n              }\n              return context.signal;\n            }\n          });\n        };\n        const queryFn = ensureQueryFn(context.options, context.fetchOptions);\n        const fetchPage = async (data, param, previous) => {\n          if (cancelled) {\n            return Promise.reject();\n          }\n          if (param == null && data.pages.length) {\n            return Promise.resolve(data);\n          }\n          const createQueryFnContext = () => {\n            const queryFnContext2 = {\n              client: context.client,\n              queryKey: context.queryKey,\n              pageParam: param,\n              direction: previous ? \"backward\" : \"forward\",\n              meta: context.options.meta\n            };\n            addSignalProperty(queryFnContext2);\n            return queryFnContext2;\n          };\n          const queryFnContext = createQueryFnContext();\n          const page = await queryFn(queryFnContext);\n          const { maxPages } = context.options;\n          const addTo = previous ? addToStart : addToEnd;\n          return {\n            pages: addTo(data.pages, page, maxPages),\n            pageParams: addTo(data.pageParams, param, maxPages)\n          };\n        };\n        if (direction && oldPages.length) {\n          const previous = direction === \"backward\";\n          const pageParamFn = previous ? getPreviousPageParam : getNextPageParam;\n          const oldData = {\n            pages: oldPages,\n            pageParams: oldPageParams\n          };\n          const param = pageParamFn(options, oldData);\n          result = await fetchPage(oldData, param, previous);\n        } else {\n          const remainingPages = pages ?? oldPages.length;\n          do {\n            const param = currentPage === 0 ? oldPageParams[0] ?? options.initialPageParam : getNextPageParam(options, result);\n            if (currentPage > 0 && param == null) {\n              break;\n            }\n            result = await fetchPage(result, param);\n            currentPage++;\n          } while (currentPage < remainingPages);\n        }\n        return result;\n      };\n      if (context.options.persister) {\n        context.fetchFn = () => {\n          return context.options.persister?.(\n            fetchFn,\n            {\n              client: context.client,\n              queryKey: context.queryKey,\n              meta: context.options.meta,\n              signal: context.signal\n            },\n            query\n          );\n        };\n      } else {\n        context.fetchFn = fetchFn;\n      }\n    }\n  };\n}\nfunction getNextPageParam(options, { pages, pageParams }) {\n  const lastIndex = pages.length - 1;\n  return pages.length > 0 ? options.getNextPageParam(\n    pages[lastIndex],\n    pages,\n    pageParams[lastIndex],\n    pageParams\n  ) : void 0;\n}\nfunction getPreviousPageParam(options, { pages, pageParams }) {\n  return pages.length > 0 ? options.getPreviousPageParam?.(pages[0], pages, pageParams[0], pageParams) : void 0;\n}\nfunction hasNextPage(options, data) {\n  if (!data) return false;\n  return getNextPageParam(options, data) != null;\n}\nfunction hasPreviousPage(options, data) {\n  if (!data || !options.getPreviousPageParam) return false;\n  return getPreviousPageParam(options, data) != null;\n}\nexport {\n  hasNextPage,\n  hasPreviousPage,\n  infiniteQueryBehavior\n};\n//# sourceMappingURL=infiniteQueryBehavior.js.map","// src/mutationCache.ts\nimport { notifyManager } from \"./notifyManager.js\";\nimport { Mutation } from \"./mutation.js\";\nimport { matchMutation, noop } from \"./utils.js\";\nimport { Subscribable } from \"./subscribable.js\";\nvar MutationCache = class extends Subscribable {\n  constructor(config = {}) {\n    super();\n    this.config = config;\n    this.#mutations = /* @__PURE__ */ new Set();\n    this.#scopes = /* @__PURE__ */ new Map();\n    this.#mutationId = 0;\n  }\n  #mutations;\n  #scopes;\n  #mutationId;\n  build(client, options, state) {\n    const mutation = new Mutation({\n      client,\n      mutationCache: this,\n      mutationId: ++this.#mutationId,\n      options: client.defaultMutationOptions(options),\n      state\n    });\n    this.add(mutation);\n    return mutation;\n  }\n  add(mutation) {\n    this.#mutations.add(mutation);\n    const scope = scopeFor(mutation);\n    if (typeof scope === \"string\") {\n      const scopedMutations = this.#scopes.get(scope);\n      if (scopedMutations) {\n        scopedMutations.push(mutation);\n      } else {\n        this.#scopes.set(scope, [mutation]);\n      }\n    }\n    this.notify({ type: \"added\", mutation });\n  }\n  remove(mutation) {\n    if (this.#mutations.delete(mutation)) {\n      const scope = scopeFor(mutation);\n      if (typeof scope === \"string\") {\n        const scopedMutations = this.#scopes.get(scope);\n        if (scopedMutations) {\n          if (scopedMutations.length > 1) {\n            const index = scopedMutations.indexOf(mutation);\n            if (index !== -1) {\n              scopedMutations.splice(index, 1);\n            }\n          } else if (scopedMutations[0] === mutation) {\n            this.#scopes.delete(scope);\n          }\n        }\n      }\n    }\n    this.notify({ type: \"removed\", mutation });\n  }\n  canRun(mutation) {\n    const scope = scopeFor(mutation);\n    if (typeof scope === \"string\") {\n      const mutationsWithSameScope = this.#scopes.get(scope);\n      const firstPendingMutation = mutationsWithSameScope?.find(\n        (m) => m.state.status === \"pending\"\n      );\n      return !firstPendingMutation || firstPendingMutation === mutation;\n    } else {\n      return true;\n    }\n  }\n  runNext(mutation) {\n    const scope = scopeFor(mutation);\n    if (typeof scope === \"string\") {\n      const foundMutation = this.#scopes.get(scope)?.find((m) => m !== mutation && m.state.isPaused);\n      return foundMutation?.continue() ?? Promise.resolve();\n    } else {\n      return Promise.resolve();\n    }\n  }\n  clear() {\n    notifyManager.batch(() => {\n      this.#mutations.forEach((mutation) => {\n        this.notify({ type: \"removed\", mutation });\n      });\n      this.#mutations.clear();\n      this.#scopes.clear();\n    });\n  }\n  getAll() {\n    return Array.from(this.#mutations);\n  }\n  find(filters) {\n    const defaultedFilters = { exact: true, ...filters };\n    return this.getAll().find(\n      (mutation) => matchMutation(defaultedFilters, mutation)\n    );\n  }\n  findAll(filters = {}) {\n    return this.getAll().filter((mutation) => matchMutation(filters, mutation));\n  }\n  notify(event) {\n    notifyManager.batch(() => {\n      this.listeners.forEach((listener) => {\n        listener(event);\n      });\n    });\n  }\n  resumePausedMutations() {\n    const pausedMutations = this.getAll().filter((x) => x.state.isPaused);\n    return notifyManager.batch(\n      () => Promise.all(\n        pausedMutations.map((mutation) => mutation.continue().catch(noop))\n      )\n    );\n  }\n};\nfunction scopeFor(mutation) {\n  return mutation.options.scope?.id;\n}\nexport {\n  MutationCache\n};\n//# sourceMappingURL=mutationCache.js.map","// src/queryCache.ts\nimport { hashQueryKeyByOptions, matchQuery } from \"./utils.js\";\nimport { Query } from \"./query.js\";\nimport { notifyManager } from \"./notifyManager.js\";\nimport { Subscribable } from \"./subscribable.js\";\nvar QueryCache = class extends Subscribable {\n  constructor(config = {}) {\n    super();\n    this.config = config;\n    this.#queries = /* @__PURE__ */ new Map();\n  }\n  #queries;\n  build(client, options, state) {\n    const queryKey = options.queryKey;\n    const queryHash = options.queryHash ?? hashQueryKeyByOptions(queryKey, options);\n    let query = this.get(queryHash);\n    if (!query) {\n      query = new Query({\n        client,\n        queryKey,\n        queryHash,\n        options: client.defaultQueryOptions(options),\n        state,\n        defaultOptions: client.getQueryDefaults(queryKey)\n      });\n      this.add(query);\n    }\n    return query;\n  }\n  add(query) {\n    if (!this.#queries.has(query.queryHash)) {\n      this.#queries.set(query.queryHash, query);\n      this.notify({\n        type: \"added\",\n        query\n      });\n    }\n  }\n  remove(query) {\n    const queryInMap = this.#queries.get(query.queryHash);\n    if (queryInMap) {\n      query.destroy();\n      if (queryInMap === query) {\n        this.#queries.delete(query.queryHash);\n      }\n      this.notify({ type: \"removed\", query });\n    }\n  }\n  clear() {\n    notifyManager.batch(() => {\n      this.getAll().forEach((query) => {\n        this.remove(query);\n      });\n    });\n  }\n  get(queryHash) {\n    return this.#queries.get(queryHash);\n  }\n  getAll() {\n    return [...this.#queries.values()];\n  }\n  find(filters) {\n    const defaultedFilters = { exact: true, ...filters };\n    return this.getAll().find(\n      (query) => matchQuery(defaultedFilters, query)\n    );\n  }\n  findAll(filters = {}) {\n    const queries = this.getAll();\n    return Object.keys(filters).length > 0 ? queries.filter((query) => matchQuery(filters, query)) : queries;\n  }\n  notify(event) {\n    notifyManager.batch(() => {\n      this.listeners.forEach((listener) => {\n        listener(event);\n      });\n    });\n  }\n  onFocus() {\n    notifyManager.batch(() => {\n      this.getAll().forEach((query) => {\n        query.onFocus();\n      });\n    });\n  }\n  onOnline() {\n    notifyManager.batch(() => {\n      this.getAll().forEach((query) => {\n        query.onOnline();\n      });\n    });\n  }\n};\nexport {\n  QueryCache\n};\n//# sourceMappingURL=queryCache.js.map","// src/queryClient.ts\nimport {\n  functionalUpdate,\n  hashKey,\n  hashQueryKeyByOptions,\n  noop,\n  partialMatchKey,\n  resolveStaleTime,\n  skipToken\n} from \"./utils.js\";\nimport { QueryCache } from \"./queryCache.js\";\nimport { MutationCache } from \"./mutationCache.js\";\nimport { focusManager } from \"./focusManager.js\";\nimport { onlineManager } from \"./onlineManager.js\";\nimport { notifyManager } from \"./notifyManager.js\";\nimport { infiniteQueryBehavior } from \"./infiniteQueryBehavior.js\";\nvar QueryClient = class {\n  #queryCache;\n  #mutationCache;\n  #defaultOptions;\n  #queryDefaults;\n  #mutationDefaults;\n  #mountCount;\n  #unsubscribeFocus;\n  #unsubscribeOnline;\n  constructor(config = {}) {\n    this.#queryCache = config.queryCache || new QueryCache();\n    this.#mutationCache = config.mutationCache || new MutationCache();\n    this.#defaultOptions = config.defaultOptions || {};\n    this.#queryDefaults = /* @__PURE__ */ new Map();\n    this.#mutationDefaults = /* @__PURE__ */ new Map();\n    this.#mountCount = 0;\n  }\n  mount() {\n    this.#mountCount++;\n    if (this.#mountCount !== 1) return;\n    this.#unsubscribeFocus = focusManager.subscribe(async (focused) => {\n      if (focused) {\n        await this.resumePausedMutations();\n        this.#queryCache.onFocus();\n      }\n    });\n    this.#unsubscribeOnline = onlineManager.subscribe(async (online) => {\n      if (online) {\n        await this.resumePausedMutations();\n        this.#queryCache.onOnline();\n      }\n    });\n  }\n  unmount() {\n    this.#mountCount--;\n    if (this.#mountCount !== 0) return;\n    this.#unsubscribeFocus?.();\n    this.#unsubscribeFocus = void 0;\n    this.#unsubscribeOnline?.();\n    this.#unsubscribeOnline = void 0;\n  }\n  isFetching(filters) {\n    return this.#queryCache.findAll({ ...filters, fetchStatus: \"fetching\" }).length;\n  }\n  isMutating(filters) {\n    return this.#mutationCache.findAll({ ...filters, status: \"pending\" }).length;\n  }\n  /**\n   * Imperative (non-reactive) way to retrieve data for a QueryKey.\n   * Should only be used in callbacks or functions where reading the latest data is necessary, e.g. for optimistic updates.\n   *\n   * Hint: Do not use this function inside a component, because it won't receive updates.\n   * Use `useQuery` to create a `QueryObserver` that subscribes to changes.\n   */\n  getQueryData(queryKey) {\n    const options = this.defaultQueryOptions({ queryKey });\n    return this.#queryCache.get(options.queryHash)?.state.data;\n  }\n  ensureQueryData(options) {\n    const defaultedOptions = this.defaultQueryOptions(options);\n    const query = this.#queryCache.build(this, defaultedOptions);\n    const cachedData = query.state.data;\n    if (cachedData === void 0) {\n      return this.fetchQuery(options);\n    }\n    if (options.revalidateIfStale && query.isStaleByTime(resolveStaleTime(defaultedOptions.staleTime, query))) {\n      void this.prefetchQuery(defaultedOptions);\n    }\n    return Promise.resolve(cachedData);\n  }\n  getQueriesData(filters) {\n    return this.#queryCache.findAll(filters).map(({ queryKey, state }) => {\n      const data = state.data;\n      return [queryKey, data];\n    });\n  }\n  setQueryData(queryKey, updater, options) {\n    const defaultedOptions = this.defaultQueryOptions({ queryKey });\n    const query = this.#queryCache.get(\n      defaultedOptions.queryHash\n    );\n    const prevData = query?.state.data;\n    const data = functionalUpdate(updater, prevData);\n    if (data === void 0) {\n      return void 0;\n    }\n    return this.#queryCache.build(this, defaultedOptions).setData(data, { ...options, manual: true });\n  }\n  setQueriesData(filters, updater, options) {\n    return notifyManager.batch(\n      () => this.#queryCache.findAll(filters).map(({ queryKey }) => [\n        queryKey,\n        this.setQueryData(queryKey, updater, options)\n      ])\n    );\n  }\n  getQueryState(queryKey) {\n    const options = this.defaultQueryOptions({ queryKey });\n    return this.#queryCache.get(\n      options.queryHash\n    )?.state;\n  }\n  removeQueries(filters) {\n    const queryCache = this.#queryCache;\n    notifyManager.batch(() => {\n      queryCache.findAll(filters).forEach((query) => {\n        queryCache.remove(query);\n      });\n    });\n  }\n  resetQueries(filters, options) {\n    const queryCache = this.#queryCache;\n    return notifyManager.batch(() => {\n      queryCache.findAll(filters).forEach((query) => {\n        query.reset();\n      });\n      return this.refetchQueries(\n        {\n          type: \"active\",\n          ...filters\n        },\n        options\n      );\n    });\n  }\n  cancelQueries(filters, cancelOptions = {}) {\n    const defaultedCancelOptions = { revert: true, ...cancelOptions };\n    const promises = notifyManager.batch(\n      () => this.#queryCache.findAll(filters).map((query) => query.cancel(defaultedCancelOptions))\n    );\n    return Promise.all(promises).then(noop).catch(noop);\n  }\n  invalidateQueries(filters, options = {}) {\n    return notifyManager.batch(() => {\n      this.#queryCache.findAll(filters).forEach((query) => {\n        query.invalidate();\n      });\n      if (filters?.refetchType === \"none\") {\n        return Promise.resolve();\n      }\n      return this.refetchQueries(\n        {\n          ...filters,\n          type: filters?.refetchType ?? filters?.type ?? \"active\"\n        },\n        options\n      );\n    });\n  }\n  refetchQueries(filters, options = {}) {\n    const fetchOptions = {\n      ...options,\n      cancelRefetch: options.cancelRefetch ?? true\n    };\n    const promises = notifyManager.batch(\n      () => this.#queryCache.findAll(filters).filter((query) => !query.isDisabled() && !query.isStatic()).map((query) => {\n        let promise = query.fetch(void 0, fetchOptions);\n        if (!fetchOptions.throwOnError) {\n          promise = promise.catch(noop);\n        }\n        return query.state.fetchStatus === \"paused\" ? Promise.resolve() : promise;\n      })\n    );\n    return Promise.all(promises).then(noop);\n  }\n  fetchQuery(options) {\n    const defaultedOptions = this.defaultQueryOptions(options);\n    if (defaultedOptions.retry === void 0) {\n      defaultedOptions.retry = false;\n    }\n    const query = this.#queryCache.build(this, defaultedOptions);\n    return query.isStaleByTime(\n      resolveStaleTime(defaultedOptions.staleTime, query)\n    ) ? query.fetch(defaultedOptions) : Promise.resolve(query.state.data);\n  }\n  prefetchQuery(options) {\n    return this.fetchQuery(options).then(noop).catch(noop);\n  }\n  fetchInfiniteQuery(options) {\n    options.behavior = infiniteQueryBehavior(options.pages);\n    return this.fetchQuery(options);\n  }\n  prefetchInfiniteQuery(options) {\n    return this.fetchInfiniteQuery(options).then(noop).catch(noop);\n  }\n  ensureInfiniteQueryData(options) {\n    options.behavior = infiniteQueryBehavior(options.pages);\n    return this.ensureQueryData(options);\n  }\n  resumePausedMutations() {\n    if (onlineManager.isOnline()) {\n      return this.#mutationCache.resumePausedMutations();\n    }\n    return Promise.resolve();\n  }\n  getQueryCache() {\n    return this.#queryCache;\n  }\n  getMutationCache() {\n    return this.#mutationCache;\n  }\n  getDefaultOptions() {\n    return this.#defaultOptions;\n  }\n  setDefaultOptions(options) {\n    this.#defaultOptions = options;\n  }\n  setQueryDefaults(queryKey, options) {\n    this.#queryDefaults.set(hashKey(queryKey), {\n      queryKey,\n      defaultOptions: options\n    });\n  }\n  getQueryDefaults(queryKey) {\n    const defaults = [...this.#queryDefaults.values()];\n    const result = {};\n    defaults.forEach((queryDefault) => {\n      if (partialMatchKey(queryKey, queryDefault.queryKey)) {\n        Object.assign(result, queryDefault.defaultOptions);\n      }\n    });\n    return result;\n  }\n  setMutationDefaults(mutationKey, options) {\n    this.#mutationDefaults.set(hashKey(mutationKey), {\n      mutationKey,\n      defaultOptions: options\n    });\n  }\n  getMutationDefaults(mutationKey) {\n    const defaults = [...this.#mutationDefaults.values()];\n    const result = {};\n    defaults.forEach((queryDefault) => {\n      if (partialMatchKey(mutationKey, queryDefault.mutationKey)) {\n        Object.assign(result, queryDefault.defaultOptions);\n      }\n    });\n    return result;\n  }\n  defaultQueryOptions(options) {\n    if (options._defaulted) {\n      return options;\n    }\n    const defaultedOptions = {\n      ...this.#defaultOptions.queries,\n      ...this.getQueryDefaults(options.queryKey),\n      ...options,\n      _defaulted: true\n    };\n    if (!defaultedOptions.queryHash) {\n      defaultedOptions.queryHash = hashQueryKeyByOptions(\n        defaultedOptions.queryKey,\n        defaultedOptions\n      );\n    }\n    if (defaultedOptions.refetchOnReconnect === void 0) {\n      defaultedOptions.refetchOnReconnect = defaultedOptions.networkMode !== \"always\";\n    }\n    if (defaultedOptions.throwOnError === void 0) {\n      defaultedOptions.throwOnError = !!defaultedOptions.suspense;\n    }\n    if (!defaultedOptions.networkMode && defaultedOptions.persister) {\n      defaultedOptions.networkMode = \"offlineFirst\";\n    }\n    if (defaultedOptions.queryFn === skipToken) {\n      defaultedOptions.enabled = false;\n    }\n    return defaultedOptions;\n  }\n  defaultMutationOptions(options) {\n    if (options?._defaulted) {\n      return options;\n    }\n    return {\n      ...this.#defaultOptions.mutations,\n      ...options?.mutationKey && this.getMutationDefaults(options.mutationKey),\n      ...options,\n      _defaulted: true\n    };\n  }\n  clear() {\n    this.#queryCache.clear();\n    this.#mutationCache.clear();\n  }\n};\nexport {\n  QueryClient\n};\n//# sourceMappingURL=queryClient.js.map","\"use client\";\n\n// src/HydrationBoundary.tsx\nimport * as React from \"react\";\nimport { hydrate } from \"@tanstack/query-core\";\nimport { useQueryClient } from \"./QueryClientProvider.js\";\nvar HydrationBoundary = ({\n  children,\n  options = {},\n  state,\n  queryClient\n}) => {\n  const client = useQueryClient(queryClient);\n  const optionsRef = React.useRef(options);\n  React.useEffect(() => {\n    optionsRef.current = options;\n  });\n  const hydrationQueue = React.useMemo(() => {\n    if (state) {\n      if (typeof state !== \"object\") {\n        return;\n      }\n      const queryCache = client.getQueryCache();\n      const queries = state.queries || [];\n      const newQueries = [];\n      const existingQueries = [];\n      for (const dehydratedQuery of queries) {\n        const existingQuery = queryCache.get(dehydratedQuery.queryHash);\n        if (!existingQuery) {\n          newQueries.push(dehydratedQuery);\n        } else {\n          const hydrationIsNewer = dehydratedQuery.state.dataUpdatedAt > existingQuery.state.dataUpdatedAt || dehydratedQuery.promise && existingQuery.state.status !== \"pending\" && existingQuery.state.fetchStatus !== \"fetching\" && dehydratedQuery.dehydratedAt !== void 0 && dehydratedQuery.dehydratedAt > existingQuery.state.dataUpdatedAt;\n          if (hydrationIsNewer) {\n            existingQueries.push(dehydratedQuery);\n          }\n        }\n      }\n      if (newQueries.length > 0) {\n        hydrate(client, { queries: newQueries }, optionsRef.current);\n      }\n      if (existingQueries.length > 0) {\n        return existingQueries;\n      }\n    }\n    return void 0;\n  }, [client, state]);\n  React.useEffect(() => {\n    if (hydrationQueue) {\n      hydrate(client, { queries: hydrationQueue }, optionsRef.current);\n    }\n  }, [client, hydrationQueue]);\n  return children;\n};\nexport {\n  HydrationBoundary\n};\n//# sourceMappingURL=HydrationBoundary.js.map"],"names":["defaultTransformerFn","data","dehydrateMutation","mutation","dehydrateQuery","query","serializeData","shouldRedactErrors","dehydratePromise","promise","error","noop","defaultShouldDehydrateMutation","defaultShouldDehydrateQuery","defaultShouldRedactErrors","_","dehydrate","client","options","filterMutation","mutations","filterQuery","queries","hydrate","dehydratedState","mutationCache","queryCache","deserializeData","state","mutationOptions","queryKey","queryHash","meta","dehydratedAt","syncData","tryResolveSync","rawData","existingQueryIsPending","existingQueryIsFetching","hasNewerSyncData","_ignored","serializedState","infiniteQueryBehavior","pages","context","direction","oldPages","oldPageParams","result","currentPage","fetchFn","cancelled","addSignalProperty","object","queryFn","ensureQueryFn","fetchPage","param","previous","queryFnContext","queryFnContext2","page","maxPages","addTo","addToStart","addToEnd","pageParamFn","getPreviousPageParam","getNextPageParam","oldData","remainingPages","pageParams","lastIndex","hasNextPage","hasPreviousPage","MutationCache","Subscribable","config","#mutations","#scopes","#mutationId","Mutation","scope","scopeFor","scopedMutations","index","firstPendingMutation","m","notifyManager","filters","defaultedFilters","matchMutation","event","listener","pausedMutations","x","QueryCache","#queries","hashQueryKeyByOptions","Query","queryInMap","matchQuery","QueryClient","#queryCache","#mutationCache","#defaultOptions","#queryDefaults","#mutationDefaults","#mountCount","#unsubscribeFocus","#unsubscribeOnline","focusManager","focused","onlineManager","online","defaultedOptions","cachedData","resolveStaleTime","updater","prevData","functionalUpdate","cancelOptions","defaultedCancelOptions","promises","fetchOptions","hashKey","defaults","queryDefault","partialMatchKey","mutationKey","skipToken","HydrationBoundary","children","queryClient","useQueryClient","optionsRef","React","hydrationQueue","newQueries","existingQueries","dehydratedQuery","existingQuery"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4,5]}