{"version":3,"file":"zudoku.auth-openid.js","sources":["../../../node_modules/.pnpm/oauth4webapi@3.8.3/node_modules/oauth4webapi/build/index.js","../src/lib/authentication/providers/openid.tsx"],"sourcesContent":["let USER_AGENT;\nif (typeof navigator === 'undefined' || !navigator.userAgent?.startsWith?.('Mozilla/5.0 ')) {\n    const NAME = 'oauth4webapi';\n    const VERSION = 'v3.8.3';\n    USER_AGENT = `${NAME}/${VERSION}`;\n}\nfunction looseInstanceOf(input, expected) {\n    if (input == null) {\n        return false;\n    }\n    try {\n        return (input instanceof expected ||\n            Object.getPrototypeOf(input)[Symbol.toStringTag] === expected.prototype[Symbol.toStringTag]);\n    }\n    catch {\n        return false;\n    }\n}\nconst ERR_INVALID_ARG_VALUE = 'ERR_INVALID_ARG_VALUE';\nconst ERR_INVALID_ARG_TYPE = 'ERR_INVALID_ARG_TYPE';\nfunction CodedTypeError(message, code, cause) {\n    const err = new TypeError(message, { cause });\n    Object.assign(err, { code });\n    return err;\n}\nexport const allowInsecureRequests = Symbol();\nexport const clockSkew = Symbol();\nexport const clockTolerance = Symbol();\nexport const customFetch = Symbol();\nexport const modifyAssertion = Symbol();\nexport const jweDecrypt = Symbol();\nexport const jwksCache = Symbol();\nconst encoder = new TextEncoder();\nconst decoder = new TextDecoder();\nfunction buf(input) {\n    if (typeof input === 'string') {\n        return encoder.encode(input);\n    }\n    return decoder.decode(input);\n}\nlet encodeBase64Url;\nif (Uint8Array.prototype.toBase64) {\n    encodeBase64Url = (input) => {\n        if (input instanceof ArrayBuffer) {\n            input = new Uint8Array(input);\n        }\n        return input.toBase64({ alphabet: 'base64url', omitPadding: true });\n    };\n}\nelse {\n    const CHUNK_SIZE = 0x8000;\n    encodeBase64Url = (input) => {\n        if (input instanceof ArrayBuffer) {\n            input = new Uint8Array(input);\n        }\n        const arr = [];\n        for (let i = 0; i < input.byteLength; i += CHUNK_SIZE) {\n            arr.push(String.fromCharCode.apply(null, input.subarray(i, i + CHUNK_SIZE)));\n        }\n        return btoa(arr.join('')).replace(/=/g, '').replace(/\\+/g, '-').replace(/\\//g, '_');\n    };\n}\nlet decodeBase64Url;\nif (Uint8Array.fromBase64) {\n    decodeBase64Url = (input) => {\n        try {\n            return Uint8Array.fromBase64(input, { alphabet: 'base64url' });\n        }\n        catch (cause) {\n            throw CodedTypeError('The input to be decoded is not correctly encoded.', ERR_INVALID_ARG_VALUE, cause);\n        }\n    };\n}\nelse {\n    decodeBase64Url = (input) => {\n        try {\n            const binary = atob(input.replace(/-/g, '+').replace(/_/g, '/').replace(/\\s/g, ''));\n            const bytes = new Uint8Array(binary.length);\n            for (let i = 0; i < binary.length; i++) {\n                bytes[i] = binary.charCodeAt(i);\n            }\n            return bytes;\n        }\n        catch (cause) {\n            throw CodedTypeError('The input to be decoded is not correctly encoded.', ERR_INVALID_ARG_VALUE, cause);\n        }\n    };\n}\nfunction b64u(input) {\n    if (typeof input === 'string') {\n        return decodeBase64Url(input);\n    }\n    return encodeBase64Url(input);\n}\nexport class UnsupportedOperationError extends Error {\n    code;\n    constructor(message, options) {\n        super(message, options);\n        this.name = this.constructor.name;\n        this.code = UNSUPPORTED_OPERATION;\n        Error.captureStackTrace?.(this, this.constructor);\n    }\n}\nexport class OperationProcessingError extends Error {\n    code;\n    constructor(message, options) {\n        super(message, options);\n        this.name = this.constructor.name;\n        if (options?.code) {\n            this.code = options?.code;\n        }\n        Error.captureStackTrace?.(this, this.constructor);\n    }\n}\nfunction OPE(message, code, cause) {\n    return new OperationProcessingError(message, { code, cause });\n}\nasync function calculateJwkThumbprint(jwk) {\n    let components;\n    switch (jwk.kty) {\n        case 'EC':\n            components = {\n                crv: jwk.crv,\n                kty: jwk.kty,\n                x: jwk.x,\n                y: jwk.y,\n            };\n            break;\n        case 'OKP':\n            components = {\n                crv: jwk.crv,\n                kty: jwk.kty,\n                x: jwk.x,\n            };\n            break;\n        case 'AKP':\n            components = {\n                alg: jwk.alg,\n                kty: jwk.kty,\n                pub: jwk.pub,\n            };\n            break;\n        case 'RSA':\n            components = {\n                e: jwk.e,\n                kty: jwk.kty,\n                n: jwk.n,\n            };\n            break;\n        default:\n            throw new UnsupportedOperationError('unsupported JWK key type', { cause: jwk });\n    }\n    return b64u(await crypto.subtle.digest('SHA-256', buf(JSON.stringify(components))));\n}\nfunction assertCryptoKey(key, it) {\n    if (!(key instanceof CryptoKey)) {\n        throw CodedTypeError(`${it} must be a CryptoKey`, ERR_INVALID_ARG_TYPE);\n    }\n}\nfunction assertPrivateKey(key, it) {\n    assertCryptoKey(key, it);\n    if (key.type !== 'private') {\n        throw CodedTypeError(`${it} must be a private CryptoKey`, ERR_INVALID_ARG_VALUE);\n    }\n}\nfunction assertPublicKey(key, it) {\n    assertCryptoKey(key, it);\n    if (key.type !== 'public') {\n        throw CodedTypeError(`${it} must be a public CryptoKey`, ERR_INVALID_ARG_VALUE);\n    }\n}\nfunction normalizeTyp(value) {\n    return value.toLowerCase().replace(/^application\\//, '');\n}\nfunction isJsonObject(input) {\n    if (input === null || typeof input !== 'object' || Array.isArray(input)) {\n        return false;\n    }\n    return true;\n}\nfunction prepareHeaders(input) {\n    if (looseInstanceOf(input, Headers)) {\n        input = Object.fromEntries(input.entries());\n    }\n    const headers = new Headers(input ?? {});\n    if (USER_AGENT && !headers.has('user-agent')) {\n        headers.set('user-agent', USER_AGENT);\n    }\n    if (headers.has('authorization')) {\n        throw CodedTypeError('\"options.headers\" must not include the \"authorization\" header name', ERR_INVALID_ARG_VALUE);\n    }\n    return headers;\n}\nfunction signal(url, value) {\n    if (value !== undefined) {\n        if (typeof value === 'function') {\n            value = value(url.href);\n        }\n        if (!(value instanceof AbortSignal)) {\n            throw CodedTypeError('\"options.signal\" must return or be an instance of AbortSignal', ERR_INVALID_ARG_TYPE);\n        }\n        return value;\n    }\n    return undefined;\n}\nfunction replaceDoubleSlash(pathname) {\n    if (pathname.includes('//')) {\n        return pathname.replace('//', '/');\n    }\n    return pathname;\n}\nfunction prependWellKnown(url, wellKnown, allowTerminatingSlash = false) {\n    if (url.pathname === '/') {\n        url.pathname = wellKnown;\n    }\n    else {\n        url.pathname = replaceDoubleSlash(`${wellKnown}/${allowTerminatingSlash ? url.pathname : url.pathname.replace(/(\\/)$/, '')}`);\n    }\n    return url;\n}\nfunction appendWellKnown(url, wellKnown) {\n    url.pathname = replaceDoubleSlash(`${url.pathname}/${wellKnown}`);\n    return url;\n}\nasync function performDiscovery(input, urlName, transform, options) {\n    if (!(input instanceof URL)) {\n        throw CodedTypeError(`\"${urlName}\" must be an instance of URL`, ERR_INVALID_ARG_TYPE);\n    }\n    checkProtocol(input, options?.[allowInsecureRequests] !== true);\n    const url = transform(new URL(input.href));\n    const headers = prepareHeaders(options?.headers);\n    headers.set('accept', 'application/json');\n    return (options?.[customFetch] || fetch)(url.href, {\n        body: undefined,\n        headers: Object.fromEntries(headers.entries()),\n        method: 'GET',\n        redirect: 'manual',\n        signal: signal(url, options?.signal),\n    });\n}\nexport async function discoveryRequest(issuerIdentifier, options) {\n    return performDiscovery(issuerIdentifier, 'issuerIdentifier', (url) => {\n        switch (options?.algorithm) {\n            case undefined:\n            case 'oidc':\n                appendWellKnown(url, '.well-known/openid-configuration');\n                break;\n            case 'oauth2':\n                prependWellKnown(url, '.well-known/oauth-authorization-server');\n                break;\n            default:\n                throw CodedTypeError('\"options.algorithm\" must be \"oidc\" (default), or \"oauth2\"', ERR_INVALID_ARG_VALUE);\n        }\n        return url;\n    }, options);\n}\nfunction assertNumber(input, allow0, it, code, cause) {\n    try {\n        if (typeof input !== 'number' || !Number.isFinite(input)) {\n            throw CodedTypeError(`${it} must be a number`, ERR_INVALID_ARG_TYPE, cause);\n        }\n        if (input > 0)\n            return;\n        if (allow0) {\n            if (input !== 0) {\n                throw CodedTypeError(`${it} must be a non-negative number`, ERR_INVALID_ARG_VALUE, cause);\n            }\n            return;\n        }\n        throw CodedTypeError(`${it} must be a positive number`, ERR_INVALID_ARG_VALUE, cause);\n    }\n    catch (err) {\n        if (code) {\n            throw OPE(err.message, code, cause);\n        }\n        throw err;\n    }\n}\nfunction assertString(input, it, code, cause) {\n    try {\n        if (typeof input !== 'string') {\n            throw CodedTypeError(`${it} must be a string`, ERR_INVALID_ARG_TYPE, cause);\n        }\n        if (input.length === 0) {\n            throw CodedTypeError(`${it} must not be empty`, ERR_INVALID_ARG_VALUE, cause);\n        }\n    }\n    catch (err) {\n        if (code) {\n            throw OPE(err.message, code, cause);\n        }\n        throw err;\n    }\n}\nexport async function processDiscoveryResponse(expectedIssuerIdentifier, response) {\n    const expected = expectedIssuerIdentifier;\n    if (!(expected instanceof URL) && expected !== _nodiscoverycheck) {\n        throw CodedTypeError('\"expectedIssuerIdentifier\" must be an instance of URL', ERR_INVALID_ARG_TYPE);\n    }\n    if (!looseInstanceOf(response, Response)) {\n        throw CodedTypeError('\"response\" must be an instance of Response', ERR_INVALID_ARG_TYPE);\n    }\n    if (response.status !== 200) {\n        throw OPE('\"response\" is not a conform Authorization Server Metadata response (unexpected HTTP status code)', RESPONSE_IS_NOT_CONFORM, response);\n    }\n    assertReadableResponse(response);\n    const json = await getResponseJsonBody(response);\n    assertString(json.issuer, '\"response\" body \"issuer\" property', INVALID_RESPONSE, { body: json });\n    if (expected !== _nodiscoverycheck && new URL(json.issuer).href !== expected.href) {\n        throw OPE('\"response\" body \"issuer\" property does not match the expected value', JSON_ATTRIBUTE_COMPARISON, { expected: expected.href, body: json, attribute: 'issuer' });\n    }\n    return json;\n}\nfunction assertApplicationJson(response) {\n    assertContentType(response, 'application/json');\n}\nfunction notJson(response, ...types) {\n    let msg = '\"response\" content-type must be ';\n    if (types.length > 2) {\n        const last = types.pop();\n        msg += `${types.join(', ')}, or ${last}`;\n    }\n    else if (types.length === 2) {\n        msg += `${types[0]} or ${types[1]}`;\n    }\n    else {\n        msg += types[0];\n    }\n    return OPE(msg, RESPONSE_IS_NOT_JSON, response);\n}\nfunction assertContentTypes(response, ...types) {\n    if (!types.includes(getContentType(response))) {\n        throw notJson(response, ...types);\n    }\n}\nfunction assertContentType(response, contentType) {\n    if (getContentType(response) !== contentType) {\n        throw notJson(response, contentType);\n    }\n}\nfunction randomBytes() {\n    return b64u(crypto.getRandomValues(new Uint8Array(32)));\n}\nexport function generateRandomCodeVerifier() {\n    return randomBytes();\n}\nexport function generateRandomState() {\n    return randomBytes();\n}\nexport function generateRandomNonce() {\n    return randomBytes();\n}\nexport async function calculatePKCECodeChallenge(codeVerifier) {\n    assertString(codeVerifier, 'codeVerifier');\n    return b64u(await crypto.subtle.digest('SHA-256', buf(codeVerifier)));\n}\nfunction getKeyAndKid(input) {\n    if (input instanceof CryptoKey) {\n        return { key: input };\n    }\n    if (!(input?.key instanceof CryptoKey)) {\n        return {};\n    }\n    if (input.kid !== undefined) {\n        assertString(input.kid, '\"kid\"');\n    }\n    return {\n        key: input.key,\n        kid: input.kid,\n    };\n}\nfunction psAlg(key) {\n    switch (key.algorithm.hash.name) {\n        case 'SHA-256':\n            return 'PS256';\n        case 'SHA-384':\n            return 'PS384';\n        case 'SHA-512':\n            return 'PS512';\n        default:\n            throw new UnsupportedOperationError('unsupported RsaHashedKeyAlgorithm hash name', {\n                cause: key,\n            });\n    }\n}\nfunction rsAlg(key) {\n    switch (key.algorithm.hash.name) {\n        case 'SHA-256':\n            return 'RS256';\n        case 'SHA-384':\n            return 'RS384';\n        case 'SHA-512':\n            return 'RS512';\n        default:\n            throw new UnsupportedOperationError('unsupported RsaHashedKeyAlgorithm hash name', {\n                cause: key,\n            });\n    }\n}\nfunction esAlg(key) {\n    switch (key.algorithm.namedCurve) {\n        case 'P-256':\n            return 'ES256';\n        case 'P-384':\n            return 'ES384';\n        case 'P-521':\n            return 'ES512';\n        default:\n            throw new UnsupportedOperationError('unsupported EcKeyAlgorithm namedCurve', { cause: key });\n    }\n}\nfunction keyToJws(key) {\n    switch (key.algorithm.name) {\n        case 'RSA-PSS':\n            return psAlg(key);\n        case 'RSASSA-PKCS1-v1_5':\n            return rsAlg(key);\n        case 'ECDSA':\n            return esAlg(key);\n        case 'Ed25519':\n        case 'ML-DSA-44':\n        case 'ML-DSA-65':\n        case 'ML-DSA-87':\n            return key.algorithm.name;\n        case 'EdDSA':\n            return 'Ed25519';\n        default:\n            throw new UnsupportedOperationError('unsupported CryptoKey algorithm name', { cause: key });\n    }\n}\nfunction getClockSkew(client) {\n    const skew = client?.[clockSkew];\n    return typeof skew === 'number' && Number.isFinite(skew) ? skew : 0;\n}\nfunction getClockTolerance(client) {\n    const tolerance = client?.[clockTolerance];\n    return typeof tolerance === 'number' && Number.isFinite(tolerance) && Math.sign(tolerance) !== -1\n        ? tolerance\n        : 30;\n}\nfunction epochTime() {\n    return Math.floor(Date.now() / 1000);\n}\nfunction assertAs(as) {\n    if (typeof as !== 'object' || as === null) {\n        throw CodedTypeError('\"as\" must be an object', ERR_INVALID_ARG_TYPE);\n    }\n    assertString(as.issuer, '\"as.issuer\"');\n}\nfunction assertClient(client) {\n    if (typeof client !== 'object' || client === null) {\n        throw CodedTypeError('\"client\" must be an object', ERR_INVALID_ARG_TYPE);\n    }\n    assertString(client.client_id, '\"client.client_id\"');\n}\nfunction formUrlEncode(token) {\n    return encodeURIComponent(token).replace(/(?:[-_.!~*'()]|%20)/g, (substring) => {\n        switch (substring) {\n            case '-':\n            case '_':\n            case '.':\n            case '!':\n            case '~':\n            case '*':\n            case \"'\":\n            case '(':\n            case ')':\n                return `%${substring.charCodeAt(0).toString(16).toUpperCase()}`;\n            case '%20':\n                return '+';\n            default:\n                throw new Error();\n        }\n    });\n}\nexport function ClientSecretPost(clientSecret) {\n    assertString(clientSecret, '\"clientSecret\"');\n    return (_as, client, body, _headers) => {\n        body.set('client_id', client.client_id);\n        body.set('client_secret', clientSecret);\n    };\n}\nexport function ClientSecretBasic(clientSecret) {\n    assertString(clientSecret, '\"clientSecret\"');\n    return (_as, client, _body, headers) => {\n        const username = formUrlEncode(client.client_id);\n        const password = formUrlEncode(clientSecret);\n        const credentials = btoa(`${username}:${password}`);\n        headers.set('authorization', `Basic ${credentials}`);\n    };\n}\nfunction clientAssertionPayload(as, client) {\n    const now = epochTime() + getClockSkew(client);\n    return {\n        jti: randomBytes(),\n        aud: as.issuer,\n        exp: now + 60,\n        iat: now,\n        nbf: now,\n        iss: client.client_id,\n        sub: client.client_id,\n    };\n}\nexport function PrivateKeyJwt(clientPrivateKey, options) {\n    const { key, kid } = getKeyAndKid(clientPrivateKey);\n    assertPrivateKey(key, '\"clientPrivateKey.key\"');\n    return async (as, client, body, _headers) => {\n        const header = { alg: keyToJws(key), kid };\n        const payload = clientAssertionPayload(as, client);\n        options?.[modifyAssertion]?.(header, payload);\n        body.set('client_id', client.client_id);\n        body.set('client_assertion_type', 'urn:ietf:params:oauth:client-assertion-type:jwt-bearer');\n        body.set('client_assertion', await signJwt(header, payload, key));\n    };\n}\nexport function ClientSecretJwt(clientSecret, options) {\n    assertString(clientSecret, '\"clientSecret\"');\n    const modify = options?.[modifyAssertion];\n    let key;\n    return async (as, client, body, _headers) => {\n        key ||= await crypto.subtle.importKey('raw', buf(clientSecret), { hash: 'SHA-256', name: 'HMAC' }, false, ['sign']);\n        const header = { alg: 'HS256' };\n        const payload = clientAssertionPayload(as, client);\n        modify?.(header, payload);\n        const data = `${b64u(buf(JSON.stringify(header)))}.${b64u(buf(JSON.stringify(payload)))}`;\n        const hmac = await crypto.subtle.sign(key.algorithm, key, buf(data));\n        body.set('client_id', client.client_id);\n        body.set('client_assertion_type', 'urn:ietf:params:oauth:client-assertion-type:jwt-bearer');\n        body.set('client_assertion', `${data}.${b64u(new Uint8Array(hmac))}`);\n    };\n}\nexport function None() {\n    return (_as, client, body, _headers) => {\n        body.set('client_id', client.client_id);\n    };\n}\nexport function TlsClientAuth() {\n    return None();\n}\nasync function signJwt(header, payload, key) {\n    if (!key.usages.includes('sign')) {\n        throw CodedTypeError('CryptoKey instances used for signing assertions must include \"sign\" in their \"usages\"', ERR_INVALID_ARG_VALUE);\n    }\n    const input = `${b64u(buf(JSON.stringify(header)))}.${b64u(buf(JSON.stringify(payload)))}`;\n    const signature = b64u(await crypto.subtle.sign(keyToSubtle(key), key, buf(input)));\n    return `${input}.${signature}`;\n}\nexport async function issueRequestObject(as, client, parameters, privateKey, options) {\n    assertAs(as);\n    assertClient(client);\n    parameters = new URLSearchParams(parameters);\n    const { key, kid } = getKeyAndKid(privateKey);\n    assertPrivateKey(key, '\"privateKey.key\"');\n    parameters.set('client_id', client.client_id);\n    const now = epochTime() + getClockSkew(client);\n    const claims = {\n        ...Object.fromEntries(parameters.entries()),\n        jti: randomBytes(),\n        aud: as.issuer,\n        exp: now + 60,\n        iat: now,\n        nbf: now,\n        iss: client.client_id,\n    };\n    let resource;\n    if (parameters.has('resource') &&\n        (resource = parameters.getAll('resource')) &&\n        resource.length > 1) {\n        claims.resource = resource;\n    }\n    {\n        let value = parameters.get('max_age');\n        if (value !== null) {\n            claims.max_age = parseInt(value, 10);\n            assertNumber(claims.max_age, true, '\"max_age\" parameter');\n        }\n    }\n    {\n        let value = parameters.get('claims');\n        if (value !== null) {\n            try {\n                claims.claims = JSON.parse(value);\n            }\n            catch (cause) {\n                throw OPE('failed to parse the \"claims\" parameter as JSON', PARSE_ERROR, cause);\n            }\n            if (!isJsonObject(claims.claims)) {\n                throw CodedTypeError('\"claims\" parameter must be a JSON with a top level object', ERR_INVALID_ARG_VALUE);\n            }\n        }\n    }\n    {\n        let value = parameters.get('authorization_details');\n        if (value !== null) {\n            try {\n                claims.authorization_details = JSON.parse(value);\n            }\n            catch (cause) {\n                throw OPE('failed to parse the \"authorization_details\" parameter as JSON', PARSE_ERROR, cause);\n            }\n            if (!Array.isArray(claims.authorization_details)) {\n                throw CodedTypeError('\"authorization_details\" parameter must be a JSON with a top level array', ERR_INVALID_ARG_VALUE);\n            }\n        }\n    }\n    const header = {\n        alg: keyToJws(key),\n        typ: 'oauth-authz-req+jwt',\n        kid,\n    };\n    options?.[modifyAssertion]?.(header, claims);\n    return signJwt(header, claims, key);\n}\nlet jwkCache;\nasync function getSetPublicJwkCache(key, alg) {\n    const { kty, e, n, x, y, crv, pub } = await crypto.subtle.exportKey('jwk', key);\n    const jwk = { kty, e, n, x, y, crv, pub };\n    if (kty === 'AKP')\n        jwk.alg = alg;\n    jwkCache.set(key, jwk);\n    return jwk;\n}\nasync function publicJwk(key, alg) {\n    jwkCache ||= new WeakMap();\n    return jwkCache.get(key) || getSetPublicJwkCache(key, alg);\n}\nconst URLParse = URL.parse\n    ?\n        (url, base) => URL.parse(url, base)\n    : (url, base) => {\n        try {\n            return new URL(url, base);\n        }\n        catch {\n            return null;\n        }\n    };\nexport function checkProtocol(url, enforceHttps) {\n    if (enforceHttps && url.protocol !== 'https:') {\n        throw OPE('only requests to HTTPS are allowed', HTTP_REQUEST_FORBIDDEN, url);\n    }\n    if (url.protocol !== 'https:' && url.protocol !== 'http:') {\n        throw OPE('only HTTP and HTTPS requests are allowed', REQUEST_PROTOCOL_FORBIDDEN, url);\n    }\n}\nfunction validateEndpoint(value, endpoint, useMtlsAlias, enforceHttps) {\n    let url;\n    if (typeof value !== 'string' || !(url = URLParse(value))) {\n        throw OPE(`authorization server metadata does not contain a valid ${useMtlsAlias ? `\"as.mtls_endpoint_aliases.${endpoint}\"` : `\"as.${endpoint}\"`}`, value === undefined ? MISSING_SERVER_METADATA : INVALID_SERVER_METADATA, { attribute: useMtlsAlias ? `mtls_endpoint_aliases.${endpoint}` : endpoint });\n    }\n    checkProtocol(url, enforceHttps);\n    return url;\n}\nexport function resolveEndpoint(as, endpoint, useMtlsAlias, enforceHttps) {\n    if (useMtlsAlias && as.mtls_endpoint_aliases && endpoint in as.mtls_endpoint_aliases) {\n        return validateEndpoint(as.mtls_endpoint_aliases[endpoint], endpoint, useMtlsAlias, enforceHttps);\n    }\n    return validateEndpoint(as[endpoint], endpoint, useMtlsAlias, enforceHttps);\n}\nexport async function pushedAuthorizationRequest(as, client, clientAuthentication, parameters, options) {\n    assertAs(as);\n    assertClient(client);\n    const url = resolveEndpoint(as, 'pushed_authorization_request_endpoint', client.use_mtls_endpoint_aliases, options?.[allowInsecureRequests] !== true);\n    const body = new URLSearchParams(parameters);\n    body.set('client_id', client.client_id);\n    const headers = prepareHeaders(options?.headers);\n    headers.set('accept', 'application/json');\n    if (options?.DPoP !== undefined) {\n        assertDPoP(options.DPoP);\n        await options.DPoP.addProof(url, headers, 'POST');\n    }\n    const response = await authenticatedRequest(as, client, clientAuthentication, url, body, headers, options);\n    options?.DPoP?.cacheNonce(response, url);\n    return response;\n}\nclass DPoPHandler {\n    #header;\n    #privateKey;\n    #publicKey;\n    #clockSkew;\n    #modifyAssertion;\n    #map;\n    #jkt;\n    constructor(client, keyPair, options) {\n        assertPrivateKey(keyPair?.privateKey, '\"DPoP.privateKey\"');\n        assertPublicKey(keyPair?.publicKey, '\"DPoP.publicKey\"');\n        if (!keyPair.publicKey.extractable) {\n            throw CodedTypeError('\"DPoP.publicKey.extractable\" must be true', ERR_INVALID_ARG_VALUE);\n        }\n        this.#modifyAssertion = options?.[modifyAssertion];\n        this.#clockSkew = getClockSkew(client);\n        this.#privateKey = keyPair.privateKey;\n        this.#publicKey = keyPair.publicKey;\n        branded.add(this);\n    }\n    #get(key) {\n        this.#map ||= new Map();\n        let item = this.#map.get(key);\n        if (item) {\n            this.#map.delete(key);\n            this.#map.set(key, item);\n        }\n        return item;\n    }\n    #set(key, val) {\n        this.#map ||= new Map();\n        this.#map.delete(key);\n        if (this.#map.size === 100) {\n            this.#map.delete(this.#map.keys().next().value);\n        }\n        this.#map.set(key, val);\n    }\n    async calculateThumbprint() {\n        if (!this.#jkt) {\n            const jwk = await crypto.subtle.exportKey('jwk', this.#publicKey);\n            this.#jkt ||= await calculateJwkThumbprint(jwk);\n        }\n        return this.#jkt;\n    }\n    async addProof(url, headers, htm, accessToken) {\n        const alg = keyToJws(this.#privateKey);\n        this.#header ||= {\n            alg,\n            typ: 'dpop+jwt',\n            jwk: await publicJwk(this.#publicKey, alg),\n        };\n        const nonce = this.#get(url.origin);\n        const now = epochTime() + this.#clockSkew;\n        const payload = {\n            iat: now,\n            jti: randomBytes(),\n            htm,\n            nonce,\n            htu: `${url.origin}${url.pathname}`,\n            ath: accessToken\n                ? b64u(await crypto.subtle.digest('SHA-256', buf(accessToken)))\n                : undefined,\n        };\n        this.#modifyAssertion?.(this.#header, payload);\n        headers.set('dpop', await signJwt(this.#header, payload, this.#privateKey));\n    }\n    cacheNonce(response, url) {\n        try {\n            const nonce = response.headers.get('dpop-nonce');\n            if (nonce) {\n                this.#set(url.origin, nonce);\n            }\n        }\n        catch { }\n    }\n}\nexport function isDPoPNonceError(err) {\n    if (err instanceof WWWAuthenticateChallengeError) {\n        const { 0: challenge, length } = err.cause;\n        return (length === 1 && challenge.scheme === 'dpop' && challenge.parameters.error === 'use_dpop_nonce');\n    }\n    if (err instanceof ResponseBodyError) {\n        return err.error === 'use_dpop_nonce';\n    }\n    return false;\n}\nexport function DPoP(client, keyPair, options) {\n    return new DPoPHandler(client, keyPair, options);\n}\nexport class ResponseBodyError extends Error {\n    cause;\n    code;\n    error;\n    status;\n    error_description;\n    response;\n    constructor(message, options) {\n        super(message, options);\n        this.name = this.constructor.name;\n        this.code = RESPONSE_BODY_ERROR;\n        this.cause = options.cause;\n        this.error = options.cause.error;\n        this.status = options.response.status;\n        this.error_description = options.cause.error_description;\n        Object.defineProperty(this, 'response', { enumerable: false, value: options.response });\n        Error.captureStackTrace?.(this, this.constructor);\n    }\n}\nexport class AuthorizationResponseError extends Error {\n    cause;\n    code;\n    error;\n    error_description;\n    constructor(message, options) {\n        super(message, options);\n        this.name = this.constructor.name;\n        this.code = AUTHORIZATION_RESPONSE_ERROR;\n        this.cause = options.cause;\n        this.error = options.cause.get('error');\n        this.error_description = options.cause.get('error_description') ?? undefined;\n        Error.captureStackTrace?.(this, this.constructor);\n    }\n}\nexport class WWWAuthenticateChallengeError extends Error {\n    cause;\n    code;\n    response;\n    status;\n    constructor(message, options) {\n        super(message, options);\n        this.name = this.constructor.name;\n        this.code = WWW_AUTHENTICATE_CHALLENGE;\n        this.cause = options.cause;\n        this.status = options.response.status;\n        this.response = options.response;\n        Object.defineProperty(this, 'response', { enumerable: false });\n        Error.captureStackTrace?.(this, this.constructor);\n    }\n}\nconst tokenMatch = \"[a-zA-Z0-9!#$%&\\\\'\\\\*\\\\+\\\\-\\\\.\\\\^_`\\\\|~]+\";\nconst token68Match = '[a-zA-Z0-9\\\\-\\\\._\\\\~\\\\+\\\\/]+={0,2}';\nconst quotedMatch = '\"((?:[^\"\\\\\\\\]|\\\\\\\\[\\\\s\\\\S])*)\"';\nconst quotedParamMatcher = '(' + tokenMatch + ')\\\\s*=\\\\s*' + quotedMatch;\nconst paramMatcher = '(' + tokenMatch + ')\\\\s*=\\\\s*(' + tokenMatch + ')';\nconst schemeRE = new RegExp('^[,\\\\s]*(' + tokenMatch + ')');\nconst quotedParamRE = new RegExp('^[,\\\\s]*' + quotedParamMatcher + '[,\\\\s]*(.*)');\nconst unquotedParamRE = new RegExp('^[,\\\\s]*' + paramMatcher + '[,\\\\s]*(.*)');\nconst token68ParamRE = new RegExp('^(' + token68Match + ')(?:$|[,\\\\s])(.*)');\nfunction parseWwwAuthenticateChallenges(response) {\n    if (!looseInstanceOf(response, Response)) {\n        throw CodedTypeError('\"response\" must be an instance of Response', ERR_INVALID_ARG_TYPE);\n    }\n    const header = response.headers.get('www-authenticate');\n    if (header === null) {\n        return undefined;\n    }\n    const challenges = [];\n    let rest = header;\n    while (rest) {\n        let match = rest.match(schemeRE);\n        const scheme = match?.['1'].toLowerCase();\n        if (!scheme) {\n            return undefined;\n        }\n        const afterScheme = rest.substring(match[0].length);\n        if (afterScheme && !afterScheme.match(/^[\\s,]/)) {\n            return undefined;\n        }\n        const spaceMatch = afterScheme.match(/^\\s+(.*)$/);\n        const hasParameters = !!spaceMatch;\n        rest = spaceMatch ? spaceMatch[1] : undefined;\n        const parameters = {};\n        let token68;\n        if (hasParameters) {\n            while (rest) {\n                let key;\n                let value;\n                if ((match = rest.match(quotedParamRE))) {\n                    ;\n                    [, key, value, rest] = match;\n                    if (value.includes('\\\\')) {\n                        try {\n                            value = JSON.parse(`\"${value}\"`);\n                        }\n                        catch { }\n                    }\n                    parameters[key.toLowerCase()] = value;\n                    continue;\n                }\n                if ((match = rest.match(unquotedParamRE))) {\n                    ;\n                    [, key, value, rest] = match;\n                    parameters[key.toLowerCase()] = value;\n                    continue;\n                }\n                if ((match = rest.match(token68ParamRE))) {\n                    if (Object.keys(parameters).length) {\n                        break;\n                    }\n                    ;\n                    [, token68, rest] = match;\n                    break;\n                }\n                return undefined;\n            }\n        }\n        else {\n            rest = afterScheme || undefined;\n        }\n        const challenge = { scheme, parameters };\n        if (token68) {\n            challenge.token68 = token68;\n        }\n        challenges.push(challenge);\n    }\n    if (!challenges.length) {\n        return undefined;\n    }\n    return challenges;\n}\nexport async function processPushedAuthorizationResponse(as, client, response) {\n    assertAs(as);\n    assertClient(client);\n    if (!looseInstanceOf(response, Response)) {\n        throw CodedTypeError('\"response\" must be an instance of Response', ERR_INVALID_ARG_TYPE);\n    }\n    await checkOAuthBodyError(response, 201, 'Pushed Authorization Request Endpoint');\n    assertReadableResponse(response);\n    const json = await getResponseJsonBody(response);\n    assertString(json.request_uri, '\"response\" body \"request_uri\" property', INVALID_RESPONSE, {\n        body: json,\n    });\n    let expiresIn = typeof json.expires_in !== 'number' ? parseFloat(json.expires_in) : json.expires_in;\n    assertNumber(expiresIn, true, '\"response\" body \"expires_in\" property', INVALID_RESPONSE, {\n        body: json,\n    });\n    json.expires_in = expiresIn;\n    return json;\n}\nasync function parseOAuthResponseErrorBody(response) {\n    if (response.status > 399 && response.status < 500) {\n        assertReadableResponse(response);\n        assertApplicationJson(response);\n        try {\n            const json = await response.clone().json();\n            if (isJsonObject(json) && typeof json.error === 'string' && json.error.length) {\n                return json;\n            }\n        }\n        catch { }\n    }\n    return undefined;\n}\nasync function checkOAuthBodyError(response, expected, label) {\n    if (response.status !== expected) {\n        checkAuthenticationChallenges(response);\n        let err;\n        if ((err = await parseOAuthResponseErrorBody(response))) {\n            await response.body?.cancel();\n            throw new ResponseBodyError('server responded with an error in the response body', {\n                cause: err,\n                response,\n            });\n        }\n        throw OPE(`\"response\" is not a conform ${label} response (unexpected HTTP status code)`, RESPONSE_IS_NOT_CONFORM, response);\n    }\n}\nfunction assertDPoP(option) {\n    if (!branded.has(option)) {\n        throw CodedTypeError('\"options.DPoP\" is not a valid DPoPHandle', ERR_INVALID_ARG_VALUE);\n    }\n}\nasync function resourceRequest(accessToken, method, url, headers, body, options) {\n    assertString(accessToken, '\"accessToken\"');\n    if (!(url instanceof URL)) {\n        throw CodedTypeError('\"url\" must be an instance of URL', ERR_INVALID_ARG_TYPE);\n    }\n    checkProtocol(url, options?.[allowInsecureRequests] !== true);\n    headers = prepareHeaders(headers);\n    if (options?.DPoP) {\n        assertDPoP(options.DPoP);\n        await options.DPoP.addProof(url, headers, method.toUpperCase(), accessToken);\n    }\n    headers.set('authorization', `${headers.has('dpop') ? 'DPoP' : 'Bearer'} ${accessToken}`);\n    const response = await (options?.[customFetch] || fetch)(url.href, {\n        body,\n        headers: Object.fromEntries(headers.entries()),\n        method,\n        redirect: 'manual',\n        signal: signal(url, options?.signal),\n    });\n    options?.DPoP?.cacheNonce(response, url);\n    return response;\n}\nexport async function protectedResourceRequest(accessToken, method, url, headers, body, options) {\n    const response = await resourceRequest(accessToken, method, url, headers, body, options);\n    checkAuthenticationChallenges(response);\n    return response;\n}\nexport async function userInfoRequest(as, client, accessToken, options) {\n    assertAs(as);\n    assertClient(client);\n    const url = resolveEndpoint(as, 'userinfo_endpoint', client.use_mtls_endpoint_aliases, options?.[allowInsecureRequests] !== true);\n    const headers = prepareHeaders(options?.headers);\n    if (client.userinfo_signed_response_alg) {\n        headers.set('accept', 'application/jwt');\n    }\n    else {\n        headers.set('accept', 'application/json');\n        headers.append('accept', 'application/jwt');\n    }\n    return resourceRequest(accessToken, 'GET', url, headers, null, {\n        ...options,\n        [clockSkew]: getClockSkew(client),\n    });\n}\nlet jwksMap;\nfunction setJwksCache(as, jwks, uat, cache) {\n    jwksMap ||= new WeakMap();\n    jwksMap.set(as, {\n        jwks,\n        uat,\n        get age() {\n            return epochTime() - this.uat;\n        },\n    });\n    if (cache) {\n        Object.assign(cache, { jwks: structuredClone(jwks), uat });\n    }\n}\nfunction isFreshJwksCache(input) {\n    if (typeof input !== 'object' || input === null) {\n        return false;\n    }\n    if (!('uat' in input) || typeof input.uat !== 'number' || epochTime() - input.uat >= 300) {\n        return false;\n    }\n    if (!('jwks' in input) ||\n        !isJsonObject(input.jwks) ||\n        !Array.isArray(input.jwks.keys) ||\n        !Array.prototype.every.call(input.jwks.keys, isJsonObject)) {\n        return false;\n    }\n    return true;\n}\nfunction clearJwksCache(as, cache) {\n    jwksMap?.delete(as);\n    delete cache?.jwks;\n    delete cache?.uat;\n}\nasync function getPublicSigKeyFromIssuerJwksUri(as, options, header) {\n    const { alg, kid } = header;\n    checkSupportedJwsAlg(header);\n    if (!jwksMap?.has(as) && isFreshJwksCache(options?.[jwksCache])) {\n        setJwksCache(as, options?.[jwksCache].jwks, options?.[jwksCache].uat);\n    }\n    let jwks;\n    let age;\n    if (jwksMap?.has(as)) {\n        ;\n        ({ jwks, age } = jwksMap.get(as));\n        if (age >= 300) {\n            clearJwksCache(as, options?.[jwksCache]);\n            return getPublicSigKeyFromIssuerJwksUri(as, options, header);\n        }\n    }\n    else {\n        jwks = await jwksRequest(as, options).then(processJwksResponse);\n        age = 0;\n        setJwksCache(as, jwks, epochTime(), options?.[jwksCache]);\n    }\n    let kty;\n    switch (alg.slice(0, 2)) {\n        case 'RS':\n        case 'PS':\n            kty = 'RSA';\n            break;\n        case 'ES':\n            kty = 'EC';\n            break;\n        case 'Ed':\n            kty = 'OKP';\n            break;\n        case 'ML':\n            kty = 'AKP';\n            break;\n        default:\n            throw new UnsupportedOperationError('unsupported JWS algorithm', { cause: { alg } });\n    }\n    const candidates = jwks.keys.filter((jwk) => {\n        if (jwk.kty !== kty) {\n            return false;\n        }\n        if (kid !== undefined && kid !== jwk.kid) {\n            return false;\n        }\n        if (jwk.alg !== undefined && alg !== jwk.alg) {\n            return false;\n        }\n        if (jwk.use !== undefined && jwk.use !== 'sig') {\n            return false;\n        }\n        if (jwk.key_ops?.includes('verify') === false) {\n            return false;\n        }\n        switch (true) {\n            case alg === 'ES256' && jwk.crv !== 'P-256':\n            case alg === 'ES384' && jwk.crv !== 'P-384':\n            case alg === 'ES512' && jwk.crv !== 'P-521':\n            case alg === 'Ed25519' && jwk.crv !== 'Ed25519':\n            case alg === 'EdDSA' && jwk.crv !== 'Ed25519':\n                return false;\n        }\n        return true;\n    });\n    const { 0: jwk, length } = candidates;\n    if (!length) {\n        if (age >= 60) {\n            clearJwksCache(as, options?.[jwksCache]);\n            return getPublicSigKeyFromIssuerJwksUri(as, options, header);\n        }\n        throw OPE('error when selecting a JWT verification key, no applicable keys found', KEY_SELECTION, { header, candidates, jwks_uri: new URL(as.jwks_uri) });\n    }\n    if (length !== 1) {\n        throw OPE('error when selecting a JWT verification key, multiple applicable keys found, a \"kid\" JWT Header Parameter is required', KEY_SELECTION, { header, candidates, jwks_uri: new URL(as.jwks_uri) });\n    }\n    return importJwk(alg, jwk);\n}\nexport const skipSubjectCheck = Symbol();\nexport function getContentType(input) {\n    return input.headers.get('content-type')?.split(';')[0];\n}\nexport async function processUserInfoResponse(as, client, expectedSubject, response, options) {\n    assertAs(as);\n    assertClient(client);\n    if (!looseInstanceOf(response, Response)) {\n        throw CodedTypeError('\"response\" must be an instance of Response', ERR_INVALID_ARG_TYPE);\n    }\n    checkAuthenticationChallenges(response);\n    if (response.status !== 200) {\n        throw OPE('\"response\" is not a conform UserInfo Endpoint response (unexpected HTTP status code)', RESPONSE_IS_NOT_CONFORM, response);\n    }\n    assertReadableResponse(response);\n    let json;\n    if (getContentType(response) === 'application/jwt') {\n        const { claims, jwt } = await validateJwt(await response.text(), checkSigningAlgorithm.bind(undefined, client.userinfo_signed_response_alg, as.userinfo_signing_alg_values_supported, undefined), getClockSkew(client), getClockTolerance(client), options?.[jweDecrypt])\n            .then(validateOptionalAudience.bind(undefined, client.client_id))\n            .then(validateOptionalIssuer.bind(undefined, as));\n        jwtRefs.set(response, jwt);\n        json = claims;\n    }\n    else {\n        if (client.userinfo_signed_response_alg) {\n            throw OPE('JWT UserInfo Response expected', JWT_USERINFO_EXPECTED, response);\n        }\n        json = await getResponseJsonBody(response);\n    }\n    assertString(json.sub, '\"response\" body \"sub\" property', INVALID_RESPONSE, { body: json });\n    switch (expectedSubject) {\n        case skipSubjectCheck:\n            break;\n        default:\n            assertString(expectedSubject, '\"expectedSubject\"');\n            if (json.sub !== expectedSubject) {\n                throw OPE('unexpected \"response\" body \"sub\" property value', JSON_ATTRIBUTE_COMPARISON, {\n                    expected: expectedSubject,\n                    body: json,\n                    attribute: 'sub',\n                });\n            }\n    }\n    return json;\n}\nasync function authenticatedRequest(as, client, clientAuthentication, url, body, headers, options) {\n    await clientAuthentication(as, client, body, headers);\n    headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8');\n    return (options?.[customFetch] || fetch)(url.href, {\n        body,\n        headers: Object.fromEntries(headers.entries()),\n        method: 'POST',\n        redirect: 'manual',\n        signal: signal(url, options?.signal),\n    });\n}\nasync function tokenEndpointRequest(as, client, clientAuthentication, grantType, parameters, options) {\n    const url = resolveEndpoint(as, 'token_endpoint', client.use_mtls_endpoint_aliases, options?.[allowInsecureRequests] !== true);\n    parameters.set('grant_type', grantType);\n    const headers = prepareHeaders(options?.headers);\n    headers.set('accept', 'application/json');\n    if (options?.DPoP !== undefined) {\n        assertDPoP(options.DPoP);\n        await options.DPoP.addProof(url, headers, 'POST');\n    }\n    const response = await authenticatedRequest(as, client, clientAuthentication, url, parameters, headers, options);\n    options?.DPoP?.cacheNonce(response, url);\n    return response;\n}\nexport async function refreshTokenGrantRequest(as, client, clientAuthentication, refreshToken, options) {\n    assertAs(as);\n    assertClient(client);\n    assertString(refreshToken, '\"refreshToken\"');\n    const parameters = new URLSearchParams(options?.additionalParameters);\n    parameters.set('refresh_token', refreshToken);\n    return tokenEndpointRequest(as, client, clientAuthentication, 'refresh_token', parameters, options);\n}\nconst idTokenClaims = new WeakMap();\nconst jwtRefs = new WeakMap();\nexport function getValidatedIdTokenClaims(ref) {\n    if (!ref.id_token) {\n        return undefined;\n    }\n    const claims = idTokenClaims.get(ref);\n    if (!claims) {\n        throw CodedTypeError('\"ref\" was already garbage collected or did not resolve from the proper sources', ERR_INVALID_ARG_VALUE);\n    }\n    return claims;\n}\nexport async function validateApplicationLevelSignature(as, ref, options) {\n    assertAs(as);\n    if (!jwtRefs.has(ref)) {\n        throw CodedTypeError('\"ref\" does not contain a processed JWT Response to verify the signature of', ERR_INVALID_ARG_VALUE);\n    }\n    const { 0: protectedHeader, 1: payload, 2: encodedSignature } = jwtRefs.get(ref).split('.');\n    const header = JSON.parse(buf(b64u(protectedHeader)));\n    if (header.alg.startsWith('HS')) {\n        throw new UnsupportedOperationError('unsupported JWS algorithm', { cause: { alg: header.alg } });\n    }\n    let key;\n    key = await getPublicSigKeyFromIssuerJwksUri(as, options, header);\n    await validateJwsSignature(protectedHeader, payload, key, b64u(encodedSignature));\n}\nasync function processGenericAccessTokenResponse(as, client, response, additionalRequiredIdTokenClaims, decryptFn, recognizedTokenTypes) {\n    assertAs(as);\n    assertClient(client);\n    if (!looseInstanceOf(response, Response)) {\n        throw CodedTypeError('\"response\" must be an instance of Response', ERR_INVALID_ARG_TYPE);\n    }\n    await checkOAuthBodyError(response, 200, 'Token Endpoint');\n    assertReadableResponse(response);\n    const json = await getResponseJsonBody(response);\n    assertString(json.access_token, '\"response\" body \"access_token\" property', INVALID_RESPONSE, {\n        body: json,\n    });\n    assertString(json.token_type, '\"response\" body \"token_type\" property', INVALID_RESPONSE, {\n        body: json,\n    });\n    json.token_type = json.token_type.toLowerCase();\n    if (json.expires_in !== undefined) {\n        let expiresIn = typeof json.expires_in !== 'number' ? parseFloat(json.expires_in) : json.expires_in;\n        assertNumber(expiresIn, true, '\"response\" body \"expires_in\" property', INVALID_RESPONSE, {\n            body: json,\n        });\n        json.expires_in = expiresIn;\n    }\n    if (json.refresh_token !== undefined) {\n        assertString(json.refresh_token, '\"response\" body \"refresh_token\" property', INVALID_RESPONSE, {\n            body: json,\n        });\n    }\n    if (json.scope !== undefined && typeof json.scope !== 'string') {\n        throw OPE('\"response\" body \"scope\" property must be a string', INVALID_RESPONSE, { body: json });\n    }\n    if (json.id_token !== undefined) {\n        assertString(json.id_token, '\"response\" body \"id_token\" property', INVALID_RESPONSE, {\n            body: json,\n        });\n        const requiredClaims = ['aud', 'exp', 'iat', 'iss', 'sub'];\n        if (client.require_auth_time === true) {\n            requiredClaims.push('auth_time');\n        }\n        if (client.default_max_age !== undefined) {\n            assertNumber(client.default_max_age, true, '\"client.default_max_age\"');\n            requiredClaims.push('auth_time');\n        }\n        if (additionalRequiredIdTokenClaims?.length) {\n            requiredClaims.push(...additionalRequiredIdTokenClaims);\n        }\n        const { claims, jwt } = await validateJwt(json.id_token, checkSigningAlgorithm.bind(undefined, client.id_token_signed_response_alg, as.id_token_signing_alg_values_supported, 'RS256'), getClockSkew(client), getClockTolerance(client), decryptFn)\n            .then(validatePresence.bind(undefined, requiredClaims))\n            .then(validateIssuer.bind(undefined, as))\n            .then(validateAudience.bind(undefined, client.client_id));\n        if (Array.isArray(claims.aud) && claims.aud.length !== 1) {\n            if (claims.azp === undefined) {\n                throw OPE('ID Token \"aud\" (audience) claim includes additional untrusted audiences', JWT_CLAIM_COMPARISON, { claims, claim: 'aud' });\n            }\n            if (claims.azp !== client.client_id) {\n                throw OPE('unexpected ID Token \"azp\" (authorized party) claim value', JWT_CLAIM_COMPARISON, { expected: client.client_id, claims, claim: 'azp' });\n            }\n        }\n        if (claims.auth_time !== undefined) {\n            assertNumber(claims.auth_time, true, 'ID Token \"auth_time\" (authentication time)', INVALID_RESPONSE, { claims });\n        }\n        jwtRefs.set(response, jwt);\n        idTokenClaims.set(json, claims);\n    }\n    if (recognizedTokenTypes?.[json.token_type] !== undefined) {\n        recognizedTokenTypes[json.token_type](response, json);\n    }\n    else if (json.token_type !== 'dpop' && json.token_type !== 'bearer') {\n        throw new UnsupportedOperationError('unsupported `token_type` value', { cause: { body: json } });\n    }\n    return json;\n}\nfunction checkAuthenticationChallenges(response) {\n    let challenges;\n    if ((challenges = parseWwwAuthenticateChallenges(response))) {\n        throw new WWWAuthenticateChallengeError('server responded with a challenge in the WWW-Authenticate HTTP Header', { cause: challenges, response });\n    }\n}\nexport async function processRefreshTokenResponse(as, client, response, options) {\n    return processGenericAccessTokenResponse(as, client, response, undefined, options?.[jweDecrypt], options?.recognizedTokenTypes);\n}\nfunction validateOptionalAudience(expected, result) {\n    if (result.claims.aud !== undefined) {\n        return validateAudience(expected, result);\n    }\n    return result;\n}\nfunction validateAudience(expected, result) {\n    if (Array.isArray(result.claims.aud)) {\n        if (!result.claims.aud.includes(expected)) {\n            throw OPE('unexpected JWT \"aud\" (audience) claim value', JWT_CLAIM_COMPARISON, {\n                expected,\n                claims: result.claims,\n                claim: 'aud',\n            });\n        }\n    }\n    else if (result.claims.aud !== expected) {\n        throw OPE('unexpected JWT \"aud\" (audience) claim value', JWT_CLAIM_COMPARISON, {\n            expected,\n            claims: result.claims,\n            claim: 'aud',\n        });\n    }\n    return result;\n}\nfunction validateOptionalIssuer(as, result) {\n    if (result.claims.iss !== undefined) {\n        return validateIssuer(as, result);\n    }\n    return result;\n}\nfunction validateIssuer(as, result) {\n    const expected = as[_expectedIssuer]?.(result) ?? as.issuer;\n    if (result.claims.iss !== expected) {\n        throw OPE('unexpected JWT \"iss\" (issuer) claim value', JWT_CLAIM_COMPARISON, {\n            expected,\n            claims: result.claims,\n            claim: 'iss',\n        });\n    }\n    return result;\n}\nconst branded = new WeakSet();\nfunction brand(searchParams) {\n    branded.add(searchParams);\n    return searchParams;\n}\nexport const nopkce = Symbol();\nexport async function authorizationCodeGrantRequest(as, client, clientAuthentication, callbackParameters, redirectUri, codeVerifier, options) {\n    assertAs(as);\n    assertClient(client);\n    if (!branded.has(callbackParameters)) {\n        throw CodedTypeError('\"callbackParameters\" must be an instance of URLSearchParams obtained from \"validateAuthResponse()\", or \"validateJwtAuthResponse()', ERR_INVALID_ARG_VALUE);\n    }\n    assertString(redirectUri, '\"redirectUri\"');\n    const code = getURLSearchParameter(callbackParameters, 'code');\n    if (!code) {\n        throw OPE('no authorization code in \"callbackParameters\"', INVALID_RESPONSE);\n    }\n    const parameters = new URLSearchParams(options?.additionalParameters);\n    parameters.set('redirect_uri', redirectUri);\n    parameters.set('code', code);\n    if (codeVerifier !== nopkce) {\n        assertString(codeVerifier, '\"codeVerifier\"');\n        parameters.set('code_verifier', codeVerifier);\n    }\n    return tokenEndpointRequest(as, client, clientAuthentication, 'authorization_code', parameters, options);\n}\nconst jwtClaimNames = {\n    aud: 'audience',\n    c_hash: 'code hash',\n    client_id: 'client id',\n    exp: 'expiration time',\n    iat: 'issued at',\n    iss: 'issuer',\n    jti: 'jwt id',\n    nonce: 'nonce',\n    s_hash: 'state hash',\n    sub: 'subject',\n    ath: 'access token hash',\n    htm: 'http method',\n    htu: 'http uri',\n    cnf: 'confirmation',\n    auth_time: 'authentication time',\n};\nfunction validatePresence(required, result) {\n    for (const claim of required) {\n        if (result.claims[claim] === undefined) {\n            throw OPE(`JWT \"${claim}\" (${jwtClaimNames[claim]}) claim missing`, INVALID_RESPONSE, {\n                claims: result.claims,\n            });\n        }\n    }\n    return result;\n}\nexport const expectNoNonce = Symbol();\nexport const skipAuthTimeCheck = Symbol();\nexport async function processAuthorizationCodeResponse(as, client, response, options) {\n    if (typeof options?.expectedNonce === 'string' ||\n        typeof options?.maxAge === 'number' ||\n        options?.requireIdToken) {\n        return processAuthorizationCodeOpenIDResponse(as, client, response, options.expectedNonce, options.maxAge, options[jweDecrypt], options.recognizedTokenTypes);\n    }\n    return processAuthorizationCodeOAuth2Response(as, client, response, options?.[jweDecrypt], options?.recognizedTokenTypes);\n}\nasync function processAuthorizationCodeOpenIDResponse(as, client, response, expectedNonce, maxAge, decryptFn, recognizedTokenTypes) {\n    const additionalRequiredClaims = [];\n    switch (expectedNonce) {\n        case undefined:\n            expectedNonce = expectNoNonce;\n            break;\n        case expectNoNonce:\n            break;\n        default:\n            assertString(expectedNonce, '\"expectedNonce\" argument');\n            additionalRequiredClaims.push('nonce');\n    }\n    maxAge ??= client.default_max_age;\n    switch (maxAge) {\n        case undefined:\n            maxAge = skipAuthTimeCheck;\n            break;\n        case skipAuthTimeCheck:\n            break;\n        default:\n            assertNumber(maxAge, true, '\"maxAge\" argument');\n            additionalRequiredClaims.push('auth_time');\n    }\n    const result = await processGenericAccessTokenResponse(as, client, response, additionalRequiredClaims, decryptFn, recognizedTokenTypes);\n    assertString(result.id_token, '\"response\" body \"id_token\" property', INVALID_RESPONSE, {\n        body: result,\n    });\n    const claims = getValidatedIdTokenClaims(result);\n    if (maxAge !== skipAuthTimeCheck) {\n        const now = epochTime() + getClockSkew(client);\n        const tolerance = getClockTolerance(client);\n        if (claims.auth_time + maxAge < now - tolerance) {\n            throw OPE('too much time has elapsed since the last End-User authentication', JWT_TIMESTAMP_CHECK, { claims, now, tolerance, claim: 'auth_time' });\n        }\n    }\n    if (expectedNonce === expectNoNonce) {\n        if (claims.nonce !== undefined) {\n            throw OPE('unexpected ID Token \"nonce\" claim value', JWT_CLAIM_COMPARISON, {\n                expected: undefined,\n                claims,\n                claim: 'nonce',\n            });\n        }\n    }\n    else if (claims.nonce !== expectedNonce) {\n        throw OPE('unexpected ID Token \"nonce\" claim value', JWT_CLAIM_COMPARISON, {\n            expected: expectedNonce,\n            claims,\n            claim: 'nonce',\n        });\n    }\n    return result;\n}\nasync function processAuthorizationCodeOAuth2Response(as, client, response, decryptFn, recognizedTokenTypes) {\n    const result = await processGenericAccessTokenResponse(as, client, response, undefined, decryptFn, recognizedTokenTypes);\n    const claims = getValidatedIdTokenClaims(result);\n    if (claims) {\n        if (client.default_max_age !== undefined) {\n            assertNumber(client.default_max_age, true, '\"client.default_max_age\"');\n            const now = epochTime() + getClockSkew(client);\n            const tolerance = getClockTolerance(client);\n            if (claims.auth_time + client.default_max_age < now - tolerance) {\n                throw OPE('too much time has elapsed since the last End-User authentication', JWT_TIMESTAMP_CHECK, { claims, now, tolerance, claim: 'auth_time' });\n            }\n        }\n        if (claims.nonce !== undefined) {\n            throw OPE('unexpected ID Token \"nonce\" claim value', JWT_CLAIM_COMPARISON, {\n                expected: undefined,\n                claims,\n                claim: 'nonce',\n            });\n        }\n    }\n    return result;\n}\nexport const WWW_AUTHENTICATE_CHALLENGE = 'OAUTH_WWW_AUTHENTICATE_CHALLENGE';\nexport const RESPONSE_BODY_ERROR = 'OAUTH_RESPONSE_BODY_ERROR';\nexport const UNSUPPORTED_OPERATION = 'OAUTH_UNSUPPORTED_OPERATION';\nexport const AUTHORIZATION_RESPONSE_ERROR = 'OAUTH_AUTHORIZATION_RESPONSE_ERROR';\nexport const JWT_USERINFO_EXPECTED = 'OAUTH_JWT_USERINFO_EXPECTED';\nexport const PARSE_ERROR = 'OAUTH_PARSE_ERROR';\nexport const INVALID_RESPONSE = 'OAUTH_INVALID_RESPONSE';\nexport const INVALID_REQUEST = 'OAUTH_INVALID_REQUEST';\nexport const RESPONSE_IS_NOT_JSON = 'OAUTH_RESPONSE_IS_NOT_JSON';\nexport const RESPONSE_IS_NOT_CONFORM = 'OAUTH_RESPONSE_IS_NOT_CONFORM';\nexport const HTTP_REQUEST_FORBIDDEN = 'OAUTH_HTTP_REQUEST_FORBIDDEN';\nexport const REQUEST_PROTOCOL_FORBIDDEN = 'OAUTH_REQUEST_PROTOCOL_FORBIDDEN';\nexport const JWT_TIMESTAMP_CHECK = 'OAUTH_JWT_TIMESTAMP_CHECK_FAILED';\nexport const JWT_CLAIM_COMPARISON = 'OAUTH_JWT_CLAIM_COMPARISON_FAILED';\nexport const JSON_ATTRIBUTE_COMPARISON = 'OAUTH_JSON_ATTRIBUTE_COMPARISON_FAILED';\nexport const KEY_SELECTION = 'OAUTH_KEY_SELECTION_FAILED';\nexport const MISSING_SERVER_METADATA = 'OAUTH_MISSING_SERVER_METADATA';\nexport const INVALID_SERVER_METADATA = 'OAUTH_INVALID_SERVER_METADATA';\nfunction checkJwtType(expected, result) {\n    if (typeof result.header.typ !== 'string' || normalizeTyp(result.header.typ) !== expected) {\n        throw OPE('unexpected JWT \"typ\" header parameter value', INVALID_RESPONSE, {\n            header: result.header,\n        });\n    }\n    return result;\n}\nexport async function clientCredentialsGrantRequest(as, client, clientAuthentication, parameters, options) {\n    assertAs(as);\n    assertClient(client);\n    return tokenEndpointRequest(as, client, clientAuthentication, 'client_credentials', new URLSearchParams(parameters), options);\n}\nexport async function genericTokenEndpointRequest(as, client, clientAuthentication, grantType, parameters, options) {\n    assertAs(as);\n    assertClient(client);\n    assertString(grantType, '\"grantType\"');\n    return tokenEndpointRequest(as, client, clientAuthentication, grantType, new URLSearchParams(parameters), options);\n}\nexport async function processGenericTokenEndpointResponse(as, client, response, options) {\n    return processGenericAccessTokenResponse(as, client, response, undefined, options?.[jweDecrypt], options?.recognizedTokenTypes);\n}\nexport async function processClientCredentialsResponse(as, client, response, options) {\n    return processGenericAccessTokenResponse(as, client, response, undefined, options?.[jweDecrypt], options?.recognizedTokenTypes);\n}\nexport async function revocationRequest(as, client, clientAuthentication, token, options) {\n    assertAs(as);\n    assertClient(client);\n    assertString(token, '\"token\"');\n    const url = resolveEndpoint(as, 'revocation_endpoint', client.use_mtls_endpoint_aliases, options?.[allowInsecureRequests] !== true);\n    const body = new URLSearchParams(options?.additionalParameters);\n    body.set('token', token);\n    const headers = prepareHeaders(options?.headers);\n    headers.delete('accept');\n    return authenticatedRequest(as, client, clientAuthentication, url, body, headers, options);\n}\nexport async function processRevocationResponse(response) {\n    if (!looseInstanceOf(response, Response)) {\n        throw CodedTypeError('\"response\" must be an instance of Response', ERR_INVALID_ARG_TYPE);\n    }\n    await checkOAuthBodyError(response, 200, 'Revocation Endpoint');\n    return undefined;\n}\nfunction assertReadableResponse(response) {\n    if (response.bodyUsed) {\n        throw CodedTypeError('\"response\" body has been used already', ERR_INVALID_ARG_VALUE);\n    }\n}\nexport async function introspectionRequest(as, client, clientAuthentication, token, options) {\n    assertAs(as);\n    assertClient(client);\n    assertString(token, '\"token\"');\n    const url = resolveEndpoint(as, 'introspection_endpoint', client.use_mtls_endpoint_aliases, options?.[allowInsecureRequests] !== true);\n    const body = new URLSearchParams(options?.additionalParameters);\n    body.set('token', token);\n    const headers = prepareHeaders(options?.headers);\n    if (options?.requestJwtResponse ?? client.introspection_signed_response_alg) {\n        headers.set('accept', 'application/token-introspection+jwt');\n    }\n    else {\n        headers.set('accept', 'application/json');\n    }\n    return authenticatedRequest(as, client, clientAuthentication, url, body, headers, options);\n}\nexport async function processIntrospectionResponse(as, client, response, options) {\n    assertAs(as);\n    assertClient(client);\n    if (!looseInstanceOf(response, Response)) {\n        throw CodedTypeError('\"response\" must be an instance of Response', ERR_INVALID_ARG_TYPE);\n    }\n    await checkOAuthBodyError(response, 200, 'Introspection Endpoint');\n    let json;\n    if (getContentType(response) === 'application/token-introspection+jwt') {\n        assertReadableResponse(response);\n        const { claims, jwt } = await validateJwt(await response.text(), checkSigningAlgorithm.bind(undefined, client.introspection_signed_response_alg, as.introspection_signing_alg_values_supported, 'RS256'), getClockSkew(client), getClockTolerance(client), options?.[jweDecrypt])\n            .then(checkJwtType.bind(undefined, 'token-introspection+jwt'))\n            .then(validatePresence.bind(undefined, ['aud', 'iat', 'iss']))\n            .then(validateIssuer.bind(undefined, as))\n            .then(validateAudience.bind(undefined, client.client_id));\n        jwtRefs.set(response, jwt);\n        if (!isJsonObject(claims.token_introspection)) {\n            throw OPE('JWT \"token_introspection\" claim must be a JSON object', INVALID_RESPONSE, {\n                claims,\n            });\n        }\n        json = claims.token_introspection;\n    }\n    else {\n        assertReadableResponse(response);\n        json = await getResponseJsonBody(response);\n    }\n    if (typeof json.active !== 'boolean') {\n        throw OPE('\"response\" body \"active\" property must be a boolean', INVALID_RESPONSE, {\n            body: json,\n        });\n    }\n    return json;\n}\nasync function jwksRequest(as, options) {\n    assertAs(as);\n    const url = resolveEndpoint(as, 'jwks_uri', false, options?.[allowInsecureRequests] !== true);\n    const headers = prepareHeaders(options?.headers);\n    headers.set('accept', 'application/json');\n    headers.append('accept', 'application/jwk-set+json');\n    return (options?.[customFetch] || fetch)(url.href, {\n        body: undefined,\n        headers: Object.fromEntries(headers.entries()),\n        method: 'GET',\n        redirect: 'manual',\n        signal: signal(url, options?.signal),\n    });\n}\nasync function processJwksResponse(response) {\n    if (!looseInstanceOf(response, Response)) {\n        throw CodedTypeError('\"response\" must be an instance of Response', ERR_INVALID_ARG_TYPE);\n    }\n    if (response.status !== 200) {\n        throw OPE('\"response\" is not a conform JSON Web Key Set response (unexpected HTTP status code)', RESPONSE_IS_NOT_CONFORM, response);\n    }\n    assertReadableResponse(response);\n    const json = await getResponseJsonBody(response, (response) => assertContentTypes(response, 'application/json', 'application/jwk-set+json'));\n    if (!Array.isArray(json.keys)) {\n        throw OPE('\"response\" body \"keys\" property must be an array', INVALID_RESPONSE, { body: json });\n    }\n    if (!Array.prototype.every.call(json.keys, isJsonObject)) {\n        throw OPE('\"response\" body \"keys\" property members must be JWK formatted objects', INVALID_RESPONSE, { body: json });\n    }\n    return json;\n}\nfunction supported(alg) {\n    switch (alg) {\n        case 'PS256':\n        case 'ES256':\n        case 'RS256':\n        case 'PS384':\n        case 'ES384':\n        case 'RS384':\n        case 'PS512':\n        case 'ES512':\n        case 'RS512':\n        case 'Ed25519':\n        case 'EdDSA':\n        case 'ML-DSA-44':\n        case 'ML-DSA-65':\n        case 'ML-DSA-87':\n            return true;\n        default:\n            return false;\n    }\n}\nfunction checkSupportedJwsAlg(header) {\n    if (!supported(header.alg)) {\n        throw new UnsupportedOperationError('unsupported JWS \"alg\" identifier', {\n            cause: { alg: header.alg },\n        });\n    }\n}\nfunction checkRsaKeyAlgorithm(key) {\n    const { algorithm } = key;\n    if (typeof algorithm.modulusLength !== 'number' || algorithm.modulusLength < 2048) {\n        throw new UnsupportedOperationError(`unsupported ${algorithm.name} modulusLength`, {\n            cause: key,\n        });\n    }\n}\nfunction ecdsaHashName(key) {\n    const { algorithm } = key;\n    switch (algorithm.namedCurve) {\n        case 'P-256':\n            return 'SHA-256';\n        case 'P-384':\n            return 'SHA-384';\n        case 'P-521':\n            return 'SHA-512';\n        default:\n            throw new UnsupportedOperationError('unsupported ECDSA namedCurve', { cause: key });\n    }\n}\nfunction keyToSubtle(key) {\n    switch (key.algorithm.name) {\n        case 'ECDSA':\n            return {\n                name: key.algorithm.name,\n                hash: ecdsaHashName(key),\n            };\n        case 'RSA-PSS': {\n            checkRsaKeyAlgorithm(key);\n            switch (key.algorithm.hash.name) {\n                case 'SHA-256':\n                case 'SHA-384':\n                case 'SHA-512':\n                    return {\n                        name: key.algorithm.name,\n                        saltLength: parseInt(key.algorithm.hash.name.slice(-3), 10) >> 3,\n                    };\n                default:\n                    throw new UnsupportedOperationError('unsupported RSA-PSS hash name', { cause: key });\n            }\n        }\n        case 'RSASSA-PKCS1-v1_5':\n            checkRsaKeyAlgorithm(key);\n            return key.algorithm.name;\n        case 'ML-DSA-44':\n        case 'ML-DSA-65':\n        case 'ML-DSA-87':\n        case 'Ed25519':\n            return key.algorithm.name;\n    }\n    throw new UnsupportedOperationError('unsupported CryptoKey algorithm name', { cause: key });\n}\nasync function validateJwsSignature(protectedHeader, payload, key, signature) {\n    const data = buf(`${protectedHeader}.${payload}`);\n    const algorithm = keyToSubtle(key);\n    const verified = await crypto.subtle.verify(algorithm, key, signature, data);\n    if (!verified) {\n        throw OPE('JWT signature verification failed', INVALID_RESPONSE, {\n            key,\n            data,\n            signature,\n            algorithm,\n        });\n    }\n}\nasync function validateJwt(jws, checkAlg, clockSkew, clockTolerance, decryptJwt) {\n    let { 0: protectedHeader, 1: payload, length } = jws.split('.');\n    if (length === 5) {\n        if (decryptJwt !== undefined) {\n            jws = await decryptJwt(jws);\n            ({ 0: protectedHeader, 1: payload, length } = jws.split('.'));\n        }\n        else {\n            throw new UnsupportedOperationError('JWE decryption is not configured', { cause: jws });\n        }\n    }\n    if (length !== 3) {\n        throw OPE('Invalid JWT', INVALID_RESPONSE, jws);\n    }\n    let header;\n    try {\n        header = JSON.parse(buf(b64u(protectedHeader)));\n    }\n    catch (cause) {\n        throw OPE('failed to parse JWT Header body as base64url encoded JSON', PARSE_ERROR, cause);\n    }\n    if (!isJsonObject(header)) {\n        throw OPE('JWT Header must be a top level object', INVALID_RESPONSE, jws);\n    }\n    checkAlg(header);\n    if (header.crit !== undefined) {\n        throw new UnsupportedOperationError('no JWT \"crit\" header parameter extensions are supported', {\n            cause: { header },\n        });\n    }\n    let claims;\n    try {\n        claims = JSON.parse(buf(b64u(payload)));\n    }\n    catch (cause) {\n        throw OPE('failed to parse JWT Payload body as base64url encoded JSON', PARSE_ERROR, cause);\n    }\n    if (!isJsonObject(claims)) {\n        throw OPE('JWT Payload must be a top level object', INVALID_RESPONSE, jws);\n    }\n    const now = epochTime() + clockSkew;\n    if (claims.exp !== undefined) {\n        if (typeof claims.exp !== 'number') {\n            throw OPE('unexpected JWT \"exp\" (expiration time) claim type', INVALID_RESPONSE, { claims });\n        }\n        if (claims.exp <= now - clockTolerance) {\n            throw OPE('unexpected JWT \"exp\" (expiration time) claim value, expiration is past current timestamp', JWT_TIMESTAMP_CHECK, { claims, now, tolerance: clockTolerance, claim: 'exp' });\n        }\n    }\n    if (claims.iat !== undefined) {\n        if (typeof claims.iat !== 'number') {\n            throw OPE('unexpected JWT \"iat\" (issued at) claim type', INVALID_RESPONSE, { claims });\n        }\n    }\n    if (claims.iss !== undefined) {\n        if (typeof claims.iss !== 'string') {\n            throw OPE('unexpected JWT \"iss\" (issuer) claim type', INVALID_RESPONSE, { claims });\n        }\n    }\n    if (claims.nbf !== undefined) {\n        if (typeof claims.nbf !== 'number') {\n            throw OPE('unexpected JWT \"nbf\" (not before) claim type', INVALID_RESPONSE, { claims });\n        }\n        if (claims.nbf > now + clockTolerance) {\n            throw OPE('unexpected JWT \"nbf\" (not before) claim value', JWT_TIMESTAMP_CHECK, {\n                claims,\n                now,\n                tolerance: clockTolerance,\n                claim: 'nbf',\n            });\n        }\n    }\n    if (claims.aud !== undefined) {\n        if (typeof claims.aud !== 'string' && !Array.isArray(claims.aud)) {\n            throw OPE('unexpected JWT \"aud\" (audience) claim type', INVALID_RESPONSE, { claims });\n        }\n    }\n    return { header, claims, jwt: jws };\n}\nexport async function validateJwtAuthResponse(as, client, parameters, expectedState, options) {\n    assertAs(as);\n    assertClient(client);\n    if (parameters instanceof URL) {\n        parameters = parameters.searchParams;\n    }\n    if (!(parameters instanceof URLSearchParams)) {\n        throw CodedTypeError('\"parameters\" must be an instance of URLSearchParams, or URL', ERR_INVALID_ARG_TYPE);\n    }\n    const response = getURLSearchParameter(parameters, 'response');\n    if (!response) {\n        throw OPE('\"parameters\" does not contain a JARM response', INVALID_RESPONSE);\n    }\n    const { claims, header, jwt } = await validateJwt(response, checkSigningAlgorithm.bind(undefined, client.authorization_signed_response_alg, as.authorization_signing_alg_values_supported, 'RS256'), getClockSkew(client), getClockTolerance(client), options?.[jweDecrypt])\n        .then(validatePresence.bind(undefined, ['aud', 'exp', 'iss']))\n        .then(validateIssuer.bind(undefined, as))\n        .then(validateAudience.bind(undefined, client.client_id));\n    const { 0: protectedHeader, 1: payload, 2: encodedSignature } = jwt.split('.');\n    const signature = b64u(encodedSignature);\n    const key = await getPublicSigKeyFromIssuerJwksUri(as, options, header);\n    await validateJwsSignature(protectedHeader, payload, key, signature);\n    const result = new URLSearchParams();\n    for (const [key, value] of Object.entries(claims)) {\n        if (typeof value === 'string' && key !== 'aud') {\n            result.set(key, value);\n        }\n    }\n    return validateAuthResponse(as, client, result, expectedState);\n}\nasync function idTokenHash(data, header, claimName) {\n    let algorithm;\n    switch (header.alg) {\n        case 'RS256':\n        case 'PS256':\n        case 'ES256':\n            algorithm = 'SHA-256';\n            break;\n        case 'RS384':\n        case 'PS384':\n        case 'ES384':\n            algorithm = 'SHA-384';\n            break;\n        case 'RS512':\n        case 'PS512':\n        case 'ES512':\n        case 'Ed25519':\n        case 'EdDSA':\n            algorithm = 'SHA-512';\n            break;\n        case 'ML-DSA-44':\n        case 'ML-DSA-65':\n        case 'ML-DSA-87':\n            algorithm = { name: 'cSHAKE256', length: 512 };\n            break;\n        default:\n            throw new UnsupportedOperationError(`unsupported JWS algorithm for ${claimName} calculation`, { cause: { alg: header.alg } });\n    }\n    const digest = await crypto.subtle.digest(algorithm, buf(data));\n    return b64u(digest.slice(0, digest.byteLength / 2));\n}\nasync function idTokenHashMatches(data, actual, header, claimName) {\n    const expected = await idTokenHash(data, header, claimName);\n    return actual === expected;\n}\nexport async function validateDetachedSignatureResponse(as, client, parameters, expectedNonce, expectedState, maxAge, options) {\n    return validateHybridResponse(as, client, parameters, expectedNonce, expectedState, maxAge, options, true);\n}\nexport async function validateCodeIdTokenResponse(as, client, parameters, expectedNonce, expectedState, maxAge, options) {\n    return validateHybridResponse(as, client, parameters, expectedNonce, expectedState, maxAge, options, false);\n}\nasync function consumeStream(request) {\n    if (request.bodyUsed) {\n        throw CodedTypeError('form_post Request instances must contain a readable body', ERR_INVALID_ARG_VALUE, { cause: request });\n    }\n    return request.text();\n}\nexport async function formPostResponse(request) {\n    if (request.method !== 'POST') {\n        throw CodedTypeError('form_post responses are expected to use the POST method', ERR_INVALID_ARG_VALUE, { cause: request });\n    }\n    if (getContentType(request) !== 'application/x-www-form-urlencoded') {\n        throw CodedTypeError('form_post responses are expected to use the application/x-www-form-urlencoded content-type', ERR_INVALID_ARG_VALUE, { cause: request });\n    }\n    return consumeStream(request);\n}\nasync function validateHybridResponse(as, client, parameters, expectedNonce, expectedState, maxAge, options, fapi) {\n    assertAs(as);\n    assertClient(client);\n    if (parameters instanceof URL) {\n        if (!parameters.hash.length) {\n            throw CodedTypeError('\"parameters\" as an instance of URL must contain a hash (fragment) with the Authorization Response parameters', ERR_INVALID_ARG_VALUE);\n        }\n        parameters = new URLSearchParams(parameters.hash.slice(1));\n    }\n    else if (looseInstanceOf(parameters, Request)) {\n        parameters = new URLSearchParams(await formPostResponse(parameters));\n    }\n    else if (parameters instanceof URLSearchParams) {\n        parameters = new URLSearchParams(parameters);\n    }\n    else {\n        throw CodedTypeError('\"parameters\" must be an instance of URLSearchParams, URL, or Response', ERR_INVALID_ARG_TYPE);\n    }\n    const id_token = getURLSearchParameter(parameters, 'id_token');\n    parameters.delete('id_token');\n    switch (expectedState) {\n        case undefined:\n        case expectNoState:\n            break;\n        default:\n            assertString(expectedState, '\"expectedState\" argument');\n    }\n    const result = validateAuthResponse({\n        ...as,\n        authorization_response_iss_parameter_supported: false,\n    }, client, parameters, expectedState);\n    if (!id_token) {\n        throw OPE('\"parameters\" does not contain an ID Token', INVALID_RESPONSE);\n    }\n    const code = getURLSearchParameter(parameters, 'code');\n    if (!code) {\n        throw OPE('\"parameters\" does not contain an Authorization Code', INVALID_RESPONSE);\n    }\n    const requiredClaims = [\n        'aud',\n        'exp',\n        'iat',\n        'iss',\n        'sub',\n        'nonce',\n        'c_hash',\n    ];\n    const state = parameters.get('state');\n    if (fapi && (typeof expectedState === 'string' || state !== null)) {\n        requiredClaims.push('s_hash');\n    }\n    if (maxAge !== undefined) {\n        assertNumber(maxAge, true, '\"maxAge\" argument');\n    }\n    else if (client.default_max_age !== undefined) {\n        assertNumber(client.default_max_age, true, '\"client.default_max_age\"');\n    }\n    maxAge ??= client.default_max_age ?? skipAuthTimeCheck;\n    if (client.require_auth_time || maxAge !== skipAuthTimeCheck) {\n        requiredClaims.push('auth_time');\n    }\n    const { claims, header, jwt } = await validateJwt(id_token, checkSigningAlgorithm.bind(undefined, client.id_token_signed_response_alg, as.id_token_signing_alg_values_supported, 'RS256'), getClockSkew(client), getClockTolerance(client), options?.[jweDecrypt])\n        .then(validatePresence.bind(undefined, requiredClaims))\n        .then(validateIssuer.bind(undefined, as))\n        .then(validateAudience.bind(undefined, client.client_id));\n    const clockSkew = getClockSkew(client);\n    const now = epochTime() + clockSkew;\n    if (claims.iat < now - 3600) {\n        throw OPE('unexpected JWT \"iat\" (issued at) claim value, it is too far in the past', JWT_TIMESTAMP_CHECK, { now, claims, claim: 'iat' });\n    }\n    assertString(claims.c_hash, 'ID Token \"c_hash\" (code hash) claim value', INVALID_RESPONSE, {\n        claims,\n    });\n    if (claims.auth_time !== undefined) {\n        assertNumber(claims.auth_time, true, 'ID Token \"auth_time\" (authentication time)', INVALID_RESPONSE, { claims });\n    }\n    if (maxAge !== skipAuthTimeCheck) {\n        const now = epochTime() + getClockSkew(client);\n        const tolerance = getClockTolerance(client);\n        if (claims.auth_time + maxAge < now - tolerance) {\n            throw OPE('too much time has elapsed since the last End-User authentication', JWT_TIMESTAMP_CHECK, { claims, now, tolerance, claim: 'auth_time' });\n        }\n    }\n    assertString(expectedNonce, '\"expectedNonce\" argument');\n    if (claims.nonce !== expectedNonce) {\n        throw OPE('unexpected ID Token \"nonce\" claim value', JWT_CLAIM_COMPARISON, {\n            expected: expectedNonce,\n            claims,\n            claim: 'nonce',\n        });\n    }\n    if (Array.isArray(claims.aud) && claims.aud.length !== 1) {\n        if (claims.azp === undefined) {\n            throw OPE('ID Token \"aud\" (audience) claim includes additional untrusted audiences', JWT_CLAIM_COMPARISON, { claims, claim: 'aud' });\n        }\n        if (claims.azp !== client.client_id) {\n            throw OPE('unexpected ID Token \"azp\" (authorized party) claim value', JWT_CLAIM_COMPARISON, {\n                expected: client.client_id,\n                claims,\n                claim: 'azp',\n            });\n        }\n    }\n    const { 0: protectedHeader, 1: payload, 2: encodedSignature } = jwt.split('.');\n    const signature = b64u(encodedSignature);\n    const key = await getPublicSigKeyFromIssuerJwksUri(as, options, header);\n    await validateJwsSignature(protectedHeader, payload, key, signature);\n    if ((await idTokenHashMatches(code, claims.c_hash, header, 'c_hash')) !== true) {\n        throw OPE('invalid ID Token \"c_hash\" (code hash) claim value', JWT_CLAIM_COMPARISON, {\n            code,\n            alg: header.alg,\n            claim: 'c_hash',\n            claims,\n        });\n    }\n    if ((fapi && state !== null) || claims.s_hash !== undefined) {\n        assertString(claims.s_hash, 'ID Token \"s_hash\" (state hash) claim value', INVALID_RESPONSE, {\n            claims,\n        });\n        assertString(state, '\"state\" response parameter', INVALID_RESPONSE, { parameters });\n        if ((await idTokenHashMatches(state, claims.s_hash, header, 's_hash')) !== true) {\n            throw OPE('invalid ID Token \"s_hash\" (state hash) claim value', JWT_CLAIM_COMPARISON, {\n                state,\n                alg: header.alg,\n                claim: 's_hash',\n                claims,\n            });\n        }\n    }\n    return result;\n}\nfunction checkSigningAlgorithm(client, issuer, fallback, header) {\n    if (client !== undefined) {\n        if (typeof client === 'string' ? header.alg !== client : !client.includes(header.alg)) {\n            throw OPE('unexpected JWT \"alg\" header parameter', INVALID_RESPONSE, {\n                header,\n                expected: client,\n                reason: 'client configuration',\n            });\n        }\n        return;\n    }\n    if (Array.isArray(issuer)) {\n        if (!issuer.includes(header.alg)) {\n            throw OPE('unexpected JWT \"alg\" header parameter', INVALID_RESPONSE, {\n                header,\n                expected: issuer,\n                reason: 'authorization server metadata',\n            });\n        }\n        return;\n    }\n    if (fallback !== undefined) {\n        if (typeof fallback === 'string'\n            ? header.alg !== fallback\n            : typeof fallback === 'function'\n                ? !fallback(header.alg)\n                : !fallback.includes(header.alg)) {\n            throw OPE('unexpected JWT \"alg\" header parameter', INVALID_RESPONSE, {\n                header,\n                expected: fallback,\n                reason: 'default value',\n            });\n        }\n        return;\n    }\n    throw OPE('missing client or server configuration to verify used JWT \"alg\" header parameter', undefined, { client, issuer, fallback });\n}\nfunction getURLSearchParameter(parameters, name) {\n    const { 0: value, length } = parameters.getAll(name);\n    if (length > 1) {\n        throw OPE(`\"${name}\" parameter must be provided only once`, INVALID_RESPONSE);\n    }\n    return value;\n}\nexport const skipStateCheck = Symbol();\nexport const expectNoState = Symbol();\nexport function validateAuthResponse(as, client, parameters, expectedState) {\n    assertAs(as);\n    assertClient(client);\n    if (parameters instanceof URL) {\n        parameters = parameters.searchParams;\n    }\n    if (!(parameters instanceof URLSearchParams)) {\n        throw CodedTypeError('\"parameters\" must be an instance of URLSearchParams, or URL', ERR_INVALID_ARG_TYPE);\n    }\n    if (getURLSearchParameter(parameters, 'response')) {\n        throw OPE('\"parameters\" contains a JARM response, use validateJwtAuthResponse() instead of validateAuthResponse()', INVALID_RESPONSE, { parameters });\n    }\n    const iss = getURLSearchParameter(parameters, 'iss');\n    const state = getURLSearchParameter(parameters, 'state');\n    if (!iss && as.authorization_response_iss_parameter_supported) {\n        throw OPE('response parameter \"iss\" (issuer) missing', INVALID_RESPONSE, { parameters });\n    }\n    if (iss && iss !== as.issuer) {\n        throw OPE('unexpected \"iss\" (issuer) response parameter value', INVALID_RESPONSE, {\n            expected: as.issuer,\n            parameters,\n        });\n    }\n    switch (expectedState) {\n        case undefined:\n        case expectNoState:\n            if (state !== undefined) {\n                throw OPE('unexpected \"state\" response parameter encountered', INVALID_RESPONSE, {\n                    expected: undefined,\n                    parameters,\n                });\n            }\n            break;\n        case skipStateCheck:\n            break;\n        default:\n            assertString(expectedState, '\"expectedState\" argument');\n            if (state !== expectedState) {\n                throw OPE(state === undefined\n                    ? 'response parameter \"state\" missing'\n                    : 'unexpected \"state\" response parameter value', INVALID_RESPONSE, { expected: expectedState, parameters });\n            }\n    }\n    const error = getURLSearchParameter(parameters, 'error');\n    if (error) {\n        throw new AuthorizationResponseError('authorization response from the server is an error', {\n            cause: parameters,\n        });\n    }\n    const id_token = getURLSearchParameter(parameters, 'id_token');\n    const token = getURLSearchParameter(parameters, 'token');\n    if (id_token !== undefined || token !== undefined) {\n        throw new UnsupportedOperationError('implicit and hybrid flows are not supported');\n    }\n    return brand(new URLSearchParams(parameters));\n}\nfunction algToSubtle(alg) {\n    switch (alg) {\n        case 'PS256':\n        case 'PS384':\n        case 'PS512':\n            return { name: 'RSA-PSS', hash: `SHA-${alg.slice(-3)}` };\n        case 'RS256':\n        case 'RS384':\n        case 'RS512':\n            return { name: 'RSASSA-PKCS1-v1_5', hash: `SHA-${alg.slice(-3)}` };\n        case 'ES256':\n        case 'ES384':\n            return { name: 'ECDSA', namedCurve: `P-${alg.slice(-3)}` };\n        case 'ES512':\n            return { name: 'ECDSA', namedCurve: 'P-521' };\n        case 'EdDSA':\n            return 'Ed25519';\n        case 'Ed25519':\n        case 'ML-DSA-44':\n        case 'ML-DSA-65':\n        case 'ML-DSA-87':\n            return alg;\n        default:\n            throw new UnsupportedOperationError('unsupported JWS algorithm', { cause: { alg } });\n    }\n}\nasync function importJwk(alg, jwk) {\n    const { ext, key_ops, use, ...key } = jwk;\n    return crypto.subtle.importKey('jwk', key, algToSubtle(alg), true, ['verify']);\n}\nexport async function deviceAuthorizationRequest(as, client, clientAuthentication, parameters, options) {\n    assertAs(as);\n    assertClient(client);\n    const url = resolveEndpoint(as, 'device_authorization_endpoint', client.use_mtls_endpoint_aliases, options?.[allowInsecureRequests] !== true);\n    const body = new URLSearchParams(parameters);\n    body.set('client_id', client.client_id);\n    const headers = prepareHeaders(options?.headers);\n    headers.set('accept', 'application/json');\n    return authenticatedRequest(as, client, clientAuthentication, url, body, headers, options);\n}\nexport async function processDeviceAuthorizationResponse(as, client, response) {\n    assertAs(as);\n    assertClient(client);\n    if (!looseInstanceOf(response, Response)) {\n        throw CodedTypeError('\"response\" must be an instance of Response', ERR_INVALID_ARG_TYPE);\n    }\n    await checkOAuthBodyError(response, 200, 'Device Authorization Endpoint');\n    assertReadableResponse(response);\n    const json = await getResponseJsonBody(response);\n    assertString(json.device_code, '\"response\" body \"device_code\" property', INVALID_RESPONSE, {\n        body: json,\n    });\n    assertString(json.user_code, '\"response\" body \"user_code\" property', INVALID_RESPONSE, {\n        body: json,\n    });\n    assertString(json.verification_uri, '\"response\" body \"verification_uri\" property', INVALID_RESPONSE, { body: json });\n    let expiresIn = typeof json.expires_in !== 'number' ? parseFloat(json.expires_in) : json.expires_in;\n    assertNumber(expiresIn, true, '\"response\" body \"expires_in\" property', INVALID_RESPONSE, {\n        body: json,\n    });\n    json.expires_in = expiresIn;\n    if (json.verification_uri_complete !== undefined) {\n        assertString(json.verification_uri_complete, '\"response\" body \"verification_uri_complete\" property', INVALID_RESPONSE, { body: json });\n    }\n    if (json.interval !== undefined) {\n        assertNumber(json.interval, false, '\"response\" body \"interval\" property', INVALID_RESPONSE, {\n            body: json,\n        });\n    }\n    return json;\n}\nexport async function deviceCodeGrantRequest(as, client, clientAuthentication, deviceCode, options) {\n    assertAs(as);\n    assertClient(client);\n    assertString(deviceCode, '\"deviceCode\"');\n    const parameters = new URLSearchParams(options?.additionalParameters);\n    parameters.set('device_code', deviceCode);\n    return tokenEndpointRequest(as, client, clientAuthentication, 'urn:ietf:params:oauth:grant-type:device_code', parameters, options);\n}\nexport async function processDeviceCodeResponse(as, client, response, options) {\n    return processGenericAccessTokenResponse(as, client, response, undefined, options?.[jweDecrypt], options?.recognizedTokenTypes);\n}\nexport async function generateKeyPair(alg, options) {\n    assertString(alg, '\"alg\"');\n    const algorithm = algToSubtle(alg);\n    if (alg.startsWith('PS') || alg.startsWith('RS')) {\n        Object.assign(algorithm, {\n            modulusLength: options?.modulusLength ?? 2048,\n            publicExponent: new Uint8Array([0x01, 0x00, 0x01]),\n        });\n    }\n    return crypto.subtle.generateKey(algorithm, options?.extractable ?? false, [\n        'sign',\n        'verify',\n    ]);\n}\nfunction normalizeHtu(htu) {\n    const url = new URL(htu);\n    url.search = '';\n    url.hash = '';\n    return url.href;\n}\nasync function validateDPoP(request, accessToken, accessTokenClaims, options) {\n    const headerValue = request.headers.get('dpop');\n    if (headerValue === null) {\n        throw OPE('operation indicated DPoP use but the request has no DPoP HTTP Header', INVALID_REQUEST, { headers: request.headers });\n    }\n    if (request.headers.get('authorization')?.toLowerCase().startsWith('dpop ') === false) {\n        throw OPE(`operation indicated DPoP use but the request's Authorization HTTP Header scheme is not DPoP`, INVALID_REQUEST, { headers: request.headers });\n    }\n    if (typeof accessTokenClaims.cnf?.jkt !== 'string') {\n        throw OPE('operation indicated DPoP use but the JWT Access Token has no jkt confirmation claim', INVALID_REQUEST, { claims: accessTokenClaims });\n    }\n    const clockSkew = getClockSkew(options);\n    const proof = await validateJwt(headerValue, checkSigningAlgorithm.bind(undefined, options?.signingAlgorithms, undefined, supported), clockSkew, getClockTolerance(options), undefined)\n        .then(checkJwtType.bind(undefined, 'dpop+jwt'))\n        .then(validatePresence.bind(undefined, ['iat', 'jti', 'ath', 'htm', 'htu']));\n    const now = epochTime() + clockSkew;\n    const diff = Math.abs(now - proof.claims.iat);\n    if (diff > 300) {\n        throw OPE('DPoP Proof iat is not recent enough', JWT_TIMESTAMP_CHECK, {\n            now,\n            claims: proof.claims,\n            claim: 'iat',\n        });\n    }\n    if (proof.claims.htm !== request.method) {\n        throw OPE('DPoP Proof htm mismatch', JWT_CLAIM_COMPARISON, {\n            expected: request.method,\n            claims: proof.claims,\n            claim: 'htm',\n        });\n    }\n    if (typeof proof.claims.htu !== 'string' ||\n        normalizeHtu(proof.claims.htu) !== normalizeHtu(request.url)) {\n        throw OPE('DPoP Proof htu mismatch', JWT_CLAIM_COMPARISON, {\n            expected: normalizeHtu(request.url),\n            claims: proof.claims,\n            claim: 'htu',\n        });\n    }\n    {\n        const expected = b64u(await crypto.subtle.digest('SHA-256', buf(accessToken)));\n        if (proof.claims.ath !== expected) {\n            throw OPE('DPoP Proof ath mismatch', JWT_CLAIM_COMPARISON, {\n                expected,\n                claims: proof.claims,\n                claim: 'ath',\n            });\n        }\n    }\n    {\n        const expected = await calculateJwkThumbprint(proof.header.jwk);\n        if (accessTokenClaims.cnf.jkt !== expected) {\n            throw OPE('JWT Access Token confirmation mismatch', JWT_CLAIM_COMPARISON, {\n                expected,\n                claims: accessTokenClaims,\n                claim: 'cnf.jkt',\n            });\n        }\n    }\n    const { 0: protectedHeader, 1: payload, 2: encodedSignature } = headerValue.split('.');\n    const signature = b64u(encodedSignature);\n    const { jwk, alg } = proof.header;\n    if (!jwk) {\n        throw OPE('DPoP Proof is missing the jwk header parameter', INVALID_REQUEST, {\n            header: proof.header,\n        });\n    }\n    const key = await importJwk(alg, jwk);\n    if (key.type !== 'public') {\n        throw OPE('DPoP Proof jwk header parameter must contain a public key', INVALID_REQUEST, {\n            header: proof.header,\n        });\n    }\n    await validateJwsSignature(protectedHeader, payload, key, signature);\n}\nexport async function validateJwtAccessToken(as, request, expectedAudience, options) {\n    assertAs(as);\n    if (!looseInstanceOf(request, Request)) {\n        throw CodedTypeError('\"request\" must be an instance of Request', ERR_INVALID_ARG_TYPE);\n    }\n    assertString(expectedAudience, '\"expectedAudience\"');\n    const authorization = request.headers.get('authorization');\n    if (authorization === null) {\n        throw OPE('\"request\" is missing an Authorization HTTP Header', INVALID_REQUEST, {\n            headers: request.headers,\n        });\n    }\n    let { 0: scheme, 1: accessToken, length } = authorization.split(' ');\n    scheme = scheme.toLowerCase();\n    switch (scheme) {\n        case 'dpop':\n        case 'bearer':\n            break;\n        default:\n            throw new UnsupportedOperationError('unsupported Authorization HTTP Header scheme', {\n                cause: { headers: request.headers },\n            });\n    }\n    if (length !== 2) {\n        throw OPE('invalid Authorization HTTP Header format', INVALID_REQUEST, {\n            headers: request.headers,\n        });\n    }\n    const requiredClaims = [\n        'iss',\n        'exp',\n        'aud',\n        'sub',\n        'iat',\n        'jti',\n        'client_id',\n    ];\n    if (options?.requireDPoP || scheme === 'dpop' || request.headers.has('dpop')) {\n        requiredClaims.push('cnf');\n    }\n    const { claims, header } = await validateJwt(accessToken, checkSigningAlgorithm.bind(undefined, options?.signingAlgorithms, undefined, supported), getClockSkew(options), getClockTolerance(options), undefined)\n        .then(checkJwtType.bind(undefined, 'at+jwt'))\n        .then(validatePresence.bind(undefined, requiredClaims))\n        .then(validateIssuer.bind(undefined, as))\n        .then(validateAudience.bind(undefined, expectedAudience))\n        .catch(reassignRSCode);\n    for (const claim of ['client_id', 'jti', 'sub']) {\n        if (typeof claims[claim] !== 'string') {\n            throw OPE(`unexpected JWT \"${claim}\" claim type`, INVALID_REQUEST, { claims });\n        }\n    }\n    if ('cnf' in claims) {\n        if (!isJsonObject(claims.cnf)) {\n            throw OPE('unexpected JWT \"cnf\" (confirmation) claim value', INVALID_REQUEST, { claims });\n        }\n        const { 0: cnf, length } = Object.keys(claims.cnf);\n        if (length) {\n            if (length !== 1) {\n                throw new UnsupportedOperationError('multiple confirmation claims are not supported', {\n                    cause: { claims },\n                });\n            }\n            if (cnf !== 'jkt') {\n                throw new UnsupportedOperationError('unsupported JWT Confirmation method', {\n                    cause: { claims },\n                });\n            }\n        }\n    }\n    const { 0: protectedHeader, 1: payload, 2: encodedSignature } = accessToken.split('.');\n    const signature = b64u(encodedSignature);\n    const key = await getPublicSigKeyFromIssuerJwksUri(as, options, header);\n    await validateJwsSignature(protectedHeader, payload, key, signature);\n    if (options?.requireDPoP ||\n        scheme === 'dpop' ||\n        claims.cnf?.jkt !== undefined ||\n        request.headers.has('dpop')) {\n        await validateDPoP(request, accessToken, claims, options).catch(reassignRSCode);\n    }\n    return claims;\n}\nfunction reassignRSCode(err) {\n    if (err instanceof OperationProcessingError && err?.code === INVALID_REQUEST) {\n        err.code = INVALID_RESPONSE;\n    }\n    throw err;\n}\nexport async function backchannelAuthenticationRequest(as, client, clientAuthentication, parameters, options) {\n    assertAs(as);\n    assertClient(client);\n    const url = resolveEndpoint(as, 'backchannel_authentication_endpoint', client.use_mtls_endpoint_aliases, options?.[allowInsecureRequests] !== true);\n    const body = new URLSearchParams(parameters);\n    body.set('client_id', client.client_id);\n    const headers = prepareHeaders(options?.headers);\n    headers.set('accept', 'application/json');\n    return authenticatedRequest(as, client, clientAuthentication, url, body, headers, options);\n}\nexport async function processBackchannelAuthenticationResponse(as, client, response) {\n    assertAs(as);\n    assertClient(client);\n    if (!looseInstanceOf(response, Response)) {\n        throw CodedTypeError('\"response\" must be an instance of Response', ERR_INVALID_ARG_TYPE);\n    }\n    await checkOAuthBodyError(response, 200, 'Backchannel Authentication Endpoint');\n    assertReadableResponse(response);\n    const json = await getResponseJsonBody(response);\n    assertString(json.auth_req_id, '\"response\" body \"auth_req_id\" property', INVALID_RESPONSE, {\n        body: json,\n    });\n    let expiresIn = typeof json.expires_in !== 'number' ? parseFloat(json.expires_in) : json.expires_in;\n    assertNumber(expiresIn, true, '\"response\" body \"expires_in\" property', INVALID_RESPONSE, {\n        body: json,\n    });\n    json.expires_in = expiresIn;\n    if (json.interval !== undefined) {\n        assertNumber(json.interval, false, '\"response\" body \"interval\" property', INVALID_RESPONSE, {\n            body: json,\n        });\n    }\n    return json;\n}\nexport async function backchannelAuthenticationGrantRequest(as, client, clientAuthentication, authReqId, options) {\n    assertAs(as);\n    assertClient(client);\n    assertString(authReqId, '\"authReqId\"');\n    const parameters = new URLSearchParams(options?.additionalParameters);\n    parameters.set('auth_req_id', authReqId);\n    return tokenEndpointRequest(as, client, clientAuthentication, 'urn:openid:params:grant-type:ciba', parameters, options);\n}\nexport async function processBackchannelAuthenticationGrantResponse(as, client, response, options) {\n    return processGenericAccessTokenResponse(as, client, response, undefined, options?.[jweDecrypt], options?.recognizedTokenTypes);\n}\nexport async function dynamicClientRegistrationRequest(as, metadata, options) {\n    assertAs(as);\n    const url = resolveEndpoint(as, 'registration_endpoint', metadata.use_mtls_endpoint_aliases, options?.[allowInsecureRequests] !== true);\n    const headers = prepareHeaders(options?.headers);\n    headers.set('accept', 'application/json');\n    headers.set('content-type', 'application/json');\n    const method = 'POST';\n    if (options?.DPoP) {\n        assertDPoP(options.DPoP);\n        await options.DPoP.addProof(url, headers, method, options.initialAccessToken);\n    }\n    if (options?.initialAccessToken) {\n        headers.set('authorization', `${headers.has('dpop') ? 'DPoP' : 'Bearer'} ${options.initialAccessToken}`);\n    }\n    const response = await (options?.[customFetch] || fetch)(url.href, {\n        body: JSON.stringify(metadata),\n        headers: Object.fromEntries(headers.entries()),\n        method,\n        redirect: 'manual',\n        signal: signal(url, options?.signal),\n    });\n    options?.DPoP?.cacheNonce(response, url);\n    return response;\n}\nexport async function processDynamicClientRegistrationResponse(response) {\n    if (!looseInstanceOf(response, Response)) {\n        throw CodedTypeError('\"response\" must be an instance of Response', ERR_INVALID_ARG_TYPE);\n    }\n    await checkOAuthBodyError(response, 201, 'Dynamic Client Registration Endpoint');\n    assertReadableResponse(response);\n    const json = await getResponseJsonBody(response);\n    assertString(json.client_id, '\"response\" body \"client_id\" property', INVALID_RESPONSE, {\n        body: json,\n    });\n    if (json.client_secret !== undefined) {\n        assertString(json.client_secret, '\"response\" body \"client_secret\" property', INVALID_RESPONSE, {\n            body: json,\n        });\n    }\n    if (json.client_secret) {\n        assertNumber(json.client_secret_expires_at, true, '\"response\" body \"client_secret_expires_at\" property', INVALID_RESPONSE, {\n            body: json,\n        });\n    }\n    return json;\n}\nexport async function resourceDiscoveryRequest(resourceIdentifier, options) {\n    return performDiscovery(resourceIdentifier, 'resourceIdentifier', (url) => {\n        prependWellKnown(url, '.well-known/oauth-protected-resource', true);\n        return url;\n    }, options);\n}\nexport async function processResourceDiscoveryResponse(expectedResourceIdentifier, response) {\n    const expected = expectedResourceIdentifier;\n    if (!(expected instanceof URL) && expected !== _nodiscoverycheck) {\n        throw CodedTypeError('\"expectedResourceIdentifier\" must be an instance of URL', ERR_INVALID_ARG_TYPE);\n    }\n    if (!looseInstanceOf(response, Response)) {\n        throw CodedTypeError('\"response\" must be an instance of Response', ERR_INVALID_ARG_TYPE);\n    }\n    if (response.status !== 200) {\n        throw OPE('\"response\" is not a conform Resource Server Metadata response (unexpected HTTP status code)', RESPONSE_IS_NOT_CONFORM, response);\n    }\n    assertReadableResponse(response);\n    const json = await getResponseJsonBody(response);\n    assertString(json.resource, '\"response\" body \"resource\" property', INVALID_RESPONSE, {\n        body: json,\n    });\n    if (expected !== _nodiscoverycheck && new URL(json.resource).href !== expected.href) {\n        throw OPE('\"response\" body \"resource\" property does not match the expected value', JSON_ATTRIBUTE_COMPARISON, { expected: expected.href, body: json, attribute: 'resource' });\n    }\n    return json;\n}\nasync function getResponseJsonBody(response, check = assertApplicationJson) {\n    let json;\n    try {\n        json = await response.json();\n    }\n    catch (cause) {\n        check(response);\n        throw OPE('failed to parse \"response\" body as JSON', PARSE_ERROR, cause);\n    }\n    if (!isJsonObject(json)) {\n        throw OPE('\"response\" body must be a top level object', INVALID_RESPONSE, { body: json });\n    }\n    return json;\n}\nexport const _nopkce = nopkce;\nexport const _nodiscoverycheck = Symbol();\nexport const _expectedIssuer = Symbol();\n//# sourceMappingURL=index.js.map","import * as oauth from \"oauth4webapi\";\nimport { ErrorBoundary } from \"react-error-boundary\";\nimport type { NavigateFunction } from \"react-router\";\nimport type { OpenIDAuthenticationConfig } from \"../../../config/config.js\";\nimport { ClientOnly } from \"../../components/ClientOnly.js\";\nimport { joinUrl } from \"../../util/joinUrl.js\";\nimport { CoreAuthenticationPlugin } from \"../AuthenticationPlugin.js\";\nimport type {\n  AuthActionContext,\n  AuthActionOptions,\n  AuthenticationPlugin,\n  AuthenticationProviderInitializer,\n} from \"../authentication.js\";\nimport { CallbackHandler } from \"../components/CallbackHandler.js\";\nimport { OAuthErrorPage } from \"../components/OAuthErrorPage.js\";\nimport { AuthorizationError } from \"../errors.js\";\nimport { type UserProfile, useAuthState } from \"../state.js\";\n\nconst CODE_VERIFIER_KEY = \"code-verifier\";\nconst STATE_KEY = \"oauth-state\";\n\nexport interface OpenIdProviderData {\n  accessToken: string;\n  idToken?: string;\n  refreshToken?: string;\n  expiresOn: Date;\n  tokenType: string;\n}\n\nexport const OPENID_CALLBACK_PATH = \"/oauth/callback\";\n\nexport class OpenIDAuthenticationProvider\n  extends CoreAuthenticationPlugin\n  implements AuthenticationPlugin\n{\n  protected client: oauth.Client;\n  protected issuer: string;\n  protected authorizationServer: oauth.AuthorizationServer | undefined;\n\n  protected callbackUrlPath: string;\n\n  protected onAuthorizationUrl?: (\n    authorizationUrl: URL,\n    options: { isSignIn: boolean; isSignUp: boolean },\n  ) => void;\n\n  protected readonly redirectToAfterSignUp: string | undefined;\n  protected readonly redirectToAfterSignIn: string | undefined;\n  protected readonly redirectToAfterSignOut: string;\n  private readonly audience?: string;\n  private readonly scopes: string[];\n\n  constructor({\n    issuer,\n    audience,\n    clientId,\n    redirectToAfterSignUp,\n    redirectToAfterSignIn,\n    redirectToAfterSignOut = \"/\",\n    basePath,\n    scopes,\n  }: OpenIDAuthenticationConfig) {\n    super();\n    this.client = {\n      client_id: clientId,\n      token_endpoint_auth_method: \"none\",\n    };\n    this.audience = audience;\n    this.issuer = issuer;\n    // This is the callback URL for the OAuth provider. So it needs the base path.\n    this.callbackUrlPath = joinUrl(basePath, OPENID_CALLBACK_PATH);\n    this.scopes = scopes ?? [\"openid\", \"profile\", \"email\"];\n\n    this.redirectToAfterSignUp = redirectToAfterSignUp;\n    this.redirectToAfterSignIn = redirectToAfterSignIn;\n    this.redirectToAfterSignOut = redirectToAfterSignOut;\n  }\n\n  protected async getAuthServer() {\n    if (!this.authorizationServer) {\n      const issuerUrl = new URL(this.issuer);\n      const response = await oauth.discoveryRequest(issuerUrl);\n      this.authorizationServer = await oauth.processDiscoveryResponse(\n        issuerUrl,\n        response,\n      );\n    }\n    return this.authorizationServer;\n  }\n\n  /**\n   * Sets the tokens from various OAuth responses\n   * @param response\n   */\n  protected setTokensFromResponse(response: oauth.TokenEndpointResponse) {\n    if (!response.expires_in) {\n      throw new AuthorizationError(\"No expires_in in response\");\n    }\n\n    const tokens: OpenIdProviderData = {\n      accessToken: response.access_token,\n      refreshToken: response.refresh_token,\n      idToken: response.id_token,\n      expiresOn: new Date(Date.now() + response.expires_in * 1000),\n      tokenType: response.token_type,\n    };\n\n    useAuthState.setState({\n      providerData: tokens,\n    });\n  }\n\n  async signUp(\n    _: { navigate: NavigateFunction },\n    {\n      redirectTo,\n      replace = false,\n    }: {\n      redirectTo?: string;\n      replace?: boolean;\n    } = {},\n  ) {\n    return this.authorize({\n      redirectTo: this.redirectToAfterSignUp ?? redirectTo ?? \"/\",\n      replace,\n      isSignUp: true,\n    });\n  }\n\n  async signIn(\n    _: AuthActionContext,\n    { redirectTo, replace = false }: AuthActionOptions,\n  ) {\n    return this.authorize({\n      redirectTo: this.redirectToAfterSignIn ?? redirectTo ?? \"/\",\n      replace,\n    });\n  }\n\n  public async refreshUserProfile(): Promise<boolean> {\n    const accessToken = await this.getAccessToken();\n    const authServer = await this.getAuthServer();\n\n    const userInfoResponse = await oauth.userInfoRequest(\n      authServer,\n      this.client,\n      accessToken,\n    );\n    const userInfo = await userInfoResponse.json();\n\n    const profile: UserProfile = {\n      sub: userInfo.sub,\n      email: userInfo.email,\n      name: userInfo.name,\n      emailVerified: userInfo.email_verified ?? false,\n      pictureUrl: userInfo.picture,\n    };\n\n    useAuthState.setState({\n      isAuthenticated: true,\n      isPending: false,\n      profile,\n    });\n\n    return true;\n  }\n\n  private async authorize({\n    redirectTo,\n    isSignUp = false,\n    replace = false,\n  }: {\n    redirectTo: string;\n    isSignUp?: boolean;\n    replace?: boolean;\n  }): Promise<void> {\n    const code_challenge_method = \"S256\";\n    const authorizationServer = await this.getAuthServer();\n\n    if (!authorizationServer.authorization_endpoint) {\n      throw new AuthorizationError(\"No authorization endpoint\");\n    }\n\n    /**\n     * The following MUST be generated for every redirect to the authorization_endpoint. You must store\n     * the codeVerifier and nonce in the end-user session such that it can be recovered as the user\n     * gets redirected from the authorization server back to your application.\n     */\n    const codeVerifier = oauth.generateRandomCodeVerifier();\n    const codeChallenge = await oauth.calculatePKCECodeChallenge(codeVerifier);\n\n    sessionStorage.setItem(CODE_VERIFIER_KEY, codeVerifier);\n\n    // redirect user to as.authorization_endpoint\n    const authorizationUrl = new URL(\n      authorizationServer.authorization_endpoint,\n    );\n\n    sessionStorage.setItem(\"redirect-to\", redirectTo);\n\n    const redirectUrl = new URL(window.location.origin);\n    redirectUrl.pathname = this.callbackUrlPath;\n    redirectUrl.search = \"\";\n    redirectUrl.hash = \"\";\n\n    authorizationUrl.searchParams.set(\"client_id\", this.client.client_id);\n    authorizationUrl.searchParams.set(\"redirect_uri\", redirectUrl.toString());\n    authorizationUrl.searchParams.set(\"response_type\", \"code\");\n    authorizationUrl.searchParams.set(\"scope\", this.scopes.join(\" \"));\n    authorizationUrl.searchParams.set(\"code_challenge\", codeChallenge);\n    authorizationUrl.searchParams.set(\n      \"code_challenge_method\",\n      code_challenge_method,\n    );\n    if (this.audience) {\n      authorizationUrl.searchParams.set(\"audience\", this.audience);\n    }\n\n    this.onAuthorizationUrl?.(authorizationUrl, {\n      isSignIn: !isSignUp,\n      isSignUp,\n    });\n\n    /**\n     * The state parameter is used to prevent CSRF attacks and should be used in all authorization requests.\n     * It is independent of PKCE and should be used regardless of PKCE support.\n     */\n    const state = oauth.generateRandomState();\n    sessionStorage.setItem(STATE_KEY, state);\n    authorizationUrl.searchParams.set(\"state\", state);\n\n    if (replace) {\n      location.replace(authorizationUrl.href);\n    } else {\n      location.href = authorizationUrl.href;\n    }\n  }\n\n  async getAccessToken(): Promise<string> {\n    const as = await this.getAuthServer();\n    const { providerData, setLoggedOut } = useAuthState.getState();\n\n    if (!providerData) {\n      setLoggedOut();\n      throw new AuthorizationError(\"User is not authenticated\");\n    }\n    const tokenState = providerData as OpenIdProviderData;\n\n    if (new Date(tokenState.expiresOn) < new Date()) {\n      if (!tokenState.refreshToken) {\n        useAuthState.getState().setLoggedOut();\n        throw new AuthorizationError(\"No refresh token found\");\n      }\n\n      const response = await oauth.refreshTokenGrantRequest(\n        as,\n        this.client,\n        oauth.None(),\n        tokenState.refreshToken,\n      );\n      const result = await oauth.processRefreshTokenResponse(\n        as,\n        this.client,\n        response,\n      );\n\n      if (!result.access_token) {\n        setLoggedOut();\n        throw new AuthorizationError(\"No access token in response\");\n      }\n\n      this.setTokensFromResponse(result);\n\n      return result.access_token.toString();\n    } else {\n      return tokenState.accessToken;\n    }\n  }\n\n  signRequest = async (request: Request): Promise<Request> => {\n    const accessToken = await this.getAccessToken();\n    request.headers.set(\"Authorization\", `Bearer ${accessToken}`);\n    return request;\n  };\n\n  signOut = async (_: AuthActionContext) => {\n    useAuthState.setState({\n      isAuthenticated: false,\n      isPending: false,\n      profile: undefined,\n      providerData: undefined,\n    });\n\n    const as = await this.getAuthServer();\n\n    const redirectUrl = new URL(\n      window.location.origin + this.redirectToAfterSignOut,\n    );\n    redirectUrl.pathname = this.callbackUrlPath;\n\n    let logoutUrl: URL;\n    // The endSessionEndpoint is set, the IdP supports some form of logout,\n    // so we use the IdP logout. Otherwise, just redirect the user to home\n    if (as.end_session_endpoint) {\n      logoutUrl = new URL(as.end_session_endpoint);\n      // TODO: get id_token and set hint\n      // const { id_token } = session;\n      // if (id_token) {\n      //   logoutUrl.searchParams.set(\"id_token_hint\", id_token);\n      // }\n      logoutUrl.searchParams.set(\n        \"post_logout_redirect_uri\",\n        redirectUrl.toString(),\n      );\n    } else {\n      logoutUrl = redirectUrl;\n    }\n  };\n\n  onPageLoad = async () => {\n    const { providerData } = useAuthState.getState();\n\n    if (!providerData) {\n      useAuthState.setState({ isPending: false });\n      return;\n    }\n\n    const tokenState = providerData as OpenIdProviderData;\n\n    if (new Date(tokenState.expiresOn) < new Date()) {\n      if (!tokenState.refreshToken) {\n        useAuthState.setState({\n          isAuthenticated: false,\n          isPending: false,\n          profile: null,\n          providerData: null,\n        });\n        return;\n      }\n\n      try {\n        const as = await this.getAuthServer();\n        const response = await oauth.refreshTokenGrantRequest(\n          as,\n          this.client,\n          oauth.None(),\n          tokenState.refreshToken,\n        );\n        const result = await oauth.processRefreshTokenResponse(\n          as,\n          this.client,\n          response,\n        );\n\n        if (!result.access_token) {\n          throw new AuthorizationError(\"No access token in response\");\n        }\n\n        this.setTokensFromResponse(result);\n      } catch {\n        useAuthState.setState({\n          isAuthenticated: false,\n          isPending: false,\n          profile: null,\n          providerData: null,\n        });\n        return;\n      }\n    }\n\n    useAuthState.setState({ isPending: false });\n  };\n\n  handleCallback = async () => {\n    const url = new URL(window.location.href);\n    const state = url.searchParams.get(\"state\");\n    const storedState = sessionStorage.getItem(STATE_KEY);\n    sessionStorage.removeItem(STATE_KEY);\n\n    if (state !== storedState) {\n      throw new AuthorizationError(\"Invalid state parameter\");\n    }\n\n    // one eternity later, the user lands back on the redirect_uri\n    // Authorization Code Grant Request & Response\n    const codeVerifier = sessionStorage.getItem(CODE_VERIFIER_KEY);\n    sessionStorage.removeItem(CODE_VERIFIER_KEY);\n    if (!codeVerifier) {\n      throw new AuthorizationError(\"No code verifier found in state.\");\n    }\n\n    const authServer = await this.getAuthServer();\n\n    const params = oauth.validateAuthResponse(\n      authServer,\n      this.client,\n      url.searchParams,\n      state ?? undefined,\n    );\n\n    const redirectUrl = new URL(url);\n    redirectUrl.pathname = this.callbackUrlPath;\n    redirectUrl.search = \"\";\n    redirectUrl.hash = \"\";\n\n    const response = await oauth.authorizationCodeGrantRequest(\n      authServer,\n      this.client,\n      oauth.None(),\n      params,\n      redirectUrl.toString(),\n      codeVerifier,\n    );\n\n    const oauthResult = await oauth.processAuthorizationCodeResponse(\n      authServer,\n      this.client,\n      response,\n    );\n\n    this.setTokensFromResponse(oauthResult);\n    await this.refreshUserProfile();\n\n    const redirectTo = sessionStorage.getItem(\"redirect-to\") ?? \"/\";\n    sessionStorage.removeItem(\"redirect-to\");\n    return redirectTo;\n  };\n\n  getRoutes() {\n    return [\n      ...super.getRoutes(),\n      {\n        path: OPENID_CALLBACK_PATH,\n        element: (\n          <ClientOnly>\n            <ErrorBoundary\n              fallbackRender={({ error }) => <OAuthErrorPage error={error} />}\n            >\n              <CallbackHandler handleCallback={this.handleCallback} />\n            </ErrorBoundary>\n          </ClientOnly>\n        ),\n      },\n    ];\n  }\n}\n\nconst openIDAuth: AuthenticationProviderInitializer<\n  OpenIDAuthenticationConfig\n> = (options) => new OpenIDAuthenticationProvider(options);\n\nexport default openIDAuth;\n"],"names":["USER_AGENT","looseInstanceOf","input","expected","ERR_INVALID_ARG_VALUE","ERR_INVALID_ARG_TYPE","CodedTypeError","message","code","cause","err","allowInsecureRequests","clockSkew","clockTolerance","customFetch","encoder","decoder","buf","encodeBase64Url","arr","i","decodeBase64Url","binary","bytes","b64u","UnsupportedOperationError","options","UNSUPPORTED_OPERATION","OperationProcessingError","OPE","isJsonObject","prepareHeaders","headers","signal","url","value","replaceDoubleSlash","pathname","prependWellKnown","wellKnown","allowTerminatingSlash","appendWellKnown","performDiscovery","urlName","transform","checkProtocol","discoveryRequest","issuerIdentifier","assertNumber","allow0","it","assertString","processDiscoveryResponse","expectedIssuerIdentifier","response","_nodiscoverycheck","RESPONSE_IS_NOT_CONFORM","assertReadableResponse","json","getResponseJsonBody","INVALID_RESPONSE","JSON_ATTRIBUTE_COMPARISON","assertApplicationJson","assertContentType","notJson","types","msg","last","RESPONSE_IS_NOT_JSON","contentType","getContentType","randomBytes","generateRandomCodeVerifier","generateRandomState","calculatePKCECodeChallenge","codeVerifier","getClockSkew","client","skew","getClockTolerance","tolerance","epochTime","assertAs","as","assertClient","None","_as","body","_headers","URLParse","base","enforceHttps","HTTP_REQUEST_FORBIDDEN","REQUEST_PROTOCOL_FORBIDDEN","validateEndpoint","endpoint","useMtlsAlias","MISSING_SERVER_METADATA","INVALID_SERVER_METADATA","resolveEndpoint","ResponseBodyError","RESPONSE_BODY_ERROR","AuthorizationResponseError","AUTHORIZATION_RESPONSE_ERROR","WWWAuthenticateChallengeError","WWW_AUTHENTICATE_CHALLENGE","tokenMatch","token68Match","quotedMatch","quotedParamMatcher","paramMatcher","schemeRE","quotedParamRE","unquotedParamRE","token68ParamRE","parseWwwAuthenticateChallenges","header","challenges","rest","match","scheme","afterScheme","spaceMatch","hasParameters","parameters","token68","key","challenge","parseOAuthResponseErrorBody","checkOAuthBodyError","label","checkAuthenticationChallenges","assertDPoP","option","branded","resourceRequest","accessToken","method","userInfoRequest","authenticatedRequest","clientAuthentication","tokenEndpointRequest","grantType","refreshTokenGrantRequest","refreshToken","idTokenClaims","jwtRefs","getValidatedIdTokenClaims","ref","claims","processGenericAccessTokenResponse","additionalRequiredIdTokenClaims","decryptFn","recognizedTokenTypes","expiresIn","requiredClaims","jwt","validateJwt","checkSigningAlgorithm","validatePresence","validateIssuer","validateAudience","JWT_CLAIM_COMPARISON","processRefreshTokenResponse","result","_expectedIssuer","brand","searchParams","nopkce","authorizationCodeGrantRequest","callbackParameters","redirectUri","getURLSearchParameter","jwtClaimNames","required","claim","processAuthorizationCodeResponse","processAuthorizationCodeOAuth2Response","now","JWT_TIMESTAMP_CHECK","PARSE_ERROR","jws","checkAlg","decryptJwt","protectedHeader","payload","length","issuer","fallback","name","skipStateCheck","expectNoState","validateAuthResponse","expectedState","iss","state","id_token","token","check","CODE_VERIFIER_KEY","STATE_KEY","OPENID_CALLBACK_PATH","OpenIDAuthenticationProvider","CoreAuthenticationPlugin","audience","clientId","redirectToAfterSignUp","redirectToAfterSignIn","redirectToAfterSignOut","basePath","scopes","joinUrl","issuerUrl","oauth.discoveryRequest","oauth.processDiscoveryResponse","AuthorizationError","tokens","useAuthState","_","redirectTo","replace","authServer","userInfo","oauth.userInfoRequest","profile","isSignUp","code_challenge_method","authorizationServer","oauth.generateRandomCodeVerifier","codeChallenge","oauth.calculatePKCECodeChallenge","authorizationUrl","redirectUrl","oauth.generateRandomState","providerData","setLoggedOut","tokenState","oauth.refreshTokenGrantRequest","oauth.None","oauth.processRefreshTokenResponse","request","logoutUrl","storedState","params","oauth.validateAuthResponse","oauth.authorizationCodeGrantRequest","oauthResult","oauth.processAuthorizationCodeResponse","ClientOnly","jsx","ErrorBoundary","error","OAuthErrorPage","CallbackHandler","openIDAuth"],"mappings":"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","x_google_ignoreList":[0]}