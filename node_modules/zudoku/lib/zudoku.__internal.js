import { a as De, H as Ce } from "./index.esm-Ca5zvoff.js";
import { j as c } from "./jsx-runtime-BzflLqGi.js";
import { b as Ot, H as St } from "./HydrationBoundary-DD-EI0m6.js";
import { L as Ue, u as Pt } from "./useQuery-DSKGiCQr.js";
import * as V from "react";
import { StrictMode as Fe, useEffect as te, useRef as Je, useState as Tt, Suspense as Et, isValidElement as Nt } from "react";
import { o as It, S as At, a as Le, b3 as Rt, O as Dt, e as Ct, L as Ut, i as Ft, x as Jt } from "./chunk-EPOLDU6W-CLHrVxOG.js";
import * as Lt from "react-dom";
import { B as Me, R as Mt } from "./RouteGuard-DnAFajw9.js";
import { CircleFadingArrowUpIcon as Bt, LoaderCircleIcon as Vt, ExternalLink as qt, PanelLeftIcon as Wt, UnlinkIcon as Kt } from "lucide-react";
import { Button as Ht } from "./ui/Button.js";
import { a as N, A as Gt, s as Yt, P as Qt, N as Xt, d as ge, f as en, g as tn, h as nn, T as Be, H as Ve, D as rn, i as qe } from "./Zudoku-BPvTuMy8.js";
import { c as S } from "./cn-5-Gd1Dss.js";
import { a as q, d as on, j as sn } from "./ZudokuContext-Mfno-z8f.js";
import "./index-DAWHN3cH.js";
import "./ZudokuReactContext-DGJAP1sN.js";
import { D as T, a as an, b as cn } from "./Drawer-Ch7927PF.js";
import { VisuallyHidden as un } from "@radix-ui/react-visually-hidden";
import { S as ln } from "./Spinner-CI6bRyZw.js";
import { C as We } from "./CategoryHeading-DhmodDcq.js";
import { isTransformConfigPlugin as dn } from "./zudoku.plugins.js";
/**
 * react-router v7.12.0
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
function fn(e) {
  return /* @__PURE__ */ V.createElement(It, { flushSync: Lt.flushSync, ...e });
}
const pn = new Ot({
  defaultOptions: {
    queries: {
      staleTime: 1e3 * 60 * 5
    }
  }
}), hn = ({
  router: e,
  hydrate: t = !1
}) => /* @__PURE__ */ c.jsx(Fe, { children: /* @__PURE__ */ c.jsx(Ue, { client: pn, children: /* @__PURE__ */ c.jsx(St, { state: t ? window.DATA : void 0, children: /* @__PURE__ */ c.jsx(Me, { value: !1, children: /* @__PURE__ */ c.jsx(De, { children: /* @__PURE__ */ c.jsx(fn, { router: e }) }) }) }) }) }), mn = ({
  router: e,
  context: t,
  queryClient: n,
  helmetContext: r,
  bypassProtection: o = !1
}) => /* @__PURE__ */ c.jsx(Fe, { children: /* @__PURE__ */ c.jsx(Ue, { client: n, children: /* @__PURE__ */ c.jsx(De, { context: r, children: /* @__PURE__ */ c.jsx(Me, { value: o, children: /* @__PURE__ */ c.jsx(At, { router: e, context: t }) }) }) }) });
function u(e, t, n) {
  function r(a, l) {
    if (a._zod || Object.defineProperty(a, "_zod", {
      value: {
        def: l,
        constr: s,
        traits: /* @__PURE__ */ new Set()
      },
      enumerable: !1
    }), a._zod.traits.has(e))
      return;
    a._zod.traits.add(e), t(a, l);
    const d = s.prototype, f = Object.keys(d);
    for (let g = 0; g < f.length; g++) {
      const h = f[g];
      h in a || (a[h] = d[h].bind(a));
    }
  }
  const o = n?.Parent ?? Object;
  class i extends o {
  }
  Object.defineProperty(i, "name", { value: e });
  function s(a) {
    var l;
    const d = n?.Parent ? new i() : this;
    r(d, a), (l = d._zod).deferred ?? (l.deferred = []);
    for (const f of d._zod.deferred)
      f();
    return d;
  }
  return Object.defineProperty(s, "init", { value: r }), Object.defineProperty(s, Symbol.hasInstance, {
    value: (a) => n?.Parent && a instanceof n.Parent ? !0 : a?._zod?.traits?.has(e)
  }), Object.defineProperty(s, "name", { value: e }), s;
}
class F extends Error {
  constructor() {
    super("Encountered Promise during synchronous parse. Use .parseAsync() instead.");
  }
}
class Ke extends Error {
  constructor(t) {
    super(`Encountered unidirectional transform during encode: ${t}`), this.name = "ZodEncodeError";
  }
}
const He = {};
function R(e) {
  return He;
}
function Ge(e) {
  const t = Object.values(e).filter((r) => typeof r == "number");
  return Object.entries(e).filter(([r, o]) => t.indexOf(+r) === -1).map(([r, o]) => o);
}
function ie(e, t) {
  return typeof t == "bigint" ? t.toString() : t;
}
function ue(e) {
  return {
    get value() {
      {
        const t = e();
        return Object.defineProperty(this, "value", { value: t }), t;
      }
    }
  };
}
function le(e) {
  return e == null;
}
function de(e) {
  const t = e.startsWith("^") ? 1 : 0, n = e.endsWith("$") ? e.length - 1 : e.length;
  return e.slice(t, n);
}
const _e = Symbol("evaluating");
function _(e, t, n) {
  let r;
  Object.defineProperty(e, t, {
    get() {
      if (r !== _e)
        return r === void 0 && (r = _e, r = n()), r;
    },
    set(o) {
      Object.defineProperty(e, t, {
        value: o
        // configurable: true,
      });
    },
    configurable: !0
  });
}
function C(e, t, n) {
  Object.defineProperty(e, t, {
    value: n,
    writable: !0,
    enumerable: !0,
    configurable: !0
  });
}
function I(...e) {
  const t = {};
  for (const n of e) {
    const r = Object.getOwnPropertyDescriptors(n);
    Object.assign(t, r);
  }
  return Object.defineProperties({}, t);
}
function ve(e) {
  return JSON.stringify(e);
}
function gn(e) {
  return e.toLowerCase().trim().replace(/[^\w\s-]/g, "").replace(/[\s_-]+/g, "-").replace(/^-+|-+$/g, "");
}
const Ye = "captureStackTrace" in Error ? Error.captureStackTrace : (...e) => {
};
function Y(e) {
  return typeof e == "object" && e !== null && !Array.isArray(e);
}
const _n = ue(() => {
  if (typeof navigator < "u" && navigator?.userAgent?.includes("Cloudflare"))
    return !1;
  try {
    const e = Function;
    return new e(""), !0;
  } catch {
    return !1;
  }
});
function M(e) {
  if (Y(e) === !1)
    return !1;
  const t = e.constructor;
  if (t === void 0 || typeof t != "function")
    return !0;
  const n = t.prototype;
  return !(Y(n) === !1 || Object.prototype.hasOwnProperty.call(n, "isPrototypeOf") === !1);
}
function Qe(e) {
  return M(e) ? { ...e } : Array.isArray(e) ? [...e] : e;
}
const vn = /* @__PURE__ */ new Set(["string", "number", "symbol"]);
function ne(e) {
  return e.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
function A(e, t, n) {
  const r = new e._zod.constr(t ?? e._zod.def);
  return (!t || n?.parent) && (r._zod.parent = e), r;
}
function p(e) {
  const t = e;
  if (!t)
    return {};
  if (typeof t == "string")
    return { error: () => t };
  if (t?.message !== void 0) {
    if (t?.error !== void 0)
      throw new Error("Cannot specify both `message` and `error` params");
    t.error = t.message;
  }
  return delete t.message, typeof t.error == "string" ? { ...t, error: () => t.error } : t;
}
function yn(e) {
  return Object.keys(e).filter((t) => e[t]._zod.optin === "optional" && e[t]._zod.optout === "optional");
}
function wn(e, t) {
  const n = e._zod.def, r = n.checks;
  if (r && r.length > 0)
    throw new Error(".pick() cannot be used on object schemas containing refinements");
  const i = I(e._zod.def, {
    get shape() {
      const s = {};
      for (const a in t) {
        if (!(a in n.shape))
          throw new Error(`Unrecognized key: "${a}"`);
        t[a] && (s[a] = n.shape[a]);
      }
      return C(this, "shape", s), s;
    },
    checks: []
  });
  return A(e, i);
}
function zn(e, t) {
  const n = e._zod.def, r = n.checks;
  if (r && r.length > 0)
    throw new Error(".omit() cannot be used on object schemas containing refinements");
  const i = I(e._zod.def, {
    get shape() {
      const s = { ...e._zod.def.shape };
      for (const a in t) {
        if (!(a in n.shape))
          throw new Error(`Unrecognized key: "${a}"`);
        t[a] && delete s[a];
      }
      return C(this, "shape", s), s;
    },
    checks: []
  });
  return A(e, i);
}
function bn(e, t) {
  if (!M(t))
    throw new Error("Invalid input to extend: expected a plain object");
  const n = e._zod.def.checks;
  if (n && n.length > 0) {
    const i = e._zod.def.shape;
    for (const s in t)
      if (Object.getOwnPropertyDescriptor(i, s) !== void 0)
        throw new Error("Cannot overwrite keys on object schemas containing refinements. Use `.safeExtend()` instead.");
  }
  const o = I(e._zod.def, {
    get shape() {
      const i = { ...e._zod.def.shape, ...t };
      return C(this, "shape", i), i;
    }
  });
  return A(e, o);
}
function kn(e, t) {
  if (!M(t))
    throw new Error("Invalid input to safeExtend: expected a plain object");
  const n = I(e._zod.def, {
    get shape() {
      const r = { ...e._zod.def.shape, ...t };
      return C(this, "shape", r), r;
    }
  });
  return A(e, n);
}
function $n(e, t) {
  const n = I(e._zod.def, {
    get shape() {
      const r = { ...e._zod.def.shape, ...t._zod.def.shape };
      return C(this, "shape", r), r;
    },
    get catchall() {
      return t._zod.def.catchall;
    },
    checks: []
    // delete existing checks
  });
  return A(e, n);
}
function jn(e, t, n) {
  const o = t._zod.def.checks;
  if (o && o.length > 0)
    throw new Error(".partial() cannot be used on object schemas containing refinements");
  const s = I(t._zod.def, {
    get shape() {
      const a = t._zod.def.shape, l = { ...a };
      if (n)
        for (const d in n) {
          if (!(d in a))
            throw new Error(`Unrecognized key: "${d}"`);
          n[d] && (l[d] = e ? new e({
            type: "optional",
            innerType: a[d]
          }) : a[d]);
        }
      else
        for (const d in a)
          l[d] = e ? new e({
            type: "optional",
            innerType: a[d]
          }) : a[d];
      return C(this, "shape", l), l;
    },
    checks: []
  });
  return A(t, s);
}
function xn(e, t, n) {
  const r = I(t._zod.def, {
    get shape() {
      const o = t._zod.def.shape, i = { ...o };
      if (n)
        for (const s in n) {
          if (!(s in i))
            throw new Error(`Unrecognized key: "${s}"`);
          n[s] && (i[s] = new e({
            type: "nonoptional",
            innerType: o[s]
          }));
        }
      else
        for (const s in o)
          i[s] = new e({
            type: "nonoptional",
            innerType: o[s]
          });
      return C(this, "shape", i), i;
    }
  });
  return A(t, r);
}
function U(e, t = 0) {
  if (e.aborted === !0)
    return !0;
  for (let n = t; n < e.issues.length; n++)
    if (e.issues[n]?.continue !== !0)
      return !0;
  return !1;
}
function Xe(e, t) {
  return t.map((n) => {
    var r;
    return (r = n).path ?? (r.path = []), n.path.unshift(e), n;
  });
}
function K(e) {
  return typeof e == "string" ? e : e?.message;
}
function D(e, t, n) {
  const r = { ...e, path: e.path ?? [] };
  if (!e.message) {
    const o = K(e.inst?._zod.def?.error?.(e)) ?? K(t?.error?.(e)) ?? K(n.customError?.(e)) ?? K(n.localeError?.(e)) ?? "Invalid input";
    r.message = o;
  }
  return delete r.inst, delete r.continue, t?.reportInput || delete r.input, r;
}
function fe(e) {
  return Array.isArray(e) ? "array" : typeof e == "string" ? "string" : "unknown";
}
function B(...e) {
  const [t, n, r] = e;
  return typeof t == "string" ? {
    message: t,
    code: "custom",
    input: n,
    inst: r
  } : { ...t };
}
const et = (e, t) => {
  e.name = "$ZodError", Object.defineProperty(e, "_zod", {
    value: e._zod,
    enumerable: !1
  }), Object.defineProperty(e, "issues", {
    value: t,
    enumerable: !1
  }), e.message = JSON.stringify(t, ie, 2), Object.defineProperty(e, "toString", {
    value: () => e.message,
    enumerable: !1
  });
}, tt = u("$ZodError", et), nt = u("$ZodError", et, { Parent: Error });
function Zn(e, t = (n) => n.message) {
  const n = {}, r = [];
  for (const o of e.issues)
    o.path.length > 0 ? (n[o.path[0]] = n[o.path[0]] || [], n[o.path[0]].push(t(o))) : r.push(t(o));
  return { formErrors: r, fieldErrors: n };
}
function On(e, t = (n) => n.message) {
  const n = { _errors: [] }, r = (o) => {
    for (const i of o.issues)
      if (i.code === "invalid_union" && i.errors.length)
        i.errors.map((s) => r({ issues: s }));
      else if (i.code === "invalid_key")
        r({ issues: i.issues });
      else if (i.code === "invalid_element")
        r({ issues: i.issues });
      else if (i.path.length === 0)
        n._errors.push(t(i));
      else {
        let s = n, a = 0;
        for (; a < i.path.length; ) {
          const l = i.path[a];
          a === i.path.length - 1 ? (s[l] = s[l] || { _errors: [] }, s[l]._errors.push(t(i))) : s[l] = s[l] || { _errors: [] }, s = s[l], a++;
        }
      }
  };
  return r(e), n;
}
const pe = (e) => (t, n, r, o) => {
  const i = r ? Object.assign(r, { async: !1 }) : { async: !1 }, s = t._zod.run({ value: n, issues: [] }, i);
  if (s instanceof Promise)
    throw new F();
  if (s.issues.length) {
    const a = new (o?.Err ?? e)(s.issues.map((l) => D(l, i, R())));
    throw Ye(a, o?.callee), a;
  }
  return s.value;
}, he = (e) => async (t, n, r, o) => {
  const i = r ? Object.assign(r, { async: !0 }) : { async: !0 };
  let s = t._zod.run({ value: n, issues: [] }, i);
  if (s instanceof Promise && (s = await s), s.issues.length) {
    const a = new (o?.Err ?? e)(s.issues.map((l) => D(l, i, R())));
    throw Ye(a, o?.callee), a;
  }
  return s.value;
}, re = (e) => (t, n, r) => {
  const o = r ? { ...r, async: !1 } : { async: !1 }, i = t._zod.run({ value: n, issues: [] }, o);
  if (i instanceof Promise)
    throw new F();
  return i.issues.length ? {
    success: !1,
    error: new (e ?? tt)(i.issues.map((s) => D(s, o, R())))
  } : { success: !0, data: i.value };
}, Sn = /* @__PURE__ */ re(nt), oe = (e) => async (t, n, r) => {
  const o = r ? Object.assign(r, { async: !0 }) : { async: !0 };
  let i = t._zod.run({ value: n, issues: [] }, o);
  return i instanceof Promise && (i = await i), i.issues.length ? {
    success: !1,
    error: new e(i.issues.map((s) => D(s, o, R())))
  } : { success: !0, data: i.value };
}, Pn = /* @__PURE__ */ oe(nt), Tn = (e) => (t, n, r) => {
  const o = r ? Object.assign(r, { direction: "backward" }) : { direction: "backward" };
  return pe(e)(t, n, o);
}, En = (e) => (t, n, r) => pe(e)(t, n, r), Nn = (e) => async (t, n, r) => {
  const o = r ? Object.assign(r, { direction: "backward" }) : { direction: "backward" };
  return he(e)(t, n, o);
}, In = (e) => async (t, n, r) => he(e)(t, n, r), An = (e) => (t, n, r) => {
  const o = r ? Object.assign(r, { direction: "backward" }) : { direction: "backward" };
  return re(e)(t, n, o);
}, Rn = (e) => (t, n, r) => re(e)(t, n, r), Dn = (e) => async (t, n, r) => {
  const o = r ? Object.assign(r, { direction: "backward" }) : { direction: "backward" };
  return oe(e)(t, n, o);
}, Cn = (e) => async (t, n, r) => oe(e)(t, n, r), Un = /^[cC][^\s-]{8,}$/, Fn = /^[0-9a-z]+$/, Jn = /^[0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{26}$/, Ln = /^[0-9a-vA-V]{20}$/, Mn = /^[A-Za-z0-9]{27}$/, Bn = /^[a-zA-Z0-9_-]{21}$/, Vn = /^P(?:(\d+W)|(?!.*W)(?=\d|T\d)(\d+Y)?(\d+M)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+([.,]\d+)?S)?)?)$/, qn = /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12})$/, ye = (e) => e ? new RegExp(`^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-${e}[0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12})$`) : /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-8][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/, Wn = /^(?!\.)(?!.*\.\.)([A-Za-z0-9_'+\-\.]*)[A-Za-z0-9_+-]@([A-Za-z0-9][A-Za-z0-9\-]*\.)+[A-Za-z]{2,}$/, Kn = "^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$";
function Hn() {
  return new RegExp(Kn, "u");
}
const Gn = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/, Yn = /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))$/, Qn = /^((25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/([0-9]|[1-2][0-9]|3[0-2])$/, Xn = /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|::|([0-9a-fA-F]{1,4})?::([0-9a-fA-F]{1,4}:?){0,6})\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/, er = /^$|^(?:[0-9a-zA-Z+/]{4})*(?:(?:[0-9a-zA-Z+/]{2}==)|(?:[0-9a-zA-Z+/]{3}=))?$/, rt = /^[A-Za-z0-9_-]*$/, tr = /^\+[1-9]\d{6,14}$/, ot = "(?:(?:\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-(?:(?:0[13578]|1[02])-(?:0[1-9]|[12]\\d|3[01])|(?:0[469]|11)-(?:0[1-9]|[12]\\d|30)|(?:02)-(?:0[1-9]|1\\d|2[0-8])))", nr = /* @__PURE__ */ new RegExp(`^${ot}$`);
function st(e) {
  const t = "(?:[01]\\d|2[0-3]):[0-5]\\d";
  return typeof e.precision == "number" ? e.precision === -1 ? `${t}` : e.precision === 0 ? `${t}:[0-5]\\d` : `${t}:[0-5]\\d\\.\\d{${e.precision}}` : `${t}(?::[0-5]\\d(?:\\.\\d+)?)?`;
}
function rr(e) {
  return new RegExp(`^${st(e)}$`);
}
function or(e) {
  const t = st({ precision: e.precision }), n = ["Z"];
  e.local && n.push(""), e.offset && n.push("([+-](?:[01]\\d|2[0-3]):[0-5]\\d)");
  const r = `${t}(?:${n.join("|")})`;
  return new RegExp(`^${ot}T(?:${r})$`);
}
const sr = (e) => {
  const t = e ? `[\\s\\S]{${e?.minimum ?? 0},${e?.maximum ?? ""}}` : "[\\s\\S]*";
  return new RegExp(`^${t}$`);
}, ir = /^[^A-Z]*$/, ar = /^[^a-z]*$/, E = /* @__PURE__ */ u("$ZodCheck", (e, t) => {
  var n;
  e._zod ?? (e._zod = {}), e._zod.def = t, (n = e._zod).onattach ?? (n.onattach = []);
}), cr = /* @__PURE__ */ u("$ZodCheckMaxLength", (e, t) => {
  var n;
  E.init(e, t), (n = e._zod.def).when ?? (n.when = (r) => {
    const o = r.value;
    return !le(o) && o.length !== void 0;
  }), e._zod.onattach.push((r) => {
    const o = r._zod.bag.maximum ?? Number.POSITIVE_INFINITY;
    t.maximum < o && (r._zod.bag.maximum = t.maximum);
  }), e._zod.check = (r) => {
    const o = r.value;
    if (o.length <= t.maximum)
      return;
    const s = fe(o);
    r.issues.push({
      origin: s,
      code: "too_big",
      maximum: t.maximum,
      inclusive: !0,
      input: o,
      inst: e,
      continue: !t.abort
    });
  };
}), ur = /* @__PURE__ */ u("$ZodCheckMinLength", (e, t) => {
  var n;
  E.init(e, t), (n = e._zod.def).when ?? (n.when = (r) => {
    const o = r.value;
    return !le(o) && o.length !== void 0;
  }), e._zod.onattach.push((r) => {
    const o = r._zod.bag.minimum ?? Number.NEGATIVE_INFINITY;
    t.minimum > o && (r._zod.bag.minimum = t.minimum);
  }), e._zod.check = (r) => {
    const o = r.value;
    if (o.length >= t.minimum)
      return;
    const s = fe(o);
    r.issues.push({
      origin: s,
      code: "too_small",
      minimum: t.minimum,
      inclusive: !0,
      input: o,
      inst: e,
      continue: !t.abort
    });
  };
}), lr = /* @__PURE__ */ u("$ZodCheckLengthEquals", (e, t) => {
  var n;
  E.init(e, t), (n = e._zod.def).when ?? (n.when = (r) => {
    const o = r.value;
    return !le(o) && o.length !== void 0;
  }), e._zod.onattach.push((r) => {
    const o = r._zod.bag;
    o.minimum = t.length, o.maximum = t.length, o.length = t.length;
  }), e._zod.check = (r) => {
    const o = r.value, i = o.length;
    if (i === t.length)
      return;
    const s = fe(o), a = i > t.length;
    r.issues.push({
      origin: s,
      ...a ? { code: "too_big", maximum: t.length } : { code: "too_small", minimum: t.length },
      inclusive: !0,
      exact: !0,
      input: r.value,
      inst: e,
      continue: !t.abort
    });
  };
}), se = /* @__PURE__ */ u("$ZodCheckStringFormat", (e, t) => {
  var n, r;
  E.init(e, t), e._zod.onattach.push((o) => {
    const i = o._zod.bag;
    i.format = t.format, t.pattern && (i.patterns ?? (i.patterns = /* @__PURE__ */ new Set()), i.patterns.add(t.pattern));
  }), t.pattern ? (n = e._zod).check ?? (n.check = (o) => {
    t.pattern.lastIndex = 0, !t.pattern.test(o.value) && o.issues.push({
      origin: "string",
      code: "invalid_format",
      format: t.format,
      input: o.value,
      ...t.pattern ? { pattern: t.pattern.toString() } : {},
      inst: e,
      continue: !t.abort
    });
  }) : (r = e._zod).check ?? (r.check = () => {
  });
}), dr = /* @__PURE__ */ u("$ZodCheckRegex", (e, t) => {
  se.init(e, t), e._zod.check = (n) => {
    t.pattern.lastIndex = 0, !t.pattern.test(n.value) && n.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "regex",
      input: n.value,
      pattern: t.pattern.toString(),
      inst: e,
      continue: !t.abort
    });
  };
}), fr = /* @__PURE__ */ u("$ZodCheckLowerCase", (e, t) => {
  t.pattern ?? (t.pattern = ir), se.init(e, t);
}), pr = /* @__PURE__ */ u("$ZodCheckUpperCase", (e, t) => {
  t.pattern ?? (t.pattern = ar), se.init(e, t);
}), hr = /* @__PURE__ */ u("$ZodCheckIncludes", (e, t) => {
  E.init(e, t);
  const n = ne(t.includes), r = new RegExp(typeof t.position == "number" ? `^.{${t.position}}${n}` : n);
  t.pattern = r, e._zod.onattach.push((o) => {
    const i = o._zod.bag;
    i.patterns ?? (i.patterns = /* @__PURE__ */ new Set()), i.patterns.add(r);
  }), e._zod.check = (o) => {
    o.value.includes(t.includes, t.position) || o.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "includes",
      includes: t.includes,
      input: o.value,
      inst: e,
      continue: !t.abort
    });
  };
}), mr = /* @__PURE__ */ u("$ZodCheckStartsWith", (e, t) => {
  E.init(e, t);
  const n = new RegExp(`^${ne(t.prefix)}.*`);
  t.pattern ?? (t.pattern = n), e._zod.onattach.push((r) => {
    const o = r._zod.bag;
    o.patterns ?? (o.patterns = /* @__PURE__ */ new Set()), o.patterns.add(n);
  }), e._zod.check = (r) => {
    r.value.startsWith(t.prefix) || r.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "starts_with",
      prefix: t.prefix,
      input: r.value,
      inst: e,
      continue: !t.abort
    });
  };
}), gr = /* @__PURE__ */ u("$ZodCheckEndsWith", (e, t) => {
  E.init(e, t);
  const n = new RegExp(`.*${ne(t.suffix)}$`);
  t.pattern ?? (t.pattern = n), e._zod.onattach.push((r) => {
    const o = r._zod.bag;
    o.patterns ?? (o.patterns = /* @__PURE__ */ new Set()), o.patterns.add(n);
  }), e._zod.check = (r) => {
    r.value.endsWith(t.suffix) || r.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "ends_with",
      suffix: t.suffix,
      input: r.value,
      inst: e,
      continue: !t.abort
    });
  };
}), _r = /* @__PURE__ */ u("$ZodCheckOverwrite", (e, t) => {
  E.init(e, t), e._zod.check = (n) => {
    n.value = t.tx(n.value);
  };
});
class vr {
  constructor(t = []) {
    this.content = [], this.indent = 0, this && (this.args = t);
  }
  indented(t) {
    this.indent += 1, t(this), this.indent -= 1;
  }
  write(t) {
    if (typeof t == "function") {
      t(this, { execution: "sync" }), t(this, { execution: "async" });
      return;
    }
    const r = t.split(`
`).filter((s) => s), o = Math.min(...r.map((s) => s.length - s.trimStart().length)), i = r.map((s) => s.slice(o)).map((s) => " ".repeat(this.indent * 2) + s);
    for (const s of i)
      this.content.push(s);
  }
  compile() {
    const t = Function, n = this?.args, o = [...(this?.content ?? [""]).map((i) => `  ${i}`)];
    return new t(...n, o.join(`
`));
  }
}
const yr = {
  major: 4,
  minor: 3,
  patch: 6
}, w = /* @__PURE__ */ u("$ZodType", (e, t) => {
  var n;
  e ?? (e = {}), e._zod.def = t, e._zod.bag = e._zod.bag || {}, e._zod.version = yr;
  const r = [...e._zod.def.checks ?? []];
  e._zod.traits.has("$ZodCheck") && r.unshift(e);
  for (const o of r)
    for (const i of o._zod.onattach)
      i(e);
  if (r.length === 0)
    (n = e._zod).deferred ?? (n.deferred = []), e._zod.deferred?.push(() => {
      e._zod.run = e._zod.parse;
    });
  else {
    const o = (s, a, l) => {
      let d = U(s), f;
      for (const g of a) {
        if (g._zod.def.when) {
          if (!g._zod.def.when(s))
            continue;
        } else if (d)
          continue;
        const h = s.issues.length, m = g._zod.check(s);
        if (m instanceof Promise && l?.async === !1)
          throw new F();
        if (f || m instanceof Promise)
          f = (f ?? Promise.resolve()).then(async () => {
            await m, s.issues.length !== h && (d || (d = U(s, h)));
          });
        else {
          if (s.issues.length === h)
            continue;
          d || (d = U(s, h));
        }
      }
      return f ? f.then(() => s) : s;
    }, i = (s, a, l) => {
      if (U(s))
        return s.aborted = !0, s;
      const d = o(a, r, l);
      if (d instanceof Promise) {
        if (l.async === !1)
          throw new F();
        return d.then((f) => e._zod.parse(f, l));
      }
      return e._zod.parse(d, l);
    };
    e._zod.run = (s, a) => {
      if (a.skipChecks)
        return e._zod.parse(s, a);
      if (a.direction === "backward") {
        const d = e._zod.parse({ value: s.value, issues: [] }, { ...a, skipChecks: !0 });
        return d instanceof Promise ? d.then((f) => i(f, s, a)) : i(d, s, a);
      }
      const l = e._zod.parse(s, a);
      if (l instanceof Promise) {
        if (a.async === !1)
          throw new F();
        return l.then((d) => o(d, r, a));
      }
      return o(l, r, a);
    };
  }
  _(e, "~standard", () => ({
    validate: (o) => {
      try {
        const i = Sn(e, o);
        return i.success ? { value: i.data } : { issues: i.error?.issues };
      } catch {
        return Pn(e, o).then((s) => s.success ? { value: s.data } : { issues: s.error?.issues });
      }
    },
    vendor: "zod",
    version: 1
  }));
}), me = /* @__PURE__ */ u("$ZodString", (e, t) => {
  w.init(e, t), e._zod.pattern = [...e?._zod.bag?.patterns ?? []].pop() ?? sr(e._zod.bag), e._zod.parse = (n, r) => {
    if (t.coerce)
      try {
        n.value = String(n.value);
      } catch {
      }
    return typeof n.value == "string" || n.issues.push({
      expected: "string",
      code: "invalid_type",
      input: n.value,
      inst: e
    }), n;
  };
}), v = /* @__PURE__ */ u("$ZodStringFormat", (e, t) => {
  se.init(e, t), me.init(e, t);
}), wr = /* @__PURE__ */ u("$ZodGUID", (e, t) => {
  t.pattern ?? (t.pattern = qn), v.init(e, t);
}), zr = /* @__PURE__ */ u("$ZodUUID", (e, t) => {
  if (t.version) {
    const r = {
      v1: 1,
      v2: 2,
      v3: 3,
      v4: 4,
      v5: 5,
      v6: 6,
      v7: 7,
      v8: 8
    }[t.version];
    if (r === void 0)
      throw new Error(`Invalid UUID version: "${t.version}"`);
    t.pattern ?? (t.pattern = ye(r));
  } else
    t.pattern ?? (t.pattern = ye());
  v.init(e, t);
}), br = /* @__PURE__ */ u("$ZodEmail", (e, t) => {
  t.pattern ?? (t.pattern = Wn), v.init(e, t);
}), kr = /* @__PURE__ */ u("$ZodURL", (e, t) => {
  v.init(e, t), e._zod.check = (n) => {
    try {
      const r = n.value.trim(), o = new URL(r);
      t.hostname && (t.hostname.lastIndex = 0, t.hostname.test(o.hostname) || n.issues.push({
        code: "invalid_format",
        format: "url",
        note: "Invalid hostname",
        pattern: t.hostname.source,
        input: n.value,
        inst: e,
        continue: !t.abort
      })), t.protocol && (t.protocol.lastIndex = 0, t.protocol.test(o.protocol.endsWith(":") ? o.protocol.slice(0, -1) : o.protocol) || n.issues.push({
        code: "invalid_format",
        format: "url",
        note: "Invalid protocol",
        pattern: t.protocol.source,
        input: n.value,
        inst: e,
        continue: !t.abort
      })), t.normalize ? n.value = o.href : n.value = r;
      return;
    } catch {
      n.issues.push({
        code: "invalid_format",
        format: "url",
        input: n.value,
        inst: e,
        continue: !t.abort
      });
    }
  };
}), $r = /* @__PURE__ */ u("$ZodEmoji", (e, t) => {
  t.pattern ?? (t.pattern = Hn()), v.init(e, t);
}), jr = /* @__PURE__ */ u("$ZodNanoID", (e, t) => {
  t.pattern ?? (t.pattern = Bn), v.init(e, t);
}), xr = /* @__PURE__ */ u("$ZodCUID", (e, t) => {
  t.pattern ?? (t.pattern = Un), v.init(e, t);
}), Zr = /* @__PURE__ */ u("$ZodCUID2", (e, t) => {
  t.pattern ?? (t.pattern = Fn), v.init(e, t);
}), Or = /* @__PURE__ */ u("$ZodULID", (e, t) => {
  t.pattern ?? (t.pattern = Jn), v.init(e, t);
}), Sr = /* @__PURE__ */ u("$ZodXID", (e, t) => {
  t.pattern ?? (t.pattern = Ln), v.init(e, t);
}), Pr = /* @__PURE__ */ u("$ZodKSUID", (e, t) => {
  t.pattern ?? (t.pattern = Mn), v.init(e, t);
}), Tr = /* @__PURE__ */ u("$ZodISODateTime", (e, t) => {
  t.pattern ?? (t.pattern = or(t)), v.init(e, t);
}), Er = /* @__PURE__ */ u("$ZodISODate", (e, t) => {
  t.pattern ?? (t.pattern = nr), v.init(e, t);
}), Nr = /* @__PURE__ */ u("$ZodISOTime", (e, t) => {
  t.pattern ?? (t.pattern = rr(t)), v.init(e, t);
}), Ir = /* @__PURE__ */ u("$ZodISODuration", (e, t) => {
  t.pattern ?? (t.pattern = Vn), v.init(e, t);
}), Ar = /* @__PURE__ */ u("$ZodIPv4", (e, t) => {
  t.pattern ?? (t.pattern = Gn), v.init(e, t), e._zod.bag.format = "ipv4";
}), Rr = /* @__PURE__ */ u("$ZodIPv6", (e, t) => {
  t.pattern ?? (t.pattern = Yn), v.init(e, t), e._zod.bag.format = "ipv6", e._zod.check = (n) => {
    try {
      new URL(`http://[${n.value}]`);
    } catch {
      n.issues.push({
        code: "invalid_format",
        format: "ipv6",
        input: n.value,
        inst: e,
        continue: !t.abort
      });
    }
  };
}), Dr = /* @__PURE__ */ u("$ZodCIDRv4", (e, t) => {
  t.pattern ?? (t.pattern = Qn), v.init(e, t);
}), Cr = /* @__PURE__ */ u("$ZodCIDRv6", (e, t) => {
  t.pattern ?? (t.pattern = Xn), v.init(e, t), e._zod.check = (n) => {
    const r = n.value.split("/");
    try {
      if (r.length !== 2)
        throw new Error();
      const [o, i] = r;
      if (!i)
        throw new Error();
      const s = Number(i);
      if (`${s}` !== i)
        throw new Error();
      if (s < 0 || s > 128)
        throw new Error();
      new URL(`http://[${o}]`);
    } catch {
      n.issues.push({
        code: "invalid_format",
        format: "cidrv6",
        input: n.value,
        inst: e,
        continue: !t.abort
      });
    }
  };
});
function it(e) {
  if (e === "")
    return !0;
  if (e.length % 4 !== 0)
    return !1;
  try {
    return atob(e), !0;
  } catch {
    return !1;
  }
}
const Ur = /* @__PURE__ */ u("$ZodBase64", (e, t) => {
  t.pattern ?? (t.pattern = er), v.init(e, t), e._zod.bag.contentEncoding = "base64", e._zod.check = (n) => {
    it(n.value) || n.issues.push({
      code: "invalid_format",
      format: "base64",
      input: n.value,
      inst: e,
      continue: !t.abort
    });
  };
});
function Fr(e) {
  if (!rt.test(e))
    return !1;
  const t = e.replace(/[-_]/g, (r) => r === "-" ? "+" : "/"), n = t.padEnd(Math.ceil(t.length / 4) * 4, "=");
  return it(n);
}
const Jr = /* @__PURE__ */ u("$ZodBase64URL", (e, t) => {
  t.pattern ?? (t.pattern = rt), v.init(e, t), e._zod.bag.contentEncoding = "base64url", e._zod.check = (n) => {
    Fr(n.value) || n.issues.push({
      code: "invalid_format",
      format: "base64url",
      input: n.value,
      inst: e,
      continue: !t.abort
    });
  };
}), Lr = /* @__PURE__ */ u("$ZodE164", (e, t) => {
  t.pattern ?? (t.pattern = tr), v.init(e, t);
});
function Mr(e, t = null) {
  try {
    const n = e.split(".");
    if (n.length !== 3)
      return !1;
    const [r] = n;
    if (!r)
      return !1;
    const o = JSON.parse(atob(r));
    return !("typ" in o && o?.typ !== "JWT" || !o.alg || t && (!("alg" in o) || o.alg !== t));
  } catch {
    return !1;
  }
}
const Br = /* @__PURE__ */ u("$ZodJWT", (e, t) => {
  v.init(e, t), e._zod.check = (n) => {
    Mr(n.value, t.alg) || n.issues.push({
      code: "invalid_format",
      format: "jwt",
      input: n.value,
      inst: e,
      continue: !t.abort
    });
  };
}), Vr = /* @__PURE__ */ u("$ZodUnknown", (e, t) => {
  w.init(e, t), e._zod.parse = (n) => n;
}), qr = /* @__PURE__ */ u("$ZodNever", (e, t) => {
  w.init(e, t), e._zod.parse = (n, r) => (n.issues.push({
    expected: "never",
    code: "invalid_type",
    input: n.value,
    inst: e
  }), n);
});
function we(e, t, n) {
  e.issues.length && t.issues.push(...Xe(n, e.issues)), t.value[n] = e.value;
}
const Wr = /* @__PURE__ */ u("$ZodArray", (e, t) => {
  w.init(e, t), e._zod.parse = (n, r) => {
    const o = n.value;
    if (!Array.isArray(o))
      return n.issues.push({
        expected: "array",
        code: "invalid_type",
        input: o,
        inst: e
      }), n;
    n.value = Array(o.length);
    const i = [];
    for (let s = 0; s < o.length; s++) {
      const a = o[s], l = t.element._zod.run({
        value: a,
        issues: []
      }, r);
      l instanceof Promise ? i.push(l.then((d) => we(d, n, s))) : we(l, n, s);
    }
    return i.length ? Promise.all(i).then(() => n) : n;
  };
});
function Q(e, t, n, r, o) {
  if (e.issues.length) {
    if (o && !(n in r))
      return;
    t.issues.push(...Xe(n, e.issues));
  }
  e.value === void 0 ? n in r && (t.value[n] = void 0) : t.value[n] = e.value;
}
function at(e) {
  const t = Object.keys(e.shape);
  for (const r of t)
    if (!e.shape?.[r]?._zod?.traits?.has("$ZodType"))
      throw new Error(`Invalid element at key "${r}": expected a Zod schema`);
  const n = yn(e.shape);
  return {
    ...e,
    keys: t,
    keySet: new Set(t),
    numKeys: t.length,
    optionalKeys: new Set(n)
  };
}
function ct(e, t, n, r, o, i) {
  const s = [], a = o.keySet, l = o.catchall._zod, d = l.def.type, f = l.optout === "optional";
  for (const g in t) {
    if (a.has(g))
      continue;
    if (d === "never") {
      s.push(g);
      continue;
    }
    const h = l.run({ value: t[g], issues: [] }, r);
    h instanceof Promise ? e.push(h.then((m) => Q(m, n, g, t, f))) : Q(h, n, g, t, f);
  }
  return s.length && n.issues.push({
    code: "unrecognized_keys",
    keys: s,
    input: t,
    inst: i
  }), e.length ? Promise.all(e).then(() => n) : n;
}
const Kr = /* @__PURE__ */ u("$ZodObject", (e, t) => {
  if (w.init(e, t), !Object.getOwnPropertyDescriptor(t, "shape")?.get) {
    const a = t.shape;
    Object.defineProperty(t, "shape", {
      get: () => {
        const l = { ...a };
        return Object.defineProperty(t, "shape", {
          value: l
        }), l;
      }
    });
  }
  const r = ue(() => at(t));
  _(e._zod, "propValues", () => {
    const a = t.shape, l = {};
    for (const d in a) {
      const f = a[d]._zod;
      if (f.values) {
        l[d] ?? (l[d] = /* @__PURE__ */ new Set());
        for (const g of f.values)
          l[d].add(g);
      }
    }
    return l;
  });
  const o = Y, i = t.catchall;
  let s;
  e._zod.parse = (a, l) => {
    s ?? (s = r.value);
    const d = a.value;
    if (!o(d))
      return a.issues.push({
        expected: "object",
        code: "invalid_type",
        input: d,
        inst: e
      }), a;
    a.value = {};
    const f = [], g = s.shape;
    for (const h of s.keys) {
      const m = g[h], $ = m._zod.optout === "optional", b = m._zod.run({ value: d[h], issues: [] }, l);
      b instanceof Promise ? f.push(b.then((W) => Q(W, a, h, d, $))) : Q(b, a, h, d, $);
    }
    return i ? ct(f, d, a, l, r.value, e) : f.length ? Promise.all(f).then(() => a) : a;
  };
}), Hr = /* @__PURE__ */ u("$ZodObjectJIT", (e, t) => {
  Kr.init(e, t);
  const n = e._zod.parse, r = ue(() => at(t)), o = (h) => {
    const m = new vr(["shape", "payload", "ctx"]), $ = r.value, b = (P) => {
      const x = ve(P);
      return `shape[${x}]._zod.run({ value: input[${x}], issues: [] }, ctx)`;
    };
    m.write("const input = payload.value;");
    const W = /* @__PURE__ */ Object.create(null);
    let jt = 0;
    for (const P of $.keys)
      W[P] = `key_${jt++}`;
    m.write("const newResult = {};");
    for (const P of $.keys) {
      const x = W[P], O = ve(P), Zt = h[P]?._zod?.optout === "optional";
      m.write(`const ${x} = ${b(P)};`), Zt ? m.write(`
        if (${x}.issues.length) {
          if (${O} in input) {
            payload.issues = payload.issues.concat(${x}.issues.map(iss => ({
              ...iss,
              path: iss.path ? [${O}, ...iss.path] : [${O}]
            })));
          }
        }
        
        if (${x}.value === undefined) {
          if (${O} in input) {
            newResult[${O}] = undefined;
          }
        } else {
          newResult[${O}] = ${x}.value;
        }
        
      `) : m.write(`
        if (${x}.issues.length) {
          payload.issues = payload.issues.concat(${x}.issues.map(iss => ({
            ...iss,
            path: iss.path ? [${O}, ...iss.path] : [${O}]
          })));
        }
        
        if (${x}.value === undefined) {
          if (${O} in input) {
            newResult[${O}] = undefined;
          }
        } else {
          newResult[${O}] = ${x}.value;
        }
        
      `);
    }
    m.write("payload.value = newResult;"), m.write("return payload;");
    const xt = m.compile();
    return (P, x) => xt(h, P, x);
  };
  let i;
  const s = Y, a = !He.jitless, d = a && _n.value, f = t.catchall;
  let g;
  e._zod.parse = (h, m) => {
    g ?? (g = r.value);
    const $ = h.value;
    return s($) ? a && d && m?.async === !1 && m.jitless !== !0 ? (i || (i = o(t.shape)), h = i(h, m), f ? ct([], $, h, m, g, e) : h) : n(h, m) : (h.issues.push({
      expected: "object",
      code: "invalid_type",
      input: $,
      inst: e
    }), h);
  };
});
function ze(e, t, n, r) {
  for (const i of e)
    if (i.issues.length === 0)
      return t.value = i.value, t;
  const o = e.filter((i) => !U(i));
  return o.length === 1 ? (t.value = o[0].value, o[0]) : (t.issues.push({
    code: "invalid_union",
    input: t.value,
    inst: n,
    errors: e.map((i) => i.issues.map((s) => D(s, r, R())))
  }), t);
}
const Gr = /* @__PURE__ */ u("$ZodUnion", (e, t) => {
  w.init(e, t), _(e._zod, "optin", () => t.options.some((o) => o._zod.optin === "optional") ? "optional" : void 0), _(e._zod, "optout", () => t.options.some((o) => o._zod.optout === "optional") ? "optional" : void 0), _(e._zod, "values", () => {
    if (t.options.every((o) => o._zod.values))
      return new Set(t.options.flatMap((o) => Array.from(o._zod.values)));
  }), _(e._zod, "pattern", () => {
    if (t.options.every((o) => o._zod.pattern)) {
      const o = t.options.map((i) => i._zod.pattern);
      return new RegExp(`^(${o.map((i) => de(i.source)).join("|")})$`);
    }
  });
  const n = t.options.length === 1, r = t.options[0]._zod.run;
  e._zod.parse = (o, i) => {
    if (n)
      return r(o, i);
    let s = !1;
    const a = [];
    for (const l of t.options) {
      const d = l._zod.run({
        value: o.value,
        issues: []
      }, i);
      if (d instanceof Promise)
        a.push(d), s = !0;
      else {
        if (d.issues.length === 0)
          return d;
        a.push(d);
      }
    }
    return s ? Promise.all(a).then((l) => ze(l, o, e, i)) : ze(a, o, e, i);
  };
}), Yr = /* @__PURE__ */ u("$ZodIntersection", (e, t) => {
  w.init(e, t), e._zod.parse = (n, r) => {
    const o = n.value, i = t.left._zod.run({ value: o, issues: [] }, r), s = t.right._zod.run({ value: o, issues: [] }, r);
    return i instanceof Promise || s instanceof Promise ? Promise.all([i, s]).then(([l, d]) => be(n, l, d)) : be(n, i, s);
  };
});
function ae(e, t) {
  if (e === t)
    return { valid: !0, data: e };
  if (e instanceof Date && t instanceof Date && +e == +t)
    return { valid: !0, data: e };
  if (M(e) && M(t)) {
    const n = Object.keys(t), r = Object.keys(e).filter((i) => n.indexOf(i) !== -1), o = { ...e, ...t };
    for (const i of r) {
      const s = ae(e[i], t[i]);
      if (!s.valid)
        return {
          valid: !1,
          mergeErrorPath: [i, ...s.mergeErrorPath]
        };
      o[i] = s.data;
    }
    return { valid: !0, data: o };
  }
  if (Array.isArray(e) && Array.isArray(t)) {
    if (e.length !== t.length)
      return { valid: !1, mergeErrorPath: [] };
    const n = [];
    for (let r = 0; r < e.length; r++) {
      const o = e[r], i = t[r], s = ae(o, i);
      if (!s.valid)
        return {
          valid: !1,
          mergeErrorPath: [r, ...s.mergeErrorPath]
        };
      n.push(s.data);
    }
    return { valid: !0, data: n };
  }
  return { valid: !1, mergeErrorPath: [] };
}
function be(e, t, n) {
  const r = /* @__PURE__ */ new Map();
  let o;
  for (const a of t.issues)
    if (a.code === "unrecognized_keys") {
      o ?? (o = a);
      for (const l of a.keys)
        r.has(l) || r.set(l, {}), r.get(l).l = !0;
    } else
      e.issues.push(a);
  for (const a of n.issues)
    if (a.code === "unrecognized_keys")
      for (const l of a.keys)
        r.has(l) || r.set(l, {}), r.get(l).r = !0;
    else
      e.issues.push(a);
  const i = [...r].filter(([, a]) => a.l && a.r).map(([a]) => a);
  if (i.length && o && e.issues.push({ ...o, keys: i }), U(e))
    return e;
  const s = ae(t.value, n.value);
  if (!s.valid)
    throw new Error(`Unmergable intersection. Error path: ${JSON.stringify(s.mergeErrorPath)}`);
  return e.value = s.data, e;
}
const Qr = /* @__PURE__ */ u("$ZodEnum", (e, t) => {
  w.init(e, t);
  const n = Ge(t.entries), r = new Set(n);
  e._zod.values = r, e._zod.pattern = new RegExp(`^(${n.filter((o) => vn.has(typeof o)).map((o) => typeof o == "string" ? ne(o) : o.toString()).join("|")})$`), e._zod.parse = (o, i) => {
    const s = o.value;
    return r.has(s) || o.issues.push({
      code: "invalid_value",
      values: n,
      input: s,
      inst: e
    }), o;
  };
}), Xr = /* @__PURE__ */ u("$ZodTransform", (e, t) => {
  w.init(e, t), e._zod.parse = (n, r) => {
    if (r.direction === "backward")
      throw new Ke(e.constructor.name);
    const o = t.transform(n.value, n);
    if (r.async)
      return (o instanceof Promise ? o : Promise.resolve(o)).then((s) => (n.value = s, n));
    if (o instanceof Promise)
      throw new F();
    return n.value = o, n;
  };
});
function ke(e, t) {
  return e.issues.length && t === void 0 ? { issues: [], value: void 0 } : e;
}
const ut = /* @__PURE__ */ u("$ZodOptional", (e, t) => {
  w.init(e, t), e._zod.optin = "optional", e._zod.optout = "optional", _(e._zod, "values", () => t.innerType._zod.values ? /* @__PURE__ */ new Set([...t.innerType._zod.values, void 0]) : void 0), _(e._zod, "pattern", () => {
    const n = t.innerType._zod.pattern;
    return n ? new RegExp(`^(${de(n.source)})?$`) : void 0;
  }), e._zod.parse = (n, r) => {
    if (t.innerType._zod.optin === "optional") {
      const o = t.innerType._zod.run(n, r);
      return o instanceof Promise ? o.then((i) => ke(i, n.value)) : ke(o, n.value);
    }
    return n.value === void 0 ? n : t.innerType._zod.run(n, r);
  };
}), eo = /* @__PURE__ */ u("$ZodExactOptional", (e, t) => {
  ut.init(e, t), _(e._zod, "values", () => t.innerType._zod.values), _(e._zod, "pattern", () => t.innerType._zod.pattern), e._zod.parse = (n, r) => t.innerType._zod.run(n, r);
}), to = /* @__PURE__ */ u("$ZodNullable", (e, t) => {
  w.init(e, t), _(e._zod, "optin", () => t.innerType._zod.optin), _(e._zod, "optout", () => t.innerType._zod.optout), _(e._zod, "pattern", () => {
    const n = t.innerType._zod.pattern;
    return n ? new RegExp(`^(${de(n.source)}|null)$`) : void 0;
  }), _(e._zod, "values", () => t.innerType._zod.values ? /* @__PURE__ */ new Set([...t.innerType._zod.values, null]) : void 0), e._zod.parse = (n, r) => n.value === null ? n : t.innerType._zod.run(n, r);
}), no = /* @__PURE__ */ u("$ZodDefault", (e, t) => {
  w.init(e, t), e._zod.optin = "optional", _(e._zod, "values", () => t.innerType._zod.values), e._zod.parse = (n, r) => {
    if (r.direction === "backward")
      return t.innerType._zod.run(n, r);
    if (n.value === void 0)
      return n.value = t.defaultValue, n;
    const o = t.innerType._zod.run(n, r);
    return o instanceof Promise ? o.then((i) => $e(i, t)) : $e(o, t);
  };
});
function $e(e, t) {
  return e.value === void 0 && (e.value = t.defaultValue), e;
}
const ro = /* @__PURE__ */ u("$ZodPrefault", (e, t) => {
  w.init(e, t), e._zod.optin = "optional", _(e._zod, "values", () => t.innerType._zod.values), e._zod.parse = (n, r) => (r.direction === "backward" || n.value === void 0 && (n.value = t.defaultValue), t.innerType._zod.run(n, r));
}), oo = /* @__PURE__ */ u("$ZodNonOptional", (e, t) => {
  w.init(e, t), _(e._zod, "values", () => {
    const n = t.innerType._zod.values;
    return n ? new Set([...n].filter((r) => r !== void 0)) : void 0;
  }), e._zod.parse = (n, r) => {
    const o = t.innerType._zod.run(n, r);
    return o instanceof Promise ? o.then((i) => je(i, e)) : je(o, e);
  };
});
function je(e, t) {
  return !e.issues.length && e.value === void 0 && e.issues.push({
    code: "invalid_type",
    expected: "nonoptional",
    input: e.value,
    inst: t
  }), e;
}
const so = /* @__PURE__ */ u("$ZodCatch", (e, t) => {
  w.init(e, t), _(e._zod, "optin", () => t.innerType._zod.optin), _(e._zod, "optout", () => t.innerType._zod.optout), _(e._zod, "values", () => t.innerType._zod.values), e._zod.parse = (n, r) => {
    if (r.direction === "backward")
      return t.innerType._zod.run(n, r);
    const o = t.innerType._zod.run(n, r);
    return o instanceof Promise ? o.then((i) => (n.value = i.value, i.issues.length && (n.value = t.catchValue({
      ...n,
      error: {
        issues: i.issues.map((s) => D(s, r, R()))
      },
      input: n.value
    }), n.issues = []), n)) : (n.value = o.value, o.issues.length && (n.value = t.catchValue({
      ...n,
      error: {
        issues: o.issues.map((i) => D(i, r, R()))
      },
      input: n.value
    }), n.issues = []), n);
  };
}), io = /* @__PURE__ */ u("$ZodPipe", (e, t) => {
  w.init(e, t), _(e._zod, "values", () => t.in._zod.values), _(e._zod, "optin", () => t.in._zod.optin), _(e._zod, "optout", () => t.out._zod.optout), _(e._zod, "propValues", () => t.in._zod.propValues), e._zod.parse = (n, r) => {
    if (r.direction === "backward") {
      const i = t.out._zod.run(n, r);
      return i instanceof Promise ? i.then((s) => H(s, t.in, r)) : H(i, t.in, r);
    }
    const o = t.in._zod.run(n, r);
    return o instanceof Promise ? o.then((i) => H(i, t.out, r)) : H(o, t.out, r);
  };
});
function H(e, t, n) {
  return e.issues.length ? (e.aborted = !0, e) : t._zod.run({ value: e.value, issues: e.issues }, n);
}
const ao = /* @__PURE__ */ u("$ZodReadonly", (e, t) => {
  w.init(e, t), _(e._zod, "propValues", () => t.innerType._zod.propValues), _(e._zod, "values", () => t.innerType._zod.values), _(e._zod, "optin", () => t.innerType?._zod?.optin), _(e._zod, "optout", () => t.innerType?._zod?.optout), e._zod.parse = (n, r) => {
    if (r.direction === "backward")
      return t.innerType._zod.run(n, r);
    const o = t.innerType._zod.run(n, r);
    return o instanceof Promise ? o.then(xe) : xe(o);
  };
});
function xe(e) {
  return e.value = Object.freeze(e.value), e;
}
const co = /* @__PURE__ */ u("$ZodCustom", (e, t) => {
  E.init(e, t), w.init(e, t), e._zod.parse = (n, r) => n, e._zod.check = (n) => {
    const r = n.value, o = t.fn(r);
    if (o instanceof Promise)
      return o.then((i) => Ze(i, n, r, e));
    Ze(o, n, r, e);
  };
});
function Ze(e, t, n, r) {
  if (!e) {
    const o = {
      code: "custom",
      input: n,
      inst: r,
      // incorporates params.error into issue reporting
      path: [...r._zod.def.path ?? []],
      // incorporates params.error into issue reporting
      continue: !r._zod.def.abort
      // params: inst._zod.def.params,
    };
    r._zod.def.params && (o.params = r._zod.def.params), t.issues.push(B(o));
  }
}
var Oe;
class uo {
  constructor() {
    this._map = /* @__PURE__ */ new WeakMap(), this._idmap = /* @__PURE__ */ new Map();
  }
  add(t, ...n) {
    const r = n[0];
    return this._map.set(t, r), r && typeof r == "object" && "id" in r && this._idmap.set(r.id, t), this;
  }
  clear() {
    return this._map = /* @__PURE__ */ new WeakMap(), this._idmap = /* @__PURE__ */ new Map(), this;
  }
  remove(t) {
    const n = this._map.get(t);
    return n && typeof n == "object" && "id" in n && this._idmap.delete(n.id), this._map.delete(t), this;
  }
  get(t) {
    const n = t._zod.parent;
    if (n) {
      const r = { ...this.get(n) ?? {} };
      delete r.id;
      const o = { ...r, ...this._map.get(t) };
      return Object.keys(o).length ? o : void 0;
    }
    return this._map.get(t);
  }
  has(t) {
    return this._map.has(t);
  }
}
function lo() {
  return new uo();
}
(Oe = globalThis).__zod_globalRegistry ?? (Oe.__zod_globalRegistry = lo());
const L = globalThis.__zod_globalRegistry;
// @__NO_SIDE_EFFECTS__
function fo(e, t) {
  return new e({
    type: "string",
    ...p(t)
  });
}
// @__NO_SIDE_EFFECTS__
function po(e, t) {
  return new e({
    type: "string",
    format: "email",
    check: "string_format",
    abort: !1,
    ...p(t)
  });
}
// @__NO_SIDE_EFFECTS__
function Se(e, t) {
  return new e({
    type: "string",
    format: "guid",
    check: "string_format",
    abort: !1,
    ...p(t)
  });
}
// @__NO_SIDE_EFFECTS__
function ho(e, t) {
  return new e({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: !1,
    ...p(t)
  });
}
// @__NO_SIDE_EFFECTS__
function mo(e, t) {
  return new e({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: !1,
    version: "v4",
    ...p(t)
  });
}
// @__NO_SIDE_EFFECTS__
function go(e, t) {
  return new e({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: !1,
    version: "v6",
    ...p(t)
  });
}
// @__NO_SIDE_EFFECTS__
function _o(e, t) {
  return new e({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: !1,
    version: "v7",
    ...p(t)
  });
}
// @__NO_SIDE_EFFECTS__
function vo(e, t) {
  return new e({
    type: "string",
    format: "url",
    check: "string_format",
    abort: !1,
    ...p(t)
  });
}
// @__NO_SIDE_EFFECTS__
function yo(e, t) {
  return new e({
    type: "string",
    format: "emoji",
    check: "string_format",
    abort: !1,
    ...p(t)
  });
}
// @__NO_SIDE_EFFECTS__
function wo(e, t) {
  return new e({
    type: "string",
    format: "nanoid",
    check: "string_format",
    abort: !1,
    ...p(t)
  });
}
// @__NO_SIDE_EFFECTS__
function zo(e, t) {
  return new e({
    type: "string",
    format: "cuid",
    check: "string_format",
    abort: !1,
    ...p(t)
  });
}
// @__NO_SIDE_EFFECTS__
function bo(e, t) {
  return new e({
    type: "string",
    format: "cuid2",
    check: "string_format",
    abort: !1,
    ...p(t)
  });
}
// @__NO_SIDE_EFFECTS__
function ko(e, t) {
  return new e({
    type: "string",
    format: "ulid",
    check: "string_format",
    abort: !1,
    ...p(t)
  });
}
// @__NO_SIDE_EFFECTS__
function $o(e, t) {
  return new e({
    type: "string",
    format: "xid",
    check: "string_format",
    abort: !1,
    ...p(t)
  });
}
// @__NO_SIDE_EFFECTS__
function jo(e, t) {
  return new e({
    type: "string",
    format: "ksuid",
    check: "string_format",
    abort: !1,
    ...p(t)
  });
}
// @__NO_SIDE_EFFECTS__
function xo(e, t) {
  return new e({
    type: "string",
    format: "ipv4",
    check: "string_format",
    abort: !1,
    ...p(t)
  });
}
// @__NO_SIDE_EFFECTS__
function Zo(e, t) {
  return new e({
    type: "string",
    format: "ipv6",
    check: "string_format",
    abort: !1,
    ...p(t)
  });
}
// @__NO_SIDE_EFFECTS__
function Oo(e, t) {
  return new e({
    type: "string",
    format: "cidrv4",
    check: "string_format",
    abort: !1,
    ...p(t)
  });
}
// @__NO_SIDE_EFFECTS__
function So(e, t) {
  return new e({
    type: "string",
    format: "cidrv6",
    check: "string_format",
    abort: !1,
    ...p(t)
  });
}
// @__NO_SIDE_EFFECTS__
function Po(e, t) {
  return new e({
    type: "string",
    format: "base64",
    check: "string_format",
    abort: !1,
    ...p(t)
  });
}
// @__NO_SIDE_EFFECTS__
function To(e, t) {
  return new e({
    type: "string",
    format: "base64url",
    check: "string_format",
    abort: !1,
    ...p(t)
  });
}
// @__NO_SIDE_EFFECTS__
function Eo(e, t) {
  return new e({
    type: "string",
    format: "e164",
    check: "string_format",
    abort: !1,
    ...p(t)
  });
}
// @__NO_SIDE_EFFECTS__
function No(e, t) {
  return new e({
    type: "string",
    format: "jwt",
    check: "string_format",
    abort: !1,
    ...p(t)
  });
}
// @__NO_SIDE_EFFECTS__
function Io(e, t) {
  return new e({
    type: "string",
    format: "datetime",
    check: "string_format",
    offset: !1,
    local: !1,
    precision: null,
    ...p(t)
  });
}
// @__NO_SIDE_EFFECTS__
function Ao(e, t) {
  return new e({
    type: "string",
    format: "date",
    check: "string_format",
    ...p(t)
  });
}
// @__NO_SIDE_EFFECTS__
function Ro(e, t) {
  return new e({
    type: "string",
    format: "time",
    check: "string_format",
    precision: null,
    ...p(t)
  });
}
// @__NO_SIDE_EFFECTS__
function Do(e, t) {
  return new e({
    type: "string",
    format: "duration",
    check: "string_format",
    ...p(t)
  });
}
// @__NO_SIDE_EFFECTS__
function Co(e) {
  return new e({
    type: "unknown"
  });
}
// @__NO_SIDE_EFFECTS__
function Uo(e, t) {
  return new e({
    type: "never",
    ...p(t)
  });
}
// @__NO_SIDE_EFFECTS__
function lt(e, t) {
  return new cr({
    check: "max_length",
    ...p(t),
    maximum: e
  });
}
// @__NO_SIDE_EFFECTS__
function X(e, t) {
  return new ur({
    check: "min_length",
    ...p(t),
    minimum: e
  });
}
// @__NO_SIDE_EFFECTS__
function dt(e, t) {
  return new lr({
    check: "length_equals",
    ...p(t),
    length: e
  });
}
// @__NO_SIDE_EFFECTS__
function Fo(e, t) {
  return new dr({
    check: "string_format",
    format: "regex",
    ...p(t),
    pattern: e
  });
}
// @__NO_SIDE_EFFECTS__
function Jo(e) {
  return new fr({
    check: "string_format",
    format: "lowercase",
    ...p(e)
  });
}
// @__NO_SIDE_EFFECTS__
function Lo(e) {
  return new pr({
    check: "string_format",
    format: "uppercase",
    ...p(e)
  });
}
// @__NO_SIDE_EFFECTS__
function Mo(e, t) {
  return new hr({
    check: "string_format",
    format: "includes",
    ...p(t),
    includes: e
  });
}
// @__NO_SIDE_EFFECTS__
function Bo(e, t) {
  return new mr({
    check: "string_format",
    format: "starts_with",
    ...p(t),
    prefix: e
  });
}
// @__NO_SIDE_EFFECTS__
function Vo(e, t) {
  return new gr({
    check: "string_format",
    format: "ends_with",
    ...p(t),
    suffix: e
  });
}
// @__NO_SIDE_EFFECTS__
function J(e) {
  return new _r({
    check: "overwrite",
    tx: e
  });
}
// @__NO_SIDE_EFFECTS__
function qo(e) {
  return /* @__PURE__ */ J((t) => t.normalize(e));
}
// @__NO_SIDE_EFFECTS__
function Wo() {
  return /* @__PURE__ */ J((e) => e.trim());
}
// @__NO_SIDE_EFFECTS__
function Ko() {
  return /* @__PURE__ */ J((e) => e.toLowerCase());
}
// @__NO_SIDE_EFFECTS__
function Ho() {
  return /* @__PURE__ */ J((e) => e.toUpperCase());
}
// @__NO_SIDE_EFFECTS__
function Go() {
  return /* @__PURE__ */ J((e) => gn(e));
}
// @__NO_SIDE_EFFECTS__
function Yo(e, t, n) {
  return new e({
    type: "array",
    element: t,
    // get element() {
    //   return element;
    // },
    ...p(n)
  });
}
// @__NO_SIDE_EFFECTS__
function Qo(e, t, n) {
  return new e({
    type: "custom",
    check: "custom",
    fn: t,
    ...p(n)
  });
}
// @__NO_SIDE_EFFECTS__
function Xo(e) {
  const t = /* @__PURE__ */ es((n) => (n.addIssue = (r) => {
    if (typeof r == "string")
      n.issues.push(B(r, n.value, t._zod.def));
    else {
      const o = r;
      o.fatal && (o.continue = !1), o.code ?? (o.code = "custom"), o.input ?? (o.input = n.value), o.inst ?? (o.inst = t), o.continue ?? (o.continue = !t._zod.def.abort), n.issues.push(B(o));
    }
  }, e(n.value, n)));
  return t;
}
// @__NO_SIDE_EFFECTS__
function es(e, t) {
  const n = new E({
    check: "custom",
    ...p(t)
  });
  return n._zod.check = e, n;
}
function ft(e) {
  let t = e?.target ?? "draft-2020-12";
  return t === "draft-4" && (t = "draft-04"), t === "draft-7" && (t = "draft-07"), {
    processors: e.processors ?? {},
    metadataRegistry: e?.metadata ?? L,
    target: t,
    unrepresentable: e?.unrepresentable ?? "throw",
    override: e?.override ?? (() => {
    }),
    io: e?.io ?? "output",
    counter: 0,
    seen: /* @__PURE__ */ new Map(),
    cycles: e?.cycles ?? "ref",
    reused: e?.reused ?? "inline",
    external: e?.external ?? void 0
  };
}
function k(e, t, n = { path: [], schemaPath: [] }) {
  var r;
  const o = e._zod.def, i = t.seen.get(e);
  if (i)
    return i.count++, n.schemaPath.includes(e) && (i.cycle = n.path), i.schema;
  const s = { schema: {}, count: 1, cycle: void 0, path: n.path };
  t.seen.set(e, s);
  const a = e._zod.toJSONSchema?.();
  if (a)
    s.schema = a;
  else {
    const f = {
      ...n,
      schemaPath: [...n.schemaPath, e],
      path: n.path
    };
    if (e._zod.processJSONSchema)
      e._zod.processJSONSchema(t, s.schema, f);
    else {
      const h = s.schema, m = t.processors[o.type];
      if (!m)
        throw new Error(`[toJSONSchema]: Non-representable type encountered: ${o.type}`);
      m(e, t, h, f);
    }
    const g = e._zod.parent;
    g && (s.ref || (s.ref = g), k(g, t, f), t.seen.get(g).isParent = !0);
  }
  const l = t.metadataRegistry.get(e);
  return l && Object.assign(s.schema, l), t.io === "input" && j(e) && (delete s.schema.examples, delete s.schema.default), t.io === "input" && s.schema._prefault && ((r = s.schema).default ?? (r.default = s.schema._prefault)), delete s.schema._prefault, t.seen.get(e).schema;
}
function pt(e, t) {
  const n = e.seen.get(t);
  if (!n)
    throw new Error("Unprocessed schema. This is a bug in Zod.");
  const r = /* @__PURE__ */ new Map();
  for (const s of e.seen.entries()) {
    const a = e.metadataRegistry.get(s[0])?.id;
    if (a) {
      const l = r.get(a);
      if (l && l !== s[0])
        throw new Error(`Duplicate schema id "${a}" detected during JSON Schema conversion. Two different schemas cannot share the same id when converted together.`);
      r.set(a, s[0]);
    }
  }
  const o = (s) => {
    const a = e.target === "draft-2020-12" ? "$defs" : "definitions";
    if (e.external) {
      const g = e.external.registry.get(s[0])?.id, h = e.external.uri ?? (($) => $);
      if (g)
        return { ref: h(g) };
      const m = s[1].defId ?? s[1].schema.id ?? `schema${e.counter++}`;
      return s[1].defId = m, { defId: m, ref: `${h("__shared")}#/${a}/${m}` };
    }
    if (s[1] === n)
      return { ref: "#" };
    const d = `#/${a}/`, f = s[1].schema.id ?? `__schema${e.counter++}`;
    return { defId: f, ref: d + f };
  }, i = (s) => {
    if (s[1].schema.$ref)
      return;
    const a = s[1], { ref: l, defId: d } = o(s);
    a.def = { ...a.schema }, d && (a.defId = d);
    const f = a.schema;
    for (const g in f)
      delete f[g];
    f.$ref = l;
  };
  if (e.cycles === "throw")
    for (const s of e.seen.entries()) {
      const a = s[1];
      if (a.cycle)
        throw new Error(`Cycle detected: #/${a.cycle?.join("/")}/<root>

Set the \`cycles\` parameter to \`"ref"\` to resolve cyclical schemas with defs.`);
    }
  for (const s of e.seen.entries()) {
    const a = s[1];
    if (t === s[0]) {
      i(s);
      continue;
    }
    if (e.external) {
      const d = e.external.registry.get(s[0])?.id;
      if (t !== s[0] && d) {
        i(s);
        continue;
      }
    }
    if (e.metadataRegistry.get(s[0])?.id) {
      i(s);
      continue;
    }
    if (a.cycle) {
      i(s);
      continue;
    }
    if (a.count > 1 && e.reused === "ref") {
      i(s);
      continue;
    }
  }
}
function ht(e, t) {
  const n = e.seen.get(t);
  if (!n)
    throw new Error("Unprocessed schema. This is a bug in Zod.");
  const r = (s) => {
    const a = e.seen.get(s);
    if (a.ref === null)
      return;
    const l = a.def ?? a.schema, d = { ...l }, f = a.ref;
    if (a.ref = null, f) {
      r(f);
      const h = e.seen.get(f), m = h.schema;
      if (m.$ref && (e.target === "draft-07" || e.target === "draft-04" || e.target === "openapi-3.0") ? (l.allOf = l.allOf ?? [], l.allOf.push(m)) : Object.assign(l, m), Object.assign(l, d), s._zod.parent === f)
        for (const b in l)
          b === "$ref" || b === "allOf" || b in d || delete l[b];
      if (m.$ref && h.def)
        for (const b in l)
          b === "$ref" || b === "allOf" || b in h.def && JSON.stringify(l[b]) === JSON.stringify(h.def[b]) && delete l[b];
    }
    const g = s._zod.parent;
    if (g && g !== f) {
      r(g);
      const h = e.seen.get(g);
      if (h?.schema.$ref && (l.$ref = h.schema.$ref, h.def))
        for (const m in l)
          m === "$ref" || m === "allOf" || m in h.def && JSON.stringify(l[m]) === JSON.stringify(h.def[m]) && delete l[m];
    }
    e.override({
      zodSchema: s,
      jsonSchema: l,
      path: a.path ?? []
    });
  };
  for (const s of [...e.seen.entries()].reverse())
    r(s[0]);
  const o = {};
  if (e.target === "draft-2020-12" ? o.$schema = "https://json-schema.org/draft/2020-12/schema" : e.target === "draft-07" ? o.$schema = "http://json-schema.org/draft-07/schema#" : e.target === "draft-04" ? o.$schema = "http://json-schema.org/draft-04/schema#" : e.target, e.external?.uri) {
    const s = e.external.registry.get(t)?.id;
    if (!s)
      throw new Error("Schema is missing an `id` property");
    o.$id = e.external.uri(s);
  }
  Object.assign(o, n.def ?? n.schema);
  const i = e.external?.defs ?? {};
  for (const s of e.seen.entries()) {
    const a = s[1];
    a.def && a.defId && (i[a.defId] = a.def);
  }
  e.external || Object.keys(i).length > 0 && (e.target === "draft-2020-12" ? o.$defs = i : o.definitions = i);
  try {
    const s = JSON.parse(JSON.stringify(o));
    return Object.defineProperty(s, "~standard", {
      value: {
        ...t["~standard"],
        jsonSchema: {
          input: ee(t, "input", e.processors),
          output: ee(t, "output", e.processors)
        }
      },
      enumerable: !1,
      writable: !1
    }), s;
  } catch {
    throw new Error("Error converting schema to JSON.");
  }
}
function j(e, t) {
  const n = t ?? { seen: /* @__PURE__ */ new Set() };
  if (n.seen.has(e))
    return !1;
  n.seen.add(e);
  const r = e._zod.def;
  if (r.type === "transform")
    return !0;
  if (r.type === "array")
    return j(r.element, n);
  if (r.type === "set")
    return j(r.valueType, n);
  if (r.type === "lazy")
    return j(r.getter(), n);
  if (r.type === "promise" || r.type === "optional" || r.type === "nonoptional" || r.type === "nullable" || r.type === "readonly" || r.type === "default" || r.type === "prefault")
    return j(r.innerType, n);
  if (r.type === "intersection")
    return j(r.left, n) || j(r.right, n);
  if (r.type === "record" || r.type === "map")
    return j(r.keyType, n) || j(r.valueType, n);
  if (r.type === "pipe")
    return j(r.in, n) || j(r.out, n);
  if (r.type === "object") {
    for (const o in r.shape)
      if (j(r.shape[o], n))
        return !0;
    return !1;
  }
  if (r.type === "union") {
    for (const o of r.options)
      if (j(o, n))
        return !0;
    return !1;
  }
  if (r.type === "tuple") {
    for (const o of r.items)
      if (j(o, n))
        return !0;
    return !!(r.rest && j(r.rest, n));
  }
  return !1;
}
const ts = (e, t = {}) => (n) => {
  const r = ft({ ...n, processors: t });
  return k(e, r), pt(r, e), ht(r, e);
}, ee = (e, t, n = {}) => (r) => {
  const { libraryOptions: o, target: i } = r ?? {}, s = ft({ ...o ?? {}, target: i, io: t, processors: n });
  return k(e, s), pt(s, e), ht(s, e);
}, ns = {
  guid: "uuid",
  url: "uri",
  datetime: "date-time",
  json_string: "json-string",
  regex: ""
  // do not set
}, rs = (e, t, n, r) => {
  const o = n;
  o.type = "string";
  const { minimum: i, maximum: s, format: a, patterns: l, contentEncoding: d } = e._zod.bag;
  if (typeof i == "number" && (o.minLength = i), typeof s == "number" && (o.maxLength = s), a && (o.format = ns[a] ?? a, o.format === "" && delete o.format, a === "time" && delete o.format), d && (o.contentEncoding = d), l && l.size > 0) {
    const f = [...l];
    f.length === 1 ? o.pattern = f[0].source : f.length > 1 && (o.allOf = [
      ...f.map((g) => ({
        ...t.target === "draft-07" || t.target === "draft-04" || t.target === "openapi-3.0" ? { type: "string" } : {},
        pattern: g.source
      }))
    ]);
  }
}, os = (e, t, n, r) => {
  n.not = {};
}, ss = (e, t, n, r) => {
}, is = (e, t, n, r) => {
  const o = e._zod.def, i = Ge(o.entries);
  i.every((s) => typeof s == "number") && (n.type = "number"), i.every((s) => typeof s == "string") && (n.type = "string"), n.enum = i;
}, as = (e, t, n, r) => {
  if (t.unrepresentable === "throw")
    throw new Error("Custom types cannot be represented in JSON Schema");
}, cs = (e, t, n, r) => {
  if (t.unrepresentable === "throw")
    throw new Error("Transforms cannot be represented in JSON Schema");
}, us = (e, t, n, r) => {
  const o = n, i = e._zod.def, { minimum: s, maximum: a } = e._zod.bag;
  typeof s == "number" && (o.minItems = s), typeof a == "number" && (o.maxItems = a), o.type = "array", o.items = k(i.element, t, { ...r, path: [...r.path, "items"] });
}, ls = (e, t, n, r) => {
  const o = n, i = e._zod.def;
  o.type = "object", o.properties = {};
  const s = i.shape;
  for (const d in s)
    o.properties[d] = k(s[d], t, {
      ...r,
      path: [...r.path, "properties", d]
    });
  const a = new Set(Object.keys(s)), l = new Set([...a].filter((d) => {
    const f = i.shape[d]._zod;
    return t.io === "input" ? f.optin === void 0 : f.optout === void 0;
  }));
  l.size > 0 && (o.required = Array.from(l)), i.catchall?._zod.def.type === "never" ? o.additionalProperties = !1 : i.catchall ? i.catchall && (o.additionalProperties = k(i.catchall, t, {
    ...r,
    path: [...r.path, "additionalProperties"]
  })) : t.io === "output" && (o.additionalProperties = !1);
}, ds = (e, t, n, r) => {
  const o = e._zod.def, i = o.inclusive === !1, s = o.options.map((a, l) => k(a, t, {
    ...r,
    path: [...r.path, i ? "oneOf" : "anyOf", l]
  }));
  i ? n.oneOf = s : n.anyOf = s;
}, fs = (e, t, n, r) => {
  const o = e._zod.def, i = k(o.left, t, {
    ...r,
    path: [...r.path, "allOf", 0]
  }), s = k(o.right, t, {
    ...r,
    path: [...r.path, "allOf", 1]
  }), a = (d) => "allOf" in d && Object.keys(d).length === 1, l = [
    ...a(i) ? i.allOf : [i],
    ...a(s) ? s.allOf : [s]
  ];
  n.allOf = l;
}, ps = (e, t, n, r) => {
  const o = e._zod.def, i = k(o.innerType, t, r), s = t.seen.get(e);
  t.target === "openapi-3.0" ? (s.ref = o.innerType, n.nullable = !0) : n.anyOf = [i, { type: "null" }];
}, hs = (e, t, n, r) => {
  const o = e._zod.def;
  k(o.innerType, t, r);
  const i = t.seen.get(e);
  i.ref = o.innerType;
}, ms = (e, t, n, r) => {
  const o = e._zod.def;
  k(o.innerType, t, r);
  const i = t.seen.get(e);
  i.ref = o.innerType, n.default = JSON.parse(JSON.stringify(o.defaultValue));
}, gs = (e, t, n, r) => {
  const o = e._zod.def;
  k(o.innerType, t, r);
  const i = t.seen.get(e);
  i.ref = o.innerType, t.io === "input" && (n._prefault = JSON.parse(JSON.stringify(o.defaultValue)));
}, _s = (e, t, n, r) => {
  const o = e._zod.def;
  k(o.innerType, t, r);
  const i = t.seen.get(e);
  i.ref = o.innerType;
  let s;
  try {
    s = o.catchValue(void 0);
  } catch {
    throw new Error("Dynamic catch values are not supported in JSON Schema");
  }
  n.default = s;
}, vs = (e, t, n, r) => {
  const o = e._zod.def, i = t.io === "input" ? o.in._zod.def.type === "transform" ? o.out : o.in : o.out;
  k(i, t, r);
  const s = t.seen.get(e);
  s.ref = i;
}, ys = (e, t, n, r) => {
  const o = e._zod.def;
  k(o.innerType, t, r);
  const i = t.seen.get(e);
  i.ref = o.innerType, n.readOnly = !0;
}, mt = (e, t, n, r) => {
  const o = e._zod.def;
  k(o.innerType, t, r);
  const i = t.seen.get(e);
  i.ref = o.innerType;
}, ws = /* @__PURE__ */ u("ZodISODateTime", (e, t) => {
  Tr.init(e, t), y.init(e, t);
});
function zs(e) {
  return /* @__PURE__ */ Io(ws, e);
}
const bs = /* @__PURE__ */ u("ZodISODate", (e, t) => {
  Er.init(e, t), y.init(e, t);
});
function ks(e) {
  return /* @__PURE__ */ Ao(bs, e);
}
const $s = /* @__PURE__ */ u("ZodISOTime", (e, t) => {
  Nr.init(e, t), y.init(e, t);
});
function js(e) {
  return /* @__PURE__ */ Ro($s, e);
}
const xs = /* @__PURE__ */ u("ZodISODuration", (e, t) => {
  Ir.init(e, t), y.init(e, t);
});
function Zs(e) {
  return /* @__PURE__ */ Do(xs, e);
}
const Os = (e, t) => {
  tt.init(e, t), e.name = "ZodError", Object.defineProperties(e, {
    format: {
      value: (n) => On(e, n)
      // enumerable: false,
    },
    flatten: {
      value: (n) => Zn(e, n)
      // enumerable: false,
    },
    addIssue: {
      value: (n) => {
        e.issues.push(n), e.message = JSON.stringify(e.issues, ie, 2);
      }
      // enumerable: false,
    },
    addIssues: {
      value: (n) => {
        e.issues.push(...n), e.message = JSON.stringify(e.issues, ie, 2);
      }
      // enumerable: false,
    },
    isEmpty: {
      get() {
        return e.issues.length === 0;
      }
      // enumerable: false,
    }
  });
}, Z = u("ZodError", Os, {
  Parent: Error
}), Ss = /* @__PURE__ */ pe(Z), Ps = /* @__PURE__ */ he(Z), Ts = /* @__PURE__ */ re(Z), Es = /* @__PURE__ */ oe(Z), Ns = /* @__PURE__ */ Tn(Z), Is = /* @__PURE__ */ En(Z), As = /* @__PURE__ */ Nn(Z), Rs = /* @__PURE__ */ In(Z), Ds = /* @__PURE__ */ An(Z), Cs = /* @__PURE__ */ Rn(Z), Us = /* @__PURE__ */ Dn(Z), Fs = /* @__PURE__ */ Cn(Z), z = /* @__PURE__ */ u("ZodType", (e, t) => (w.init(e, t), Object.assign(e["~standard"], {
  jsonSchema: {
    input: ee(e, "input"),
    output: ee(e, "output")
  }
}), e.toJSONSchema = ts(e, {}), e.def = t, e.type = t.type, Object.defineProperty(e, "_def", { value: t }), e.check = (...n) => e.clone(I(t, {
  checks: [
    ...t.checks ?? [],
    ...n.map((r) => typeof r == "function" ? { _zod: { check: r, def: { check: "custom" }, onattach: [] } } : r)
  ]
}), {
  parent: !0
}), e.with = e.check, e.clone = (n, r) => A(e, n, r), e.brand = () => e, e.register = ((n, r) => (n.add(e, r), e)), e.parse = (n, r) => Ss(e, n, r, { callee: e.parse }), e.safeParse = (n, r) => Ts(e, n, r), e.parseAsync = async (n, r) => Ps(e, n, r, { callee: e.parseAsync }), e.safeParseAsync = async (n, r) => Es(e, n, r), e.spa = e.safeParseAsync, e.encode = (n, r) => Ns(e, n, r), e.decode = (n, r) => Is(e, n, r), e.encodeAsync = async (n, r) => As(e, n, r), e.decodeAsync = async (n, r) => Rs(e, n, r), e.safeEncode = (n, r) => Ds(e, n, r), e.safeDecode = (n, r) => Cs(e, n, r), e.safeEncodeAsync = async (n, r) => Us(e, n, r), e.safeDecodeAsync = async (n, r) => Fs(e, n, r), e.refine = (n, r) => e.check(Ei(n, r)), e.superRefine = (n) => e.check(Ni(n)), e.overwrite = (n) => e.check(/* @__PURE__ */ J(n)), e.optional = () => Ne(e), e.exactOptional = () => yi(e), e.nullable = () => Ie(e), e.nullish = () => Ne(Ie(e)), e.nonoptional = (n) => ji(e, n), e.array = () => ui(e), e.or = (n) => pi([e, n]), e.and = (n) => mi(e, n), e.transform = (n) => Ae(e, _i(n)), e.default = (n) => bi(e, n), e.prefault = (n) => $i(e, n), e.catch = (n) => Zi(e, n), e.pipe = (n) => Ae(e, n), e.readonly = () => Pi(e), e.describe = (n) => {
  const r = e.clone();
  return L.add(r, { description: n }), r;
}, Object.defineProperty(e, "description", {
  get() {
    return L.get(e)?.description;
  },
  configurable: !0
}), e.meta = (...n) => {
  if (n.length === 0)
    return L.get(e);
  const r = e.clone();
  return L.add(r, n[0]), r;
}, e.isOptional = () => e.safeParse(void 0).success, e.isNullable = () => e.safeParse(null).success, e.apply = (n) => n(e), e)), gt = /* @__PURE__ */ u("_ZodString", (e, t) => {
  me.init(e, t), z.init(e, t), e._zod.processJSONSchema = (r, o, i) => rs(e, r, o);
  const n = e._zod.bag;
  e.format = n.format ?? null, e.minLength = n.minimum ?? null, e.maxLength = n.maximum ?? null, e.regex = (...r) => e.check(/* @__PURE__ */ Fo(...r)), e.includes = (...r) => e.check(/* @__PURE__ */ Mo(...r)), e.startsWith = (...r) => e.check(/* @__PURE__ */ Bo(...r)), e.endsWith = (...r) => e.check(/* @__PURE__ */ Vo(...r)), e.min = (...r) => e.check(/* @__PURE__ */ X(...r)), e.max = (...r) => e.check(/* @__PURE__ */ lt(...r)), e.length = (...r) => e.check(/* @__PURE__ */ dt(...r)), e.nonempty = (...r) => e.check(/* @__PURE__ */ X(1, ...r)), e.lowercase = (r) => e.check(/* @__PURE__ */ Jo(r)), e.uppercase = (r) => e.check(/* @__PURE__ */ Lo(r)), e.trim = () => e.check(/* @__PURE__ */ Wo()), e.normalize = (...r) => e.check(/* @__PURE__ */ qo(...r)), e.toLowerCase = () => e.check(/* @__PURE__ */ Ko()), e.toUpperCase = () => e.check(/* @__PURE__ */ Ho()), e.slugify = () => e.check(/* @__PURE__ */ Go());
}), Js = /* @__PURE__ */ u("ZodString", (e, t) => {
  me.init(e, t), gt.init(e, t), e.email = (n) => e.check(/* @__PURE__ */ po(Ls, n)), e.url = (n) => e.check(/* @__PURE__ */ vo(Ms, n)), e.jwt = (n) => e.check(/* @__PURE__ */ No(oi, n)), e.emoji = (n) => e.check(/* @__PURE__ */ yo(Bs, n)), e.guid = (n) => e.check(/* @__PURE__ */ Se(Te, n)), e.uuid = (n) => e.check(/* @__PURE__ */ ho(G, n)), e.uuidv4 = (n) => e.check(/* @__PURE__ */ mo(G, n)), e.uuidv6 = (n) => e.check(/* @__PURE__ */ go(G, n)), e.uuidv7 = (n) => e.check(/* @__PURE__ */ _o(G, n)), e.nanoid = (n) => e.check(/* @__PURE__ */ wo(Vs, n)), e.guid = (n) => e.check(/* @__PURE__ */ Se(Te, n)), e.cuid = (n) => e.check(/* @__PURE__ */ zo(qs, n)), e.cuid2 = (n) => e.check(/* @__PURE__ */ bo(Ws, n)), e.ulid = (n) => e.check(/* @__PURE__ */ ko(Ks, n)), e.base64 = (n) => e.check(/* @__PURE__ */ Po(ti, n)), e.base64url = (n) => e.check(/* @__PURE__ */ To(ni, n)), e.xid = (n) => e.check(/* @__PURE__ */ $o(Hs, n)), e.ksuid = (n) => e.check(/* @__PURE__ */ jo(Gs, n)), e.ipv4 = (n) => e.check(/* @__PURE__ */ xo(Ys, n)), e.ipv6 = (n) => e.check(/* @__PURE__ */ Zo(Qs, n)), e.cidrv4 = (n) => e.check(/* @__PURE__ */ Oo(Xs, n)), e.cidrv6 = (n) => e.check(/* @__PURE__ */ So(ei, n)), e.e164 = (n) => e.check(/* @__PURE__ */ Eo(ri, n)), e.datetime = (n) => e.check(zs(n)), e.date = (n) => e.check(ks(n)), e.time = (n) => e.check(js(n)), e.duration = (n) => e.check(Zs(n));
});
function Pe(e) {
  return /* @__PURE__ */ fo(Js, e);
}
const y = /* @__PURE__ */ u("ZodStringFormat", (e, t) => {
  v.init(e, t), gt.init(e, t);
}), Ls = /* @__PURE__ */ u("ZodEmail", (e, t) => {
  br.init(e, t), y.init(e, t);
}), Te = /* @__PURE__ */ u("ZodGUID", (e, t) => {
  wr.init(e, t), y.init(e, t);
}), G = /* @__PURE__ */ u("ZodUUID", (e, t) => {
  zr.init(e, t), y.init(e, t);
}), Ms = /* @__PURE__ */ u("ZodURL", (e, t) => {
  kr.init(e, t), y.init(e, t);
}), Bs = /* @__PURE__ */ u("ZodEmoji", (e, t) => {
  $r.init(e, t), y.init(e, t);
}), Vs = /* @__PURE__ */ u("ZodNanoID", (e, t) => {
  jr.init(e, t), y.init(e, t);
}), qs = /* @__PURE__ */ u("ZodCUID", (e, t) => {
  xr.init(e, t), y.init(e, t);
}), Ws = /* @__PURE__ */ u("ZodCUID2", (e, t) => {
  Zr.init(e, t), y.init(e, t);
}), Ks = /* @__PURE__ */ u("ZodULID", (e, t) => {
  Or.init(e, t), y.init(e, t);
}), Hs = /* @__PURE__ */ u("ZodXID", (e, t) => {
  Sr.init(e, t), y.init(e, t);
}), Gs = /* @__PURE__ */ u("ZodKSUID", (e, t) => {
  Pr.init(e, t), y.init(e, t);
}), Ys = /* @__PURE__ */ u("ZodIPv4", (e, t) => {
  Ar.init(e, t), y.init(e, t);
}), Qs = /* @__PURE__ */ u("ZodIPv6", (e, t) => {
  Rr.init(e, t), y.init(e, t);
}), Xs = /* @__PURE__ */ u("ZodCIDRv4", (e, t) => {
  Dr.init(e, t), y.init(e, t);
}), ei = /* @__PURE__ */ u("ZodCIDRv6", (e, t) => {
  Cr.init(e, t), y.init(e, t);
}), ti = /* @__PURE__ */ u("ZodBase64", (e, t) => {
  Ur.init(e, t), y.init(e, t);
}), ni = /* @__PURE__ */ u("ZodBase64URL", (e, t) => {
  Jr.init(e, t), y.init(e, t);
}), ri = /* @__PURE__ */ u("ZodE164", (e, t) => {
  Lr.init(e, t), y.init(e, t);
}), oi = /* @__PURE__ */ u("ZodJWT", (e, t) => {
  Br.init(e, t), y.init(e, t);
}), si = /* @__PURE__ */ u("ZodUnknown", (e, t) => {
  Vr.init(e, t), z.init(e, t), e._zod.processJSONSchema = (n, r, o) => ss();
});
function Ee() {
  return /* @__PURE__ */ Co(si);
}
const ii = /* @__PURE__ */ u("ZodNever", (e, t) => {
  qr.init(e, t), z.init(e, t), e._zod.processJSONSchema = (n, r, o) => os(e, n, r);
});
function ai(e) {
  return /* @__PURE__ */ Uo(ii, e);
}
const ci = /* @__PURE__ */ u("ZodArray", (e, t) => {
  Wr.init(e, t), z.init(e, t), e._zod.processJSONSchema = (n, r, o) => us(e, n, r, o), e.element = t.element, e.min = (n, r) => e.check(/* @__PURE__ */ X(n, r)), e.nonempty = (n) => e.check(/* @__PURE__ */ X(1, n)), e.max = (n, r) => e.check(/* @__PURE__ */ lt(n, r)), e.length = (n, r) => e.check(/* @__PURE__ */ dt(n, r)), e.unwrap = () => e.element;
});
function ui(e, t) {
  return /* @__PURE__ */ Yo(ci, e, t);
}
const li = /* @__PURE__ */ u("ZodObject", (e, t) => {
  Hr.init(e, t), z.init(e, t), e._zod.processJSONSchema = (n, r, o) => ls(e, n, r, o), _(e, "shape", () => t.shape), e.keyof = () => _t(Object.keys(e._zod.def.shape)), e.catchall = (n) => e.clone({ ...e._zod.def, catchall: n }), e.passthrough = () => e.clone({ ...e._zod.def, catchall: Ee() }), e.loose = () => e.clone({ ...e._zod.def, catchall: Ee() }), e.strict = () => e.clone({ ...e._zod.def, catchall: ai() }), e.strip = () => e.clone({ ...e._zod.def, catchall: void 0 }), e.extend = (n) => bn(e, n), e.safeExtend = (n) => kn(e, n), e.merge = (n) => $n(e, n), e.pick = (n) => wn(e, n), e.omit = (n) => zn(e, n), e.partial = (...n) => jn(vt, e, n[0]), e.required = (...n) => xn(yt, e, n[0]);
});
function di(e, t) {
  const n = {
    type: "object",
    shape: e ?? {},
    ...p(t)
  };
  return new li(n);
}
const fi = /* @__PURE__ */ u("ZodUnion", (e, t) => {
  Gr.init(e, t), z.init(e, t), e._zod.processJSONSchema = (n, r, o) => ds(e, n, r, o), e.options = t.options;
});
function pi(e, t) {
  return new fi({
    type: "union",
    options: e,
    ...p(t)
  });
}
const hi = /* @__PURE__ */ u("ZodIntersection", (e, t) => {
  Yr.init(e, t), z.init(e, t), e._zod.processJSONSchema = (n, r, o) => fs(e, n, r, o);
});
function mi(e, t) {
  return new hi({
    type: "intersection",
    left: e,
    right: t
  });
}
const ce = /* @__PURE__ */ u("ZodEnum", (e, t) => {
  Qr.init(e, t), z.init(e, t), e._zod.processJSONSchema = (r, o, i) => is(e, r, o), e.enum = t.entries, e.options = Object.values(t.entries);
  const n = new Set(Object.keys(t.entries));
  e.extract = (r, o) => {
    const i = {};
    for (const s of r)
      if (n.has(s))
        i[s] = t.entries[s];
      else
        throw new Error(`Key ${s} not found in enum`);
    return new ce({
      ...t,
      checks: [],
      ...p(o),
      entries: i
    });
  }, e.exclude = (r, o) => {
    const i = { ...t.entries };
    for (const s of r)
      if (n.has(s))
        delete i[s];
      else
        throw new Error(`Key ${s} not found in enum`);
    return new ce({
      ...t,
      checks: [],
      ...p(o),
      entries: i
    });
  };
});
function _t(e, t) {
  const n = Array.isArray(e) ? Object.fromEntries(e.map((r) => [r, r])) : e;
  return new ce({
    type: "enum",
    entries: n,
    ...p(t)
  });
}
const gi = /* @__PURE__ */ u("ZodTransform", (e, t) => {
  Xr.init(e, t), z.init(e, t), e._zod.processJSONSchema = (n, r, o) => cs(e, n), e._zod.parse = (n, r) => {
    if (r.direction === "backward")
      throw new Ke(e.constructor.name);
    n.addIssue = (i) => {
      if (typeof i == "string")
        n.issues.push(B(i, n.value, t));
      else {
        const s = i;
        s.fatal && (s.continue = !1), s.code ?? (s.code = "custom"), s.input ?? (s.input = n.value), s.inst ?? (s.inst = e), n.issues.push(B(s));
      }
    };
    const o = t.transform(n.value, n);
    return o instanceof Promise ? o.then((i) => (n.value = i, n)) : (n.value = o, n);
  };
});
function _i(e) {
  return new gi({
    type: "transform",
    transform: e
  });
}
const vt = /* @__PURE__ */ u("ZodOptional", (e, t) => {
  ut.init(e, t), z.init(e, t), e._zod.processJSONSchema = (n, r, o) => mt(e, n, r, o), e.unwrap = () => e._zod.def.innerType;
});
function Ne(e) {
  return new vt({
    type: "optional",
    innerType: e
  });
}
const vi = /* @__PURE__ */ u("ZodExactOptional", (e, t) => {
  eo.init(e, t), z.init(e, t), e._zod.processJSONSchema = (n, r, o) => mt(e, n, r, o), e.unwrap = () => e._zod.def.innerType;
});
function yi(e) {
  return new vi({
    type: "optional",
    innerType: e
  });
}
const wi = /* @__PURE__ */ u("ZodNullable", (e, t) => {
  to.init(e, t), z.init(e, t), e._zod.processJSONSchema = (n, r, o) => ps(e, n, r, o), e.unwrap = () => e._zod.def.innerType;
});
function Ie(e) {
  return new wi({
    type: "nullable",
    innerType: e
  });
}
const zi = /* @__PURE__ */ u("ZodDefault", (e, t) => {
  no.init(e, t), z.init(e, t), e._zod.processJSONSchema = (n, r, o) => ms(e, n, r, o), e.unwrap = () => e._zod.def.innerType, e.removeDefault = e.unwrap;
});
function bi(e, t) {
  return new zi({
    type: "default",
    innerType: e,
    get defaultValue() {
      return typeof t == "function" ? t() : Qe(t);
    }
  });
}
const ki = /* @__PURE__ */ u("ZodPrefault", (e, t) => {
  ro.init(e, t), z.init(e, t), e._zod.processJSONSchema = (n, r, o) => gs(e, n, r, o), e.unwrap = () => e._zod.def.innerType;
});
function $i(e, t) {
  return new ki({
    type: "prefault",
    innerType: e,
    get defaultValue() {
      return typeof t == "function" ? t() : Qe(t);
    }
  });
}
const yt = /* @__PURE__ */ u("ZodNonOptional", (e, t) => {
  oo.init(e, t), z.init(e, t), e._zod.processJSONSchema = (n, r, o) => hs(e, n, r, o), e.unwrap = () => e._zod.def.innerType;
});
function ji(e, t) {
  return new yt({
    type: "nonoptional",
    innerType: e,
    ...p(t)
  });
}
const xi = /* @__PURE__ */ u("ZodCatch", (e, t) => {
  so.init(e, t), z.init(e, t), e._zod.processJSONSchema = (n, r, o) => _s(e, n, r, o), e.unwrap = () => e._zod.def.innerType, e.removeCatch = e.unwrap;
});
function Zi(e, t) {
  return new xi({
    type: "catch",
    innerType: e,
    catchValue: typeof t == "function" ? t : () => t
  });
}
const Oi = /* @__PURE__ */ u("ZodPipe", (e, t) => {
  io.init(e, t), z.init(e, t), e._zod.processJSONSchema = (n, r, o) => vs(e, n, r, o), e.in = t.in, e.out = t.out;
});
function Ae(e, t) {
  return new Oi({
    type: "pipe",
    in: e,
    out: t
    // ...util.normalizeParams(params),
  });
}
const Si = /* @__PURE__ */ u("ZodReadonly", (e, t) => {
  ao.init(e, t), z.init(e, t), e._zod.processJSONSchema = (n, r, o) => ys(e, n, r, o), e.unwrap = () => e._zod.def.innerType;
});
function Pi(e) {
  return new Si({
    type: "readonly",
    innerType: e
  });
}
const Ti = /* @__PURE__ */ u("ZodCustom", (e, t) => {
  co.init(e, t), z.init(e, t), e._zod.processJSONSchema = (n, r, o) => as(e, n);
});
function Ei(e, t = {}) {
  return /* @__PURE__ */ Qo(Ti, e, t);
}
function Ni(e) {
  return /* @__PURE__ */ Xo(e);
}
const Ii = di({
  buildId: Pe(),
  timestamp: Pe(),
  status: _t(["in-progress", "success", "failed"])
}), Ai = ({
  buildId: e,
  environmentType: t,
  endpoint: n = "/__zuplo/docs"
}) => {
  const r = Pt({
    queryKey: ["zuplo-build-check", e, n],
    refetchInterval: 3e3,
    enabled: e !== void 0 && t === "WORKING_COPY",
    retry: !1,
    queryFn: () => fetch(n, { signal: AbortSignal.timeout(2e3) }).then((i) => {
      if (!i.ok) throw new Error("Failed to fetch build status");
      return i.json();
    }).then((i) => Ii.parse(i))
  });
  if (te(() => {
    r.data?.status === "success" && r.data.buildId && (document.cookie = `zuplo-build=${r.data.buildId}; path=/; max-age=300; secure; SameSite=None`);
  }, [r.data]), r.isError || !r.data || r.data.buildId === e)
    return null;
  const o = r.data.status === "success";
  return /* @__PURE__ */ c.jsxs("div", { className: "fixed flex flex-col gap-3 p-4 rounded-xl w-96 border z-20 bg-background left-0 right-0 top-4 mx-auto shadow-lg", children: [
    o ? /* @__PURE__ */ c.jsxs("div", { className: "flex flex-row items-center gap-2", children: [
      /* @__PURE__ */ c.jsx(Bt, { size: 16 }),
      /* @__PURE__ */ c.jsx("span", { className: "text-sm", children: "New version available" })
    ] }) : /* @__PURE__ */ c.jsxs("div", { className: "flex flex-row items-center gap-2", children: [
      /* @__PURE__ */ c.jsx(Vt, { size: 16, className: "animate-spin" }),
      /* @__PURE__ */ c.jsx("span", { className: "text-sm", children: "Building new version..." })
    ] }),
    /* @__PURE__ */ c.jsx("span", { className: "text-xs", children: o ? "To see the new version, reload the page now." : "A new version of the developer portal will be available soon." }),
    o && /* @__PURE__ */ c.jsx(
      Ht,
      {
        variant: "outline",
        size: "sm",
        className: "w-full",
        onClick: () => {
          window.location.reload();
        },
        children: "Reload"
      }
    )
  ] });
}, Ri = () => {
  const e = Le(), t = Je(e.pathname);
  te(() => {
    const n = t.current !== e.pathname, r = e.hash !== "";
    n && !r && window.scrollTo(0, 0), t.current = e.pathname;
  }, [e.pathname, e.hash]);
}, Di = ({
  icon: e
}) => typeof e == "string" ? /* @__PURE__ */ c.jsx(
  "img",
  {
    src: `https://cdn.simpleicons.org/${e}/000000/ffffff`,
    className: "size-5",
    alt: e
  }
) : e, Ci = (e) => /^https?:/.test(e), Ui = () => {
  const { options: e } = q(), { site: t } = e, n = t?.footer;
  return n ? /* @__PURE__ */ c.jsx("footer", { className: "border-t bg-background", children: /* @__PURE__ */ c.jsxs("div", { className: "mx-auto max-w-screen-2xl px-4 lg:px-8 py-8 pt-20", children: [
    /* @__PURE__ */ c.jsxs(
      "div",
      {
        className: S("flex flex-row gap-8", {
          "justify-center": !n.position || n.position === "center",
          "justify-start": n.position === "start",
          "justify-end": n.position === "end"
        }),
        children: [
          /* @__PURE__ */ c.jsx(N.Target, { name: "footer-before" }),
          n.columns && /* @__PURE__ */ c.jsx(
            "div",
            {
              className: "w-full md:max-w-3xl grid grid-cols-[1fr_1fr] gap-8 md:grid-cols-[repeat(var(--columns),minmax(0,1fr))]",
              style: { "--columns": n.columns.length },
              children: n.columns.map((r) => /* @__PURE__ */ c.jsxs(
                "div",
                {
                  className: S({
                    "justify-self-center": !r.position || r.position === "center",
                    "justify-self-start": r.position === "start",
                    "justify-self-end": r.position === "end"
                  }),
                  children: [
                    /* @__PURE__ */ c.jsx("span", { className: "text-sm font-semibold", children: r.title }),
                    /* @__PURE__ */ c.jsx("ul", { className: "mt-4 space-y-2", children: r.links.map((o) => {
                      const i = "flex flex-row gap-1 items-center text-sm text-muted-foreground hover:text-accent-foreground";
                      return /* @__PURE__ */ c.jsx("li", { children: Ci(o.href) ? /* @__PURE__ */ c.jsxs(
                        "a",
                        {
                          href: o.href,
                          target: "_blank",
                          rel: "noopener noreferrer",
                          className: i,
                          children: [
                            /* @__PURE__ */ c.jsx("span", { children: o.label }),
                            /* @__PURE__ */ c.jsx(qt, { size: 12 })
                          ]
                        }
                      ) : /* @__PURE__ */ c.jsx(Gt, { to: o.href, className: i, children: /* @__PURE__ */ c.jsx("span", { children: o.label }) }) }, o.href + o.label);
                    }) })
                  ]
                },
                r.title
              ))
            }
          ),
          /* @__PURE__ */ c.jsx(N.Target, { name: "footer-after" })
        ]
      }
    ),
    /* @__PURE__ */ c.jsxs(
      "div",
      {
        className: S(
          "flex items-center justify-between",
          n.columns && "border-t mt-8 pt-8"
        ),
        children: [
          n.logo && /* @__PURE__ */ c.jsxs(c.Fragment, { children: [
            /* @__PURE__ */ c.jsx(
              "img",
              {
                src: n.logo.src.light,
                alt: n.logo.alt,
                className: "w-8 dark:hidden",
                style: { width: n.logo.width }
              }
            ),
            /* @__PURE__ */ c.jsx(
              "img",
              {
                src: n.logo.src.dark,
                alt: n.logo.alt,
                className: "w-8 hidden dark:block",
                style: { width: n.logo.width }
              }
            )
          ] }),
          n.copyright && /* @__PURE__ */ c.jsx("p", { className: "text-sm text-muted-foreground", children: n.copyright }),
          /* @__PURE__ */ c.jsx("div", { className: "flex items-center gap-2", children: n.social?.map((r) => /* @__PURE__ */ c.jsxs(
            "a",
            {
              href: r.href,
              target: "_blank",
              rel: "noopener noreferrer",
              className: "w-auto gap-2 flex text-muted-foreground hover:text-accent-foreground",
              children: [
                /* @__PURE__ */ c.jsx(Di, { icon: r.icon }),
                r.label
              ]
            },
            r.href
          )) })
        ]
      }
    )
  ] }) }) : null;
}, wt = ({
  shouldScaleBackground: e = !0,
  ...t
}) => /* @__PURE__ */ c.jsx(
  T.Root,
  {
    shouldScaleBackground: e,
    ...t
  }
);
wt.displayName = "Drawer";
const Fi = T.Trigger, Ji = T.Portal, zt = V.forwardRef(({ className: e, ...t }, n) => /* @__PURE__ */ c.jsx(
  T.Overlay,
  {
    ref: n,
    className: S("fixed inset-0 z-50 bg-black/80", e),
    ...t
  }
));
zt.displayName = T.Overlay.displayName;
const Li = V.forwardRef(
  ({ className: e, children: t, hideBar: n = !0, ...r }, o) => /* @__PURE__ */ c.jsxs(Ji, { children: [
    /* @__PURE__ */ c.jsx(zt, {}),
    /* @__PURE__ */ c.jsxs(
      T.Content,
      {
        ref: o,
        className: S(
          "fixed inset-x-0 bottom-0 z-50 mt-24 flex h-auto flex-col rounded-t-[10px] border bg-background",
          e
        ),
        ...r,
        children: [
          !n && /* @__PURE__ */ c.jsx("div", { className: "mx-auto mt-4 h-2 w-[100px] rounded-full bg-muted" }),
          t
        ]
      }
    )
  ] })
);
Li.displayName = "DrawerContent";
const Mi = V.forwardRef(({ className: e, ...t }, n) => /* @__PURE__ */ c.jsx(
  T.Title,
  {
    ref: n,
    className: S(
      "text-lg font-semibold leading-none tracking-tight",
      e
    ),
    ...t
  }
));
Mi.displayName = T.Title.displayName;
const Bi = V.forwardRef(({ className: e, ...t }, n) => /* @__PURE__ */ c.jsx(
  T.Description,
  {
    ref: n,
    className: S("text-sm text-muted-foreground", e),
    ...t
  }
));
Bi.displayName = T.Description.displayName;
const bt = ({
  children: e,
  className: t
}) => {
  const { options: n } = q(), r = Je(null);
  return te(() => {
    const o = r.current?.querySelector('[aria-current="page"]');
    Yt(o ?? null);
  }, []), /* @__PURE__ */ c.jsxs(
    "div",
    {
      className: "grid sticky top-(--header-height) lg:h-[calc(100vh-var(--header-height))] grid-rows-[1fr_min-content] border-r",
      "data-pagefind-ignore": "all",
      children: [
        /* @__PURE__ */ c.jsx(
          "nav",
          {
            ref: r,
            className: S(
              "hidden max-w-[calc(var(--side-nav-width)+var(--padding-nav-item))] lg:flex scrollbar flex-col overflow-y-auto shrink-0 text-sm pe-3 ps-4 lg:ps-8",
              "-mx-(--padding-nav-item) pb-[8vh] pt-(--padding-content-top) scroll-pt-2 gap-1",
              // Revert the padding/margin on the first child
              "-mt-2.5",
              t
            ),
            style: {
              maskImage: "linear-gradient(180deg, transparent 1%, rgba(0, 0, 0, 1) 20px, rgba(0, 0, 0, 1) 90%, transparent 99%)"
            },
            children: e
          }
        ),
        /* @__PURE__ */ c.jsx("div", { className: "bg-background border-t p-2 mx-5  gap-2 items-center mt-2 drop-shadow-[0_-3px_1px_rgba(0,0,0,0.015)] hidden lg:[&:has(>_:nth-child(1):last-child)]:flex", children: n.site?.showPoweredBy !== !1 && /* @__PURE__ */ c.jsx(Qt, {}) })
      ]
    }
  );
};
bt.displayName = "NavigationWrapper";
const Vi = ({
  onRequestClose: e,
  navigation: t
}) => /* @__PURE__ */ c.jsxs(Xt, { children: [
  /* @__PURE__ */ c.jsxs(bt, { children: [
    /* @__PURE__ */ c.jsx(N.Target, { name: "navigation-before" }),
    t.map((n) => /* @__PURE__ */ c.jsx(
      ge,
      {
        item: n
      },
      n.type + (n.label ?? "") + ("path" in n ? n.path : "") + ("file" in n ? n.file : "") + ("to" in n ? n.to : "")
    )),
    /* @__PURE__ */ c.jsx(N.Target, { name: "navigation-after" })
  ] }),
  /* @__PURE__ */ c.jsx(
    an,
    {
      className: "lg:hidden h-dvh start-0 w-[320px] rounded-none",
      "aria-describedby": void 0,
      children: /* @__PURE__ */ c.jsxs("div", { className: "p-4 overflow-y-auto overscroll-none", children: [
        /* @__PURE__ */ c.jsx(un, { children: /* @__PURE__ */ c.jsx(cn, { children: "Navigation" }) }),
        t.map((n) => /* @__PURE__ */ c.jsx(
          ge,
          {
            item: n,
            onRequestClose: e
          },
          n.label
        ))
      ] })
    }
  )
] }), qi = ({ children: e }) => {
  const [t, n] = Tt(!1), { navigation: r } = on(), o = r.length > 0, i = Rt().state === "loading", { options: s } = q();
  return /* @__PURE__ */ c.jsxs(
    wt,
    {
      direction: s.site?.dir === "rtl" ? "right" : "left",
      open: t,
      onOpenChange: (a) => n(a),
      children: [
        o && /* @__PURE__ */ c.jsx(
          Vi,
          {
            onRequestClose: () => n(!1),
            navigation: r
          }
        ),
        o && /* @__PURE__ */ c.jsx("div", { className: "lg:hidden m-0 p-0 md:-mx-4 md:px-4 py-2 sticky bg-background/80 backdrop-blur-xs z-10 top-0 start-0 end-0 border-b", children: /* @__PURE__ */ c.jsxs(Fi, { className: "flex items-center gap-2 px-4", children: [
          /* @__PURE__ */ c.jsx(Wt, { size: 16, strokeWidth: 1.5 }),
          /* @__PURE__ */ c.jsx("span", { className: "text-sm", children: "Menu" })
        ] }) }),
        /* @__PURE__ */ c.jsxs(
          "main",
          {
            "data-pagefind-body": !0,
            className: S(
              "px-4 lg:pe-8 lg:px-8",
              !o && "col-span-full",
              i && "animate-pulse"
            ),
            children: [
              /* @__PURE__ */ c.jsx(N.Target, { name: "content-before" }),
              e,
              /* @__PURE__ */ c.jsx(N.Target, { name: "content-after" })
            ]
          }
        )
      ]
    }
  );
}, Wi = () => /* @__PURE__ */ c.jsx("main", { className: "col-span-full row-span-full grid place-items-center", children: /* @__PURE__ */ c.jsx(ln, {}) }), Ki = ({ children: e }) => {
  const { authentication: t } = q();
  return en(), Ri(), te(() => {
    t?.onPageLoad?.();
  }, [t]), /* @__PURE__ */ c.jsxs(tn, { children: [
    /* @__PURE__ */ c.jsx(N.Target, { name: "layout-before-head" }),
    /* @__PURE__ */ c.jsx(nn, {}),
    /* @__PURE__ */ c.jsx(N.Target, { name: "layout-after-head" }),
    /* @__PURE__ */ c.jsx(
      "div",
      {
        className: S(
          "grid max-w-screen-2xl w-full lg:mx-auto",
          "[&:has(>:only-child)]:grid-rows-1 grid-rows-[0_min-content_1fr] lg:grid-rows-[min-content_1fr]",
          "grid-cols-1 lg:grid-cols-[var(--side-nav-width)_1fr]"
        ),
        children: /* @__PURE__ */ c.jsx(Et, { fallback: /* @__PURE__ */ c.jsx(Wi, {}), children: /* @__PURE__ */ c.jsx(qi, { children: e ?? /* @__PURE__ */ c.jsx(Dt, {}) }) })
      }
    ),
    /* @__PURE__ */ c.jsx(Ui, {})
  ] });
}, Hi = ({ children: e }) => {
  const { options: t } = q(), { metadata: n } = t, r = Le();
  return /* @__PURE__ */ c.jsxs(c.Fragment, { children: [
    /* @__PURE__ */ c.jsxs(Ce, { titleTemplate: n?.title, defaultTitle: n?.defaultTitle, children: [
      t.canonicalUrlOrigin && /* @__PURE__ */ c.jsx(
        "link",
        {
          rel: "canonical",
          href: sn(
            t.canonicalUrlOrigin,
            t.basePath,
            r.pathname
          )
        }
      ),
      n?.description && /* @__PURE__ */ c.jsx("meta", { name: "description", content: n.description }),
      n?.favicon && /* @__PURE__ */ c.jsx("link", { rel: "icon", href: n.favicon }),
      n?.generator && /* @__PURE__ */ c.jsx("meta", { name: "generator", content: n.generator }),
      n?.applicationName && /* @__PURE__ */ c.jsx("meta", { name: "application-name", content: n.applicationName }),
      n?.referrer && /* @__PURE__ */ c.jsx("meta", { name: "referrer", content: n.referrer }),
      n?.keywords && n.keywords.length > 0 && /* @__PURE__ */ c.jsx("meta", { name: "keywords", content: n.keywords.join(", ") }),
      n?.authors?.map((o) => /* @__PURE__ */ c.jsx("meta", { name: "author", content: o }, o)),
      n?.creator && /* @__PURE__ */ c.jsx("meta", { name: "creator", content: n.creator }),
      n?.publisher && /* @__PURE__ */ c.jsx("meta", { name: "publisher", content: n.publisher })
    ] }),
    e
  ] });
}, Gi = ({
  title: e = "An error occurred",
  message: t,
  category: n
}) => /* @__PURE__ */ c.jsxs(Be, { className: "h-full pt-(--padding-content-top)", children: [
  n && /* @__PURE__ */ c.jsx(We, { children: n }),
  e && /* @__PURE__ */ c.jsx(Ve, { level: 1, className: "flex gap-3.5 items-center", children: e }),
  /* @__PURE__ */ c.jsx("p", { children: t })
] }), kt = () => {
  const e = Ct();
  return /* @__PURE__ */ c.jsxs(Be, { className: "h-full pt-(--padding-content-top)", children: [
    /* @__PURE__ */ c.jsx(We, { children: "404" }),
    /* @__PURE__ */ c.jsxs(Ve, { level: 1, className: "flex gap-3.5 items-center", children: [
      "Page not found",
      /* @__PURE__ */ c.jsx(Kt, { size: 24 })
    ] }),
    /* @__PURE__ */ c.jsxs(rn, { children: [
      "Start by adding a file at",
      " ",
      /* @__PURE__ */ c.jsxs("code", { children: [
        "{DOCUMENT_ROOT}",
        "/",
        e["*"],
        ".mdx"
      ] }),
      " ",
      "and add some content to make this error go away. By default",
      " ",
      /* @__PURE__ */ c.jsx("code", { children: "DOCUMENT_ROOT" }),
      " is the `pages` directory."
    ] }),
    /* @__PURE__ */ c.jsx("p", { children: "It seems that the page you are looking for does not exist or may have been moved. Please check the URL for any typos or use the navigation menu to find the correct page." }),
    /* @__PURE__ */ c.jsx(Ut, { to: "/", children: "Go back home" })
  ] });
}, Yi = (e) => {
  switch (e) {
    case 400:
      return {
        title: "Bad Request",
        message: "The request could not be understood by the server due to malformed syntax."
      };
    case 403:
      return {
        title: "Forbidden",
        message: "You don't have permission to access this resource."
      };
    case 404:
      return {
        title: "Not Found",
        message: "The requested resource could not be found."
      };
    case 405:
      return {
        title: "Method Not Allowed",
        message: "The request method is not supported for the requested resource."
      };
    case 414:
      return {
        title: "Request URI Too Large",
        message: "The request URI is too large."
      };
    case 416:
      return {
        title: "Range Not Satisfiable",
        message: "The server cannot satisfy the request range."
      };
    case 500:
      return {
        title: "Internal Server Error",
        message: "An unexpected error occurred while processing your request."
      };
    case 501:
      return {
        title: "Not Implemented",
        message: "The server does not support the functionality required to fulfill the request."
      };
    case 502:
      return {
        title: "Bad Gateway",
        message: "The server received an invalid response from the upstream server."
      };
    case 503:
      return {
        title: "Service Unavailable",
        message: "The server is temporarily unable to handle the request."
      };
    case 504:
      return {
        title: "Gateway Timeout",
        message: "The server did not receive a timely response from the upstream server."
      };
    default:
      return {
        title: "An error occurred",
        message: "Something went wrong while processing your request."
      };
  }
}, Qi = ({ statusCode: e, message: t }) => {
  if (e === 404)
    return /* @__PURE__ */ c.jsx(kt, {});
  const n = Yi(e);
  return /* @__PURE__ */ c.jsx(
    Gi,
    {
      title: n.title,
      message: t ?? n.message,
      category: e
    }
  );
};
function Xi({ className: e }) {
  const t = Ft();
  return Jt(t) && t.status === 404 ? /* @__PURE__ */ c.jsx(kt, {}) : /* @__PURE__ */ c.jsx("div", { className: S("mx-4 max-w-2xl", e), children: /* @__PURE__ */ c.jsx(qe, { error: t }) });
}
function ea({ error: e }) {
  return /* @__PURE__ */ c.jsx(qe, { error: e });
}
const Re = (e) => typeof e == "object" && e !== null && !Array.isArray(e) && Object.getPrototypeOf(e) === Object.prototype, $t = (e, t) => {
  const n = { ...e };
  for (const r of Object.keys(t)) {
    const o = t[r], i = e[r];
    Nt(o) || Array.isArray(o) || !Re(o) ? n[r] = o : Re(i) ? n[r] = $t(
      i,
      o
    ) : n[r] = o;
  }
  return n;
}, ta = async (e) => {
  const t = e.plugins ?? [];
  let n = e;
  for (const r of t.filter(dn)) {
    const o = (s) => $t(n, s), i = await r.transformConfig?.({
      config: n,
      merge: o
    });
    i && (n = i);
  }
  return n;
}, ba = Ki, ka = Xi, $a = ea, ja = hn, xa = mn, Za = Mt, Oa = Ce, Sa = Qi, Pa = Ai, Ta = Hi, Ea = ta;
export {
  ja as Bootstrap,
  xa as BootstrapStatic,
  Pa as BuildCheck,
  Oa as Head,
  ba as Layout,
  Ta as Meta,
  Za as RouteGuard,
  ka as RouterError,
  $a as ServerError,
  Sa as StatusPage,
  Ea as runPluginTransformConfig
};
//# sourceMappingURL=zudoku.__internal.js.map
