import { ascComparator } from "../../ord.js";
import { createArrayComparator, createDeduplicator, isArrayEmpty, } from "../../array.js";
import { isRecordEmpty } from "../../object.js";
import { weakMemoize } from "../../memoize.js";
import { isAllowAnySchema, isSchemaObject } from "../json-schema.js";
const zero = () => 0;
const isUndefined = (v) => v === undefined;
const isSchemaPrimitiveExceptNull = (value) => typeof value !== "object";
const PRIMITIVE_TYPE_ORDER = {
    boolean: 0,
    number: 1,
    string: 2,
};
function compareSchemaPrimitive(a, b) {
    const ta = typeof a;
    const tb = typeof b;
    return ta === tb
        ? ascComparator(a, b)
        : PRIMITIVE_TYPE_ORDER[ta] - PRIMITIVE_TYPE_ORDER[tb];
}
function insertUniqueValues(mutableTarget, mutableSource) {
    const tl = mutableTarget.length;
    if (tl === 0)
        return mutableSource;
    const sl = mutableSource.length;
    if (sl === 0)
        return mutableTarget;
    if (sl > tl) {
        const t = mutableTarget;
        mutableTarget = mutableSource;
        mutableSource = t;
    }
    const seen = new Set(mutableTarget);
    const l = mutableSource.length;
    for (let i = 0; i < l; i++) {
        const key = mutableSource[i];
        if (!seen.has(key)) {
            mutableTarget.push(key);
        }
    }
    return mutableTarget;
}
function createCmpMatcher(isEmpty, compare, compareEmpty = zero) {
    return (a, b) => {
        if (isEmpty(a)) {
            if (isEmpty(b)) {
                return compareEmpty(a, b);
            }
            return -1;
        }
        if (isEmpty(b)) {
            return 1;
        }
        return compare(a, b);
    };
}
function createOptionalComparator(compare) {
    return createCmpMatcher(isUndefined, compare);
}
function createNarrowingOptionalComparator(isEmpty, compare) {
    return createCmpMatcher((v) => v === undefined || isEmpty(v), compare);
}
function createArrayOrItemComparator(compare, compareArray) {
    return createCmpMatcher(Array.isArray, compare, compareArray);
}
const compareOptionalSameTypeSchemaPrimitives = createOptionalComparator(ascComparator);
const compareNumbersWithZeroDefault = createNarrowingOptionalComparator((v) => v === 0, (a, b) => a - b);
export function createComparator({ deduplicationCache = new WeakMap(), sortedKeysCache = new WeakMap(), } = {}) {
    const getSortedKeys = weakMemoize(sortedKeysCache, (obj) => Object.keys(obj).sort());
    function createRecordsComparator(compare) {
        return (a, b) => {
            const aKeys = getSortedKeys(a);
            const bKeys = getSortedKeys(b);
            const l = Math.min(aKeys.length, bKeys.length);
            for (let i = 0; i < l; i++) {
                const cmp = ascComparator(aKeys[i], bKeys[i]);
                if (cmp !== 0) {
                    return cmp;
                }
            }
            if (aKeys.length !== bKeys.length) {
                return aKeys.length - bKeys.length;
            }
            for (let i = 0; i < l; i++) {
                const key = aKeys[i];
                // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
                const cmp = compare(a[key], b[key]);
                if (cmp !== 0) {
                    return cmp;
                }
            }
            return 0;
        };
    }
    function createArrayComparatorWithDeduplication(compare) {
        const cmp = createArrayComparator(compare);
        const deduplicate = weakMemoize(deduplicationCache, 
        // NOTE: Always sort output
        createDeduplicator(compare, { threshold: 0 }));
        return (a, b) => cmp(deduplicate(a), deduplicate(b));
    }
    const compareArrayOfSameTypePrimitivesWithDeduplication = createArrayComparatorWithDeduplication(ascComparator);
    function compareSchemaDefinitions(a, b) {
        if (isSchemaObject(a)) {
            if (isSchemaObject(b)) {
                const aKeys = Object.keys(a);
                const bKeys = Object.keys(b);
                const allKeys = insertUniqueValues(aKeys, bKeys);
                const l = allKeys.length;
                for (let i = 0; i < l; i++) {
                    const key = allKeys[i];
                    if (a[key] === b[key]) {
                        continue;
                    }
                    const cmp = COMPARATORS[key] ?? compareOptionalSchemaValues;
                    const d = cmp(a[key], b[key]);
                    if (d !== 0) {
                        return d;
                    }
                }
                return 0;
            }
            return b === true && isRecordEmpty(a) ? 0 : 1;
        }
        if (isSchemaObject(b)) {
            return a === true && isRecordEmpty(b) ? 0 : -1;
        }
        return ascComparator(a, b);
    }
    const compareOptionalSchemaValues = createOptionalComparator(compareSchemaValues);
    const compareNonNullSchemaValue = createCmpMatcher(isSchemaPrimitiveExceptNull, createArrayOrItemComparator(createRecordsComparator(compareOptionalSchemaValues), createArrayComparator(compareSchemaValues)), compareSchemaPrimitive);
    function compareSchemaValues(a, b) {
        if (a === null) {
            return -1;
        }
        if (b === null) {
            return 1;
        }
        return compareNonNullSchemaValue(a, b);
    }
    const compareOptionalSchemaDefinitions = createOptionalComparator(compareSchemaDefinitions);
    const compareRecordOfOptionalSchemasWithEmptyRecordDefault = createNarrowingOptionalComparator(isRecordEmpty, createRecordsComparator(compareOptionalSchemaDefinitions));
    const compareOptionalArrayOfSchemasWithDeduplication = createOptionalComparator(createArrayComparatorWithDeduplication(compareSchemaDefinitions));
    const compareSchemaDefinitionsWithEmptyDefinitionDefault = createNarrowingOptionalComparator(isAllowAnySchema, compareSchemaDefinitions);
    const COMPARATORS = {
        $id: compareOptionalSameTypeSchemaPrimitives,
        $comment: compareOptionalSameTypeSchemaPrimitives,
        $defs: compareRecordOfOptionalSchemasWithEmptyRecordDefault,
        $ref: compareOptionalSameTypeSchemaPrimitives,
        $schema: compareOptionalSameTypeSchemaPrimitives,
        const: compareOptionalSchemaValues,
        contains: compareOptionalSchemaDefinitions,
        contentEncoding: compareOptionalSameTypeSchemaPrimitives,
        contentMediaType: compareOptionalSameTypeSchemaPrimitives,
        default: compareOptionalSchemaValues,
        definitions: compareRecordOfOptionalSchemasWithEmptyRecordDefault,
        description: compareOptionalSameTypeSchemaPrimitives,
        else: compareOptionalSchemaDefinitions,
        examples: compareOptionalSchemaValues,
        exclusiveMaximum: compareOptionalSameTypeSchemaPrimitives,
        exclusiveMinimum: compareOptionalSameTypeSchemaPrimitives,
        format: compareOptionalSameTypeSchemaPrimitives,
        if: compareOptionalSchemaDefinitions,
        maximum: compareOptionalSameTypeSchemaPrimitives,
        maxItems: compareOptionalSameTypeSchemaPrimitives,
        maxLength: compareOptionalSameTypeSchemaPrimitives,
        maxProperties: compareOptionalSameTypeSchemaPrimitives,
        minimum: compareOptionalSameTypeSchemaPrimitives,
        multipleOf: compareOptionalSameTypeSchemaPrimitives,
        not: compareOptionalSchemaDefinitions,
        pattern: compareOptionalSameTypeSchemaPrimitives,
        propertyNames: compareOptionalSchemaDefinitions,
        readOnly: compareOptionalSameTypeSchemaPrimitives,
        then: compareOptionalSchemaDefinitions,
        title: compareOptionalSameTypeSchemaPrimitives,
        writeOnly: compareOptionalSameTypeSchemaPrimitives,
        uniqueItems: createNarrowingOptionalComparator((v) => v === false, zero),
        minLength: compareNumbersWithZeroDefault,
        minItems: compareNumbersWithZeroDefault,
        minProperties: compareNumbersWithZeroDefault,
        required: createNarrowingOptionalComparator(isArrayEmpty, compareArrayOfSameTypePrimitivesWithDeduplication),
        enum: createNarrowingOptionalComparator(isArrayEmpty, createArrayComparatorWithDeduplication(compareSchemaValues)),
        type: createOptionalComparator((a, b) => {
            const isAArr = Array.isArray(a);
            const isBArr = Array.isArray(b);
            if (!isAArr && !isBArr) {
                return ascComparator(a, b);
            }
            return compareArrayOfSameTypePrimitivesWithDeduplication(isAArr ? a : [a], isBArr ? b : [b]);
        }),
        items: createNarrowingOptionalComparator((v) => !Array.isArray(v) && isAllowAnySchema(v), createArrayOrItemComparator(compareSchemaDefinitions, createArrayComparator(compareSchemaDefinitions))),
        anyOf: compareOptionalArrayOfSchemasWithDeduplication,
        allOf: compareOptionalArrayOfSchemasWithDeduplication,
        oneOf: compareOptionalArrayOfSchemasWithDeduplication,
        properties: compareRecordOfOptionalSchemasWithEmptyRecordDefault,
        patternProperties: compareRecordOfOptionalSchemasWithEmptyRecordDefault,
        additionalProperties: compareSchemaDefinitionsWithEmptyDefinitionDefault,
        additionalItems: compareSchemaDefinitionsWithEmptyDefinitionDefault,
        dependencies: createNarrowingOptionalComparator(isRecordEmpty, createRecordsComparator(createOptionalComparator(createArrayOrItemComparator(compareSchemaDefinitions, compareArrayOfSameTypePrimitivesWithDeduplication)))),
    };
    return {
        compareSchemaValues,
        compareSchemaDefinitions,
    };
}
//# sourceMappingURL=compare.js.map