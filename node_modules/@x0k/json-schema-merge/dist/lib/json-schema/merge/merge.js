import { intersection, union, } from "../../array.js";
import { identity } from "../../function.js";
import { lcm } from "../../math.js";
import { isAllowAnySchema } from "../json-schema.js";
import { simplePatternsMerger } from "./patterns.js";
function* createPairCombinations(l, r, action) {
    const ll = l.length;
    const rl = r.length;
    if (ll > 0 && rl > 0) {
        for (let i = 0; i < ll; i++) {
            const lv = l[i];
            for (let j = 0; j < rl; j++) {
                yield action(lv, r[j]);
            }
        }
    }
}
function mergeBooleans(l, r) {
    return l || r;
}
function createRecordsMerge(merge) {
    return (left, right) => {
        const target = { ...left };
        const keys = Object.keys(right);
        const l = keys.length;
        for (let i = 0; i < l; i++) {
            const key = keys[i];
            target[key] =
                left[key] === undefined ? right[key] : merge(left[key], right[key]);
        }
        return target;
    };
}
function createMap(items) {
    const map = new Map();
    for (const pair of items) {
        for (const key of pair[0]) {
            map.set(key, pair[1]);
        }
    }
    return map;
}
function assignSchemaDefinitionOrRecordOfSchemaDefinitions(target, key, value) {
    if (value === undefined || isAllowAnySchema(value)) {
        delete target[key];
    }
    else {
        target[key] = value;
    }
}
const PROPERTIES_ASSIGNER_KEYS = [
    "properties",
    "patternProperties",
    "additionalProperties",
];
function compilePatterns(patterns) {
    const keys = Object.keys(patterns);
    const l = keys.length;
    const result = [];
    for (let i = 0; i < l; i++) {
        const source = keys[i];
        result.push({
            regExp: new RegExp(source),
            schema: patterns[source],
        });
    }
    return [result, keys];
}
const EMPTY_PATTERNS_AND_KEYS = [[], []];
/**
 * @returns `true` when `false` schema occurred
 */
function appendKeyConstraints(target, key, patterns) {
    const l = patterns.length;
    for (let i = 0; i < l; i++) {
        const p = patterns[i];
        if (!p.regExp.test(key)) {
            continue;
        }
        const s = p.schema;
        if (s === false) {
            return true;
        }
        target.push(s);
    }
    return false;
}
const ITEMS_ASSIGNER_KEYS = [
    "items",
    "additionalItems",
];
const CONDITION_ASSIGNER_KEYS = [
    "if",
    "then",
    "else",
];
function assignCondition(target, source) {
    if (source.if !== undefined) {
        target.if = source.if;
    }
    if (source.then !== undefined) {
        target.then = source.then;
    }
    if (source.else !== undefined) {
        target.else = source.else;
    }
    return target;
}
function intersectSchemaTypes(a, b) {
    if (a === b) {
        return a;
    }
    switch (a) {
        case "number": {
            if (b === "integer") {
                return "integer";
            }
        }
        // eslint-disable-next-line no-fallthrough
        case "integer": {
            if (b === "number") {
                return "integer";
            }
        }
        // eslint-disable-next-line no-fallthrough
        default:
            return undefined;
    }
}
export function check(a, b, check) {
    return [a, b, check];
}
function createChecksMap(checks) {
    const map = new Map();
    for (const [a, b, check] of checks) {
        const fn = (target) => {
            if (!check(target)) {
                throw new Error(`Schema keys '${a}' and '${b}' are conflicting (${a}: ${JSON.stringify(target[a])}, ${b}: ${JSON.stringify(target[b])})`);
            }
        };
        for (const k of [
            [a, b],
            [b, a],
        ]) {
            let arr = map.get(k[0]);
            if (arr === undefined) {
                arr = [];
                map.set(k[0], arr);
            }
            arr.push({ oppositeKey: k[1], check: fn });
        }
    }
    return map;
}
export const DEFAULT_CHECKS = [
    check("minimum", "maximum", (t) => t.maximum >= t.minimum),
    check("exclusiveMinimum", "maximum", (t) => t.maximum > t.exclusiveMinimum),
    check("minimum", "exclusiveMaximum", (t) => t.exclusiveMaximum > t.minimum),
    check("exclusiveMinimum", "exclusiveMaximum", (t) => t.exclusiveMaximum > t.exclusiveMinimum),
    check("minLength", "maxLength", (t) => t.maxLength >= t.minLength),
    check("minItems", "maxItems", (t) => t.maxItems >= t.minItems),
    check("minProperties", "maxProperties", (t) => t.maxProperties >= t.minProperties),
];
export function createMerger({ mergePatterns = simplePatternsMerger, isSubRegExp = Object.is, intersectJson = intersection, deduplicateJsonSchemaDef = identity, defaultMerger = identity, assigners = [], checks = DEFAULT_CHECKS, mergers, } = {}) {
    function mergeArrayOfSchemaDefinitions(schemas) {
        const l = schemas.length;
        let result = schemas[0];
        for (let i = 1; i < l; i++) {
            const r = mergeSchemaDefinitions(result, schemas[i]);
            if (r === false) {
                return false;
            }
            if (isAllowAnySchema(r)) {
                continue;
            }
            result = r;
        }
        return result;
    }
    function createProperty(constraints, key, value, patterns, oppositeValue, oppositePatterns, oppositeAdditional) {
        constraints.length = 0;
        if (value === false) {
            return false;
        }
        constraints.push(value);
        const isOppositeValueDefined = oppositeValue !== undefined;
        if (isOppositeValueDefined) {
            if (oppositeValue === false) {
                return false;
            }
            constraints.push(oppositeValue);
        }
        if (appendKeyConstraints(constraints, key, oppositePatterns)) {
            return false;
        }
        const isNotYetAllowed = constraints.length < 2;
        if (oppositeAdditional === false) {
            // There are no allowing constraints from opposite side -> drop property
            if (isNotYetAllowed) {
                return undefined;
            }
            // Applying patterns of current schema cause they may disappear
            if (appendKeyConstraints(constraints, key, patterns)) {
                return false;
            }
        }
        else if (isNotYetAllowed && oppositeAdditional !== undefined) {
            constraints.push(oppositeAdditional);
        }
        const l = constraints.length;
        if (l === 1) {
            return constraints[0];
        }
        return mergeArrayOfSchemaDefinitions(constraints);
    }
    function assignPatternPropertiesAndAdditionalPropertiesMerge(target, patterns, patternKeys, matchedPatterns, oppositeAdditional, isOppositeTruthy) {
        const l = patternKeys.length;
        if (l > 0 && oppositeAdditional !== false) {
            if (isOppositeTruthy) {
                // TODO: in some cases we can just assign new value instead of copying
                Object.assign(target, patterns);
            }
            else {
                for (let i = 0; i < l; i++) {
                    const pattern = patternKeys[i];
                    if (matchedPatterns.has(pattern)) {
                        continue;
                    }
                    target[pattern] = mergeSchemaDefinitions(patterns[pattern], oppositeAdditional);
                }
            }
        }
        return target;
    }
    const propertiesAssigner = (target, { properties: lProps = {}, patternProperties: lPatterns, additionalProperties: lAdditional = true, }, { properties: rProps = {}, patternProperties: rPatterns, additionalProperties: rAdditional = true, }) => {
        // Special case
        const isLAddTruthy = isAllowAnySchema(lAdditional);
        const isRAddTruthy = isAllowAnySchema(rAdditional);
        if (isLAddTruthy && isRAddTruthy) {
            assignSchemaDefinitionOrRecordOfSchemaDefinitions(target, "properties", mergeRecordsOfSchemaDefinitions(lProps, rProps));
            assignSchemaDefinitionOrRecordOfSchemaDefinitions(target, "patternProperties", lPatterns && rPatterns
                ? mergeRecordsOfSchemaDefinitions(lPatterns, rPatterns)
                : (lPatterns ?? rPatterns));
            delete target.additionalProperties;
            return target;
        }
        // Additional Properties
        const additionalProperties = mergeSchemaDefinitions(lAdditional, rAdditional);
        assignSchemaDefinitionOrRecordOfSchemaDefinitions(target, "additionalProperties", additionalProperties);
        // Properties
        const properties = {};
        const lKeys = Object.keys(lProps);
        const lKeysLen = lKeys.length;
        const [lCompiledPatterns, lPatternKeys] = lPatterns
            ? compilePatterns(lPatterns)
            : EMPTY_PATTERNS_AND_KEYS;
        const [rCompiledPatterns, rPatternKeys] = rPatterns
            ? compilePatterns(rPatterns)
            : EMPTY_PATTERNS_AND_KEYS;
        const constraints = [];
        const lKeysSet = new Set();
        const mappedRAdditional = isRAddTruthy ? undefined : rAdditional;
        for (let i = 0; i < lKeysLen; i++) {
            const key = lKeys[i];
            lKeysSet.add(key);
            const prop = createProperty(constraints, key, lProps[key], lCompiledPatterns, rProps[key], rCompiledPatterns, mappedRAdditional);
            if (prop !== undefined) {
                properties[key] = prop;
            }
        }
        const rKeys = Object.keys(rProps);
        const rKeysLen = rKeys.length;
        const mappedLAdditional = isLAddTruthy ? undefined : lAdditional;
        for (let i = 0; i < rKeysLen; i++) {
            const key = rKeys[i];
            if (lKeysSet.has(key)) {
                continue;
            }
            const prop = createProperty(constraints, key, rProps[key], rCompiledPatterns, undefined, lCompiledPatterns, mappedLAdditional);
            if (prop !== undefined) {
                properties[key] = prop;
            }
        }
        assignSchemaDefinitionOrRecordOfSchemaDefinitions(target, "properties", properties);
        // Pattern Properties
        // (lPatterns and rPatterns) or (lPatterns and rAdditional) or (rPatterns and lAdditional)
        let patterns = {};
        const matchedPatterns = new Set();
        if (lPatternKeys.length > 0 && rPatternKeys.length > 0) {
            const gen = createPairCombinations(lPatternKeys, rPatternKeys, (lKey, rKey) => {
                if (isSubRegExp(lKey, rKey)) {
                    matchedPatterns.add(lKey);
                }
                if (isSubRegExp(rKey, lKey)) {
                    matchedPatterns.add(rKey);
                }
                patterns[mergePatterns(lKey, rKey)] = mergeSchemaDefinitions(lPatterns[lKey], rPatterns[rKey]);
            });
            while (!gen.next().done) {
                /* empty */
            }
        }
        patterns = assignPatternPropertiesAndAdditionalPropertiesMerge(patterns, lPatterns, lPatternKeys, matchedPatterns, rAdditional, isRAddTruthy);
        patterns = assignPatternPropertiesAndAdditionalPropertiesMerge(patterns, rPatterns, rPatternKeys, matchedPatterns, lAdditional, isLAddTruthy);
        assignSchemaDefinitionOrRecordOfSchemaDefinitions(target, "patternProperties", patterns);
        return target;
    };
    const itemsAssigner = (target, 
    // NOTE: Schema that has `additionalItems` without an `items` keyword is invalid
    // so the assigner should be triggered only be colliding `items` properties
    // so default values are used only for type narrowing
    { items: lItems = [], additionalItems: lAdditional }, { items: rItems = [], additionalItems: rAdditional }) => {
        const isLArr = Array.isArray(lItems);
        const isRArr = Array.isArray(rItems);
        const itemsArray = [];
        target.items = itemsArray;
        if (isLArr && isRArr) {
            const [l, additional, tail] = lItems.length < rItems.length
                ? [lItems.length, lAdditional, rItems]
                : [rItems.length, rAdditional, lItems];
            let i = 0;
            for (; i < l; i++) {
                itemsArray.push(mergeSchemaDefinitions(lItems[i], rItems[i]));
            }
            if (additional === false) {
                target.additionalItems = false;
            }
            else {
                const isAdditionalTruthy = additional === undefined || isAllowAnySchema(additional);
                for (; i < tail.length; i++) {
                    itemsArray.push(isAdditionalTruthy
                        ? tail[i]
                        : mergeSchemaDefinitions(tail[i], additional));
                }
                assignSchemaDefinitionOrRecordOfSchemaDefinitions(target, "additionalItems", lAdditional !== undefined && rAdditional !== undefined
                    ? mergeSchemaDefinitions(lAdditional, rAdditional)
                    : (lAdditional ?? rAdditional));
            }
        }
        else if (isLArr || isRArr) {
            const [arr, item, additional] = (isLArr ? [lItems, rItems, lAdditional] : [rItems, lItems, rAdditional]);
            assignSchemaDefinitionOrRecordOfSchemaDefinitions(target, "additionalItems", additional && mergeSchemaDefinitions(additional, item));
            for (let i = 0; i < arr.length; i++) {
                itemsArray.push(mergeSchemaDefinitions(arr[i], item));
            }
        }
        else {
            delete target.additionalItems;
            target.items = mergeSchemaDefinitions(lItems, rItems);
        }
        return target;
    };
    const conditionAssigner = (target, l, r) => {
        assignCondition(target, l);
        const cond = assignCondition({}, r);
        if (target.allOf === undefined) {
            target.allOf = [cond];
        }
        else {
            target.allOf = target.allOf.concat(cond);
        }
        return target;
    };
    function mergeArraysOfSchemaDefinition(l, r) {
        return deduplicateJsonSchemaDef(Array.from(createPairCombinations(l, r, mergeSchemaDefinitions)));
    }
    const ASSIGNERS_MAP = createMap([
        [PROPERTIES_ASSIGNER_KEYS, propertiesAssigner],
        [ITEMS_ASSIGNER_KEYS, itemsAssigner],
        [CONDITION_ASSIGNER_KEYS, conditionAssigner],
        ...assigners,
    ]);
    const CHECKS_MAP = createChecksMap(checks);
    function mergeSchemaDefinitions(left, right) {
        if (left === false || right === false) {
            return false;
        }
        if (isAllowAnySchema(left)) {
            if (isAllowAnySchema(right)) {
                return true;
            }
            return right;
        }
        if (isAllowAnySchema(right)) {
            return left;
        }
        let target = { ...left };
        const assigners = new Set();
        const checks = new Set();
        const rKeys = Object.keys(right);
        const l = rKeys.length;
        for (let i = 0; i < l; i++) {
            const rKey = rKeys[i];
            const rv = right[rKey];
            if (rv === undefined) {
                continue;
            }
            const checkData = CHECKS_MAP.get(rKey);
            if (checkData !== undefined) {
                const l = checkData.length;
                for (let j = 0; j < l; j++) {
                    const item = checkData[j];
                    if (left[item.oppositeKey] !== undefined) {
                        checks.add(item.check);
                    }
                }
            }
            const lv = left[rKey];
            if (lv === undefined) {
                // @ts-expect-error too complex
                target[rKey] = rv;
                continue;
            }
            const assign = ASSIGNERS_MAP.get(rKey);
            if (assign) {
                assigners.add(assign);
                continue;
            }
            const merge = MERGERS[rKey] ?? defaultMerger;
            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
            target[rKey] = merge(lv, rv);
        }
        for (const assign of assigners) {
            target = assign(target, left, right);
        }
        for (const check of checks) {
            check(target);
        }
        return target;
    }
    const mergeRecordsOfSchemaDefinitions = createRecordsMerge(mergeSchemaDefinitions);
    const MERGERS = {
        $id: defaultMerger,
        $ref: defaultMerger,
        $schema: defaultMerger,
        $comment: defaultMerger,
        $defs: mergeRecordsOfSchemaDefinitions,
        definitions: mergeRecordsOfSchemaDefinitions,
        type: (a, b) => {
            if (a === b) {
                return a;
            }
            const isAArr = Array.isArray(a);
            const isBArr = Array.isArray(b);
            if (!isAArr && !isBArr) {
                const intersection = intersectSchemaTypes(a, b);
                if (intersection !== undefined) {
                    return intersection;
                }
            }
            else if (isAArr || isBArr) {
                const r = new Set();
                if (isAArr && isBArr) {
                    for (const intersection of createPairCombinations(a, b, intersectSchemaTypes)) {
                        if (intersection !== undefined) {
                            r.add(intersection);
                        }
                    }
                }
                else {
                    const arr = (isAArr ? a : b);
                    const el = (isAArr ? b : a);
                    const l = arr.length;
                    for (let i = 0; i < l; i++) {
                        const intersection = intersectSchemaTypes(el, arr[i]);
                        if (intersection !== undefined) {
                            r.add(intersection);
                        }
                    }
                }
                const s = r.size;
                if (s === 1) {
                    return r.values().next().value;
                }
                if (s > 1) {
                    return Array.from(r);
                }
            }
            throw new Error(`It is not possible to create an intersection of the following incompatible types: ${a.toString()}, ${b.toString()}`);
        },
        default: defaultMerger,
        description: defaultMerger,
        title: defaultMerger,
        const: defaultMerger,
        format: defaultMerger,
        contentEncoding: defaultMerger,
        contentMediaType: defaultMerger,
        not: (a, b) => {
            const items = deduplicateJsonSchemaDef([a, b]);
            return items.length === 1 ? items[0] : { anyOf: items };
        },
        pattern: mergePatterns,
        readOnly: mergeBooleans,
        writeOnly: mergeBooleans,
        enum: (a, b) => {
            const data = intersectJson(a, b);
            if (data.length === 0) {
                throw new Error(`Intersection of the following enums is empty: "${JSON.stringify(a)}", "${JSON.stringify(b)}"`);
            }
            return data;
        },
        anyOf: mergeArraysOfSchemaDefinition,
        oneOf: mergeArraysOfSchemaDefinition,
        allOf: (l, r) => deduplicateJsonSchemaDef(l.concat(r)),
        propertyNames: mergeSchemaDefinitions,
        contains: mergeSchemaDefinitions,
        dependencies: createRecordsMerge((a, b) => {
            if (Array.isArray(a)) {
                if (Array.isArray(b)) {
                    return union(a, b);
                }
                return mergeSchemaDefinitions(b, { required: a });
            }
            if (Array.isArray(b)) {
                return mergeSchemaDefinitions(a, { required: b });
            }
            return mergeSchemaDefinitions(a, b);
        }),
        examples: (l, r) => {
            // https://datatracker.ietf.org/doc/html/draft-handrews-json-schema-validation-01#section-10.4
            if (!Array.isArray(l) || !Array.isArray(r)) {
                throw new Error(`Value of the 'examples' field should be an array, but got "${JSON.stringify(l)}" and "${JSON.stringify(r)}"`);
            }
            // TODO: Proper deduplication
            return union(l, r);
        },
        multipleOf: (a, b) => {
            let factor = 1;
            while (!Number.isInteger(a) || !Number.isInteger(b)) {
                factor *= 10;
                a *= 10;
                b *= 10;
            }
            return lcm(a, b) / factor;
        },
        exclusiveMaximum: Math.min,
        maximum: Math.min,
        maxItems: Math.min,
        maxLength: Math.min,
        maxProperties: Math.min,
        exclusiveMinimum: Math.max,
        minimum: Math.max,
        minItems: Math.max,
        minLength: Math.max,
        minProperties: Math.max,
        uniqueItems: mergeBooleans,
        required: union,
        ...mergers,
    };
    return {
        mergeSchemaDefinitions,
        mergeArrayOfSchemaDefinitions,
    };
}
//# sourceMappingURL=merge.js.map